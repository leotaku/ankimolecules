if (typeof window !== "undefined") {
  (function() {
    window.console = window.console || {};
    var con = window.console;
    var prop, method;
    var empty = {};
    var dummy = function() {
    };
    var properties = "memory".split(",");
    var methods = "assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");
    while (prop = properties.pop()) {
      if (!con[prop]) {
        con[prop] = empty;
      }
    }
    while (method = methods.pop()) {
      if (!con[method]) {
        con[method] = dummy;
      }
    }
  })();
}
if (typeof window.HTMLCanvasElement !== "undefined" && !window.HTMLCanvasElement.prototype.toBlob) {
  Object.defineProperty(window.HTMLCanvasElement.prototype, "toBlob", {
    value: function(callback, type2, quality) {
      var bin = window.atob(this.toDataURL(type2, quality).split(",")[1]);
      var len = bin.length;
      var len32 = len >> 2;
      var a8 = new Uint8Array(len);
      var a32 = new Uint32Array(a8.buffer, 0, len32);
      for (var i = 0, j = 0; i < len32; i++) {
        a32[i] = bin.charCodeAt(j++) | bin.charCodeAt(j++) << 8 | bin.charCodeAt(j++) << 16 | bin.charCodeAt(j++) << 24;
      }
      var tailLength = len & 3;
      while (tailLength--) {
        a8[j] = bin.charCodeAt(j++);
      }
      callback(new window.Blob([a8], {type: type2 || "image/png"}));
    }
  });
}
Math.cbrt = Math.cbrt || function(x) {
  var y = Math.pow(Math.abs(x), 1 / 3);
  return x < 0 ? -y : y;
};
if (!Math.sign) {
  Math.sign = function(x) {
    x = +x;
    if (x === 0 || isNaN(x)) {
      return Number(x);
    }
    return x > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function isInteger(nVal) {
    return typeof nVal === "number" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;
  };
}
if (!Number.isNaN) {
  Number.isNaN = function isNaN2(value2) {
    return value2 !== value2;
  };
}
if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target2) {
      var arguments$1 = arguments;
      if (target2 === void 0 || target2 === null) {
        throw new TypeError("Cannot convert first argument to object");
      }
      var to = Object(target2);
      var hasPendingException = false;
      var pendingException;
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments$1[i];
        if (nextSource === void 0 || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          try {
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          } catch (e) {
            if (!hasPendingException) {
              hasPendingException = true;
              pendingException = e;
            }
          }
        }
        if (hasPendingException) {
          throw pendingException;
        }
      }
      return to;
    }
  });
}
if (!String.prototype.startsWith) {
  /*! https://mths.be/startswith v0.2.0 by @mathias */
  (function() {
    var defineProperty = function() {
      var result;
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    var toString3 = {}.toString;
    var startsWith = function(search) {
      if (this === null) {
        throw TypeError();
      }
      var string = String(this);
      if (search && toString3.call(search) === "[object RegExp]") {
        throw TypeError();
      }
      var stringLength = string.length;
      var searchString = String(search);
      var searchLength = searchString.length;
      var position = arguments.length > 1 ? arguments[1] : void 0;
      var pos = position ? Number(position) : 0;
      if (Number.isNaN(pos)) {
        pos = 0;
      }
      var start = Math.min(Math.max(pos, 0), stringLength);
      if (searchLength + start > stringLength) {
        return false;
      }
      var index = -1;
      while (++index < searchLength) {
        if (string.charCodeAt(start + index) !== searchString.charCodeAt(index)) {
          return false;
        }
      }
      return true;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "startsWith", {
        value: startsWith,
        configurable: true,
        writable: true
      });
    } else {
      String.prototype.startsWith = startsWith;
    }
  })();
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement) {
    if (this == null) {
      throw new TypeError("Array.prototype.includes called on null or undefined");
    }
    var O = Object(this);
    var len = parseInt(O.length, 10) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1], 10) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement || Number.isNaN(searchElement) && Number.isNaN(currentElement)) {
        return true;
      }
      k++;
    }
    return false;
  };
}
if (!Array.from) {
  Array.from = function() {
    var toStr = Object.prototype.toString;
    var isCallable = function(fn) {
      return typeof fn === "function" || toStr.call(fn) === "[object Function]";
    };
    var toInteger = function(value2) {
      var number = Number(value2);
      if (isNaN(number)) {
        return 0;
      }
      if (number === 0 || !isFinite(number)) {
        return number;
      }
      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var toLength = function(value2) {
      var len = toInteger(value2);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    };
    return function from(arrayLike) {
      var C = this;
      var items = Object(arrayLike);
      if (arrayLike == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }
      var mapFn = arguments.length > 1 ? arguments[1] : void 0;
      var T;
      if (typeof mapFn !== "undefined") {
        if (!isCallable(mapFn)) {
          throw new TypeError("Array.from: when provided, the second argument must be a function");
        }
        if (arguments.length > 2) {
          T = arguments[2];
        }
      }
      var len = toLength(items.length);
      var A = isCallable(C) ? Object(new C(len)) : new Array(len);
      var k = 0;
      var kValue;
      while (k < len) {
        kValue = items[k];
        if (mapFn) {
          A[k] = typeof T === "undefined" ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }
        k += 1;
      }
      A.length = len;
      return A;
    };
  }();
}
if (typeof window !== "undefined") {
  (function() {
    var lastTime = 0;
    var vendors = ["ms", "moz", "webkit", "o"];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
          var time = currTime + timeToCall;
          callback(time);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
      };
    }
  })();
}
if (Function.prototype.name === void 0 && Object.defineProperty !== void 0) {
  Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
    }
  });
}
if (typeof window !== "undefined") {
  if (window.performance === void 0) {
    self.performance = {};
  }
  if (window.performance.now === void 0) {
    (function() {
      var start = Date.now();
      window.performance.now = function() {
        return Date.now() - start;
      };
    })();
  }
}
var setTimeoutFunc = setTimeout;
function noop() {
}
var asap = typeof setImmediate === "function" && setImmediate || function(fn) {
  setTimeoutFunc(fn, 0);
};
var onUnhandledRejection = function onUnhandledRejection2(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise$1(fn) {
  if (typeof this !== "object") {
    throw new TypeError("Promises must be constructed via new");
  }
  if (typeof fn !== "function") {
    throw new TypeError("not a function");
  }
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  asap(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self2, newValue) {
  try {
    if (newValue === self2) {
      throw new TypeError("A promise cannot be resolved with itself.");
    }
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then3 = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then3 === "function") {
        doResolve(bind(then3, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e) {
    reject(self2, e);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    asap(function() {
      if (!self2._handled) {
        onUnhandledRejection(self2._value);
      }
    });
  }
  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
    handle(self2, self2._deferreds[i]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(function(value2) {
      if (done) {
        return;
      }
      done = true;
      resolve(self2, value2);
    }, function(reason) {
      if (done) {
        return;
      }
      done = true;
      reject(self2, reason);
    });
  } catch (ex) {
    if (done) {
      return;
    }
    done = true;
    reject(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.all = function(arr) {
  var args = Array.prototype.slice.call(arr);
  return new Promise$1(function(resolve2, reject2) {
    if (args.length === 0) {
      return resolve2([]);
    }
    var remaining = args.length;
    function res(i2, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then3 = val.then;
          if (typeof then3 === "function") {
            then3.call(val, function(val2) {
              res(i2, val2);
            }, reject2);
            return;
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.resolve = function(value2) {
  if (value2 && typeof value2 === "object" && value2.constructor === Promise$1) {
    return value2;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value2);
  });
};
Promise$1.reject = function(value2) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value2);
  });
};
Promise$1.race = function(values) {
  return new Promise$1(function(resolve2, reject2) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve2, reject2);
    }
  });
};
Promise$1._setImmediateFn = function _setImmediateFn(fn) {
  asap = fn;
};
Promise$1._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
  onUnhandledRejection = fn;
};
if (Number.EPSILON === void 0) {
  Number.EPSILON = Math.pow(2, -52);
}
if (Number.isInteger === void 0) {
  Number.isInteger = function(value2) {
    return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
  };
}
if (Math.sign === void 0) {
  Math.sign = function(x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}
if (Function.prototype.name === void 0) {
  Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}
if (Object.assign === void 0) {
  (function() {
    Object.assign = function(target2) {
      var arguments$1 = arguments;
      if (target2 === void 0 || target2 === null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var output = Object(target2);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments$1[index];
        if (source !== void 0 && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  })();
}
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type2, listener) {
    if (this._listeners === void 0) {
      this._listeners = {};
    }
    var listeners = this._listeners;
    if (listeners[type2] === void 0) {
      listeners[type2] = [];
    }
    if (listeners[type2].indexOf(listener) === -1) {
      listeners[type2].push(listener);
    }
  },
  hasEventListener: function(type2, listener) {
    if (this._listeners === void 0) {
      return false;
    }
    var listeners = this._listeners;
    return listeners[type2] !== void 0 && listeners[type2].indexOf(listener) !== -1;
  },
  removeEventListener: function(type2, listener) {
    if (this._listeners === void 0) {
      return;
    }
    var listeners = this._listeners;
    var listenerArray = listeners[type2];
    if (listenerArray !== void 0) {
      var index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    var this$1 = this;
    if (this._listeners === void 0) {
      return;
    }
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      var array = listenerArray.slice(0);
      for (var i = 0, l = array.length; i < l; i++) {
        array[i].call(this$1, event);
      }
    }
  }
});
var REVISION = "86";
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var FrontFaceDirectionCW = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    var chars2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
    var uuid2 = new Array(36);
    var rnd2 = 0, r;
    return function generateUUID2() {
      for (var i = 0; i < 36; i++) {
        if (i === 8 || i === 13 || i === 18 || i === 23) {
          uuid2[i] = "-";
        } else if (i === 14) {
          uuid2[i] = "4";
        } else {
          if (rnd2 <= 2) {
            rnd2 = 33554432 + Math.random() * 16777216 | 0;
          }
          r = rnd2 & 15;
          rnd2 = rnd2 >> 4;
          uuid2[i] = chars2[i === 19 ? r & 3 | 8 : r];
        }
      }
      return uuid2.join("");
    };
  }(),
  clamp: function(value2, min, max2) {
    return Math.max(min, Math.min(max2, value2));
  },
  euclideanModulo: function(n, m2) {
    return (n % m2 + m2) % m2;
  },
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  lerp: function(x, y, t) {
    return (1 - t) * x + t * y;
  },
  smoothstep: function(x, min, max2) {
    if (x <= min) {
      return 0;
    }
    if (x >= max2) {
      return 1;
    }
    x = (x - min) / (max2 - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function(x, min, max2) {
    if (x <= min) {
      return 0;
    }
    if (x >= max2) {
      return 1;
    }
    x = (x - min) / (max2 - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function(degrees) {
    return degrees * _Math.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function(value2) {
    return (value2 & value2 - 1) === 0 && value2 !== 0;
  },
  nearestPowerOfTwo: function(value2) {
    return Math.pow(2, Math.round(Math.log(value2) / Math.LN2));
  },
  nextPowerOfTwo: function(value2) {
    value2--;
    value2 |= value2 >> 1;
    value2 |= value2 >> 2;
    value2 |= value2 >> 4;
    value2 |= value2 >> 8;
    value2 |= value2 >> 16;
    value2++;
    return value2;
  }
};
function Vector2(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}
Object.defineProperties(Vector2.prototype, {
  width: {
    get: function() {
      return this.x;
    },
    set: function(value2) {
      this.x = value2;
    }
  },
  height: {
    get: function() {
      return this.y;
    },
    set: function(value2) {
      this.y = value2;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setComponent: function(index, value2) {
    switch (index) {
      case 0:
        this.x = value2;
        break;
      case 1:
        this.y = value2;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    return this;
  },
  clampScalar: function() {
    var min = new Vector2();
    var max2 = new Vector2();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal);
      max2.set(maxVal, maxVal);
      return this.clamp(min, max2);
    };
  }(),
  clampLength: function(min, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  lengthManhattan: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0) {
      angle += 2 * Math.PI;
    }
    return angle;
  },
  distanceTo: function(v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function(v) {
    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  distanceToManhattan: function(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function(center2, angle) {
    var c = Math.cos(angle), s = Math.sin(angle);
    var x = this.x - center2.x;
    var y = this.y - center2.y;
    this.x = x * c - y * s + center2.x;
    this.y = x * s + y * c + center2.y;
    return this;
  }
});
var textureId = 0;
function Texture(image, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy, encoding) {
  Object.defineProperty(this, "id", {value: textureId++});
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping2 !== void 0 ? mapping2 : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
  this.format = format !== void 0 ? format : RGBAFormat;
  this.type = type2 !== void 0 ? type2 : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function(value2) {
    if (value2 === true) {
      this.version++;
    }
  }
});
Object.assign(Texture.prototype, EventDispatcher.prototype, {
  constructor: Texture,
  isTexture: true,
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function(meta) {
    if (meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    function getDataURL(image2) {
      var canvas;
      if (image2.toDataURL !== void 0) {
        canvas = image2;
      } else {
        canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        canvas.width = image2.width;
        canvas.height = image2.height;
        canvas.getContext("2d").drawImage(image2, 0, 0, image2.width, image2.height);
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
    var output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      wrap: [this.wrapS, this.wrapT],
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY
    };
    if (this.image !== void 0) {
      var image = this.image;
      if (image.uuid === void 0) {
        image.uuid = _Math.generateUUID();
      }
      if (meta.images[image.uuid] === void 0) {
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: getDataURL(image)
        };
      }
      output.image = image.uuid;
    }
    meta.textures[this.uuid] = output;
    return output;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  },
  transformUv: function(uv) {
    if (this.mapping !== UVMapping) {
      return;
    }
    uv.multiply(this.repeat);
    uv.add(this.offset);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
  }
});
function Vector4(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== void 0 ? w : 1;
}
Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z) {
    this.z = z;
    return this;
  },
  setW: function(w) {
    this.w = w;
    return this;
  },
  setComponent: function(index, value2) {
    switch (index) {
      case 0:
        this.x = value2;
        break;
      case 1:
        this.y = value2;
        break;
      case 2:
        this.z = value2;
        break;
      case 3:
        this.w = value2;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function(m2) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    var e = m2.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function(q) {
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function(m2) {
    var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) {
      s = 1;
    }
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    this.z = Math.max(min.z, Math.min(max2.z, this.z));
    this.w = Math.max(min.w, Math.min(max2.w, this.w));
    return this;
  },
  clampScalar: function() {
    var min, max2;
    return function clampScalar(minVal, maxVal) {
      if (min === void 0) {
        min = new Vector4();
        max2 = new Vector4();
      }
      min.set(minVal, minVal, minVal, minVal);
      max2.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min, max2);
    };
  }(),
  clampLength: function(min, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
});
function WebGLRenderTarget(width, height, options) {
  this.uuid = _Math.generateUUID();
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  if (options.minFilter === void 0) {
    options.minFilter = LinearFilter;
  }
  this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
}
Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
  isWebGLRenderTarget: true,
  setSize: function(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
function Quaternion(x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== void 0 ? w : 1;
}
Object.assign(Quaternion, {
  slerp: function(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t, cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos2 >= 0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;
      if (sqrSin > Number.EPSILON) {
        var sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);
        s = Math.sin(s * len) / sin2;
        t = Math.sin(t * len) / sin2;
      }
      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value2) {
      this._x = value2;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value2) {
      this._y = value2;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value2) {
      this._z = value2;
      this.onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(value2) {
      this._w = value2;
      this.onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  set: function(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function(euler, update2) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
    var cos2 = Math.cos;
    var sin2 = Math.sin;
    var c1 = cos2(x / 2);
    var c2 = cos2(y / 2);
    var c3 = cos2(z / 2);
    var s1 = sin2(x / 2);
    var s2 = sin2(y / 2);
    var s3 = sin2(z / 2);
    if (order === "XYZ") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "YXZ") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === "ZXY") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "ZYX") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === "YZX") {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === "XZY") {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }
    if (update2 !== false) {
      this.onChangeCallback();
    }
    return this;
  },
  setFromAxisAngle: function(axis, angle) {
    var halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m2) {
    var te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace2 = m11 + m22 + m33, s;
    if (trace2 > 0) {
      s = 0.5 / Math.sqrt(trace2 + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function() {
    var v1 = new Vector3();
    var r;
    var EPS = 1e-6;
    return function setFromUnitVectors(vFrom, vTo) {
      if (v1 === void 0) {
        v1 = new Vector3();
      }
      r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }
      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      return this.normalize();
    };
  }(),
  inverse: function() {
    return this.conjugate().normalize();
  },
  conjugate: function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this.onChangeCallback();
    return this;
  },
  multiply: function(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  },
  premultiply: function(q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function(a, b) {
    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function(qb, t) {
    if (t === 0) {
      return this;
    }
    if (t === 1) {
      return this.copy(qb);
    }
    var x = this._x, y = this._y, z = this._z, w = this._w;
    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 1e-3) {
      this._w = 0.5 * (w + this._w);
      this._x = 0.5 * (x + this._x);
      this._y = 0.5 * (y + this._y);
      this._z = 0.5 * (z + this._z);
      return this;
    }
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}
Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z) {
    this.z = z;
    return this;
  },
  setComponent: function(index, value2) {
    switch (index) {
      case 0:
        this.x = value2;
        break;
      case 1:
        this.y = value2;
        break;
      case 2:
        this.z = value2;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function() {
    var quaternion = new Quaternion();
    return function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),
  applyAxisAngle: function() {
    var quaternion = new Quaternion();
    return function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),
  applyMatrix3: function(m2) {
    var x = this.x, y = this.y, z = this.z;
    var e = m2.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function(m2) {
    var x = this.x, y = this.y, z = this.z;
    var e = m2.elements;
    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function(q) {
    var x = this.x, y = this.y, z = this.z;
    var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function() {
    var matrix2 = new Matrix4();
    return function project(camera) {
      matrix2.multiplyMatrices(camera.projectionMatrix, matrix2.getInverse(camera.matrixWorld));
      return this.applyMatrix4(matrix2);
    };
  }(),
  unproject: function() {
    var matrix2 = new Matrix4();
    return function unproject(camera) {
      matrix2.multiplyMatrices(camera.matrixWorld, matrix2.getInverse(camera.projectionMatrix));
      return this.applyMatrix4(matrix2);
    };
  }(),
  transformDirection: function(m2) {
    var x = this.x, y = this.y, z = this.z;
    var e = m2.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function(scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    this.z = Math.max(min.z, Math.min(max2.z, this.z));
    return this;
  },
  clampScalar: function() {
    var min = new Vector3();
    var max2 = new Vector3();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal, minVal);
      max2.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max2);
    };
  }(),
  clampLength: function(min, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  cross: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    var x = this.x, y = this.y, z = this.z;
    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;
    return this;
  },
  crossVectors: function(a, b) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function(vector) {
    var scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  },
  projectOnPlane: function() {
    var v1 = new Vector3();
    return function projectOnPlane(planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function() {
    var v1 = new Vector3();
    return function reflect(normal2) {
      return this.sub(v1.copy(normal2).multiplyScalar(2 * this.dot(normal2)));
    };
  }(),
  angleTo: function(v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(_Math.clamp(theta, -1, 1));
  },
  distanceTo: function(v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function(v) {
    var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  distanceToManhattan: function(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function(s) {
    var sinPhiRadius = Math.sin(s.phi) * s.radius;
    this.x = sinPhiRadius * Math.sin(s.theta);
    this.y = Math.cos(s.phi) * s.radius;
    this.z = sinPhiRadius * Math.cos(s.theta);
    return this;
  },
  setFromCylindrical: function(c) {
    this.x = c.radius * Math.sin(c.theta);
    this.y = c.y;
    this.z = c.radius * Math.cos(c.theta);
    return this;
  },
  setFromMatrixPosition: function(m2) {
    var e = m2.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function(m2) {
    var sx = this.setFromMatrixColumn(m2, 0).length();
    var sy = this.setFromMatrixColumn(m2, 1).length();
    var sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
});
function Matrix4() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function() {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function(m2) {
    var te = this.elements;
    var me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function(m2) {
    var te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function() {
    var v1 = new Vector3();
    return function extractRotation(m2) {
      var te = this.elements;
      var me = m2.elements;
      var scaleX = 1 / v1.setFromMatrixColumn(m2, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m2, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m2, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      return this;
    };
  }(),
  makeRotationFromEuler: function(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    var te = this.elements;
    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos(x), b = Math.sin(x);
    var c = Math.cos(y), d = Math.sin(y);
    var e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function(q) {
    var te = this.elements;
    var x = q._x, y = q._y, z = q._z, w = q._w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  lookAt: function() {
    var x = new Vector3();
    var y = new Vector3();
    var z = new Vector3();
    return function lookAt(eye2, target2, up2) {
      var te = this.elements;
      z.subVectors(eye2, target2);
      if (z.lengthSq() === 0) {
        z.z = 1;
      }
      z.normalize();
      x.crossVectors(up2, z);
      if (x.lengthSq() === 0) {
        if (Math.abs(up2.z) === 1) {
          z.x += 1e-4;
        } else {
          z.z += 1e-4;
        }
        z.normalize();
        x.crossVectors(up2, z);
      }
      x.normalize();
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function(m2, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n);
    }
    return this.multiplyMatrices(this, m2);
  },
  premultiply: function(m2) {
    return this.multiplyMatrices(m2, this);
  },
  multiplyMatrices: function(a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function(s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      var this$1 = this;
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix4(this$1);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  determinant: function() {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function() {
    var te = this.elements;
    var tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  },
  setPosition: function(v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function(m2, throwOnDegenerate) {
    var te = this.elements, me = m2.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) {
      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function(v) {
    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function() {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function(axis, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function(x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function(position, quaternion, scale2) {
    this.makeRotationFromQuaternion(quaternion);
    this.scale(scale2);
    this.setPosition(position);
    return this;
  },
  decompose: function() {
    var vector = new Vector3();
    var matrix2 = new Matrix4();
    return function decompose(position, quaternion, scale2) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      var det = this.determinant();
      if (det < 0) {
        sx = -sx;
      }
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix2.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix2.elements[0] *= invSX;
      matrix2.elements[1] *= invSX;
      matrix2.elements[2] *= invSX;
      matrix2.elements[4] *= invSY;
      matrix2.elements[5] *= invSY;
      matrix2.elements[6] *= invSY;
      matrix2.elements[8] *= invSZ;
      matrix2.elements[9] *= invSZ;
      matrix2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix2);
      scale2.x = sx;
      scale2.y = sy;
      scale2.z = sz;
      return this;
    };
  }(),
  makePerspective: function(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function(left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1 / (right - left);
    var h = 1 / (top - bottom);
    var p = 1 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function(matrix2) {
    var te = this.elements;
    var me = matrix2.elements;
    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i]) {
        return false;
      }
    }
    return true;
  },
  fromArray: function(array, offset) {
    var this$1 = this;
    if (offset === void 0) {
      offset = 0;
    }
    for (var i = 0; i < 16; i++) {
      this$1.elements[i] = array[i + offset];
    }
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});
function DataTexture(data, width, height, format, type2, mapping2, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy, encoding);
  this.image = {data, width, height};
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
function CubeTexture(images, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy, encoding) {
  images = images !== void 0 ? images : [];
  mapping2 = mapping2 !== void 0 ? mapping2 : CubeReflectionMapping;
  Texture.call(this, images, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy, encoding);
  this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(value2) {
    this.image = value2;
  }
});
var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();
function UniformContainer() {
  this.seq = [];
  this.map = {};
}
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) {
    return array;
  }
  var n = nBlocks * blockSize, r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function allocTexUnits(renderer, n) {
  var r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (var i = 0; i !== n; ++i) {
    r[i] = renderer.allocTextureUnit();
  }
  return r;
}
function setValue1f(gl, v) {
  gl.uniform1f(this.addr, v);
}
function setValue1i(gl, v) {
  gl.uniform1i(this.addr, v);
}
function setValue2fv(gl, v) {
  if (v.x === void 0) {
    gl.uniform2fv(this.addr, v);
  } else {
    gl.uniform2f(this.addr, v.x, v.y);
  }
}
function setValue3fv(gl, v) {
  if (v.x !== void 0) {
    gl.uniform3f(this.addr, v.x, v.y, v.z);
  } else if (v.r !== void 0) {
    gl.uniform3f(this.addr, v.r, v.g, v.b);
  } else {
    gl.uniform3fv(this.addr, v);
  }
}
function setValue4fv(gl, v) {
  if (v.x === void 0) {
    gl.uniform4fv(this.addr, v);
  } else {
    gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
  }
}
function setValue2fm(gl, v) {
  gl.uniformMatrix2fv(this.addr, false, v.elements || v);
}
function setValue3fm(gl, v) {
  if (v.elements === void 0) {
    gl.uniformMatrix3fv(this.addr, false, v);
  } else {
    mat3array.set(v.elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
  }
}
function setValue4fm(gl, v) {
  if (v.elements === void 0) {
    gl.uniformMatrix4fv(this.addr, false, v);
  } else {
    mat4array.set(v.elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
  }
}
function setValueT1(gl, v, renderer) {
  var unit = renderer.allocTextureUnit();
  gl.uniform1i(this.addr, unit);
  renderer.setTexture2D(v || emptyTexture, unit);
}
function setValueT6(gl, v, renderer) {
  var unit = renderer.allocTextureUnit();
  gl.uniform1i(this.addr, unit);
  renderer.setTextureCube(v || emptyCubeTexture, unit);
}
function setValue2iv(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValue3iv(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValue4iv(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function getSingularSetter(type2) {
  switch (type2) {
    case 5126:
      return setValue1f;
    case 35664:
      return setValue2fv;
    case 35665:
      return setValue3fv;
    case 35666:
      return setValue4fv;
    case 35674:
      return setValue2fm;
    case 35675:
      return setValue3fm;
    case 35676:
      return setValue4fm;
    case 35678:
    case 36198:
      return setValueT1;
    case 35680:
      return setValueT6;
    case 5124:
    case 35670:
      return setValue1i;
    case 35667:
    case 35671:
      return setValue2iv;
    case 35668:
    case 35672:
      return setValue3iv;
    case 35669:
    case 35673:
      return setValue4iv;
  }
}
function setValue1fv(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValue1iv(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2a(gl, v) {
  gl.uniform2fv(this.addr, flatten(v, this.size, 2));
}
function setValueV3a(gl, v) {
  gl.uniform3fv(this.addr, flatten(v, this.size, 3));
}
function setValueV4a(gl, v) {
  gl.uniform4fv(this.addr, flatten(v, this.size, 4));
}
function setValueM2a(gl, v) {
  gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
}
function setValueM3a(gl, v) {
  gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
}
function setValueM4a(gl, v) {
  gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
}
function setValueT1a(gl, v, renderer) {
  var n = v.length, units = allocTexUnits(renderer, n);
  gl.uniform1iv(this.addr, units);
  for (var i = 0; i !== n; ++i) {
    renderer.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT6a(gl, v, renderer) {
  var n = v.length, units = allocTexUnits(renderer, n);
  gl.uniform1iv(this.addr, units);
  for (var i = 0; i !== n; ++i) {
    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function getPureArraySetter(type2) {
  switch (type2) {
    case 5126:
      return setValue1fv;
    case 35664:
      return setValueV2a;
    case 35665:
      return setValueV3a;
    case 35666:
      return setValueV4a;
    case 35674:
      return setValueM2a;
    case 35675:
      return setValueM3a;
    case 35676:
      return setValueM4a;
    case 35678:
      return setValueT1a;
    case 35680:
      return setValueT6a;
    case 5124:
    case 35670:
      return setValue1iv;
    case 35667:
    case 35671:
      return setValue2iv;
    case 35668:
    case 35672:
      return setValue3iv;
    case 35669:
    case 35673:
      return setValue4iv;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
function StructuredUniform(id) {
  this.id = id;
  UniformContainer.call(this);
}
StructuredUniform.prototype.setValue = function(gl, value2) {
  var seq = this.seq;
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    u.setValue(gl, value2[u.id]);
  }
};
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  for (; ; ) {
    var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) {
      id = id | 0;
    }
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      var map2 = container.map, next = map2[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program, renderer) {
  var this$1 = this;
  UniformContainer.call(this);
  this.renderer = renderer;
  var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < n; ++i) {
    var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
    parseUniform(info, addr, this$1);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value2) {
  var u = this.map[name];
  if (u !== void 0) {
    u.setValue(gl, value2, this.renderer);
  }
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  var v = object[name];
  if (v !== void 0) {
    this.setValue(gl, name, v);
  }
};
WebGLUniforms.upload = function(gl, seq, values, renderer) {
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, renderer);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  var r = [];
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    if (u.id in values) {
      r.push(u);
    }
  }
  return r;
};
var ColorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function Color(r, g, b) {
  if (g === void 0 && b === void 0) {
    return this.set(r);
  }
  return this.setRGB(r, g, b);
}
Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function(value2) {
    if (value2 && value2.isColor) {
      this.copy(value2);
    } else if (typeof value2 === "number") {
      this.setHex(value2);
    } else if (typeof value2 === "string") {
      this.setStyle(value2);
    }
    return this;
  },
  setScalar: function(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function() {
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * 6 * (2 / 3 - t);
      }
      return p;
    }
    return function setHSL(h, s, l) {
      h = _Math.euclideanModulo(h, 1);
      s = _Math.clamp(s, 0, 1);
      l = _Math.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function(style) {
    function handleAlpha(string) {
      if (string === void 0) {
        return;
      }
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    var m2;
    if (m2 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      var color;
      var name = m2[1];
      var components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }
          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            var h = parseFloat(color[1]) / 360;
            var s = parseInt(color[2], 10) / 100;
            var l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      var hex = m2[1];
      var size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      var hex = ColorKeywords[style];
      if (hex !== void 0) {
        this.setHex(hex);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
    }
    return this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function(color, gammaFactor) {
    if (gammaFactor === void 0) {
      gammaFactor = 2;
    }
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function(color, gammaFactor) {
    if (gammaFactor === void 0) {
      gammaFactor = 2;
    }
    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function() {
    var r = this.r, g = this.g, b = this.b;
    this.r = r * r;
    this.g = g * g;
    this.b = b * b;
    return this;
  },
  convertLinearToGamma: function() {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(optionalTarget) {
    var hsl = optionalTarget || {h: 0, s: 0, l: 0};
    var r = this.r, g = this.g, b = this.b;
    var max2 = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min + max2) / 2;
    if (min === max2) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max2 - min;
      saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
      switch (max2) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;
    return hsl;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: function(h, s, l) {
    var hsl = this.getHSL();
    hsl.h += h;
    hsl.s += s;
    hsl.l += l;
    this.setHSL(hsl.h, hsl.s, hsl.l);
    return this;
  },
  add: function(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  equals: function(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  toJSON: function() {
    return this.getHex();
  }
});
var UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    offsetRepeat: {value: new Vector4(0, 0, 1, 1)},
    specularMap: {value: null},
    alphaMap: {value: null},
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    offsetRepeat: {value: new Vector4(0, 0, 1, 1)}
  }
};
var UniformsUtils = {
  merge: function(uniforms) {
    var this$1 = this;
    var merged = {};
    for (var u = 0; u < uniforms.length; u++) {
      var tmp2 = this$1.clone(uniforms[u]);
      for (var p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  },
  clone: function(uniforms_src) {
    var uniforms_dst = {};
    for (var u in uniforms_src) {
      uniforms_dst[u] = {};
      for (var p in uniforms_src[u]) {
        var parameter_src = uniforms_src[u][p];
        if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
          uniforms_dst[u][p] = parameter_src.clone();
        } else if (Array.isArray(parameter_src)) {
          uniforms_dst[u][p] = parameter_src.slice();
        } else {
          uniforms_dst[u][p] = parameter_src;
        }
      }
    }
    return uniforms_dst;
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "\nvec3 transformed = vec3( position );\n";
var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		return distanceFalloff * maxDistanceCutoffFactor;\n#else\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float theta = acos( dot( N, V ) );\n	vec2 uv = vec2(\n		sqrt( saturate( roughness ) ),\n		saturate( theta / ( 0.5 * PI ) ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n	float b = 3.45068 + (4.18814 + y) * y;\n	float v = a / b;\n	float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	vec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n	return result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n		\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n			vec4 plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	\n	#endif\n#endif\n";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n	mat3 tmp;\n	tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n	tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n	tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n	return tmp;\n}\n";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M            = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float D      = max( maxRange / maxRGB, 1.0 );\n	D            = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract(Le);\n	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n	return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";
var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif\n";
var gradientmap_pars_fragment = "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif\n";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltcMat;	uniform sampler2D ltcMag;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		float norm = texture2D( ltcMag, uv ).a;\n		vec4 t = texture2D( ltcMat, uv );\n		mat3 mInv = mat3(\n			vec3(   1,   0, t.y ),\n			vec3(   0, t.z,   0 ),\n			vec3( t.w,   0, t.x )\n		);\n		reflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";
var map_particle_fragment = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
var map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif\n";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
var normal_flip = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n";
var normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
var dithering_pars_fragment = "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif\n";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif\n";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n";
var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";
var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}\n";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}\n";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n";
var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n";
var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}\n";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n";
var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";
var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_template,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_flip,
  normal_fragment,
  normalmap_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert
};
var ShaderLib = {
  basic: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 0.5},
        metalness: {value: 0.5},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  points: {
    uniforms: UniformsUtils.merge([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  cube: {
    uniforms: {
      tCube: {value: null},
      tFlip: {value: -1},
      opacity: {value: 1}
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null},
      tFlip: {value: -1}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: {
      lightPos: {value: new Vector3()}
    },
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  }
};
ShaderLib.physical = {
  uniforms: UniformsUtils.merge([
    ShaderLib.standard.uniforms,
    {
      clearCoat: {value: 0},
      clearCoatRoughness: {value: 0}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function Box2(min, max2) {
  this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
  this.max = max2 !== void 0 ? max2 : new Vector2(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
  set: function(min, max2) {
    this.min.copy(min);
    this.max.copy(max2);
    return this;
  },
  setFromPoints: function(points) {
    var this$1 = this;
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this$1.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector2();
    return function setFromCenterAndSize(center2, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center2).sub(halfSize);
      this.max.copy(center2).add(halfSize);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(optionalTarget) {
    var result = optionalTarget || new Vector2();
    return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(optionalTarget) {
    var result = optionalTarget || new Vector2();
    return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function(point, optionalTarget) {
    var result = optionalTarget || new Vector2();
    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function(point, optionalTarget) {
    var result = optionalTarget || new Vector2();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector2();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function LensFlarePlugin(renderer, flares) {
  var gl = renderer.context;
  var state = renderer.state;
  var vertexBuffer, elementBuffer;
  var shader, program, attributes, uniforms;
  var tempTexture, occlusionTexture;
  function init3() {
    var vertices = new Float32Array([
      -1,
      -1,
      0,
      0,
      1,
      -1,
      1,
      0,
      1,
      1,
      1,
      1,
      -1,
      1,
      0,
      1
    ]);
    var faces = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    tempTexture = gl.createTexture();
    occlusionTexture = gl.createTexture();
    state.bindTexture(gl.TEXTURE_2D, tempTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    shader = {
      vertexShader: [
        "uniform lowp int renderType;",
        "uniform vec3 screenPosition;",
        "uniform vec2 scale;",
        "uniform float rotation;",
        "uniform sampler2D occlusionMap;",
        "attribute vec2 position;",
        "attribute vec2 uv;",
        "varying vec2 vUV;",
        "varying float vVisibility;",
        "void main() {",
        "vUV = uv;",
        "vec2 pos = position;",
        "if ( renderType == 2 ) {",
        "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
        "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
        "vVisibility =        visibility.r / 9.0;",
        "vVisibility *= 1.0 - visibility.g / 9.0;",
        "vVisibility *=       visibility.b / 9.0;",
        "vVisibility *= 1.0 - visibility.a / 9.0;",
        "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
        "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
        "}",
        "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
        "}"
      ].join("\n"),
      fragmentShader: [
        "uniform lowp int renderType;",
        "uniform sampler2D map;",
        "uniform float opacity;",
        "uniform vec3 color;",
        "varying vec2 vUV;",
        "varying float vVisibility;",
        "void main() {",
        "if ( renderType == 0 ) {",
        "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
        "} else if ( renderType == 1 ) {",
        "gl_FragColor = texture2D( map, vUV );",
        "} else {",
        "vec4 texture = texture2D( map, vUV );",
        "texture.a *= opacity * vVisibility;",
        "gl_FragColor = texture;",
        "gl_FragColor.rgb *= color;",
        "}",
        "}"
      ].join("\n")
    };
    program = createProgram(shader);
    attributes = {
      vertex: gl.getAttribLocation(program, "position"),
      uv: gl.getAttribLocation(program, "uv")
    };
    uniforms = {
      renderType: gl.getUniformLocation(program, "renderType"),
      map: gl.getUniformLocation(program, "map"),
      occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
      opacity: gl.getUniformLocation(program, "opacity"),
      color: gl.getUniformLocation(program, "color"),
      scale: gl.getUniformLocation(program, "scale"),
      rotation: gl.getUniformLocation(program, "rotation"),
      screenPosition: gl.getUniformLocation(program, "screenPosition")
    };
  }
  this.render = function(scene, camera, viewport) {
    if (flares.length === 0) {
      return;
    }
    var tempPosition = new Vector3();
    var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
    var size = 16 / viewport.w, scale2 = new Vector2(size * invAspect, size);
    var screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1);
    var validArea = new Box2();
    validArea.min.set(viewport.x, viewport.y);
    validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
    if (program === void 0) {
      init3();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.vertex);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    gl.uniform1i(uniforms.occlusionMap, 0);
    gl.uniform1i(uniforms.map, 1);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    state.disable(gl.CULL_FACE);
    state.buffers.depth.setMask(false);
    for (var i = 0, l = flares.length; i < l; i++) {
      size = 16 / viewport.w;
      scale2.set(size * invAspect, size);
      var flare = flares[i];
      tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
      tempPosition.applyMatrix4(camera.matrixWorldInverse);
      tempPosition.applyMatrix4(camera.projectionMatrix);
      screenPosition.copy(tempPosition);
      screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
      screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;
      if (validArea.containsPoint(screenPositionPixels) === true) {
        state.activeTexture(gl.TEXTURE0);
        state.bindTexture(gl.TEXTURE_2D, null);
        state.activeTexture(gl.TEXTURE1);
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
        gl.uniform1i(uniforms.renderType, 0);
        gl.uniform2f(uniforms.scale, scale2.x, scale2.y);
        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
        state.disable(gl.BLEND);
        state.enable(gl.DEPTH_TEST);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        state.activeTexture(gl.TEXTURE0);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
        gl.uniform1i(uniforms.renderType, 1);
        state.disable(gl.DEPTH_TEST);
        state.activeTexture(gl.TEXTURE1);
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        flare.positionScreen.copy(screenPosition);
        if (flare.customUpdateCallback) {
          flare.customUpdateCallback(flare);
        } else {
          flare.updateLensFlares();
        }
        gl.uniform1i(uniforms.renderType, 2);
        state.enable(gl.BLEND);
        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
          var sprite = flare.lensFlares[j];
          if (sprite.opacity > 1e-3 && sprite.scale > 1e-3) {
            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;
            size = sprite.size * sprite.scale / viewport.w;
            scale2.x = size * invAspect;
            scale2.y = size;
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            gl.uniform2f(uniforms.scale, scale2.x, scale2.y);
            gl.uniform1f(uniforms.rotation, sprite.rotation);
            gl.uniform1f(uniforms.opacity, sprite.opacity);
            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
            renderer.setTexture2D(sprite.texture, 1);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
          }
        }
      }
    }
    state.enable(gl.CULL_FACE);
    state.enable(gl.DEPTH_TEST);
    state.buffers.depth.setMask(true);
    renderer.resetGLState();
  };
  function createProgram(shader2) {
    var program2 = gl.createProgram();
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var prefix = "precision " + renderer.getPrecision() + " float;\n";
    gl.shaderSource(fragmentShader, prefix + shader2.fragmentShader);
    gl.shaderSource(vertexShader, prefix + shader2.vertexShader);
    gl.compileShader(fragmentShader);
    gl.compileShader(vertexShader);
    gl.attachShader(program2, fragmentShader);
    gl.attachShader(program2, vertexShader);
    gl.linkProgram(program2);
    return program2;
  }
}
function SpritePlugin(renderer, sprites) {
  var gl = renderer.context;
  var state = renderer.state;
  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var texture;
  var spritePosition = new Vector3();
  var spriteRotation = new Quaternion();
  var spriteScale = new Vector3();
  function init3() {
    var vertices = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]);
    var faces = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    program = createProgram();
    attributes = {
      position: gl.getAttribLocation(program, "position"),
      uv: gl.getAttribLocation(program, "uv")
    };
    uniforms = {
      uvOffset: gl.getUniformLocation(program, "uvOffset"),
      uvScale: gl.getUniformLocation(program, "uvScale"),
      rotation: gl.getUniformLocation(program, "rotation"),
      scale: gl.getUniformLocation(program, "scale"),
      color: gl.getUniformLocation(program, "color"),
      map: gl.getUniformLocation(program, "map"),
      opacity: gl.getUniformLocation(program, "opacity"),
      modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
      projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
      fogType: gl.getUniformLocation(program, "fogType"),
      fogDensity: gl.getUniformLocation(program, "fogDensity"),
      fogNear: gl.getUniformLocation(program, "fogNear"),
      fogFar: gl.getUniformLocation(program, "fogFar"),
      fogColor: gl.getUniformLocation(program, "fogColor"),
      alphaTest: gl.getUniformLocation(program, "alphaTest")
    };
    var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    canvas.width = 8;
    canvas.height = 8;
    var context2 = canvas.getContext("2d");
    context2.fillStyle = "white";
    context2.fillRect(0, 0, 8, 8);
    texture = new Texture(canvas);
    texture.needsUpdate = true;
  }
  this.render = function(scene, camera) {
    if (sprites.length === 0) {
      return;
    }
    if (program === void 0) {
      init3();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.position);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    state.disable(gl.CULL_FACE);
    state.enable(gl.BLEND);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
    state.activeTexture(gl.TEXTURE0);
    gl.uniform1i(uniforms.map, 0);
    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;
    if (fog) {
      gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
      if (fog.isFog) {
        gl.uniform1f(uniforms.fogNear, fog.near);
        gl.uniform1f(uniforms.fogFar, fog.far);
        gl.uniform1i(uniforms.fogType, 1);
        oldFogType = 1;
        sceneFogType = 1;
      } else if (fog.isFogExp2) {
        gl.uniform1f(uniforms.fogDensity, fog.density);
        gl.uniform1i(uniforms.fogType, 2);
        oldFogType = 2;
        sceneFogType = 2;
      }
    } else {
      gl.uniform1i(uniforms.fogType, 0);
      oldFogType = 0;
      sceneFogType = 0;
    }
    for (var i = 0, l = sprites.length; i < l; i++) {
      var sprite = sprites[i];
      sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
      sprite.z = -sprite.modelViewMatrix.elements[14];
    }
    sprites.sort(painterSortStable2);
    var scale2 = [];
    for (var i = 0, l = sprites.length; i < l; i++) {
      var sprite = sprites[i];
      var material = sprite.material;
      if (material.visible === false) {
        continue;
      }
      sprite.onBeforeRender(renderer, scene, camera, void 0, material, void 0);
      gl.uniform1f(uniforms.alphaTest, material.alphaTest);
      gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
      sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
      scale2[0] = spriteScale.x;
      scale2[1] = spriteScale.y;
      var fogType = 0;
      if (scene.fog && material.fog) {
        fogType = sceneFogType;
      }
      if (oldFogType !== fogType) {
        gl.uniform1i(uniforms.fogType, fogType);
        oldFogType = fogType;
      }
      if (material.map !== null) {
        gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
      } else {
        gl.uniform2f(uniforms.uvOffset, 0, 0);
        gl.uniform2f(uniforms.uvScale, 1, 1);
      }
      gl.uniform1f(uniforms.opacity, material.opacity);
      gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
      gl.uniform1f(uniforms.rotation, material.rotation);
      gl.uniform2fv(uniforms.scale, scale2);
      state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      state.buffers.depth.setTest(material.depthTest);
      state.buffers.depth.setMask(material.depthWrite);
      if (material.map) {
        renderer.setTexture2D(material.map, 0);
      } else {
        renderer.setTexture2D(texture, 0);
      }
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      sprite.onAfterRender(renderer, scene, camera, void 0, material, void 0);
    }
    state.enable(gl.CULL_FACE);
    renderer.resetGLState();
  };
  function createProgram() {
    var program2 = gl.createProgram();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(vertexShader, [
      "precision " + renderer.getPrecision() + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform float rotation;",
      "uniform vec2 scale;",
      "uniform vec2 uvOffset;",
      "uniform vec2 uvScale;",
      "attribute vec2 position;",
      "attribute vec2 uv;",
      "varying vec2 vUV;",
      "void main() {",
      "vUV = uvOffset + uv * uvScale;",
      "vec2 alignedPosition = position * scale;",
      "vec2 rotatedPosition;",
      "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
      "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
      "vec4 finalPosition;",
      "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
      "finalPosition.xy += rotatedPosition;",
      "finalPosition = projectionMatrix * finalPosition;",
      "gl_Position = finalPosition;",
      "}"
    ].join("\n"));
    gl.shaderSource(fragmentShader, [
      "precision " + renderer.getPrecision() + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform vec3 color;",
      "uniform sampler2D map;",
      "uniform float opacity;",
      "uniform int fogType;",
      "uniform vec3 fogColor;",
      "uniform float fogDensity;",
      "uniform float fogNear;",
      "uniform float fogFar;",
      "uniform float alphaTest;",
      "varying vec2 vUV;",
      "void main() {",
      "vec4 texture = texture2D( map, vUV );",
      "if ( texture.a < alphaTest ) discard;",
      "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
      "if ( fogType > 0 ) {",
      "float depth = gl_FragCoord.z / gl_FragCoord.w;",
      "float fogFactor = 0.0;",
      "if ( fogType == 1 ) {",
      "fogFactor = smoothstep( fogNear, fogFar, depth );",
      "} else {",
      "const float LOG2 = 1.442695;",
      "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
      "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
      "}",
      "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
      "}",
      "}"
    ].join("\n"));
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);
    gl.attachShader(program2, vertexShader);
    gl.attachShader(program2, fragmentShader);
    gl.linkProgram(program2);
    return program2;
  }
  function painterSortStable2(a, b) {
    if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return b.id - a.id;
    }
  }
}
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.lights = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.shading = SmoothShading;
  this.vertexColors = NoColors;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.overdraw = 0;
  this.visible = true;
  this.needsUpdate = true;
}
Object.assign(Material.prototype, EventDispatcher.prototype, {
  isMaterial: true,
  onBeforeCompile: function() {
  },
  setValues: function(values) {
    var this$1 = this;
    if (values === void 0) {
      return;
    }
    for (var key in values) {
      var newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      var currentValue = this$1[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this$1.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else if (key === "overdraw") {
        this$1[key] = Number(newValue);
      } else {
        this$1[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    var isRoot = meta === void 0;
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    var data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") {
      data.name = this.name;
    }
    if (this.color && this.color.isColor) {
      data.color = this.color.getHex();
    }
    if (this.roughness !== void 0) {
      data.roughness = this.roughness;
    }
    if (this.metalness !== void 0) {
      data.metalness = this.metalness;
    }
    if (this.emissive && this.emissive.isColor) {
      data.emissive = this.emissive.getHex();
    }
    if (this.specular && this.specular.isColor) {
      data.specular = this.specular.getHex();
    }
    if (this.shininess !== void 0) {
      data.shininess = this.shininess;
    }
    if (this.clearCoat !== void 0) {
      data.clearCoat = this.clearCoat;
    }
    if (this.clearCoatRoughness !== void 0) {
      data.clearCoatRoughness = this.clearCoatRoughness;
    }
    if (this.map && this.map.isTexture) {
      data.map = this.map.toJSON(meta).uuid;
    }
    if (this.alphaMap && this.alphaMap.isTexture) {
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    }
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) {
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    }
    if (this.metalnessMap && this.metalnessMap.isTexture) {
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    }
    if (this.emissiveMap && this.emissiveMap.isTexture) {
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    }
    if (this.specularMap && this.specularMap.isTexture) {
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    }
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0) {
      data.size = this.size;
    }
    if (this.sizeAttenuation !== void 0) {
      data.sizeAttenuation = this.sizeAttenuation;
    }
    if (this.blending !== NormalBlending) {
      data.blending = this.blending;
    }
    if (this.shading !== SmoothShading) {
      data.shading = this.shading;
    }
    if (this.side !== FrontSide) {
      data.side = this.side;
    }
    if (this.vertexColors !== NoColors) {
      data.vertexColors = this.vertexColors;
    }
    if (this.opacity < 1) {
      data.opacity = this.opacity;
    }
    if (this.transparent === true) {
      data.transparent = this.transparent;
    }
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    if (this.alphaTest > 0) {
      data.alphaTest = this.alphaTest;
    }
    if (this.premultipliedAlpha === true) {
      data.premultipliedAlpha = this.premultipliedAlpha;
    }
    if (this.wireframe === true) {
      data.wireframe = this.wireframe;
    }
    if (this.wireframeLinewidth > 1) {
      data.wireframeLinewidth = this.wireframeLinewidth;
    }
    if (this.wireframeLinecap !== "round") {
      data.wireframeLinecap = this.wireframeLinecap;
    }
    if (this.wireframeLinejoin !== "round") {
      data.wireframeLinejoin = this.wireframeLinejoin;
    }
    data.skinning = this.skinning;
    data.morphTargets = this.morphTargets;
    data.dithering = this.dithering;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0) {
        data.textures = textures;
      }
      if (images.length > 0) {
        data.images = images;
      }
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.shading = source.shading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.overdraw = source.overdraw;
    this.visible = source.visible;
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes, dstPlanes = null;
    if (srcPlanes !== null) {
      var n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (var i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = UniformsUtils.clone(source.uniforms);
  this.defines = source.defines;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  var data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = this.uniforms;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  return data;
};
function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDepthMaterial";
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
function Box3(min, max2) {
  this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
  this.max = max2 !== void 0 ? max2 : new Vector3(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box3.prototype, {
  isBox3: true,
  set: function(min, max2) {
    this.min.copy(min);
    this.max.copy(max2);
    return this;
  },
  setFromArray: function(array) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i = 0, l = array.length; i < l; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX) {
        minX = x;
      }
      if (y < minY) {
        minY = y;
      }
      if (z < minZ) {
        minZ = z;
      }
      if (x > maxX) {
        maxX = x;
      }
      if (y > maxY) {
        maxY = y;
      }
      if (z > maxZ) {
        maxZ = z;
      }
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function(attribute) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i = 0, l = attribute.count; i < l; i++) {
      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);
      if (x < minX) {
        minX = x;
      }
      if (y < minY) {
        minY = y;
      }
      if (z < minZ) {
        minZ = z;
      }
      if (x > maxX) {
        maxX = x;
      }
      if (y > maxY) {
        maxY = y;
      }
      if (z > maxZ) {
        maxZ = z;
      }
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function(points) {
    var this$1 = this;
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this$1.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector3();
    return function setFromCenterAndSize(center2, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center2).sub(halfSize);
      this.max.copy(center2).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function() {
    var v1 = new Vector3();
    return function expandByObject(object) {
      var scope = this;
      object.updateMatrixWorld(true);
      object.traverse(function(node) {
        var i, l;
        var geometry = node.geometry;
        if (geometry !== void 0) {
          if (geometry.isGeometry) {
            var vertices = geometry.vertices;
            for (i = 0, l = vertices.length; i < l; i++) {
              v1.copy(vertices[i]);
              v1.applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          } else if (geometry.isBufferGeometry) {
            var attribute = geometry.attributes.position;
            if (attribute !== void 0) {
              for (i = 0, l = attribute.count; i < l; i++) {
                v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                scope.expandByPoint(v1);
              }
            }
          }
        }
      });
      return this;
    };
  }(),
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function(point, optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function() {
    var closestPoint = new Vector3();
    return function intersectsSphere(sphere) {
      this.clampPoint(sphere.center, closestPoint);
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function(plane) {
    var min, max2;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min <= plane.constant && max2 >= plane.constant;
  },
  clampPoint: function(point, optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector3();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function() {
    var v1 = new Vector3();
    return function getBoundingSphere(optionalTarget) {
      var result = optionalTarget || new Sphere();
      this.getCenter(result.center);
      result.radius = this.getSize(v1).length() * 0.5;
      return result;
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) {
      this.makeEmpty();
    }
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function() {
    var points = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    return function applyMatrix4(matrix2) {
      if (this.isEmpty()) {
        return this;
      }
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix2);
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix2);
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix2);
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix2);
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix2);
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix2);
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix2);
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix2);
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function Sphere(center2, radius) {
  this.center = center2 !== void 0 ? center2 : new Vector3();
  this.radius = radius !== void 0 ? radius : 0;
}
Object.assign(Sphere.prototype, {
  set: function(center2, radius) {
    this.center.copy(center2);
    this.radius = radius;
    return this;
  },
  setFromPoints: function() {
    var box = new Box3();
    return function setFromPoints(points, optionalCenter) {
      var center2 = this.center;
      if (optionalCenter !== void 0) {
        center2.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center2);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function() {
    return this.radius <= 0;
  },
  containsPoint: function(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function(box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function(plane) {
    return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
  },
  clampPoint: function(point, optionalTarget) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    var result = optionalTarget || new Vector3();
    result.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      result.sub(this.center).normalize();
      result.multiplyScalar(this.radius).add(this.center);
    }
    return result;
  },
  getBoundingBox: function(optionalTarget) {
    var box = optionalTarget || new Box3();
    box.set(this.center, this.center);
    box.expandByScalar(this.radius);
    return box;
  },
  applyMatrix4: function(matrix2) {
    this.center.applyMatrix4(matrix2);
    this.radius = this.radius * matrix2.getMaxScaleOnAxis();
    return this;
  },
  translate: function(offset) {
    this.center.add(offset);
    return this;
  },
  equals: function(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});
function Matrix3() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(m2) {
    var te = this.elements;
    var me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function(m2) {
    var me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      var this$1 = this;
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix3(this$1);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  multiply: function(m2) {
    return this.multiplyMatrices(this, m2);
  },
  premultiply: function(m2) {
    return this.multiplyMatrices(m2, this);
  },
  multiplyMatrices: function(a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[3], a13 = ae[6];
    var a21 = ae[1], a22 = ae[4], a23 = ae[7];
    var a31 = ae[2], a32 = ae[5], a33 = ae[8];
    var b11 = be[0], b12 = be[3], b13 = be[6];
    var b21 = be[1], b22 = be[4], b23 = be[7];
    var b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function(s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function() {
    var te = this.elements;
    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function(matrix2, throwOnDegenerate) {
    if (matrix2 && matrix2.isMatrix4) {
      console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
    }
    var me = matrix2.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) {
      var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function() {
    var tmp2, m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  },
  getNormalMatrix: function(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function(r) {
    var m2 = this.elements;
    r[0] = m2[0];
    r[1] = m2[3];
    r[2] = m2[6];
    r[3] = m2[1];
    r[4] = m2[4];
    r[5] = m2[7];
    r[6] = m2[2];
    r[7] = m2[5];
    r[8] = m2[8];
    return this;
  },
  equals: function(matrix2) {
    var te = this.elements;
    var me = matrix2.elements;
    for (var i = 0; i < 9; i++) {
      if (te[i] !== me[i]) {
        return false;
      }
    }
    return true;
  },
  fromArray: function(array, offset) {
    var this$1 = this;
    if (offset === void 0) {
      offset = 0;
    }
    for (var i = 0; i < 9; i++) {
      this$1.elements[i] = array[i + offset];
    }
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});
function Plane(normal2, constant) {
  this.normal = normal2 !== void 0 ? normal2 : new Vector3(1, 0, 0);
  this.constant = constant !== void 0 ? constant : 0;
}
Object.assign(Plane.prototype, {
  set: function(normal2, constant) {
    this.normal.copy(normal2);
    this.constant = constant;
    return this;
  },
  setComponents: function(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function(normal2, point) {
    this.normal.copy(normal2);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function setFromCoplanarPoints(a, b, c) {
      var normal2 = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal2, a);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function() {
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function(point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function(point, optionalTarget) {
    return this.orthoPoint(point, optionalTarget).sub(point).negate();
  },
  orthoPoint: function(point, optionalTarget) {
    var perpendicularMagnitude = this.distanceToPoint(point);
    var result = optionalTarget || new Vector3();
    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
  },
  intersectLine: function() {
    var v1 = new Vector3();
    return function intersectLine(line, optionalTarget) {
      var result = optionalTarget || new Vector3();
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return result.copy(line.start);
        }
        return void 0;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return void 0;
      }
      return result.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  intersectsLine: function(line) {
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function(box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function(sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function() {
    var v1 = new Vector3();
    var m1 = new Matrix3();
    return function applyMatrix4(matrix2, optionalNormalMatrix) {
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix2);
      var normalMatrix2 = optionalNormalMatrix || m1.getNormalMatrix(matrix2);
      var normal2 = this.normal.applyMatrix3(normalMatrix2).normalize();
      this.constant = -referencePoint.dot(normal2);
      return this;
    };
  }(),
  translate: function(offset) {
    this.constant = this.constant - offset.dot(this.normal);
    return this;
  },
  equals: function(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== void 0 ? p0 : new Plane(),
    p1 !== void 0 ? p1 : new Plane(),
    p2 !== void 0 ? p2 : new Plane(),
    p3 !== void 0 ? p3 : new Plane(),
    p4 !== void 0 ? p4 : new Plane(),
    p5 !== void 0 ? p5 : new Plane()
  ];
}
Object.assign(Frustum.prototype, {
  set: function(p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(frustum) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  },
  setFromMatrix: function(m2) {
    var planes = this.planes;
    var me = m2.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function() {
    var sphere = new Sphere();
    return function intersectsObject(object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSprite: function() {
    var sphere = new Sphere();
    return function intersectsSprite(sprite) {
      sphere.center.set(0, 0, 0);
      sphere.radius = 0.7071067811865476;
      sphere.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function(sphere) {
    var planes = this.planes;
    var center2 = sphere.center;
    var negRadius = -sphere.radius;
    for (var i = 0; i < 6; i++) {
      var distance3 = planes[i].distanceToPoint(center2);
      if (distance3 < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function() {
    var p1 = new Vector3(), p2 = new Vector3();
    return function intersectsBox(box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        var d1 = plane.distanceToPoint(p1);
        var d2 = plane.distanceToPoint(p2);
        if (d1 < 0 && d2 < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function(point) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
});
function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
  var _gl = _renderer.context, _state = _renderer.state, _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _lightShadows = _lights.shadows, _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
  var cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
  ];
  var cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
  var cube2DViewPorts = [
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4()
  ];
  var depthMaterialTemplate = new MeshDepthMaterial();
  depthMaterialTemplate.depthPacking = RGBADepthPacking;
  depthMaterialTemplate.clipping = true;
  var distanceShader = ShaderLib["distanceRGBA"];
  var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);
  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = depthMaterialTemplate.clone();
    depthMaterial.morphTargets = useMorphing;
    depthMaterial.skinning = useSkinning;
    _depthMaterials[i] = depthMaterial;
    var distanceMaterial = new ShaderMaterial({
      defines: {
        USE_SHADOWMAP: ""
      },
      uniforms: distanceUniforms,
      vertexShader: distanceShader.vertexShader,
      fragmentShader: distanceShader.fragmentShader,
      morphTargets: useMorphing,
      skinning: useSkinning,
      clipping: true
    });
    _distanceMaterials[i] = distanceMaterial;
  }
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.renderReverseSided = true;
  this.renderSingleSided = true;
  this.render = function(scene, camera) {
    if (scope.enabled === false) {
      return;
    }
    if (scope.autoUpdate === false && scope.needsUpdate === false) {
      return;
    }
    if (_lightShadows.length === 0) {
      return;
    }
    _state.disable(_gl.BLEND);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    var faceCount;
    for (var i2 = 0, il = _lightShadows.length; i2 < il; i2++) {
      var light = _lightShadows[i2];
      var shadow = light.shadow;
      var isPointLight = light && light.isPointLight;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      var shadowCamera = shadow.camera;
      _shadowMapSize.copy(shadow.mapSize);
      _shadowMapSize.min(_maxShadowMapSize);
      if (isPointLight) {
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y;
        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4;
        _shadowMapSize.y *= 2;
      }
      if (shadow.map === null) {
        var pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadowCamera.updateProjectionMatrix();
      }
      if (shadow.isSpotLightShadow) {
        shadow.update(light);
      }
      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld);
      if (isPointLight) {
        faceCount = 6;
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      } else {
        faceCount = 1;
        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget);
        shadowCamera.updateMatrixWorld();
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);
          _lookTarget.add(cubeDirections[face]);
          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          var vpDimensions = cube2DViewPorts[face];
          _state.viewport(vpDimensions);
        }
        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        renderObject(scene, camera, shadowCamera, isPointLight);
      }
    }
    var clearColor = _renderer.getClearColor();
    var clearAlpha = _renderer.getClearAlpha();
    _renderer.setClearColor(clearColor, clearAlpha);
    scope.needsUpdate = false;
  };
  function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
    var geometry = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;
    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }
    if (!customMaterial) {
      var useMorphing2 = false;
      if (material.morphTargets) {
        if (geometry && geometry.isBufferGeometry) {
          useMorphing2 = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        } else if (geometry && geometry.isGeometry) {
          useMorphing2 = geometry.morphTargets && geometry.morphTargets.length > 0;
        }
      }
      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
      }
      var useSkinning2 = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing2) {
        variantIndex |= _MorphingFlag;
      }
      if (useSkinning2) {
        variantIndex |= _SkinningFlag;
      }
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      var keyA = result.uuid, keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      var cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    var side = material.side;
    if (scope.renderSingleSided && side == DoubleSide) {
      side = FrontSide;
    }
    if (scope.renderReverseSided) {
      if (side === FrontSide) {
        side = BackSide;
      } else if (side === BackSide) {
        side = FrontSide;
      }
    }
    result.side = side;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (isPointLight && result.uniforms.lightPos !== void 0) {
      result.uniforms.lightPos.value.copy(lightPositionWorld);
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, isPointLight) {
    if (object.visible === false) {
      return;
    }
    var visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        var geometry = _objects.update(object);
        var material = object.material;
        if (Array.isArray(material)) {
          var groups = geometry.groups;
          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial2 = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial2, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial2 = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial2, object, null);
        }
      }
    }
    var children = object.children;
    for (var i2 = 0, l = children.length; i2 < l; i2++) {
      renderObject(children[i2], camera, shadowCamera, isPointLight);
    }
  }
}
function WebGLAttributes(gl) {
  var buffers = {};
  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type2 = gl.FLOAT;
    if (array instanceof Float32Array) {
      type2 = gl.FLOAT;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      type2 = gl.UNSIGNED_SHORT;
    } else if (array instanceof Int16Array) {
      type2 = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type2 = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type2 = gl.INT;
    } else if (array instanceof Int8Array) {
      type2 = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type2 = gl.UNSIGNED_BYTE;
    }
    return {
      buffer,
      type: type2,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, gl.STATIC_DRAW);
    } else if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
    } else {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      updateRange.count = -1;
    }
  }
  function get7(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
      attribute = attribute.data;
    }
    return buffers[attribute.uuid];
  }
  function remove3(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
      attribute = attribute.data;
    }
    var data = buffers[attribute.uuid];
    if (data) {
      gl.deleteBuffer(data.buffer);
      delete buffers[attribute.uuid];
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) {
      attribute = attribute.data;
    }
    var data = buffers[attribute.uuid];
    if (data === void 0) {
      buffers[attribute.uuid] = createBuffer(attribute, bufferType);
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get7,
    remove: remove3,
    update: update2
  };
}
function Euler(x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Euler.DefaultOrder = "XYZ";
Object.defineProperties(Euler.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value2) {
      this._x = value2;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value2) {
      this._y = value2;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value2) {
      this._z = value2;
      this.onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(value2) {
      this._order = value2;
      this.onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m2, order, update2) {
    var clamp2 = _Math.clamp;
    var te = m2.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === "XYZ") {
      this._y = Math.asin(clamp2(m13, -1, 1));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === "YXZ") {
      this._x = Math.asin(-clamp2(m23, -1, 1));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === "ZXY") {
      this._x = Math.asin(clamp2(m32, -1, 1));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === "ZYX") {
      this._y = Math.asin(-clamp2(m31, -1, 1));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === "YZX") {
      this._z = Math.asin(clamp2(m21, -1, 1));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === "XZY") {
      this._z = Math.asin(-clamp2(m12, -1, 1));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
    }
    this._order = order;
    if (update2 !== false) {
      this.onChangeCallback();
    }
    return this;
  },
  setFromQuaternion: function() {
    var matrix2 = new Matrix4();
    return function setFromQuaternion(q, order, update2) {
      matrix2.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix2, order, update2);
    };
  }(),
  setFromVector3: function(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function() {
    var q = new Quaternion();
    return function reorder(newOrder) {
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) {
      this._order = array[3];
    }
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Layers() {
  this.mask = 1 | 0;
}
Object.assign(Layers.prototype, {
  set: function(channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function(channel) {
    this.mask |= 1 << channel | 0;
  },
  toggle: function(channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function(channel) {
    this.mask &= ~(1 << channel | 0);
  },
  test: function(layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
var object3DId = 0;
function Object3D() {
  Object.defineProperty(this, "id", {value: object3DId++});
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new Vector3();
  var rotation = new Euler();
  var quaternion = new Quaternion();
  var scale2 = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale2
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object.assign(Object3D.prototype, EventDispatcher.prototype, {
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix: function(matrix2) {
    this.matrix.multiplyMatrices(matrix2, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function() {
    var q1 = new Quaternion();
    return function rotateOnAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function rotateX(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function rotateY(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function rotateZ(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function() {
    var v1 = new Vector3();
    return function translateOnAxis(axis, distance3) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance3));
      return this;
    };
  }(),
  translateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function translateX(distance3) {
      return this.translateOnAxis(v1, distance3);
    };
  }(),
  translateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function translateY(distance3) {
      return this.translateOnAxis(v1, distance3);
    };
  }(),
  translateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function translateZ(distance3) {
      return this.translateOnAxis(v1, distance3);
    };
  }(),
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function() {
    var m1 = new Matrix4();
    return function worldToLocal(vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function() {
    var m1 = new Matrix4();
    return function lookAt(vector) {
      if (this.isCamera) {
        m1.lookAt(this.position, vector, this.up);
      } else {
        m1.lookAt(vector, this.position, this.up);
      }
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  add: function(object) {
    var arguments$1 = arguments;
    var this$1 = this;
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this$1.add(arguments$1[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({type: "added"});
      this.children.push(object);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    var arguments$1 = arguments;
    var this$1 = this;
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this$1.remove(arguments$1[i]);
      }
      return this;
    }
    var index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      object.dispatchEvent({type: "removed"});
      this.children.splice(index, 1);
    }
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value2) {
    var this$1 = this;
    if (this[name] === value2) {
      return this;
    }
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this$1.children[i];
      var object = child.getObjectByProperty(name, value2);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    this.updateMatrixWorld(true);
    return result.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function() {
    var position = new Vector3();
    var scale2 = new Vector3();
    return function getWorldQuaternion(optionalTarget) {
      var result = optionalTarget || new Quaternion();
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, result, scale2);
      return result;
    };
  }(),
  getWorldRotation: function() {
    var quaternion = new Quaternion();
    return function getWorldRotation(optionalTarget) {
      var result = optionalTarget || new Euler();
      this.getWorldQuaternion(quaternion);
      return result.setFromQuaternion(quaternion, this.rotation.order, false);
    };
  }(),
  getWorldScale: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    return function getWorldScale(optionalTarget) {
      var result = optionalTarget || new Vector3();
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, result);
      return result;
    };
  }(),
  getWorldDirection: function() {
    var quaternion = new Quaternion();
    return function getWorldDirection(optionalTarget) {
      var result = optionalTarget || new Vector3();
      this.getWorldQuaternion(quaternion);
      return result.set(0, 0, 1).applyQuaternion(quaternion);
    };
  }(),
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false) {
      return;
    }
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    var parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate) {
      this.updateMatrix();
    }
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  toJSON: function(meta) {
    var this$1 = this;
    var isRootObject = meta === void 0 || meta === "";
    var output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") {
      object.name = this.name;
    }
    if (JSON.stringify(this.userData) !== "{}") {
      object.userData = this.userData;
    }
    if (this.castShadow === true) {
      object.castShadow = true;
    }
    if (this.receiveShadow === true) {
      object.receiveShadow = true;
    }
    if (this.visible === false) {
      object.visible = false;
    }
    object.matrix = this.matrix.toArray();
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.geometry !== void 0) {
      object.geometry = serialize(meta.geometries, this.geometry);
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        var uuids = [];
        for (var i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this$1.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this$1.children[i].toJSON(meta).object);
      }
    }
    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (geometries.length > 0) {
        output.geometries = geometries;
      }
      if (materials.length > 0) {
        output.materials = materials;
      }
      if (textures.length > 0) {
        output.textures = textures;
      }
      if (images.length > 0) {
        output.images = images;
      }
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive) {
    var this$1 = this;
    if (recursive === void 0) {
      recursive = true;
    }
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this$1.add(child.clone());
      }
    }
    return this;
  }
});
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    return this;
  },
  getWorldDirection: function() {
    var quaternion = new Quaternion();
    return function getWorldDirection(optionalTarget) {
      var result = optionalTarget || new Vector3();
      this.getWorldQuaternion(quaternion);
      return result.set(0, 0, -1).applyQuaternion(quaternion);
    };
  }(),
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = "OrthographicCamera";
  this.zoom = 1;
  this.view = null;
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    this.view = {
      fullWidth,
      fullHeight,
      offsetX: x,
      offsetY: y,
      width,
      height
    };
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view = null;
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if (this.view !== null) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) {
      data.object.view = Object.assign({}, this.view);
    }
    return data;
  }
});
function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov !== void 0 ? fov : 50;
  this.zoom = 1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.focus = 10;
  this.aspect = aspect !== void 0 ? aspect : 1;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    this.view = {
      fullWidth,
      fullHeight,
      offsetX: x,
      offsetY: y,
      width,
      height
    };
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view = null;
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
    if (view !== null) {
      var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    var skew = this.filmOffset;
    if (skew !== 0) {
      left += near * skew / this.getFilmWidth();
    }
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) {
      data.object.view = Object.assign({}, this.view);
    }
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
function Face3(a, b, c, normal2, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal2 && normal2.isVector3 ? normal2 : new Vector3();
  this.vertexNormals = Array.isArray(normal2) ? normal2 : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
}
Object.assign(Face3.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    var this$1 = this;
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this$1.vertexNormals[i] = source.vertexNormals[i].clone();
    }
    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this$1.vertexColors[i] = source.vertexColors[i].clone();
    }
    return this;
  }
});
var count = 0;
function GeometryIdCount() {
  return count++;
}
function Geometry() {
  Object.defineProperty(this, "id", {value: GeometryIdCount()});
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Geometry";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Object.assign(Geometry.prototype, EventDispatcher.prototype, {
  isGeometry: true,
  applyMatrix: function(matrix2) {
    var this$1 = this;
    var normalMatrix2 = new Matrix3().getNormalMatrix(matrix2);
    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex2 = this$1.vertices[i];
      vertex2.applyMatrix4(matrix2);
    }
    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this$1.faces[i];
      face.normal.applyMatrix3(normalMatrix2).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix2).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate2(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function(geometry) {
    var scope = this;
    var indices = geometry.index !== null ? geometry.index.array : void 0;
    var attributes = geometry.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
    var colors = attributes.color !== void 0 ? attributes.color.array : void 0;
    var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
    var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
    if (uvs2 !== void 0) {
      this.faceVertexUvs[1] = [];
    }
    var tempNormals = [];
    var tempUVs = [];
    var tempUVs2 = [];
    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
      scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
      if (normals !== void 0) {
        tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
      }
      if (colors !== void 0) {
        scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
      }
      if (uvs !== void 0) {
        tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
      }
      if (uvs2 !== void 0) {
        tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
      }
    }
    function addFace(a, b, c, materialIndex) {
      var vertexNormals = normals !== void 0 ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
      var vertexColors = colors !== void 0 ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uvs !== void 0) {
        scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
      }
      if (uvs2 !== void 0) {
        scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
      }
    }
    var groups = geometry.groups;
    if (groups.length > 0) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var start = group.start;
        var count2 = group.count;
        for (var j = start, jl = start + count2; j < jl; j += 3) {
          if (indices !== void 0) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== void 0) {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      } else {
        for (var i = 0; i < positions.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    var offset = this.boundingBox.getCenter().negate();
    this.translate(offset.x, offset.y, offset.z);
    return offset;
  },
  normalize: function() {
    this.computeBoundingSphere();
    var center2 = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1 / radius;
    var matrix2 = new Matrix4();
    matrix2.set(s, 0, 0, -s * center2.x, 0, s, 0, -s * center2.y, 0, 0, s, -s * center2.z, 0, 0, 0, 1);
    this.applyMatrix(matrix2);
    return this;
  },
  computeFaceNormals: function() {
    var this$1 = this;
    var cb = new Vector3(), ab = new Vector3();
    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this$1.faces[f];
      var vA = this$1.vertices[face.a];
      var vB = this$1.vertices[face.b];
      var vC = this$1.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function(areaWeighted) {
    var this$1 = this;
    if (areaWeighted === void 0) {
      areaWeighted = true;
    }
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }
    if (areaWeighted) {
      var vA, vB, vC;
      var cb = new Vector3(), ab = new Vector3();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this$1.faces[f];
        vA = this$1.vertices[face.a];
        vB = this$1.vertices[face.b];
        vC = this$1.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this$1.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this$1.faces[f];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function() {
    var this$1 = this;
    var f, fl, face;
    this.computeFaceNormals();
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this$1.faces[f];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function() {
    var this$1 = this;
    var i, il, f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this$1.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals) {
        face.__originalVertexNormals = [];
      }
      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    }
    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      if (!this$1.morphNormals[i]) {
        this$1.morphNormals[i] = {};
        this$1.morphNormals[i].faceNormals = [];
        this$1.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this$1.morphNormals[i].faceNormals;
        var dstNormalsVertex = this$1.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new Vector3();
          vertexNormals = {a: new Vector3(), b: new Vector3(), c: new Vector3()};
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this$1.morphNormals[i];
      tmpGeo.vertices = this$1.morphTargets[i].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      var faceNormal, vertexNormals;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this$1.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this$1.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeLineDistances: function() {
    var this$1 = this;
    var d = 0;
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      if (i > 0) {
        d += vertices[i].distanceTo(vertices[i - 1]);
      }
      this$1.lineDistances[i] = d;
    }
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(geometry, matrix2, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
      return;
    }
    var normalMatrix2, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
    if (materialIndexOffset === void 0) {
      materialIndexOffset = 0;
    }
    if (matrix2 !== void 0) {
      normalMatrix2 = new Matrix3().getNormalMatrix(matrix2);
    }
    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex2 = vertices2[i];
      var vertexCopy = vertex2.clone();
      if (matrix2 !== void 0) {
        vertexCopy.applyMatrix4(matrix2);
      }
      vertices1.push(vertexCopy);
    }
    for (var i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    }
    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i], faceCopy, normal2, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix2 !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix2).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal2 = faceVertexNormals[j].clone();
        if (normalMatrix2 !== void 0) {
          normal2.applyMatrix3(normalMatrix2).normalize();
        }
        faceCopy.vertexNormals.push(normal2);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i], uvCopy = [];
      if (uv === void 0) {
        continue;
      }
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }
      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    mesh.matrixAutoUpdate && mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },
  mergeVertices: function() {
    var this$1 = this;
    var verticesMap = {};
    var unique = [], changes = [];
    var v, key;
    var precisionPoints = 4;
    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;
    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this$1.vertices[i];
      key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i;
        unique.push(this$1.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        changes[i] = changes[verticesMap[key]];
      }
    }
    var faceIndicesToRemove = [];
    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this$1.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c];
      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }
    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this$1.faces.splice(idx, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this$1.faceVertexUvs[j].splice(idx, 1);
      }
    }
    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  sortFacesByMaterialIndex: function() {
    var faces = this.faces;
    var length = faces.length;
    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    }
    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }
    faces.sort(materialIndexSort);
    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) {
      newUvs1 = [];
    }
    if (uvs2 && uvs2.length === length) {
      newUvs2 = [];
    }
    for (var i = 0; i < length; i++) {
      var id = faces[i]._id;
      if (newUvs1) {
        newUvs1.push(uvs1[id]);
      }
      if (newUvs2) {
        newUvs2.push(uvs2[id]);
      }
    }
    if (newUvs1) {
      this.faceVertexUvs[0] = newUvs1;
    }
    if (newUvs2) {
      this.faceVertexUvs[1] = newUvs2;
    }
  },
  toJSON: function() {
    var this$1 = this;
    var data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") {
      data.name = this.name;
    }
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0) {
          data[key] = parameters[key];
        }
      }
      return data;
    }
    var vertices = [];
    for (var i = 0; i < this.vertices.length; i++) {
      var vertex2 = this$1.vertices[i];
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
    }
    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};
    for (var i = 0; i < this.faces.length; i++) {
      var face = this$1.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false;
      var hasFaceVertexUv = this$1.faceVertexUvs[0][i] !== void 0;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        var faceVertexUvs = this$1.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value2, position, enabled) {
      return enabled ? value2 | 1 << position : value2 & ~(1 << position);
    }
    function getNormalIndex(normal2) {
      var hash = normal2.x.toString() + normal2.y.toString() + normal2.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal2.x, normal2.y, normal2.z);
      return normalsHash[hash];
    }
    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) {
      data.data.colors = colors;
    }
    if (uvs.length > 0) {
      data.data.uvs = [uvs];
    }
    data.data.faces = faces;
    return data;
  },
  clone: function() {
    return new Geometry().copy(this);
  },
  copy: function(source) {
    var this$1 = this;
    var i, il, j, jl, k, kl;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var vertices = source.vertices;
    for (i = 0, il = vertices.length; i < il; i++) {
      this$1.vertices.push(vertices[i].clone());
    }
    var colors = source.colors;
    for (i = 0, il = colors.length; i < il; i++) {
      this$1.colors.push(colors[i].clone());
    }
    var faces = source.faces;
    for (i = 0, il = faces.length; i < il; i++) {
      this$1.faces.push(faces[i].clone());
    }
    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];
      if (this$1.faceVertexUvs[i] === void 0) {
        this$1.faceVertexUvs[i] = [];
      }
      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j], uvsCopy = [];
        for (k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }
        this$1.faceVertexUvs[i].push(uvsCopy);
      }
    }
    var morphTargets = source.morphTargets;
    for (i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i].name;
      if (morphTargets[i].vertices !== void 0) {
        morphTarget.vertices = [];
        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      }
      if (morphTargets[i].normals !== void 0) {
        morphTarget.normals = [];
        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }
      this$1.morphTargets.push(morphTarget);
    }
    var morphNormals = source.morphNormals;
    for (i = 0, il = morphNormals.length; i < il; i++) {
      var morphNormal = {};
      if (morphNormals[i].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }
      this$1.morphNormals.push(morphNormal);
    }
    var skinWeights = source.skinWeights;
    for (i = 0, il = skinWeights.length; i < il; i++) {
      this$1.skinWeights.push(skinWeights[i].clone());
    }
    var skinIndices = source.skinIndices;
    for (i = 0, il = skinIndices.length; i < il; i++) {
      this$1.skinIndices.push(skinIndices[i].clone());
    }
    var lineDistances = source.lineDistances;
    for (i = 0, il = lineDistances.length; i < il; i++) {
      this$1.lineDistances.push(lineDistances[i]);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
function BufferAttribute(array, itemSize2, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.array = array;
  this.itemSize = itemSize2;
  this.count = array !== void 0 ? array.length / itemSize2 : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = {offset: 0, count: -1};
  this.onUploadCallback = function() {
  };
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value2) {
    if (value2 === true) {
      this.version++;
    }
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.itemSize : 0;
    this.array = array;
  },
  setDynamic: function(value2) {
    this.dynamic = value2;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    var this$1 = this;
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (var i = 0, l = this.itemSize; i < l; i++) {
      this$1.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = colors.length; i < l; i++) {
      var color = colors[i];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyIndicesArray: function(indices) {
    var array = this.array, offset = 0;
    for (var i = 0, l = indices.length; i < l; i++) {
      var index = indices[i];
      array[offset++] = index.a;
      array[offset++] = index.b;
      array[offset++] = index.c;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  set: function(value2, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.array.set(value2, offset);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
});
function Uint16BufferAttribute(array, itemSize2) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize2);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Uint32BufferAttribute(array, itemSize2) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize2);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize2) {
  BufferAttribute.call(this, new Float32Array(array), itemSize2);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function DirectGeometry() {
  this.indices = [];
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Object.assign(DirectGeometry.prototype, {
  computeGroups: function(geometry) {
    var group;
    var groups = [];
    var materialIndex = void 0;
    var faces = geometry.faces;
    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  },
  fromGeometry: function(geometry) {
    var this$1 = this;
    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = [];
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = [];
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;
    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      this$1.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this$1.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal2 = face.normal;
        this$1.normals.push(normal2, normal2, normal2);
      }
      var vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this$1.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color = face.color;
        this$1.colors.push(color, color, color);
      }
      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i];
        if (vertexUvs !== void 0) {
          this$1.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
          this$1.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i];
        if (vertexUvs !== void 0) {
          this$1.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
          this$1.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this$1.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this$1.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    return this;
  }
});
function arrayMax(array) {
  if (array.length === 0) {
    return -Infinity;
  }
  var max2 = array[0];
  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max2) {
      max2 = array[i];
    }
  }
  return max2;
}
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: GeometryIdCount()});
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
}
BufferGeometry.MaxIndex = 65535;
Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  addAttribute: function(name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      return;
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return;
    }
    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  removeAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function(start, count2, materialIndex) {
    this.groups.push({
      start,
      count: count2,
      materialIndex: materialIndex !== void 0 ? materialIndex : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count2) {
    this.drawRange.start = start;
    this.drawRange.count = count2;
  },
  applyMatrix: function(matrix2) {
    var position = this.attributes.position;
    if (position !== void 0) {
      matrix2.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }
    var normal2 = this.attributes.normal;
    if (normal2 !== void 0) {
      var normalMatrix2 = new Matrix3().getNormalMatrix(matrix2);
      normalMatrix2.applyToBufferAttribute(normal2);
      normal2.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate2(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function() {
    this.computeBoundingBox();
    var offset = this.boundingBox.getCenter().negate();
    this.translate(offset.x, offset.y, offset.z);
    return offset;
  },
  setFromObject: function(object) {
    var geometry = object.geometry;
    if (object.isPoints || object.isLine) {
      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      this.addAttribute("position", positions.copyVector3sArray(geometry.vertices));
      this.addAttribute("color", colors.copyColorsArray(geometry.colors));
      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }
    return this;
  },
  updateFromObject: function(object) {
    var geometry = object.geometry;
    if (object.isMesh) {
      var direct = geometry.__directGeometry;
      if (geometry.elementsNeedUpdate === true) {
        direct = void 0;
        geometry.elementsNeedUpdate = false;
      }
      if (direct === void 0) {
        return this.fromGeometry(geometry);
      }
      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }
    var attribute;
    if (geometry.verticesNeedUpdate === true) {
      attribute = this.attributes.position;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }
      geometry.verticesNeedUpdate = false;
    }
    if (geometry.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }
      geometry.normalsNeedUpdate = false;
    }
    if (geometry.colorsNeedUpdate === true) {
      attribute = this.attributes.color;
      if (attribute !== void 0) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }
      geometry.colorsNeedUpdate = false;
    }
    if (geometry.uvsNeedUpdate) {
      attribute = this.attributes.uv;
      if (attribute !== void 0) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }
      geometry.uvsNeedUpdate = false;
    }
    if (geometry.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;
      if (attribute !== void 0) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }
      geometry.lineDistancesNeedUpdate = false;
    }
    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }
    return this;
  },
  fromGeometry: function(geometry) {
    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function(geometry) {
    var this$1 = this;
    var positions = new Float32Array(geometry.vertices.length * 3);
    this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
    if (geometry.normals.length > 0) {
      var normals = new Float32Array(geometry.normals.length * 3);
      this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }
    if (geometry.colors.length > 0) {
      var colors = new Float32Array(geometry.colors.length * 3);
      this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }
    if (geometry.uvs.length > 0) {
      var uvs = new Float32Array(geometry.uvs.length * 2);
      this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }
    if (geometry.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    }
    if (geometry.indices.length > 0) {
      var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array;
      var indices = new TypeArray(geometry.indices.length * 3);
      this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
    }
    this.groups = geometry.groups;
    for (var name in geometry.morphTargets) {
      var array = [];
      var morphTargets = geometry.morphTargets[name];
      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);
        array.push(attribute.copyVector3sArray(morphTarget));
      }
      this$1.morphAttributes[name] = array;
    }
    if (geometry.skinIndices.length > 0) {
      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
    }
    if (geometry.skinWeights.length > 0) {
      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
    }
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    var position = this.attributes.position;
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    var box = new Box3();
    var vector = new Vector3();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var position = this.attributes.position;
      if (position) {
        var center2 = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        box.getCenter(center2);
        var maxRadiusSq = 0;
        for (var i = 0, il = position.count; i < il; i++) {
          vector.x = position.getX(i);
          vector.y = position.getY(i);
          vector.z = position.getZ(i);
          maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var index = this.index;
    var attributes = this.attributes;
    var groups = this.groups;
    if (attributes.position) {
      var positions = attributes.position.array;
      if (attributes.normal === void 0) {
        this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        var array = attributes.normal.array;
        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }
      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      var cb = new Vector3(), ab = new Vector3();
      if (index) {
        var indices = index.array;
        if (groups.length === 0) {
          this.addGroup(0, indices.length);
        }
        for (var j = 0, jl = groups.length; j < jl; ++j) {
          var group = groups[j];
          var start = group.start;
          var count2 = group.count;
          for (var i = start, il = start + count2; i < il; i += 3) {
            vA = indices[i + 0] * 3;
            vB = indices[i + 1] * 3;
            vC = indices[i + 2] * 3;
            pA.fromArray(positions, vA);
            pB.fromArray(positions, vB);
            pC.fromArray(positions, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA] += cb.x;
            normals[vA + 1] += cb.y;
            normals[vA + 2] += cb.z;
            normals[vB] += cb.x;
            normals[vB + 1] += cb.y;
            normals[vB + 2] += cb.z;
            normals[vC] += cb.x;
            normals[vC + 1] += cb.y;
            normals[vC + 2] += cb.z;
          }
        }
      } else {
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      if (geometry.attributes[key] === void 0) {
        continue;
      }
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeSize = attribute2.itemSize;
      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    var normals = this.attributes.normal;
    var x, y, z, n;
    for (var i = 0, il = normals.count; i < il; i++) {
      x = normals.getX(i);
      y = normals.getY(i);
      z = normals.getZ(i);
      n = 1 / Math.sqrt(x * x + y * y + z * z);
      normals.setXYZ(i, x * n, y * n, z * n);
    }
  },
  toNonIndexed: function() {
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
      return this;
    }
    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      var array = attribute.array;
      var itemSize2 = attribute.itemSize;
      var array2 = new array.constructor(indices.length * itemSize2);
      var index = 0, index2 = 0;
      for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize2;
        for (var j = 0; j < itemSize2; j++) {
          array2[index2++] = array[index++];
        }
      }
      geometry2.addAttribute(name, new BufferAttribute(array2, itemSize2));
    }
    return geometry2;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") {
      data.name = this.name;
    }
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0) {
          data[key] = parameters[key];
        }
      }
      return data;
    }
    data.data = {attributes: {}};
    var index = this.index;
    if (index !== null) {
      var array = Array.prototype.slice.call(index.array);
      data.data.index = {
        type: index.array.constructor.name,
        array
      };
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var array = Array.prototype.slice.call(attribute.array);
      data.data.attributes[key] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array,
        normalized: attribute.normalized
      };
    }
    var groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    var boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    var this$1 = this;
    var name, i, l;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (name in attributes) {
      var attribute = attributes[name];
      this$1.addAttribute(name, attribute.clone());
    }
    var morphAttributes = source.morphAttributes;
    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name];
      for (i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone());
      }
      this$1.morphAttributes[name] = array;
    }
    var groups = source.groups;
    for (i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this$1.addGroup(group.start, group.count, group.materialIndex);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  Geometry.call(this);
  this.type = "BoxGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}
BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry;
function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  BufferGeometry.call(this);
  this.type = "BoxBufferGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  var scope = this;
  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var numberOfVertices = 0;
  var groupStart = 0;
  buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
  buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
  buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
  buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
  buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
  buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
    var segmentWidth = width2 / gridX;
    var segmentHeight = height2 / gridY;
    var widthHalf = width2 / 2;
    var heightHalf = height2 / 2;
    var depthHalf = depth2 / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new Vector3();
    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;
      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - widthHalf;
        vector[u] = x * udir;
        vector[v] = y * vdir;
        vector[w] = depthHalf;
        vertices.push(vector.x, vector.y, vector.z);
        vector[u] = 0;
        vector[v] = 0;
        vector[w] = depth2 > 0 ? 1 : -1;
        normals.push(vector.x, vector.y, vector.z);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
        vertexCounter += 1;
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = numberOfVertices + ix + gridX1 * iy;
        var b = numberOfVertices + ix + gridX1 * (iy + 1);
        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d = numberOfVertices + (ix + 1) + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, materialIndex);
    groupStart += groupCount;
    numberOfVertices += vertexCounter;
  }
}
BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = "PlaneGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = "PlaneBufferGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;
    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  }
  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = "MeshBasicMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
function Ray(origin, direction) {
  this.origin = origin !== void 0 ? origin : new Vector3();
  this.direction = direction !== void 0 ? direction : new Vector3();
}
Object.assign(Ray.prototype, {
  set: function(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function(t, optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function() {
    var v1 = new Vector3();
    return function recast(t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function(point, optionalTarget) {
    var result = optionalTarget || new Vector3();
    result.subVectors(point, this.origin);
    var directionDistance = result.dot(this.direction);
    if (directionDistance < 0) {
      return result.copy(this.origin);
    }
    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function() {
    var v1 = new Vector3();
    return function distanceSqToPoint(point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function() {
    var segCenter = new Vector3();
    var segDir = new Vector3();
    var diff = new Vector3();
    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }
      return sqrDist;
    };
  }(),
  intersectSphere: function() {
    var v1 = new Vector3();
    return function intersectSphere(sphere, optionalTarget) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) {
        return null;
      }
      var thc = Math.sqrt(radius2 - d2);
      var t0 = tca - thc;
      var t1 = tca + thc;
      if (t0 < 0 && t1 < 0) {
        return null;
      }
      if (t0 < 0) {
        return this.at(t1, optionalTarget);
      }
      return this.at(t0, optionalTarget);
    };
  }(),
  intersectsSphere: function(sphere) {
    return this.distanceToPoint(sphere.center) <= sphere.radius;
  },
  distanceToPlane: function(plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  },
  intersectPlane: function(plane, optionalTarget) {
    var t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, optionalTarget);
  },
  intersectsPlane: function(plane) {
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  },
  intersectBox: function(box, optionalTarget) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) {
      return null;
    }
    if (tymin > tmin || tmin !== tmin) {
      tmin = tymin;
    }
    if (tymax < tmax || tmax !== tmax) {
      tmax = tymax;
    }
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) {
      return null;
    }
    if (tzmin > tmin || tmin !== tmin) {
      tmin = tzmin;
    }
    if (tzmax < tmax || tmax !== tmax) {
      tmax = tzmax;
    }
    if (tmax < 0) {
      return null;
    }
    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
  },
  intersectsBox: function() {
    var v = new Vector3();
    return function intersectsBox(box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectTriangle: function() {
    var diff = new Vector3();
    var edge1 = new Vector3();
    var edge2 = new Vector3();
    var normal2 = new Vector3();
    return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal2.crossVectors(edge1, edge2);
      var DdN = this.direction.dot(normal2);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling) {
          return null;
        }
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign * diff.dot(normal2);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, optionalTarget);
    };
  }(),
  applyMatrix4: function(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
function Line3(start, end) {
  this.start = start !== void 0 ? start : new Vector3();
  this.end = end !== void 0 ? end : new Vector3();
}
Object.assign(Line3.prototype, {
  set: function(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  getCenter: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(t, optionalTarget) {
    var result = optionalTarget || new Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function() {
    var startP = new Vector3();
    var startEnd = new Vector3();
    return function closestPointToPointParameter(point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = _Math.clamp(t, 0, 1);
      }
      return t;
    };
  }(),
  closestPointToPoint: function(point, clampToLine, optionalTarget) {
    var t = this.closestPointToPointParameter(point, clampToLine);
    var result = optionalTarget || new Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function(matrix2) {
    this.start.applyMatrix4(matrix2);
    this.end.applyMatrix4(matrix2);
    return this;
  },
  equals: function(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
});
function Triangle(a, b, c) {
  this.a = a !== void 0 ? a : new Vector3();
  this.b = b !== void 0 ? b : new Vector3();
  this.c = c !== void 0 ? c : new Vector3();
}
Object.assign(Triangle, {
  normal: function() {
    var v0 = new Vector3();
    return function normal2(a, b, c, optionalTarget) {
      var result = optionalTarget || new Vector3();
      result.subVectors(c, b);
      v0.subVectors(a, b);
      result.cross(v0);
      var resultLengthSq = result.lengthSq();
      if (resultLengthSq > 0) {
        return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
      }
      return result.set(0, 0, 0);
    };
  }(),
  barycoordFromPoint: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function barycoordFromPoint(point, a, b, c, optionalTarget) {
      v0.subVectors(c, a);
      v1.subVectors(b, a);
      v2.subVectors(point, a);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = dot00 * dot11 - dot01 * dot01;
      var result = optionalTarget || new Vector3();
      if (denom === 0) {
        return result.set(-2, -1, -1);
      }
      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return result.set(1 - u - v, v, u);
    };
  }(),
  containsPoint: function() {
    var v1 = new Vector3();
    return function containsPoint(point, a, b, c) {
      var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
      return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
    };
  }()
});
Object.assign(Triangle.prototype, {
  set: function(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  area: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    return function area() {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  midpoint: function(optionalTarget) {
    var result = optionalTarget || new Vector3();
    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function(optionalTarget) {
    return Triangle.normal(this.a, this.b, this.c, optionalTarget);
  },
  plane: function(optionalTarget) {
    var result = optionalTarget || new Plane();
    return result.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function(point, optionalTarget) {
    return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
  },
  containsPoint: function(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  closestPointToPoint: function() {
    var plane = new Plane();
    var edgeList = [new Line3(), new Line3(), new Line3()];
    var projectedPoint = new Vector3();
    var closestPoint = new Vector3();
    return function closestPointToPoint(point, optionalTarget) {
      var result = optionalTarget || new Vector3();
      var minDistance = Infinity;
      plane.setFromCoplanarPoints(this.a, this.b, this.c);
      plane.projectPoint(point, projectedPoint);
      if (this.containsPoint(projectedPoint) === true) {
        result.copy(projectedPoint);
      } else {
        edgeList[0].set(this.a, this.b);
        edgeList[1].set(this.b, this.c);
        edgeList[2].set(this.c, this.a);
        for (var i = 0; i < edgeList.length; i++) {
          edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
          var distance3 = projectedPoint.distanceToSquared(closestPoint);
          if (distance3 < minDistance) {
            minDistance = distance3;
            result.copy(closestPoint);
          }
        }
      }
      return result;
    };
  }(),
  equals: function(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new MeshBasicMaterial({color: Math.random() * 16777215});
  this.drawMode = TrianglesDrawMode;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function(value2) {
    this.drawMode = value2;
  },
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.drawMode = source.drawMode;
    return this;
  },
  updateMorphTargets: function() {
    var this$1 = this;
    var geometry = this.geometry;
    var m2, ml, name;
    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            name = morphAttribute[m2].name || String(m2);
            this$1.morphTargetInfluences.push(0);
            this$1.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (m2 = 0, ml = morphTargets.length; m2 < ml; m2++) {
          name = morphTargets[m2].name || String(m2);
          this$1.morphTargetInfluences.push(0);
          this$1.morphTargetDictionary[name] = m2;
        }
      }
    }
  },
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var tempA = new Vector3();
    var tempB = new Vector3();
    var tempC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    var barycoord = new Vector3();
    var intersectionPoint = new Vector3();
    var intersectionPointWorld = new Vector3();
    function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
      Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
      uv1.multiplyScalar(barycoord.x);
      uv2.multiplyScalar(barycoord.y);
      uv3.multiplyScalar(barycoord.z);
      uv1.add(uv2).add(uv3);
      return uv1.clone();
    }
    function checkIntersection(object, raycaster, ray2, pA, pB, pC, point) {
      var intersect;
      var material = object.material;
      if (material.side === BackSide) {
        intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray2.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
      }
      if (intersect === null) {
        return null;
      }
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance3 = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance3 < raycaster.near || distance3 > raycaster.far) {
        return null;
      }
      return {
        distance: distance3,
        point: intersectionPointWorld.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection(object, raycaster, ray2, position, uv, a, b, c) {
      vA.fromBufferAttribute(position, a);
      vB.fromBufferAttribute(position, b);
      vC.fromBufferAttribute(position, c);
      var intersection2 = checkIntersection(object, raycaster, ray2, vA, vB, vC, intersectionPoint);
      if (intersection2) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a);
          uvB.fromBufferAttribute(uv, b);
          uvC.fromBufferAttribute(uv, c);
          intersection2.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
        }
        intersection2.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
        intersection2.faceIndex = a;
      }
      return intersection2;
    }
    return function raycast(raycaster, intersects2) {
      var this$1 = this;
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === void 0) {
        return;
      }
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false) {
        return;
      }
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (ray.intersectsBox(geometry.boundingBox) === false) {
          return;
        }
      }
      var intersection2;
      if (geometry.isBufferGeometry) {
        var a, b, c;
        var index = geometry.index;
        var position = geometry.attributes.position;
        var uv = geometry.attributes.uv;
        var i, l;
        if (index !== null) {
          for (i = 0, l = index.count; i < l; i += 3) {
            a = index.getX(i);
            b = index.getX(i + 1);
            c = index.getX(i + 2);
            intersection2 = checkBufferGeometryIntersection(this$1, raycaster, ray, position, uv, a, b, c);
            if (intersection2) {
              intersection2.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection2);
            }
          }
        } else {
          for (i = 0, l = position.count; i < l; i += 3) {
            a = i;
            b = i + 1;
            c = i + 2;
            intersection2 = checkBufferGeometryIntersection(this$1, raycaster, ray, position, uv, a, b, c);
            if (intersection2) {
              intersection2.index = a;
              intersects2.push(intersection2);
            }
          }
        }
      } else if (geometry.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var uvs;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0) {
          uvs = faceVertexUvs;
        }
        for (var f = 0, fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === void 0) {
            continue;
          }
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];
          if (faceMaterial.morphTargets === true) {
            var morphTargets = geometry.morphTargets;
            var morphInfluences = this$1.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);
            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
              var influence = morphInfluences[t];
              if (influence === 0) {
                continue;
              }
              var targets = morphTargets[t].vertices;
              vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
              vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
              vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }
            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
          }
          intersection2 = checkIntersection(this$1, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
          if (intersection2) {
            if (uvs && uvs[f]) {
              var uvs_f = uvs[f];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection2.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
            }
            intersection2.face = face;
            intersection2.faceIndex = f;
            intersects2.push(intersection2);
          }
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new Color(0);
  var clearAlpha = 0;
  var planeCamera, planeMesh;
  var boxCamera, boxMesh;
  function render(scene, camera, forceClear) {
    var background = scene.background;
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && background.isCubeTexture) {
      if (boxCamera === void 0) {
        boxCamera = new PerspectiveCamera();
        boxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
          uniforms: ShaderLib.cube.uniforms,
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
      }
      boxCamera.projectionMatrix.copy(camera.projectionMatrix);
      boxCamera.matrixWorld.extractRotation(camera.matrixWorld);
      boxCamera.matrixWorldInverse.getInverse(boxCamera.matrixWorld);
      boxMesh.material.uniforms["tCube"].value = background;
      boxMesh.modelViewMatrix.multiplyMatrices(boxCamera.matrixWorldInverse, boxMesh.matrixWorld);
      objects.update(boxMesh);
      renderer.renderBufferDirect(boxCamera, null, boxMesh.geometry, boxMesh.material, boxMesh, null);
    } else if (background && background.isTexture) {
      if (planeCamera === void 0) {
        planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({depthTest: false, depthWrite: false, fog: false}));
      }
      planeMesh.material.map = background;
      objects.update(planeMesh);
      renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== void 0 ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function painterSortStable(a, b) {
  if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program && b.program && a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  }
  if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  var opaque = [];
  var opaqueLastIndex = -1;
  var transparent = [];
  var transparentLastIndex = -1;
  function init3() {
    opaqueLastIndex = -1;
    transparentLastIndex = -1;
  }
  function push(object, geometry, material, z, group) {
    var array, index;
    if (material.transparent) {
      array = transparent;
      index = ++transparentLastIndex;
    } else {
      array = opaque;
      index = ++opaqueLastIndex;
    }
    var renderItem = array[index];
    if (renderItem) {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = material.program;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    } else {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: material.program,
        renderOrder: object.renderOrder,
        z,
        group
      };
      array.push(renderItem);
    }
  }
  function finish() {
    opaque.length = opaqueLastIndex + 1;
    transparent.length = transparentLastIndex + 1;
  }
  function sort2() {
    opaque.sort(painterSortStable);
    transparent.sort(reversePainterSortStable);
  }
  return {
    opaque,
    transparent,
    init: init3,
    push,
    finish,
    sort: sort2
  };
}
function WebGLRenderLists() {
  var lists = {};
  function get7(scene, camera) {
    var hash = scene.id + "," + camera.id;
    var list = lists[hash];
    if (list === void 0) {
      list = new WebGLRenderList();
      lists[hash] = list;
    }
    return list;
  }
  function dispose24() {
    lists = {};
  }
  return {
    get: get7,
    dispose: dispose24
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
  var mode;
  function setMode(value2) {
    mode = value2;
  }
  var type2, bytesPerElement;
  function setIndex(value2) {
    type2 = value2.type;
    bytesPerElement = value2.bytesPerElement;
  }
  function render(start, count2) {
    gl.drawElements(mode, count2, type2, start * bytesPerElement);
    infoRender.calls++;
    infoRender.vertices += count2;
    if (mode === gl.TRIANGLES) {
      infoRender.faces += count2 / 3;
    }
  }
  function renderInstances(geometry, start, count2) {
    var extension = extensions.get("ANGLE_instanced_arrays");
    if (extension === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    extension.drawElementsInstancedANGLE(mode, count2, type2, start * bytesPerElement, geometry.maxInstancedCount);
    infoRender.calls++;
    infoRender.vertices += count2 * geometry.maxInstancedCount;
    if (mode === gl.TRIANGLES) {
      infoRender.faces += geometry.maxInstancedCount * count2 / 3;
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLBufferRenderer(gl, extensions, infoRender) {
  var mode;
  function setMode(value2) {
    mode = value2;
  }
  function render(start, count2) {
    gl.drawArrays(mode, start, count2);
    infoRender.calls++;
    infoRender.vertices += count2;
    if (mode === gl.TRIANGLES) {
      infoRender.faces += count2 / 3;
    }
  }
  function renderInstances(geometry, start, count2) {
    var extension = extensions.get("ANGLE_instanced_arrays");
    if (extension === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    var position = geometry.attributes.position;
    if (position.isInterleavedBufferAttribute) {
      count2 = position.data.count;
      extension.drawArraysInstancedANGLE(mode, 0, count2, geometry.maxInstancedCount);
    } else {
      extension.drawArraysInstancedANGLE(mode, start, count2, geometry.maxInstancedCount);
    }
    infoRender.calls++;
    infoRender.vertices += count2 * geometry.maxInstancedCount;
    if (mode === gl.TRIANGLES) {
      infoRender.faces += geometry.maxInstancedCount * count2 / 3;
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLGeometries(gl, attributes, infoMemory) {
  var geometries = {};
  var wireframeAttributes = {};
  function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }
    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes[geometry.id];
    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[geometry.id];
    }
    attribute = wireframeAttributes[buffergeometry.id];
    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[buffergeometry.id];
    }
    infoMemory.geometries--;
  }
  function get7(object, geometry) {
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry) {
      return buffergeometry;
    }
    geometry.addEventListener("dispose", onGeometryDispose);
    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === void 0) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }
      buffergeometry = geometry._bufferGeometry;
    }
    geometries[geometry.id] = buffergeometry;
    infoMemory.geometries++;
    return buffergeometry;
  }
  function update2(geometry) {
    var index = geometry.index;
    var geometryAttributes = geometry.attributes;
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    var morphAttributes = geometry.morphAttributes;
    for (var name in morphAttributes) {
      var array = morphAttributes[name];
      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function getWireframeAttribute(geometry) {
    var attribute = wireframeAttributes[geometry.id];
    if (attribute) {
      return attribute;
    }
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryAttributes = geometry.attributes;
    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryAttributes.position.array;
      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
    wireframeAttributes[geometry.id] = attribute;
    return attribute;
  }
  return {
    get: get7,
    update: update2,
    getWireframeAttribute
  };
}
function WebGLLights() {
  var lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      var uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color(),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function WebGLObjects(gl, geometries, infoRender) {
  var updateList = {};
  function update2(object) {
    var frame = infoRender.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry);
    if (updateList[buffergeometry.id] !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }
      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame;
    }
    return buffergeometry;
  }
  function clear7() {
    updateList = {};
  }
  return {
    update: update2,
    clear: clear7
  };
}
function addLineNumbers(string) {
  var lines = string.split("\n");
  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function WebGLShader(gl, type2, string) {
  var shader = gl.createShader(type2);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
    console.error("THREE.WebGLShader: Shader couldn't compile.");
  }
  if (gl.getShaderInfoLog(shader) !== "") {
    console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type2 === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
  }
  return shader;
}
var programIdCount = 0;
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      throw new Error("unsupported encoding: " + encoding);
  }
}
function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case Uncharted2ToneMapping:
      toneMappingName = "Uncharted2";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    default:
      throw new Error("unsupported toneMapping: " + toneMapping);
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [
    extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
    (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
    extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
    (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  var chunks = [];
  for (var name in defines) {
    var value2 = defines[name];
    if (value2 === false) {
      continue;
    }
    chunks.push("#define " + name + " " + value2);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program, identifiers) {
  var attributes = {};
  var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}
function parseIncludes(string) {
  var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
  function replace(match, include) {
    var replace2 = ShaderChunk[include];
    if (replace2 === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return parseIncludes(replace2);
  }
  return string.replace(pattern, replace);
}
function unrollLoops(string) {
  var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  function replace(match, start, end, snippet) {
    var unroll = "";
    for (var i = parseInt(start); i < parseInt(end); i++) {
      unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
    }
    return unroll;
  }
  return string.replace(pattern, replace);
}
function WebGLProgram(renderer, code, material, shader, parameters) {
  var gl = renderer.context;
  var extensions = material.extensions;
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  }
  var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
        break;
      case SphericalReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
        break;
    }
    switch (material.envMap.mapping) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
    switch (material.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
  var customDefines = generateDefines(defines);
  var program = gl.createProgram();
  var prefixVertex, prefixFragment;
  if (material.isRawShaderMaterial) {
    prefixVertex = [
      customDefines,
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      customDefines,
      "\n"
    ].filter(filterEmptyLine).join("\n");
  } else {
    prefixVertex = [
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes,
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes,
      "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection),
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
      parameters.envMap && renderer.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
      parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
      parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  if (!material.isShaderMaterial) {
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
  }
  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader;
  var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (material.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  var programLog = gl.getProgramInfoLog(program);
  var vertexLog = gl.getShaderInfoLog(glVertexShader);
  var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
  var runnable = true;
  var haveDiagnostics = true;
  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    runnable = false;
    console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
  } else if (programLog !== "") {
    console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
  } else if (vertexLog === "" || fragmentLog === "") {
    haveDiagnostics = false;
  }
  if (haveDiagnostics) {
    this.diagnostics = {
      runnable,
      material,
      programLog,
      vertexShader: {
        log: vertexLog,
        prefix: prefixVertex
      },
      fragmentShader: {
        log: fragmentLog,
        prefix: prefixFragment
      }
    };
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  var cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program, renderer);
    }
    return cachedUniforms;
  };
  var cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    gl.deleteProgram(program);
    this.program = void 0;
  };
  Object.defineProperties(this, {
    uniforms: {
      get: function() {
        console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
        return this.getUniforms();
      }
    },
    attributes: {
      get: function() {
        console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
        return this.getAttributes();
      }
    }
  });
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points"
  };
  var parameterNames = [
    "precision",
    "supportsVertexTextures",
    "map",
    "mapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "lightMap",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "fog",
    "useFog",
    "fogExp",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering"
  ];
  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;
    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map2, gammaOverrideLinear) {
    var encoding;
    if (!map2) {
      encoding = LinearEncoding;
    } else if (map2.isTexture) {
      encoding = map2.encoding;
    } else if (map2.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map2.texture.encoding;
    }
    if (encoding === LinearEncoding && gammaOverrideLinear) {
      encoding = GammaEncoding;
    }
    return encoding;
  }
  this.getParameters = function(material, lights, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type];
    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = renderer.getPrecision();
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID,
      precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      combine: material.combine,
      vertexColors: material.vertexColors,
      fog: !!fog,
      useFog: material.fog,
      fogExp: fog && fog.isFogExp2,
      flatShading: material.shading === FlatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false
    };
    return parameters;
  };
  this.getProgramCode = function(material, parameters) {
    var array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }
    if (material.defines !== void 0) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }
    for (var i = 0; i < parameterNames.length; i++) {
      array.push(parameters[parameterNames[i]]);
    }
    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    return array.join();
  };
  this.acquireProgram = function(material, shader, parameters, code) {
    var program;
    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];
      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, code, material, shader, parameters);
      programs.push(program);
    }
    return program;
  };
  this.releaseProgram = function(program) {
    if (--program.usedTimes === 0) {
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  };
  this.programs = programs;
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, infoMemory) {
  var _isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && _gl instanceof WebGL2RenderingContext;
  function clampToMaxSize(image, maxSize) {
    if (image.width > maxSize || image.height > maxSize) {
      var scale2 = maxSize / Math.max(image.width, image.height);
      var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      canvas.width = Math.floor(image.width * scale2);
      canvas.height = Math.floor(image.height * scale2);
      var context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
      return canvas;
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
  }
  function makePowerOfTwo(image) {
    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
      var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      canvas.width = _Math.nearestPowerOfTwo(image.width);
      canvas.height = _Math.nearestPowerOfTwo(image.height);
      var context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, canvas.width, canvas.height);
      console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
      return canvas;
    }
    return image;
  }
  function textureNeedsPowerOfTwo(texture) {
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, isPowerOfTwo2) {
    return texture.generateMipmaps && isPowerOfTwo2 && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    infoMemory.textures--;
  }
  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    infoMemory.textures--;
  }
  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (texture.image && textureProperties.__image__webglTextureCube) {
      _gl.deleteTexture(textureProperties.__image__webglTextureCube);
    } else {
      if (textureProperties.__webglInit === void 0) {
        return;
      }
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) {
      return;
    }
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer) {
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer) {
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      }
    }
    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  }
  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture);
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture);
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        if (!textureProperties.__image__webglTextureCube) {
          texture.addEventListener("dispose", onTextureDispose);
          textureProperties.__image__webglTextureCube = _gl.createTexture();
          infoMemory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture && texture.isCompressedTexture;
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];
        for (var i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }
        var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate) {
          texture.onUpdate(texture);
        }
      } else {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
      }
    }
  }
  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
  }
  function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
    var extension;
    if (isPowerOfTwoImage) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture);
      }
    }
    extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension) {
      if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) {
        return;
      }
      if (texture.type === HalfFloatType && extensions.get("OES_texture_half_float_linear") === null) {
        return;
      }
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      infoMemory.textures++;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
    if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
      image = makePowerOfTwo(image);
    }
    var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
    var mipmap, mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      var internalFormat = _gl.DEPTH_COMPONENT;
      if (texture.type === FloatType) {
        if (!_isWebGL2) {
          throw new Error("Float Depth Texture only supported in WebGL2.0");
        }
        internalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (_isWebGL2) {
        internalFormat = _gl.DEPTH_COMPONENT16;
      }
      if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = paramThreeToGL(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat) {
        internalFormat = _gl.DEPTH_STENCIL;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = paramThreeToGL(texture.type);
        }
      }
      state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
      }
    } else if (texture.isCompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
    } else {
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
      }
    }
    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
      _gl.generateMipmap(_gl.TEXTURE_2D);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) {
      texture.onUpdate(texture);
    }
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = paramThreeToGL(renderTarget.texture.format);
    var glType = paramThreeToGL(renderTarget.texture.type);
    state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube) {
      throw new Error("Depth Texture with cube render targets is not supported!");
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    if (renderTarget.depthTexture) {
      if (isCube) {
        throw new Error("target.depthTexture not supported in Cube render targets");
      }
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (var i = 0; i < 6; i++) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    infoMemory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      }
      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        _gl.generateMipmap(_gl.TEXTURE_2D);
      }
      state.bindTexture(_gl.TEXTURE_2D, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
    if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
      var target2 = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
      var webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target2, webglTexture);
      _gl.generateMipmap(target2);
      state.bindTexture(target2, null);
    }
  }
  this.setTexture2D = setTexture2D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
}
function WebGLProperties() {
  var properties = {};
  function get7(object) {
    var uuid2 = object.uuid;
    var map2 = properties[uuid2];
    if (map2 === void 0) {
      map2 = {};
      properties[uuid2] = map2;
    }
    return map2;
  }
  function remove3(object) {
    delete properties[object.uuid];
  }
  function clear7() {
    properties = {};
  }
  return {
    get: get7,
    remove: remove3,
    clear: clear7
  };
}
function WebGLState(gl, extensions, paramThreeToGL) {
  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4();
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(0, 0, 0, 1);
      }
    };
  }
  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (stencilTest) {
          enable(gl.STENCIL_TEST);
        } else {
          disable(gl.STENCIL_TEST);
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var capabilities = {};
  var compressedTextureFormats = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var currentScissorTest = null;
  var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  var version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
  var lineWidthAvailable = parseFloat(version) >= 1;
  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new Vector4();
  var currentViewport = new Vector4();
  function createTexture(type2, target2, count2) {
    var data = new Uint8Array(4);
    var texture = gl.createTexture();
    gl.bindTexture(type2, texture);
    gl.texParameteri(type2, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type2, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (var i = 0; i < count2; i++) {
      gl.texImage2D(target2 + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    return texture;
  }
  var emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  function init3() {
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl.CULL_FACE);
    enable(gl.BLEND);
    setBlending(NormalBlending);
  }
  function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== 0) {
      var extension = extensions.get("ANGLE_instanced_arrays");
      extension.vertexAttribDivisorANGLE(attribute, 0);
      attributeDivisors[attribute] = 0;
    }
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = extensions.get("ANGLE_instanced_arrays");
      extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function enable(id) {
    if (capabilities[id] !== true) {
      gl.enable(id);
      capabilities[id] = true;
    }
  }
  function disable(id) {
    if (capabilities[id] !== false) {
      gl.disable(id);
      capabilities[id] = false;
    }
  }
  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];
      if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1")) {
        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }
    return compressedTextureFormats;
  }
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending !== NoBlending) {
      enable(gl.BLEND);
    } else {
      disable(gl.BLEND);
    }
    if (blending !== CustomBlending && (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha)) {
      if (blending === AdditiveBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        }
      } else if (blending === SubtractiveBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
        }
      } else if (blending === MultiplyBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
        }
      } else {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        } else {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }
      }
      currentBlending = blending;
      currentPremultipledAlpha = premultipliedAlpha;
    }
    if (blending === CustomBlending) {
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
    } else {
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
    }
  }
  function setMaterial(material) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    setFlipSided(material.side === BackSide);
    material.transparent === true ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) {
        gl.lineWidth(width);
      }
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function getScissorTest() {
    return currentScissorTest;
  }
  function setScissorTest(scissorTest) {
    currentScissorTest = scissorTest;
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) {
      webglSlot = gl.TEXTURE0 + maxTextures - 1;
    }
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
    capabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    init: init3,
    initAttributes,
    enableAttribute,
    enableAttributeAndDivisor,
    disableUnusedAttributes,
    enable,
    disable,
    getCompressedTextureFormats,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    getScissorTest,
    setScissorTest,
    activeTexture,
    bindTexture,
    compressedTexImage2D,
    texImage2D,
    scissor,
    viewport,
    reset
  };
}
function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) {
      return maxAnisotropy;
    }
    var extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  var maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get("EXT_frag_depth");
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = !!extensions.get("OES_texture_float");
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  return {
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures
  };
}
function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
function WebVRManager(renderer) {
  var scope = this;
  var device = null;
  var frameData = null;
  if ("VRFrameData" in window) {
    frameData = new window.VRFrameData();
  }
  var matrixWorldInverse = new Matrix4();
  var standingMatrix = new Matrix4();
  var standingMatrixInverse = new Matrix4();
  var cameraL = new PerspectiveCamera();
  cameraL.bounds = new Vector4(0, 0, 0.5, 1);
  cameraL.layers.enable(1);
  var cameraR = new PerspectiveCamera();
  cameraR.bounds = new Vector4(0.5, 0, 0.5, 1);
  cameraR.layers.enable(2);
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  var currentSize, currentPixelRatio;
  function onVRDisplayPresentChange() {
    if (device.isPresenting) {
      var eyeParameters = device.getEyeParameters("left");
      var renderWidth = eyeParameters.renderWidth;
      var renderHeight = eyeParameters.renderHeight;
      currentPixelRatio = renderer.getPixelRatio();
      currentSize = renderer.getSize();
      renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
    } else if (scope.enabled) {
      renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
    }
  }
  window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
  this.enabled = false;
  this.standing = false;
  this.getDevice = function() {
    return device;
  };
  this.setDevice = function(value2) {
    if (value2 !== void 0) {
      device = value2;
    }
  };
  this.getCamera = function(camera) {
    if (device === null) {
      return camera;
    }
    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData);
    var pose = frameData.pose;
    if (pose.position !== null) {
      camera.position.fromArray(pose.position);
    } else {
      camera.position.set(0, 0, 0);
    }
    if (pose.orientation !== null) {
      camera.quaternion.fromArray(pose.orientation);
    }
    camera.updateMatrixWorld();
    var stageParameters = device.stageParameters;
    if (this.standing && stageParameters) {
      standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      standingMatrixInverse.getInverse(standingMatrix);
      camera.matrixWorld.multiply(standingMatrix);
      camera.matrixWorldInverse.multiply(standingMatrixInverse);
    }
    if (device.isPresenting === false) {
      return camera;
    }
    cameraVR.matrixWorld.copy(camera.matrixWorld);
    cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
    if (this.standing && stageParameters) {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }
    var parent = camera.parent;
    if (parent !== null) {
      matrixWorldInverse.getInverse(parent.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    }
    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
    cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    var layers = device.getLayers();
    if (layers.length) {
      var layer = layers[0];
      if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
        cameraL.bounds.fromArray(layer.leftBounds);
      }
      if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
        cameraR.bounds.fromArray(layer.rightBounds);
      }
    }
    return cameraVR;
  };
  this.getStandingMatrix = function() {
    return standingMatrix;
  };
  this.submitFrame = function() {
    if (device && device.isPresenting) {
      device.submitFrame();
    }
  };
}
function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      var extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        case "WEBGL_compressed_texture_etc1":
          extension = gl.getExtension("WEBGL_compressed_texture_etc1");
          break;
        default:
          extension = gl.getExtension(name);
      }
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      extensions[name] = extension;
      return extension;
    }
  };
}
function WebGLClipping() {
  var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    return dstArray;
  }
}
function WebGLRenderer(parameters) {
  console.log("THREE.WebGLRenderer", REVISION);
  parameters = parameters || {};
  var _canvas = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false;
  var lights = [];
  var currentRenderList = null;
  var morphInfluences = new Float32Array(8);
  var sprites = [];
  var lensFlares = [];
  this.domElement = _canvas;
  this.context = null;
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.physicallyCorrectLights = false;
  this.toneMapping = LinearToneMapping;
  this.toneMappingExposure = 1;
  this.toneMappingWhitePoint = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  var _this = this, _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentArrayCamera = null, _currentScissor = new Vector4(), _currentScissorTest = null, _currentViewport = new Vector4(), _usedTextureUnits = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _viewport = new Vector4(0, 0, _width, _height), _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _matrix4 = new Matrix4(), _matrix42 = new Matrix4(), _lights = {
    hash: "",
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    shadows: []
  }, _infoMemory = {
    geometries: 0,
    textures: 0
  }, _infoRender = {
    frame: 0,
    calls: 0,
    vertices: 0,
    faces: 0,
    points: 0
  };
  this.info = {
    render: _infoRender,
    memory: _infoMemory,
    programs: null
  };
  var _gl;
  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };
    _gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes);
    if (_gl === null) {
      if (_canvas.getContext("webgl") !== null) {
        throw "Error creating WebGL context with your selected attributes.";
      } else {
        throw "Error creating WebGL context.";
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
    _canvas.addEventListener("webglcontextlost", onContextLost, false);
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error);
  }
  var extensions = new WebGLExtensions(_gl);
  extensions.get("WEBGL_depth_texture");
  extensions.get("OES_texture_float");
  extensions.get("OES_texture_float_linear");
  extensions.get("OES_texture_half_float");
  extensions.get("OES_texture_half_float_linear");
  extensions.get("OES_standard_derivatives");
  extensions.get("ANGLE_instanced_arrays");
  if (extensions.get("OES_element_index_uint")) {
    BufferGeometry.MaxIndex = 4294967296;
  }
  var capabilities = new WebGLCapabilities(_gl, extensions, parameters);
  var state = new WebGLState(_gl, extensions, paramThreeToGL);
  var properties = new WebGLProperties();
  var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory);
  var attributes = new WebGLAttributes(_gl);
  var geometries = new WebGLGeometries(_gl, attributes, _infoMemory);
  var objects = new WebGLObjects(_gl, geometries, _infoRender);
  var programCache = new WebGLPrograms(this, capabilities);
  var lightCache = new WebGLLights();
  var renderLists = new WebGLRenderLists();
  var background = new WebGLBackground(this, state, objects, _premultipliedAlpha);
  var vr = new WebVRManager(this);
  this.info.programs = programCache.programs;
  var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
  var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  function setDefaultGLState() {
    state.init();
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  }
  function resetGLState() {
    _currentProgram = null;
    _currentCamera = null;
    _currentGeometryProgram = "";
    _currentMaterialId = -1;
    state.reset();
  }
  setDefaultGLState();
  this.context = _gl;
  this.capabilities = capabilities;
  this.extensions = extensions;
  this.properties = properties;
  this.renderLists = renderLists;
  this.state = state;
  this.vr = vr;
  var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
  this.shadowMap = shadowMap;
  var spritePlugin = new SpritePlugin(this, sprites);
  var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    var extension = extensions.get("WEBGL_lose_context");
    if (extension) {
      extension.loseContext();
    }
  };
  this.getMaxAnisotropy = function() {
    return capabilities.getMaxAnisotropy();
  };
  this.getPrecision = function() {
    return capabilities.precision;
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value2) {
    if (value2 === void 0) {
      return;
    }
    _pixelRatio = value2;
    this.setSize(_width, _height, false);
  };
  this.getSize = function() {
    return {
      width: _width,
      height: _height
    };
  };
  this.setSize = function(width, height, updateStyle) {
    var device = vr.getDevice();
    if (device && device.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas.width = width * _pixelRatio;
    _canvas.height = height * _pixelRatio;
    if (updateStyle !== false) {
      _canvas.style.width = width + "px";
      _canvas.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function() {
    return {
      width: _width * _pixelRatio,
      height: _height * _pixelRatio
    };
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;
    this.setViewport(0, 0, width, height);
  };
  this.setViewport = function(x, y, width, height) {
    _viewport.set(x, _height - y - height, width, height);
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  };
  this.setScissor = function(x, y, width, height) {
    _scissor.set(x, _height - y - height, width, height);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
  };
  this.setScissorTest = function(boolean2) {
    state.setScissorTest(_scissorTest = boolean2);
  };
  this.getClearColor = background.getClearColor;
  this.setClearColor = background.setClearColor;
  this.getClearAlpha = background.getClearAlpha;
  this.setClearAlpha = background.setClearAlpha;
  this.clear = function(color, depth, stencil) {
    var bits = 0;
    if (color === void 0 || color) {
      bits |= _gl.COLOR_BUFFER_BIT;
    }
    if (depth === void 0 || depth) {
      bits |= _gl.DEPTH_BUFFER_BIT;
    }
    if (stencil === void 0 || stencil) {
      bits |= _gl.STENCIL_BUFFER_BIT;
    }
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.clearTarget = function(renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  this.resetGLState = resetGLState;
  this.dispose = function() {
    _canvas.removeEventListener("webglcontextlost", onContextLost, false);
    renderLists.dispose();
  };
  function onContextLost(event) {
    event.preventDefault();
    resetGLState();
    setDefaultGLState();
    properties.clear();
    objects.clear();
  }
  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = void 0;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program, material) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program, material);
    });
  }
  this.renderBufferImmediate = function(object, program, material) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) {
      buffers.position = _gl.createBuffer();
    }
    if (object.hasNormals && !buffers.normal) {
      buffers.normal = _gl.createBuffer();
    }
    if (object.hasUvs && !buffers.uv) {
      buffers.uv = _gl.createBuffer();
    }
    if (object.hasColors && !buffers.color) {
      buffers.color = _gl.createBuffer();
    }
    var programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
      if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.shading === FlatShading) {
        for (var i = 0, l = object.count * 3; i < l; i += 9) {
          var array = object.normalArray;
          var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
          var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
          var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
          array[i + 0] = nx;
          array[i + 1] = ny;
          array[i + 2] = nz;
          array[i + 3] = nx;
          array[i + 4] = ny;
          array[i + 5] = nz;
          array[i + 6] = nx;
          array[i + 7] = ny;
          array[i + 8] = nz;
        }
      }
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs && material.map) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors && material.vertexColors !== NoColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    state.disableUnusedAttributes();
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  function absNumericalSort(a, b) {
    return Math.abs(b[0]) - Math.abs(a[0]);
  }
  this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
    state.setMaterial(material);
    var program = setProgram(camera, fog, material, object);
    var geometryProgram = geometry.id + "_" + program.id + "_" + (material.wireframe === true);
    var updateBuffers = false;
    if (geometryProgram !== _currentGeometryProgram) {
      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;
    }
    var morphTargetInfluences = object.morphTargetInfluences;
    if (morphTargetInfluences !== void 0) {
      var activeInfluences = [];
      for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
        var influence = morphTargetInfluences[i];
        activeInfluences.push([influence, i]);
      }
      activeInfluences.sort(absNumericalSort);
      if (activeInfluences.length > 8) {
        activeInfluences.length = 8;
      }
      var morphAttributes = geometry.morphAttributes;
      for (var i = 0, l = activeInfluences.length; i < l; i++) {
        var influence = activeInfluences[i];
        morphInfluences[i] = influence[0];
        if (influence[0] !== 0) {
          var index = influence[1];
          if (material.morphTargets === true && morphAttributes.position) {
            geometry.addAttribute("morphTarget" + i, morphAttributes.position[index]);
          }
          if (material.morphNormals === true && morphAttributes.normal) {
            geometry.addAttribute("morphNormal" + i, morphAttributes.normal[index]);
          }
        } else {
          if (material.morphTargets === true) {
            geometry.removeAttribute("morphTarget" + i);
          }
          if (material.morphNormals === true) {
            geometry.removeAttribute("morphNormal" + i);
          }
        }
      }
      for (var i = activeInfluences.length, il = morphInfluences.length; i < il; i++) {
        morphInfluences[i] = 0;
      }
      program.getUniforms().setValue(_gl, "morphTargetInfluences", morphInfluences);
      updateBuffers = true;
    }
    var index = geometry.index;
    var position = geometry.attributes.position;
    var rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    var attribute;
    var renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry);
      if (index !== null) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
      }
    }
    var dataCount = 0;
    if (index !== null) {
      dataCount = index.count;
    } else if (position !== void 0) {
      dataCount = position.count;
    }
    var rangeStart = geometry.drawRange.start * rangeFactor;
    var rangeCount = geometry.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) {
      return;
    }
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(_gl.LINES);
      } else {
        switch (object.drawMode) {
          case TrianglesDrawMode:
            renderer.setMode(_gl.TRIANGLES);
            break;
          case TriangleStripDrawMode:
            renderer.setMode(_gl.TRIANGLE_STRIP);
            break;
          case TriangleFanDrawMode:
            renderer.setMode(_gl.TRIANGLE_FAN);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === void 0) {
        lineWidth = 1;
      }
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(_gl.LINES);
      } else if (object.isLineLoop) {
        renderer.setMode(_gl.LINE_LOOP);
      } else {
        renderer.setMode(_gl.LINE_STRIP);
      }
    } else if (object.isPoints) {
      renderer.setMode(_gl.POINTS);
    }
    if (geometry && geometry.isInstancedBufferGeometry) {
      if (geometry.maxInstancedCount > 0) {
        renderer.renderInstances(geometry, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  function setupVertexAttributes(material, program, geometry, startIndex) {
    if (geometry && geometry.isInstancedBufferGeometry) {
      if (extensions.get("ANGLE_instanced_arrays") === null) {
        console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    if (startIndex === void 0) {
      startIndex = 0;
    }
    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute);
          var buffer = attribute.buffer;
          var type2 = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry.maxInstancedCount === void 0) {
                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
            _gl.vertexAttribPointer(programAttribute, size, type2, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry.maxInstancedCount === void 0) {
                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
            _gl.vertexAttribPointer(programAttribute, size, type2, normalized, 0, startIndex * size * bytesPerElement);
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          var value2 = materialDefaultAttributeValues[name];
          if (value2 !== void 0) {
            switch (value2.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value2);
                break;
              case 3:
                _gl.vertexAttrib3fv(programAttribute, value2);
                break;
              case 4:
                _gl.vertexAttrib4fv(programAttribute, value2);
                break;
              default:
                _gl.vertexAttrib1fv(programAttribute, value2);
            }
          }
        }
      }
    }
    state.disableUnusedAttributes();
  }
  this.compile = function(scene, camera) {
    lights = [];
    scene.traverse(function(object) {
      if (object.isLight) {
        lights.push(object);
      }
    });
    setupLights(lights, camera);
    scene.traverse(function(object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            initMaterial(object.material[i], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  };
  this.animate = function(callback) {
    function onFrame() {
      callback();
      (vr.getDevice() || window).requestAnimationFrame(onFrame);
    }
    (vr.getDevice() || window).requestAnimationFrame(onFrame);
  };
  this.render = function(scene, camera, renderTarget, forceClear) {
    if (!(camera && camera.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    _currentGeometryProgram = "";
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true) {
      scene.updateMatrixWorld();
    }
    if (camera.parent === null) {
      camera.updateMatrixWorld();
    }
    if (vr.enabled) {
      camera = vr.getCamera(camera);
    }
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    lights.length = 0;
    sprites.length = 0;
    lensFlares.length = 0;
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort();
    }
    if (_clippingEnabled) {
      _clipping.beginShadows();
    }
    setupShadows(lights);
    shadowMap.render(scene, camera);
    setupLights(lights, camera);
    if (_clippingEnabled) {
      _clipping.endShadows();
    }
    _infoRender.frame++;
    _infoRender.calls = 0;
    _infoRender.vertices = 0;
    _infoRender.faces = 0;
    _infoRender.points = 0;
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    this.setRenderTarget(renderTarget);
    background.render(scene, camera, forceClear);
    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;
    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length) {
        renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      }
      if (transparentObjects.length) {
        renderObjects(transparentObjects, scene, camera, overrideMaterial);
      }
    } else {
      if (opaqueObjects.length) {
        renderObjects(opaqueObjects, scene, camera);
      }
      if (transparentObjects.length) {
        renderObjects(transparentObjects, scene, camera);
      }
    }
    spritePlugin.render(scene, camera);
    lensFlarePlugin.render(scene, camera, _currentViewport);
    if (renderTarget) {
      textures.updateRenderTargetMipmap(renderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    if (camera.isArrayCamera) {
      _this.setScissorTest(false);
    }
    if (vr.enabled) {
      vr.submitFrame();
    }
  };
  function projectObject(object, camera, sortObjects) {
    if (!object.visible) {
      return;
    }
    var visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isLight) {
        lights.push(object);
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          sprites.push(object);
        }
      } else if (object.isLensFlare) {
        lensFlares.push(object);
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }
        currentRenderList.push(object, null, object.material, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          var geometry = objects.update(object);
          var material = object.material;
          if (Array.isArray(material)) {
            var groups = geometry.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, _vector3.z, null);
          }
        }
      }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
      var group = renderItem.group;
      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;
        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            var bounds = camera2.bounds;
            var x = bounds.x * _width;
            var y = bounds.y * _height;
            var width = bounds.z * _width;
            var height = bounds.w * _height;
            _this.setViewport(x, y, width, height);
            _this.setScissor(x, y, width, height);
            _this.setScissorTest(true);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram = "";
      renderObjectImmediate(object, program, material);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var parameters2 = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object);
    var code = programCache.getProgramCode(material, parameters2);
    var program = materialProperties.program;
    var programChange = true;
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.code !== code) {
      releaseMaterialProgramReference(material);
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      if (parameters2.shaderID) {
        var shader = ShaderLib[parameters2.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: UniformsUtils.clone(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }
      material.onBeforeCompile(materialProperties.shader);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters2, code);
      materialProperties.program = program;
      material.program = program;
    }
    var programAttributes = program.getAttributes();
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes["morphTarget" + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes["morphNormal" + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    var uniforms = materialProperties.shader.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }
    materialProperties.fog = fog;
    materialProperties.lightsHash = _lights.hash;
    if (material.lights) {
      uniforms.ambientLightColor.value = _lights.ambient;
      uniforms.directionalLights.value = _lights.directional;
      uniforms.spotLights.value = _lights.spot;
      uniforms.rectAreaLights.value = _lights.rectArea;
      uniforms.pointLights.value = _lights.point;
      uniforms.hemisphereLights.value = _lights.hemi;
      uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
      uniforms.spotShadowMap.value = _lights.spotShadowMap;
      uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
      uniforms.pointShadowMap.value = _lights.pointShadowMap;
      uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
    }
    var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId;
        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }
    if (material.needsUpdate === false) {
      if (materialProperties.program === void 0) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }
    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }
    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
    if (program.id !== _currentProgram) {
      _gl.useProgram(program.program);
      _currentProgram = program.id;
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || camera !== _currentCamera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== (_currentArrayCamera || camera)) {
        _currentCamera = _currentArrayCamera || camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      var skeleton = object.skeleton;
      if (skeleton) {
        var bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === void 0) {
            var size = Math.sqrt(bones.length * 4);
            size = _Math.nextPowerOfTwo(Math.ceil(size));
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
      if (material.lights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshNormalMaterial || material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      }
      if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
      } else if (material.isLineDashedMaterial) {
        refreshUniformsLine(m_uniforms, material);
        refreshUniformsDash(m_uniforms, material);
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsToon(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsPhong(m_uniforms, material);
      } else if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(m_uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsStandard(m_uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        if (material.displacementMap) {
          m_uniforms.displacementMap.value = material.displacementMap;
          m_uniforms.displacementScale.value = material.displacementScale;
          m_uniforms.displacementBias.value = material.displacementBias;
        }
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsNormal(m_uniforms, material);
      }
      if (m_uniforms.ltcMat !== void 0) {
        m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
      }
      if (m_uniforms.ltcMag !== void 0) {
        m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;
      }
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    uniforms.diffuse.value = material.color;
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;
    if (material.map !== null) {
      var offset = material.map.offset;
      var repeat = material.map.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
  }
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
    refreshUniformsStandard(uniforms, material);
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function markUniformsLightsNeedsUpdate(uniforms, value2) {
    uniforms.ambientLightColor.needsUpdate = value2;
    uniforms.directionalLights.needsUpdate = value2;
    uniforms.pointLights.needsUpdate = value2;
    uniforms.spotLights.needsUpdate = value2;
    uniforms.rectAreaLights.needsUpdate = value2;
    uniforms.hemisphereLights.needsUpdate = value2;
  }
  function setupShadows(lights2) {
    var lightShadowsLength = 0;
    for (var i = 0, l = lights2.length; i < l; i++) {
      var light = lights2[i];
      if (light.castShadow) {
        _lights.shadows[lightShadowsLength] = light;
        lightShadowsLength++;
      }
    }
    _lights.shadows.length = lightShadowsLength;
  }
  function setupLights(lights2, camera) {
    var l, ll, light, shadow, r = 0, g = 0, b = 0, color, intensity, distance3, shadowMap2, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0;
    for (l = 0, ll = lights2.length; l < ll; l++) {
      light = lights2[l];
      color = light.color;
      intensity = light.intensity;
      distance3 = light.distance;
      shadowMap2 = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isDirectionalLight) {
        var uniforms = lightCache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        _vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(_vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        _lights.directionalShadowMap[directionalLength] = shadowMap2;
        _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        _lights.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = lightCache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance3;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        _vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(_vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.distance === 0 ? 0 : light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        _lights.spotShadowMap[spotLength] = shadowMap2;
        _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
        _lights.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = lightCache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height));
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        _matrix42.identity();
        _matrix4.copy(light.matrixWorld);
        _matrix4.premultiply(viewMatrix);
        _matrix42.extractRotation(_matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(_matrix42);
        uniforms.halfHeight.applyMatrix4(_matrix42);
        _lights.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = lightCache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.distance === 0 ? 0 : light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        _lights.pointShadowMap[pointLength] = shadowMap2;
        _lights.pointShadowMatrix[pointLength] = light.shadow.matrix;
        _lights.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = lightCache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        _lights.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    _lights.ambient[0] = r;
    _lights.ambient[1] = g;
    _lights.ambient[2] = b;
    _lights.directional.length = directionalLength;
    _lights.spot.length = spotLength;
    _lights.rectArea.length = rectAreaLength;
    _lights.point.length = pointLength;
    _lights.hemi.length = hemiLength;
    _lights.hash = directionalLength + "," + pointLength + "," + spotLength + "," + rectAreaLength + "," + hemiLength + "," + _lights.shadows.length;
  }
  this.setFaceCulling = function(cullFace, frontFaceDirection) {
    state.setCullFace(cullFace);
    state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
  };
  function allocTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  this.allocTextureUnit = allocTextureUnit;
  this.setTexture2D = function() {
    var warned = false;
    return function setTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warned = true;
        }
        texture = texture.texture;
      }
      textures.setTexture2D(texture, slot);
    };
  }();
  this.setTexture = function() {
    var warned = false;
    return function setTexture(texture, slot) {
      if (!warned) {
        console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
        warned = true;
      }
      textures.setTexture2D(texture, slot);
    };
  }();
  this.setTextureCube = function() {
    var warned = false;
    return function setTextureCube(texture, slot) {
      if (texture && texture.isWebGLRenderTargetCube) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warned = true;
        }
        texture = texture.texture;
      }
      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        textures.setTextureCube(texture, slot);
      } else {
        textures.setTextureCubeDynamic(texture, slot);
      }
    };
  }();
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget) {
    _currentRenderTarget = renderTarget;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    var framebuffer;
    if (renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      if (isCube) {
        framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
      } else {
        framebuffer = renderTargetProperties.__webglFramebuffer;
      }
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
      _currentViewport.copy(renderTarget.viewport);
    } else {
      framebuffer = null;
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
      _currentScissorTest = _scissorTest;
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    state.viewport(_currentViewport);
    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (framebuffer) {
      var restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        restore = true;
      }
      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;
        if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
        }
      }
    }
  };
  function paramThreeToGL(p) {
    var extension;
    if (p === RepeatWrapping) {
      return _gl.REPEAT;
    }
    if (p === ClampToEdgeWrapping) {
      return _gl.CLAMP_TO_EDGE;
    }
    if (p === MirroredRepeatWrapping) {
      return _gl.MIRRORED_REPEAT;
    }
    if (p === NearestFilter) {
      return _gl.NEAREST;
    }
    if (p === NearestMipMapNearestFilter) {
      return _gl.NEAREST_MIPMAP_NEAREST;
    }
    if (p === NearestMipMapLinearFilter) {
      return _gl.NEAREST_MIPMAP_LINEAR;
    }
    if (p === LinearFilter) {
      return _gl.LINEAR;
    }
    if (p === LinearMipMapNearestFilter) {
      return _gl.LINEAR_MIPMAP_NEAREST;
    }
    if (p === LinearMipMapLinearFilter) {
      return _gl.LINEAR_MIPMAP_LINEAR;
    }
    if (p === UnsignedByteType) {
      return _gl.UNSIGNED_BYTE;
    }
    if (p === UnsignedShort4444Type) {
      return _gl.UNSIGNED_SHORT_4_4_4_4;
    }
    if (p === UnsignedShort5551Type) {
      return _gl.UNSIGNED_SHORT_5_5_5_1;
    }
    if (p === UnsignedShort565Type) {
      return _gl.UNSIGNED_SHORT_5_6_5;
    }
    if (p === ByteType) {
      return _gl.BYTE;
    }
    if (p === ShortType) {
      return _gl.SHORT;
    }
    if (p === UnsignedShortType) {
      return _gl.UNSIGNED_SHORT;
    }
    if (p === IntType) {
      return _gl.INT;
    }
    if (p === UnsignedIntType) {
      return _gl.UNSIGNED_INT;
    }
    if (p === FloatType) {
      return _gl.FLOAT;
    }
    if (p === HalfFloatType) {
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      }
    }
    if (p === AlphaFormat) {
      return _gl.ALPHA;
    }
    if (p === RGBFormat) {
      return _gl.RGB;
    }
    if (p === RGBAFormat) {
      return _gl.RGBA;
    }
    if (p === LuminanceFormat) {
      return _gl.LUMINANCE;
    }
    if (p === LuminanceAlphaFormat) {
      return _gl.LUMINANCE_ALPHA;
    }
    if (p === DepthFormat) {
      return _gl.DEPTH_COMPONENT;
    }
    if (p === DepthStencilFormat) {
      return _gl.DEPTH_STENCIL;
    }
    if (p === AddEquation) {
      return _gl.FUNC_ADD;
    }
    if (p === SubtractEquation) {
      return _gl.FUNC_SUBTRACT;
    }
    if (p === ReverseSubtractEquation) {
      return _gl.FUNC_REVERSE_SUBTRACT;
    }
    if (p === ZeroFactor) {
      return _gl.ZERO;
    }
    if (p === OneFactor) {
      return _gl.ONE;
    }
    if (p === SrcColorFactor) {
      return _gl.SRC_COLOR;
    }
    if (p === OneMinusSrcColorFactor) {
      return _gl.ONE_MINUS_SRC_COLOR;
    }
    if (p === SrcAlphaFactor) {
      return _gl.SRC_ALPHA;
    }
    if (p === OneMinusSrcAlphaFactor) {
      return _gl.ONE_MINUS_SRC_ALPHA;
    }
    if (p === DstAlphaFactor) {
      return _gl.DST_ALPHA;
    }
    if (p === OneMinusDstAlphaFactor) {
      return _gl.ONE_MINUS_DST_ALPHA;
    }
    if (p === DstColorFactor) {
      return _gl.DST_COLOR;
    }
    if (p === OneMinusDstColorFactor) {
      return _gl.ONE_MINUS_DST_COLOR;
    }
    if (p === SrcAlphaSaturateFactor) {
      return _gl.SRC_ALPHA_SATURATE;
    }
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) {
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        }
        if (p === RGBA_S3TC_DXT1_Format) {
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        }
        if (p === RGBA_S3TC_DXT3_Format) {
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        }
        if (p === RGBA_S3TC_DXT5_Format) {
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) {
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        }
        if (p === RGB_PVRTC_2BPPV1_Format) {
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        }
        if (p === RGBA_PVRTC_4BPPV1_Format) {
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        }
        if (p === RGBA_PVRTC_2BPPV1_Format) {
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      }
    }
    if (p === MinEquation || p === MaxEquation) {
      extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        if (p === MinEquation) {
          return extension.MIN_EXT;
        }
        if (p === MaxEquation) {
          return extension.MAX_EXT;
        }
      }
    }
    if (p === UnsignedInt248Type) {
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    return 0;
  }
}
function FogExp2(color, density) {
  this.name = "";
  this.color = new Color(color);
  this.density = density !== void 0 ? density : 25e-5;
}
FogExp2.prototype.isFogExp2 = true;
FogExp2.prototype.clone = function() {
  return new FogExp2(this.color.getHex(), this.density);
};
FogExp2.prototype.toJSON = function(meta) {
  return {
    type: "FogExp2",
    color: this.color.getHex(),
    density: this.density
  };
};
function Fog(color, near, far) {
  this.name = "";
  this.color = new Color(color);
  this.near = near !== void 0 ? near : 1;
  this.far = far !== void 0 ? far : 1e3;
}
Fog.prototype.isFog = true;
Fog.prototype.clone = function() {
  return new Fog(this.color.getHex(), this.near, this.far);
};
Fog.prototype.toJSON = function(meta) {
  return {
    type: "Fog",
    color: this.color.getHex(),
    near: this.near,
    far: this.far
  };
};
function Scene() {
  Object3D.call(this);
  this.type = "Scene";
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
}
Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null) {
      this.background = source.background.clone();
    }
    if (source.fog !== null) {
      this.fog = source.fog.clone();
    }
    if (source.overrideMaterial !== null) {
      this.overrideMaterial = source.overrideMaterial.clone();
    }
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null) {
      data.object.background = this.background.toJSON(meta);
    }
    if (this.fog !== null) {
      data.object.fog = this.fog.toJSON();
    }
    return data;
  }
});
function LensFlare(texture, size, distance3, blending, color) {
  Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new Vector3();
  this.customUpdateCallback = void 0;
  if (texture !== void 0) {
    this.add(texture, size, distance3, blending, color);
  }
}
LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LensFlare,
  isLensFlare: true,
  copy: function(source) {
    var this$1 = this;
    Object3D.prototype.copy.call(this, source);
    this.positionScreen.copy(source.positionScreen);
    this.customUpdateCallback = source.customUpdateCallback;
    for (var i = 0, l = source.lensFlares.length; i < l; i++) {
      this$1.lensFlares.push(source.lensFlares[i]);
    }
    return this;
  },
  add: function(texture, size, distance3, blending, color, opacity) {
    if (size === void 0) {
      size = -1;
    }
    if (distance3 === void 0) {
      distance3 = 0;
    }
    if (opacity === void 0) {
      opacity = 1;
    }
    if (color === void 0) {
      color = new Color(16777215);
    }
    if (blending === void 0) {
      blending = NormalBlending;
    }
    distance3 = Math.min(distance3, Math.max(0, distance3));
    this.lensFlares.push({
      texture,
      size,
      distance: distance3,
      x: 0,
      y: 0,
      z: 0,
      scale: 1,
      rotation: 0,
      opacity,
      color,
      blending
    });
  },
  updateLensFlares: function() {
    var this$1 = this;
    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;
    for (f = 0; f < fl; f++) {
      flare = this$1.lensFlares[f];
      flare.x = this$1.positionScreen.x + vecX * flare.distance;
      flare.y = this$1.positionScreen.y + vecY * flare.distance;
      flare.wantedRotation = flare.x * Math.PI * 0.25;
      flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
    }
  }
});
function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = "SpriteMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.rotation = source.rotation;
  return this;
};
function Sprite(material) {
  Object3D.call(this);
  this.type = "Sprite";
  this.material = material !== void 0 ? material : new SpriteMaterial();
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function() {
    var intersectPoint = new Vector3();
    var worldPosition = new Vector3();
    var worldScale = new Vector3();
    return function raycast(raycaster, intersects2) {
      worldPosition.setFromMatrixPosition(this.matrixWorld);
      raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);
      worldScale.setFromMatrixScale(this.matrixWorld);
      var guessSizeSq = worldScale.x * worldScale.y / 4;
      if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq) {
        return;
      }
      var distance3 = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance3 < raycaster.near || distance3 > raycaster.far) {
        return;
      }
      intersects2.push({
        distance: distance3,
        point: intersectPoint.clone(),
        face: null,
        object: this
      });
    };
  }(),
  clone: function() {
    return new this.constructor(this.material).copy(this);
  }
});
function LOD() {
  Object3D.call(this);
  this.type = "LOD";
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  copy: function(source) {
    var this$1 = this;
    Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;
    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      this$1.addLevel(level.object.clone(), level.distance);
    }
    return this;
  },
  addLevel: function(object, distance3) {
    if (distance3 === void 0) {
      distance3 = 0;
    }
    distance3 = Math.abs(distance3);
    var levels = this.levels;
    for (var l = 0; l < levels.length; l++) {
      if (distance3 < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, {distance: distance3, object});
    this.add(object);
  },
  getObjectForDistance: function(distance3) {
    var levels = this.levels;
    for (var i = 1, l = levels.length; i < l; i++) {
      if (distance3 < levels[i].distance) {
        break;
      }
    }
    return levels[i - 1].object;
  },
  raycast: function() {
    var matrixPosition = new Vector3();
    return function raycast(raycaster, intersects2) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distance3 = raycaster.ray.origin.distanceTo(matrixPosition);
      this.getObjectForDistance(distance3).raycast(raycaster, intersects2);
    };
  }(),
  update: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function update2(camera) {
      var levels = this.levels;
      if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance3 = v1.distanceTo(v2);
        levels[0].object.visible = true;
        for (var i = 1, l = levels.length; i < l; i++) {
          if (distance3 >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    };
  }(),
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;
    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
});
function Skeleton(bones, boneInverses) {
  var this$1 = this;
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  if (boneInverses === void 0) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn("THREE.Skeleton boneInverses is the wrong length.");
      this.boneInverses = [];
      for (var i = 0, il = this.bones.length; i < il; i++) {
        this$1.boneInverses.push(new Matrix4());
      }
    }
  }
}
Object.assign(Skeleton.prototype, {
  calculateInverses: function() {
    var this$1 = this;
    this.boneInverses = [];
    for (var i = 0, il = this.bones.length; i < il; i++) {
      var inverse = new Matrix4();
      if (this$1.bones[i]) {
        inverse.getInverse(this$1.bones[i].matrixWorld);
      }
      this$1.boneInverses.push(inverse);
    }
  },
  pose: function() {
    var this$1 = this;
    var bone, i, il;
    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this$1.bones[i];
      if (bone) {
        bone.matrixWorld.getInverse(this$1.boneInverses[i]);
      }
    }
    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this$1.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function() {
    var offsetMatrix = new Matrix4();
    var identityMatrix = new Matrix4();
    return function update2() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture;
      for (var i = 0, il = bones.length; i < il; i++) {
        var matrix2 = bones[i] ? bones[i].matrixWorld : identityMatrix;
        offsetMatrix.multiplyMatrices(matrix2, boneInverses[i]);
        offsetMatrix.toArray(boneMatrices, i * 16);
      }
      if (boneTexture !== void 0) {
        boneTexture.needsUpdate = true;
      }
    };
  }(),
  clone: function() {
    return new Skeleton(this.bones, this.boneInverses);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
  var bones = this.initBones();
  var skeleton = new Skeleton(bones);
  this.bind(skeleton, this.matrixWorld);
  this.normalizeSkinWeights();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  initBones: function() {
    var this$1 = this;
    var bones = [], bone, gbone;
    var i, il;
    if (this.geometry && this.geometry.bones !== void 0) {
      for (i = 0, il = this.geometry.bones.length; i < il; i++) {
        gbone = this$1.geometry.bones[i];
        bone = new Bone();
        bones.push(bone);
        bone.name = gbone.name;
        bone.position.fromArray(gbone.pos);
        bone.quaternion.fromArray(gbone.rotq);
        if (gbone.scl !== void 0) {
          bone.scale.fromArray(gbone.scl);
        }
      }
      for (i = 0, il = this.geometry.bones.length; i < il; i++) {
        gbone = this$1.geometry.bones[i];
        if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
          bones[gbone.parent].add(bones[i]);
        } else {
          this$1.add(bones[i]);
        }
      }
    }
    this.updateMatrixWorld(true);
    return bones;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    var this$1 = this;
    var scale2, i;
    if (this.geometry && this.geometry.isGeometry) {
      for (i = 0; i < this.geometry.skinWeights.length; i++) {
        var sw = this$1.geometry.skinWeights[i];
        scale2 = 1 / sw.lengthManhattan();
        if (scale2 !== Infinity) {
          sw.multiplyScalar(scale2);
        } else {
          sw.set(1, 0, 0, 0);
        }
      }
    } else if (this.geometry && this.geometry.isBufferGeometry) {
      var vec = new Vector4();
      var skinWeight = this.geometry.attributes.skinWeight;
      for (i = 0; i < skinWeight.count; i++) {
        vec.x = skinWeight.getX(i);
        vec.y = skinWeight.getY(i);
        vec.z = skinWeight.getZ(i);
        vec.w = skinWeight.getW(i);
        scale2 = 1 / vec.lengthManhattan();
        if (scale2 !== Infinity) {
          vec.multiplyScalar(scale2);
        } else {
          vec.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
      }
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = "LineBasicMaterial";
  this.color = new Color(16777215);
  this.linewidth = 1;
  this.linecap = "round";
  this.linejoin = "round";
  this.lights = false;
  this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};
function Line(geometry, material, mode) {
  if (mode === 1) {
    console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.");
    return new LineSegments(geometry, material);
  }
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new LineBasicMaterial({color: Math.random() * 16777215});
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var this$1 = this;
      var precision = raycaster.linePrecision;
      var precisionSq = precision * precision;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false) {
        return;
      }
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step = this && this.isLineSegments ? 2 : 1;
      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
          var indices = index.array;
          for (var i = 0, l = indices.length - 1; i < l; i += step) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq) {
              continue;
            }
            interRay.applyMatrix4(this$1.matrixWorld);
            var distance3 = raycaster.ray.origin.distanceTo(interRay);
            if (distance3 < raycaster.near || distance3 > raycaster.far) {
              continue;
            }
            intersects2.push({
              distance: distance3,
              point: interSegment.clone().applyMatrix4(this$1.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this$1
            });
          }
        } else {
          for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq) {
              continue;
            }
            interRay.applyMatrix4(this$1.matrixWorld);
            var distance3 = raycaster.ray.origin.distanceTo(interRay);
            if (distance3 < raycaster.near || distance3 > raycaster.far) {
              continue;
            }
            intersects2.push({
              distance: distance3,
              point: interSegment.clone().applyMatrix4(this$1.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this$1
            });
          }
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;
        for (var i = 0; i < nbVertices - 1; i += step) {
          var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > precisionSq) {
            continue;
          }
          interRay.applyMatrix4(this$1.matrixWorld);
          var distance3 = raycaster.ray.origin.distanceTo(interRay);
          if (distance3 < raycaster.near || distance3 > raycaster.far) {
            continue;
          }
          intersects2.push({
            distance: distance3,
            point: interSegment.clone().applyMatrix4(this$1.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this$1
          });
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true
});
function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
function PointsMaterial(parameters) {
  Material.call(this);
  this.type = "PointsMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.lights = false;
  this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
function Points(geometry, material) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
  this.material = material !== void 0 ? material : new PointsMaterial({color: Math.random() * 16777215});
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var object = this;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold;
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(sphere) === false) {
        return;
      }
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new Vector3();
      function testPoint(point, index2) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          var intersectPoint = ray.closestPointToPoint(point);
          intersectPoint.applyMatrix4(matrixWorld);
          var distance3 = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance3 < raycaster.near || distance3 > raycaster.far) {
            return;
          }
          intersects2.push({
            distance: distance3,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index2,
            face: null,
            object
          });
        }
      }
      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
          var indices = index.array;
          for (var i = 0, il = indices.length; i < il; i++) {
            var a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (var i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      } else {
        var vertices = geometry.vertices;
        for (var i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i);
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function Group() {
  Object3D.call(this);
  this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group
});
function CompressedTexture(mipmaps, width, height, format, type2, mapping2, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy, encoding);
  this.image = {width, height};
  this.mipmaps = mipmaps;
  this.flipY = false;
  this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy) {
  Texture.call(this, canvas, mapping2, wrapS, wrapT, magFilter, minFilter, format, type2, anisotropy);
  this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
function WireframeGeometry(geometry) {
  BufferGeometry.call(this);
  this.type = "WireframeGeometry";
  var vertices = [];
  var i, j, l, o, ol;
  var edge = [0, 0], edges = {}, e, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var vertex2;
  if (geometry && geometry.isGeometry) {
    var faces = geometry.faces;
    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + "," + edge[1];
        if (edges[key] === void 0) {
          edges[key] = {index1: edge[0], index2: edge[1]};
        }
      }
    }
    for (key in edges) {
      e = edges[key];
      vertex2 = geometry.vertices[e.index1];
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      vertex2 = geometry.vertices[e.index2];
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
    }
  } else if (geometry && geometry.isBufferGeometry) {
    var position, indices, groups;
    var group, start, count2;
    var index1, index2;
    vertex2 = new Vector3();
    if (geometry.index !== null) {
      position = geometry.attributes.position;
      indices = geometry.index;
      groups = geometry.groups;
      if (groups.length === 0) {
        groups = [{start: 0, count: indices.count, materialIndex: 0}];
      }
      for (o = 0, ol = groups.length; o < ol; ++o) {
        group = groups[o];
        start = group.start;
        count2 = group.count;
        for (i = start, l = start + count2; i < l; i += 3) {
          for (j = 0; j < 3; j++) {
            edge1 = indices.getX(i + j);
            edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = {index1: edge[0], index2: edge[1]};
            }
          }
        }
      }
      for (key in edges) {
        e = edges[key];
        vertex2.fromBufferAttribute(position, e.index1);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        vertex2.fromBufferAttribute(position, e.index2);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    } else {
      position = geometry.attributes.position;
      for (i = 0, l = position.count / 3; i < l; i++) {
        for (j = 0; j < 3; j++) {
          index1 = 3 * i + j;
          vertex2.fromBufferAttribute(position, index1);
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          index2 = 3 * i + (j + 1) % 3;
          vertex2.fromBufferAttribute(position, index2);
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
        }
      }
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
function ParametricGeometry(func3, slices, stacks) {
  Geometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func: func3,
    slices,
    stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func3, slices, stacks));
  this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
function ParametricBufferGeometry(func3, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricBufferGeometry";
  this.parameters = {
    func: func3,
    slices,
    stacks
  };
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var EPS = 1e-5;
  var normal2 = new Vector3();
  var p0 = new Vector3(), p1 = new Vector3();
  var pu = new Vector3(), pv = new Vector3();
  var i, j;
  var sliceCount = slices + 1;
  for (i = 0; i <= stacks; i++) {
    var v = i / stacks;
    for (j = 0; j <= slices; j++) {
      var u = j / slices;
      p0 = func3(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        p1 = func3(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        p1 = func3(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        p1 = func3(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        p1 = func3(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal2.crossVectors(pu, pv).normalize();
      normals.push(normal2.x, normal2.y, normal2.z);
      uvs.push(u, v);
    }
  }
  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      var a = i * sliceCount + j;
      var b = i * sliceCount + j + 1;
      var c = (i + 1) * sliceCount + j + 1;
      var d = (i + 1) * sliceCount + j;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = "PolyhedronGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = "PolyhedronBufferGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  radius = radius || 1;
  detail = detail || 0;
  var vertexBuffer = [];
  var uvBuffer = [];
  subdivide(detail);
  appplyRadius(radius);
  generateUVs();
  this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
  this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
  if (detail === 0) {
    this.computeVertexNormals();
  } else {
    this.normalizeNormals();
  }
  function subdivide(detail2) {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    for (var i = 0; i < indices.length; i += 3) {
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c);
      subdivideFace(a, b, c, detail2);
    }
  }
  function subdivideFace(a, b, c, detail2) {
    var cols = Math.pow(2, detail2);
    var v = [];
    var i, j;
    for (i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = a.clone().lerp(c, i / cols);
      var bj = b.clone().lerp(c, i / cols);
      var rows = cols - i;
      for (j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    }
    for (i = 0; i < cols; i++) {
      for (j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);
        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }
  function appplyRadius(radius2) {
    var vertex2 = new Vector3();
    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex2.x = vertexBuffer[i + 0];
      vertex2.y = vertexBuffer[i + 1];
      vertex2.z = vertexBuffer[i + 2];
      vertex2.normalize().multiplyScalar(radius2);
      vertexBuffer[i + 0] = vertex2.x;
      vertexBuffer[i + 1] = vertex2.y;
      vertexBuffer[i + 2] = vertex2.z;
    }
  }
  function generateUVs() {
    var vertex2 = new Vector3();
    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex2.x = vertexBuffer[i + 0];
      vertex2.y = vertexBuffer[i + 1];
      vertex2.z = vertexBuffer[i + 2];
      var u = azimuth(vertex2) / 2 / Math.PI + 0.5;
      var v = inclination(vertex2) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }
    correctUVs();
    correctSeam();
  }
  function correctSeam() {
    for (var i = 0; i < uvBuffer.length; i += 6) {
      var x0 = uvBuffer[i + 0];
      var x1 = uvBuffer[i + 2];
      var x2 = uvBuffer[i + 4];
      var max2 = Math.max(x0, x1, x2);
      var min = Math.min(x0, x1, x2);
      if (max2 > 0.9 && min < 0.1) {
        if (x0 < 0.2) {
          uvBuffer[i + 0] += 1;
        }
        if (x1 < 0.2) {
          uvBuffer[i + 2] += 1;
        }
        if (x2 < 0.2) {
          uvBuffer[i + 4] += 1;
        }
      }
    }
  }
  function pushVertex(vertex2) {
    vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
  }
  function getVertexByIndex(index, vertex2) {
    var stride = index * 3;
    vertex2.x = vertices[stride + 0];
    vertex2.y = vertices[stride + 1];
    vertex2.z = vertices[stride + 2];
  }
  function correctUVs() {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    var centroid = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      var azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }
  function correctUV(uv, stride, vector, azimuth2) {
    if (azimuth2 < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }
    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "TetrahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
function TetrahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ];
  var indices = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "TetrahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "OctahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
function OctahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ];
  var indices = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "OctahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "IcosahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
function IcosahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    t,
    0,
    -1,
    t,
    0,
    1,
    -t,
    0,
    -1,
    -t,
    0,
    1
  ];
  var indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "IcosahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "DodecahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
function DodecahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var r = 1 / t;
  var vertices = [
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    0,
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    0,
    -t,
    0,
    -r,
    t,
    0,
    -r,
    -t,
    0,
    r,
    t,
    0,
    r
  ];
  var indices = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "DodecahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = "TubeGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  if (taper !== void 0) {
    console.warn("THREE.TubeGeometry: taper has been removed.");
  }
  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals;
  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = "TubeBufferGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  var frames = path.computeFrenetFrames(tubularSegments, closed);
  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals;
  var vertex2 = new Vector3();
  var normal2 = new Vector3();
  var uv = new Vector2();
  var i, j;
  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  generateBufferData();
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateBufferData() {
    for (i = 0; i < tubularSegments; i++) {
      generateSegment(i);
    }
    generateSegment(closed === false ? tubularSegments : 0);
    generateUVs();
    generateIndices();
  }
  function generateSegment(i2) {
    var P = path.getPointAt(i2 / tubularSegments);
    var N = frames.normals[i2];
    var B = frames.binormals[i2];
    for (j = 0; j <= radialSegments; j++) {
      var v = j / radialSegments * Math.PI * 2;
      var sin2 = Math.sin(v);
      var cos2 = -Math.cos(v);
      normal2.x = cos2 * N.x + sin2 * B.x;
      normal2.y = cos2 * N.y + sin2 * B.y;
      normal2.z = cos2 * N.z + sin2 * B.z;
      normal2.normalize();
      normals.push(normal2.x, normal2.y, normal2.z);
      vertex2.x = P.x + radius * normal2.x;
      vertex2.y = P.y + radius * normal2.y;
      vertex2.z = P.z + radius * normal2.z;
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
    }
  }
  function generateIndices() {
    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }
  function generateUVs() {
    for (i = 0; i <= tubularSegments; i++) {
      for (j = 0; j <= radialSegments; j++) {
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = "TorusKnotGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  if (heightScale !== void 0) {
    console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
  }
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = "TorusKnotBufferGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  radius = radius || 100;
  tube = tube || 40;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i, j;
  var vertex2 = new Vector3();
  var normal2 = new Vector3();
  var P1 = new Vector3();
  var P2 = new Vector3();
  var B = new Vector3();
  var T = new Vector3();
  var N = new Vector3();
  for (i = 0; i <= tubularSegments; ++i) {
    var u = i / tubularSegments * p * Math.PI * 2;
    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T);
    B.normalize();
    N.normalize();
    for (j = 0; j <= radialSegments; ++j) {
      var v = j / radialSegments * Math.PI * 2;
      var cx = -tube * Math.cos(v);
      var cy = tube * Math.sin(v);
      vertex2.x = P1.x + (cx * N.x + cy * B.x);
      vertex2.y = P1.y + (cx * N.y + cy * B.y);
      vertex2.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normal2.subVectors(vertex2, P1).normalize();
      normals.push(normal2.x, normal2.y, normal2.z);
      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= tubularSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
      var a = (radialSegments + 1) * (j - 1) + (i - 1);
      var b = (radialSegments + 1) * j + (i - 1);
      var c = (radialSegments + 1) * j + i;
      var d = (radialSegments + 1) * (j - 1) + i;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function calculatePositionOnCurve(u2, p2, q2, radius2, position) {
    var cu = Math.cos(u2);
    var su = Math.sin(u2);
    var quOverP = q2 / p2 * u2;
    var cs = Math.cos(quOverP);
    position.x = radius2 * (2 + cs) * 0.5 * cu;
    position.y = radius2 * (2 + cs) * su * 0.5;
    position.z = radius2 * Math.sin(quOverP) * 0.5;
  }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = "TorusGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = "TorusBufferGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  radius = radius || 100;
  tube = tube || 40;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var center2 = new Vector3();
  var vertex2 = new Vector3();
  var normal2 = new Vector3();
  var j, i;
  for (j = 0; j <= radialSegments; j++) {
    for (i = 0; i <= tubularSegments; i++) {
      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;
      vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex2.z = tube * Math.sin(v);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      center2.x = radius * Math.cos(u);
      center2.y = radius * Math.sin(u);
      normal2.subVectors(vertex2, center2).normalize();
      normals.push(normal2.x, normal2.y, normal2.z);
      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= radialSegments; j++) {
    for (i = 1; i <= tubularSegments; i++) {
      var a = (tubularSegments + 1) * j + i - 1;
      var b = (tubularSegments + 1) * (j - 1) + i - 1;
      var c = (tubularSegments + 1) * (j - 1) + i;
      var d = (tubularSegments + 1) * j + i;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
var ShapeUtils = {
  area: function(contour) {
    var n = contour.length;
    var a = 0;
    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  },
  triangulate: function() {
    function snip(contour, u, v, w, n, verts) {
      var p;
      var ax, ay, bx, by;
      var cx, cy, px2, py2;
      ax = contour[verts[u]].x;
      ay = contour[verts[u]].y;
      bx = contour[verts[v]].x;
      by = contour[verts[v]].y;
      cx = contour[verts[w]].x;
      cy = contour[verts[w]].y;
      if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) {
        return false;
      }
      var aX, aY, bX, bY, cX, cY;
      var apx, apy, bpx, bpy, cpx, cpy;
      var cCROSSap, bCROSScp, aCROSSbp;
      aX = cx - bx;
      aY = cy - by;
      bX = ax - cx;
      bY = ay - cy;
      cX = bx - ax;
      cY = by - ay;
      for (p = 0; p < n; p++) {
        px2 = contour[verts[p]].x;
        py2 = contour[verts[p]].y;
        if (px2 === ax && py2 === ay || px2 === bx && py2 === by || px2 === cx && py2 === cy) {
          continue;
        }
        apx = px2 - ax;
        apy = py2 - ay;
        bpx = px2 - bx;
        bpy = py2 - by;
        cpx = px2 - cx;
        cpy = py2 - cy;
        aCROSSbp = aX * bpy - aY * bpx;
        cCROSSap = cX * apy - cY * apx;
        bCROSScp = bX * cpy - bY * cpx;
        if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON) {
          return false;
        }
      }
      return true;
    }
    return function triangulate(contour, indices) {
      var n = contour.length;
      if (n < 3) {
        return null;
      }
      var result = [], verts = [], vertIndices = [];
      var u, v, w;
      if (ShapeUtils.area(contour) > 0) {
        for (v = 0; v < n; v++) {
          verts[v] = v;
        }
      } else {
        for (v = 0; v < n; v++) {
          verts[v] = n - 1 - v;
        }
      }
      var nv = n;
      var count2 = 2 * nv;
      for (v = nv - 1; nv > 2; ) {
        if (count2-- <= 0) {
          console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
          if (indices) {
            return vertIndices;
          }
          return result;
        }
        u = v;
        if (nv <= u) {
          u = 0;
        }
        v = u + 1;
        if (nv <= v) {
          v = 0;
        }
        w = v + 1;
        if (nv <= w) {
          w = 0;
        }
        if (snip(contour, u, v, w, nv, verts)) {
          var a, b, c, s, t;
          a = verts[u];
          b = verts[v];
          c = verts[w];
          result.push([
            contour[a],
            contour[b],
            contour[c]
          ]);
          vertIndices.push([verts[u], verts[v], verts[w]]);
          for (s = v, t = v + 1; t < nv; s++, t++) {
            verts[s] = verts[t];
          }
          nv--;
          count2 = 2 * nv;
        }
      }
      if (indices) {
        return vertIndices;
      }
      return result;
    };
  }(),
  triangulateShape: function(contour, holes) {
    function removeDupEndPts(points) {
      var l = points.length;
      if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
      }
    }
    removeDupEndPts(contour);
    holes.forEach(removeDupEndPts);
    function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
      if (inSegPt1.x !== inSegPt2.x) {
        if (inSegPt1.x < inSegPt2.x) {
          return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
        } else {
          return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
        }
      } else {
        if (inSegPt1.y < inSegPt2.y) {
          return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
        } else {
          return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
        }
      }
    }
    function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
      var limit2 = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
      if (Math.abs(limit2) > Number.EPSILON) {
        var perpSeg2;
        if (limit2 > 0) {
          if (perpSeg1 < 0 || perpSeg1 > limit2) {
            return [];
          }
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if (perpSeg2 < 0 || perpSeg2 > limit2) {
            return [];
          }
        } else {
          if (perpSeg1 > 0 || perpSeg1 < limit2) {
            return [];
          }
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if (perpSeg2 > 0 || perpSeg2 < limit2) {
            return [];
          }
        }
        if (perpSeg2 === 0) {
          if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit2)) {
            return [];
          }
          return [inSeg1Pt1];
        }
        if (perpSeg2 === limit2) {
          if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit2)) {
            return [];
          }
          return [inSeg1Pt2];
        }
        if (perpSeg1 === 0) {
          return [inSeg2Pt1];
        }
        if (perpSeg1 === limit2) {
          return [inSeg2Pt2];
        }
        var factorSeg1 = perpSeg2 / limit2;
        return [{
          x: inSeg1Pt1.x + factorSeg1 * seg1dx,
          y: inSeg1Pt1.y + factorSeg1 * seg1dy
        }];
      } else {
        if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy) {
          return [];
        }
        var seg1Pt = seg1dx === 0 && seg1dy === 0;
        var seg2Pt = seg2dx === 0 && seg2dy === 0;
        if (seg1Pt && seg2Pt) {
          if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y) {
            return [];
          }
          return [inSeg1Pt1];
        }
        if (seg1Pt) {
          if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) {
            return [];
          }
          return [inSeg1Pt1];
        }
        if (seg2Pt) {
          if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) {
            return [];
          }
          return [inSeg2Pt1];
        }
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if (seg1dx !== 0) {
          if (inSeg1Pt1.x < inSeg1Pt2.x) {
            seg1min = inSeg1Pt1;
            seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2;
            seg1maxVal = inSeg1Pt2.x;
          } else {
            seg1min = inSeg1Pt2;
            seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1;
            seg1maxVal = inSeg1Pt1.x;
          }
          if (inSeg2Pt1.x < inSeg2Pt2.x) {
            seg2min = inSeg2Pt1;
            seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2;
            seg2maxVal = inSeg2Pt2.x;
          } else {
            seg2min = inSeg2Pt2;
            seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1;
            seg2maxVal = inSeg2Pt1.x;
          }
        } else {
          if (inSeg1Pt1.y < inSeg1Pt2.y) {
            seg1min = inSeg1Pt1;
            seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2;
            seg1maxVal = inSeg1Pt2.y;
          } else {
            seg1min = inSeg1Pt2;
            seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1;
            seg1maxVal = inSeg1Pt1.y;
          }
          if (inSeg2Pt1.y < inSeg2Pt2.y) {
            seg2min = inSeg2Pt1;
            seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2;
            seg2maxVal = inSeg2Pt2.y;
          } else {
            seg2min = inSeg2Pt2;
            seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1;
            seg2maxVal = inSeg2Pt1.y;
          }
        }
        if (seg1minVal <= seg2minVal) {
          if (seg1maxVal < seg2minVal) {
            return [];
          }
          if (seg1maxVal === seg2minVal) {
            if (inExcludeAdjacentSegs) {
              return [];
            }
            return [seg2min];
          }
          if (seg1maxVal <= seg2maxVal) {
            return [seg2min, seg1max];
          }
          return [seg2min, seg2max];
        } else {
          if (seg1minVal > seg2maxVal) {
            return [];
          }
          if (seg1minVal === seg2maxVal) {
            if (inExcludeAdjacentSegs) {
              return [];
            }
            return [seg1min];
          }
          if (seg1maxVal <= seg2maxVal) {
            return [seg1min, seg1max];
          }
          return [seg1min, seg2max];
        }
      }
    }
    function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
      var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
      var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
      var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
      if (Math.abs(from2toAngle) > Number.EPSILON) {
        var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
        if (from2toAngle > 0) {
          return from2otherAngle >= 0 && other2toAngle >= 0;
        } else {
          return from2otherAngle >= 0 || other2toAngle >= 0;
        }
      } else {
        return from2otherAngle > 0;
      }
    }
    function removeHoles(contour2, holes2) {
      var shape = contour2.concat();
      var hole;
      function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
        var lastShapeIdx = shape.length - 1;
        var prevShapeIdx = inShapeIdx - 1;
        if (prevShapeIdx < 0) {
          prevShapeIdx = lastShapeIdx;
        }
        var nextShapeIdx = inShapeIdx + 1;
        if (nextShapeIdx > lastShapeIdx) {
          nextShapeIdx = 0;
        }
        var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
        if (!insideAngle) {
          return false;
        }
        var lastHoleIdx = hole.length - 1;
        var prevHoleIdx = inHoleIdx - 1;
        if (prevHoleIdx < 0) {
          prevHoleIdx = lastHoleIdx;
        }
        var nextHoleIdx = inHoleIdx + 1;
        if (nextHoleIdx > lastHoleIdx) {
          nextHoleIdx = 0;
        }
        insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
        if (!insideAngle) {
          return false;
        }
        return true;
      }
      function intersectsShapeEdge(inShapePt, inHolePt) {
        var sIdx, nextIdx, intersection2;
        for (sIdx = 0; sIdx < shape.length; sIdx++) {
          nextIdx = sIdx + 1;
          nextIdx %= shape.length;
          intersection2 = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
          if (intersection2.length > 0) {
            return true;
          }
        }
        return false;
      }
      var indepHoles = [];
      function intersectsHoleEdge(inShapePt, inHolePt) {
        var ihIdx, chkHole, hIdx, nextIdx, intersection2;
        for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
          chkHole = holes2[indepHoles[ihIdx]];
          for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
            nextIdx = hIdx + 1;
            nextIdx %= chkHole.length;
            intersection2 = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
            if (intersection2.length > 0) {
              return true;
            }
          }
        }
        return false;
      }
      var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
      for (var h2 = 0, hl2 = holes2.length; h2 < hl2; h2++) {
        indepHoles.push(h2);
      }
      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while (indepHoles.length > 0) {
        counter--;
        if (counter < 0) {
          console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
          break;
        }
        for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
          shapePt = shape[shapeIndex];
          holeIndex = -1;
          for (var h2 = 0; h2 < indepHoles.length; h2++) {
            holeIdx = indepHoles[h2];
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if (failedCuts[cutKey] !== void 0) {
              continue;
            }
            hole = holes2[holeIdx];
            for (var h22 = 0; h22 < hole.length; h22++) {
              holePt = hole[h22];
              if (!isCutLineInsideAngles(shapeIndex, h22)) {
                continue;
              }
              if (intersectsShapeEdge(shapePt, holePt)) {
                continue;
              }
              if (intersectsHoleEdge(shapePt, holePt)) {
                continue;
              }
              holeIndex = h22;
              indepHoles.splice(h2, 1);
              tmpShape1 = shape.slice(0, shapeIndex + 1);
              tmpShape2 = shape.slice(shapeIndex);
              tmpHole1 = hole.slice(holeIndex);
              tmpHole2 = hole.slice(0, holeIndex + 1);
              shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
              minShapeIndex = shapeIndex;
              break;
            }
            if (holeIndex >= 0) {
              break;
            }
            failedCuts[cutKey] = true;
          }
          if (holeIndex >= 0) {
            break;
          }
        }
      }
      return shape;
    }
    var i, il, f, face, key, index, allPointsMap = {};
    var allpoints = contour.concat();
    for (var h = 0, hl = holes.length; h < hl; h++) {
      Array.prototype.push.apply(allpoints, holes[h]);
    }
    for (i = 0, il = allpoints.length; i < il; i++) {
      key = allpoints[i].x + ":" + allpoints[i].y;
      if (allPointsMap[key] !== void 0) {
        console.warn("THREE.ShapeUtils: Duplicate point", key, i);
      }
      allPointsMap[key] = i;
    }
    var shapeWithoutHoles = removeHoles(contour, holes);
    var triangles = ShapeUtils.triangulate(shapeWithoutHoles, false);
    for (i = 0, il = triangles.length; i < il; i++) {
      face = triangles[i];
      for (f = 0; f < 3; f++) {
        key = face[f].x + ":" + face[f].y;
        index = allPointsMap[key];
        if (index !== void 0) {
          face[f] = index;
        }
      }
    }
    return triangles.concat();
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  }
};
function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = "ExtrudeGeometry";
  this.parameters = {
    shapes,
    options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
function ExtrudeBufferGeometry(shapes, options) {
  if (typeof shapes === "undefined") {
    return;
  }
  BufferGeometry.call(this);
  this.type = "ExtrudeBufferGeometry";
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  this.addShapeList(shapes, options);
  this.computeVertexNormals();
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.getArrays = function() {
  var positionAttribute = this.getAttribute("position");
  var verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [];
  var uvAttribute = this.getAttribute("uv");
  var uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [];
  var IndexAttribute = this.index;
  var indicesArray = IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : [];
  return {
    position: verticesArray,
    uv: uvArray,
    index: indicesArray
  };
};
ExtrudeBufferGeometry.prototype.addShapeList = function(shapes, options) {
  var this$1 = this;
  var sl = shapes.length;
  options.arrays = this.getArrays();
  for (var s = 0; s < sl; s++) {
    var shape = shapes[s];
    this$1.addShape(shape, options);
  }
  this.setIndex(options.arrays.index);
  this.addAttribute("position", new Float32BufferAttribute(options.arrays.position, 3));
  this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2));
};
ExtrudeBufferGeometry.prototype.addShape = function(shape, options) {
  var arrays = options.arrays ? options.arrays : this.getArrays();
  var verticesArray = arrays.position;
  var indicesArray = arrays.index;
  var uvArray = arrays.uv;
  var placeholder = [];
  var amount = options.amount !== void 0 ? options.amount : 100;
  var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
  var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
  var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
  var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
  var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
  var steps = options.steps !== void 0 ? options.steps : 1;
  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;
  var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
  var splineTube, binormal, normal2, position2;
  if (extrudePath) {
    extrudePts = extrudePath.getSpacedPoints(steps);
    extrudeByPath = true;
    bevelEnabled = false;
    splineTube = options.frames !== void 0 ? options.frames : extrudePath.computeFrenetFrames(steps, false);
    binormal = new Vector3();
    normal2 = new Vector3();
    position2 = new Vector3();
  }
  if (!bevelEnabled) {
    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;
  }
  var ahole, h, hl;
  var scope = this;
  var shapePoints = shape.extractPoints(curveSegments);
  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;
  var reverse = !ShapeUtils.isClockWise(vertices);
  if (reverse) {
    vertices = vertices.reverse();
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      if (ShapeUtils.isClockWise(ahole)) {
        holes[h] = ahole.reverse();
      }
    }
  }
  var faces = ShapeUtils.triangulateShape(vertices, holes);
  var contour = vertices;
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    vertices = vertices.concat(ahole);
  }
  function scalePt2(pt, vec, size) {
    if (!vec) {
      console.error("THREE.ExtrudeGeometry: vec does not exist");
    }
    return vec.clone().multiplyScalar(size).add(pt);
  }
  var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
  function getBevelVec(inPt, inPrev, inNext) {
    var v_trans_x, v_trans_y, shrink_by;
    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
    var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
    var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
    if (Math.abs(collinear0) > Number.EPSILON) {
      var v_prev_len = Math.sqrt(v_prev_lensq);
      var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
      var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
      var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
      var ptNextShift_x = inNext.x - v_next_y / v_next_len;
      var ptNextShift_y = inNext.y + v_next_x / v_next_len;
      var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
      v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
      v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
      var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
      if (v_trans_lensq <= 2) {
        return new Vector2(v_trans_x, v_trans_y);
      } else {
        shrink_by = Math.sqrt(v_trans_lensq / 2);
      }
    } else {
      var direction_eq = false;
      if (v_prev_x > Number.EPSILON) {
        if (v_next_x > Number.EPSILON) {
          direction_eq = true;
        }
      } else {
        if (v_prev_x < -Number.EPSILON) {
          if (v_next_x < -Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
            direction_eq = true;
          }
        }
      }
      if (direction_eq) {
        v_trans_x = -v_prev_y;
        v_trans_y = v_prev_x;
        shrink_by = Math.sqrt(v_prev_lensq);
      } else {
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt(v_prev_lensq / 2);
      }
    }
    return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
  }
  var contourMovements = [];
  for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
    if (j === il) {
      j = 0;
    }
    if (k === il) {
      k = 0;
    }
    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
  }
  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    oneHoleMovements = [];
    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il) {
        j = 0;
      }
      if (k === il) {
        k = 0;
      }
      oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
    }
    holesMovements.push(oneHoleMovements);
    verticesMovements = verticesMovements.concat(oneHoleMovements);
  }
  for (b = 0; b < bevelSegments; b++) {
    t = b / bevelSegments;
    z = bevelThickness * Math.cos(t * Math.PI / 2);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, -z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        v(vert.x, vert.y, -z);
      }
    }
  }
  bs = bevelSize;
  for (i = 0; i < vlen; i++) {
    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
    if (!extrudeByPath) {
      v(vert.x, vert.y, 0);
    } else {
      normal2.copy(splineTube.normals[0]).multiplyScalar(vert.x);
      binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
      position2.copy(extrudePts[0]).add(normal2).add(binormal);
      v(position2.x, position2.y, position2.z);
    }
  }
  var s;
  for (s = 1; s <= steps; s++) {
    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
      if (!extrudeByPath) {
        v(vert.x, vert.y, amount / steps * s);
      } else {
        normal2.copy(splineTube.normals[s]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
        position2.copy(extrudePts[s]).add(normal2).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
  }
  for (b = bevelSegments - 1; b >= 0; b--) {
    t = b / bevelSegments;
    z = bevelThickness * Math.cos(t * Math.PI / 2);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, amount + z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        if (!extrudeByPath) {
          v(vert.x, vert.y, amount + z);
        } else {
          v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
        }
      }
    }
  }
  buildLidFaces();
  buildSideFaces();
  function buildLidFaces() {
    var start = verticesArray.length / 3;
    if (bevelEnabled) {
      var layer = 0;
      var offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2] + offset, face[1] + offset, face[0] + offset);
      }
      layer = steps + bevelSegments * 2;
      offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + offset, face[1] + offset, face[2] + offset);
      }
    } else {
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2], face[1], face[0]);
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
      }
    }
    scope.addGroup(start, verticesArray.length / 3 - start, options.material !== void 0 ? options.material : 0);
  }
  function buildSideFaces() {
    var start = verticesArray.length / 3;
    var layeroffset = 0;
    sidewalls(contour, layeroffset);
    layeroffset += contour.length;
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      sidewalls(ahole, layeroffset);
      layeroffset += ahole.length;
    }
    scope.addGroup(start, verticesArray.length / 3 - start, options.extrudeMaterial !== void 0 ? options.extrudeMaterial : 1);
  }
  function sidewalls(contour2, layeroffset) {
    var j2, k2;
    i = contour2.length;
    while (--i >= 0) {
      j2 = i;
      k2 = i - 1;
      if (k2 < 0) {
        k2 = contour2.length - 1;
      }
      var s2 = 0, sl = steps + bevelSegments * 2;
      for (s2 = 0; s2 < sl; s2++) {
        var slen1 = vlen * s2;
        var slen2 = vlen * (s2 + 1);
        var a = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c = layeroffset + k2 + slen2, d = layeroffset + j2 + slen2;
        f4(a, b2, c, d);
      }
    }
  }
  function v(x, y, z2) {
    placeholder.push(x);
    placeholder.push(y);
    placeholder.push(z2);
  }
  function f3(a, b2, c) {
    addVertex(a);
    addVertex(b2);
    addVertex(c);
    var nextIndex = verticesArray.length / 3;
    var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
    addUV(uvs[0]);
    addUV(uvs[1]);
    addUV(uvs[2]);
  }
  function f4(a, b2, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    addVertex(a);
    addVertex(b2);
    addVertex(d);
    addVertex(b2);
    addVertex(c);
    addVertex(d);
    var nextIndex = verticesArray.length / 3;
    var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
    addUV(uvs[0]);
    addUV(uvs[1]);
    addUV(uvs[3]);
    addUV(uvs[1]);
    addUV(uvs[2]);
    addUV(uvs[3]);
  }
  function addVertex(index) {
    indicesArray.push(verticesArray.length / 3);
    verticesArray.push(placeholder[index * 3 + 0]);
    verticesArray.push(placeholder[index * 3 + 1]);
    verticesArray.push(placeholder[index * 3 + 2]);
  }
  function addUV(vector2) {
    uvArray.push(vector2.x);
    uvArray.push(vector2.y);
  }
  if (!options.arrays) {
    this.setIndex(indicesArray);
    this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2));
  }
};
ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = "TextGeometry";
  this.parameters = {
    text,
    parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  var font = parameters.font;
  if (!(font && font.isFont)) {
    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
    return new Geometry();
  }
  var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
  parameters.amount = parameters.height !== void 0 ? parameters.height : 50;
  if (parameters.bevelThickness === void 0) {
    parameters.bevelThickness = 10;
  }
  if (parameters.bevelSize === void 0) {
    parameters.bevelSize = 8;
  }
  if (parameters.bevelEnabled === void 0) {
    parameters.bevelEnabled = false;
  }
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = "TextBufferGeometry";
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "SphereGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "SphereBufferGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  radius = radius || 50;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== void 0 ? phiStart : 0;
  phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
  var thetaEnd = thetaStart + thetaLength;
  var ix, iy;
  var index = 0;
  var grid = [];
  var vertex2 = new Vector3();
  var normal2 = new Vector3();
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy <= heightSegments; iy++) {
    var verticesRow = [];
    var v = iy / heightSegments;
    for (ix = 0; ix <= widthSegments; ix++) {
      var u = ix / widthSegments;
      vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normal2.set(vertex2.x, vertex2.y, vertex2.z).normalize();
      normals.push(normal2.x, normal2.y, normal2.z);
      uvs.push(u, 1 - v);
      verticesRow.push(index++);
    }
    grid.push(verticesRow);
  }
  for (iy = 0; iy < heightSegments; iy++) {
    for (ix = 0; ix < widthSegments; ix++) {
      var a = grid[iy][ix + 1];
      var b = grid[iy][ix];
      var c = grid[iy + 1][ix];
      var d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0) {
        indices.push(a, b, d);
      }
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {
        indices.push(b, c, d);
      }
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "RingGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "RingBufferGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  innerRadius = innerRadius || 20;
  outerRadius = outerRadius || 50;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var segment;
  var radius = innerRadius;
  var radiusStep = (outerRadius - innerRadius) / phiSegments;
  var vertex2 = new Vector3();
  var uv = new Vector2();
  var j, i;
  for (j = 0; j <= phiSegments; j++) {
    for (i = 0; i <= thetaSegments; i++) {
      segment = thetaStart + i / thetaSegments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertex2.x / outerRadius + 1) / 2;
      uv.y = (vertex2.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    radius += radiusStep;
  }
  for (j = 0; j < phiSegments; j++) {
    var thetaSegmentLevel = j * (thetaSegments + 1);
    for (i = 0; i < thetaSegments; i++) {
      segment = i + thetaSegmentLevel;
      var a = segment;
      var b = segment + thetaSegments + 1;
      var c = segment + thetaSegments + 2;
      var d = segment + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = "LatheGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = "LatheBufferGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2;
  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
  var indices = [];
  var vertices = [];
  var uvs = [];
  var base;
  var inverseSegments = 1 / segments;
  var vertex2 = new Vector3();
  var uv = new Vector2();
  var i, j;
  for (i = 0; i <= segments; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var sin2 = Math.sin(phi);
    var cos2 = Math.cos(phi);
    for (j = 0; j <= points.length - 1; j++) {
      vertex2.x = points[j].x * sin2;
      vertex2.y = points[j].y;
      vertex2.z = points[j].x * cos2;
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      uv.x = i / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  }
  for (i = 0; i < segments; i++) {
    for (j = 0; j < points.length - 1; j++) {
      base = j + i * points.length;
      var a = base;
      var b = base + points.length;
      var c = base + points.length + 1;
      var d = base + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  this.computeVertexNormals();
  if (phiLength === Math.PI * 2) {
    var normals = this.attributes.normal.array;
    var n1 = new Vector3();
    var n2 = new Vector3();
    var n = new Vector3();
    base = segments * points.length * 3;
    for (i = 0, j = 0; i < points.length; i++, j += 3) {
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2];
      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2];
      n.addVectors(n1, n2).normalize();
      normals[j + 0] = normals[base + j + 0] = n.x;
      normals[j + 1] = normals[base + j + 1] = n.y;
      normals[j + 2] = normals[base + j + 2] = n.z;
    }
  }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = "ShapeGeometry";
  if (typeof curveSegments === "object") {
    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
    curveSegments = curveSegments.curveSegments;
  }
  this.parameters = {
    shapes,
    curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
function ShapeBufferGeometry(shapes, curveSegments) {
  var this$1 = this;
  BufferGeometry.call(this);
  this.type = "ShapeBufferGeometry";
  this.parameters = {
    shapes,
    curveSegments
  };
  curveSegments = curveSegments || 12;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var groupStart = 0;
  var groupCount = 0;
  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (var i = 0; i < shapes.length; i++) {
      addShape(shapes[i]);
      this$1.addGroup(groupStart, groupCount, i);
      groupStart += groupCount;
      groupCount = 0;
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function addShape(shape) {
    var i2, l, shapeHole;
    var indexOffset = vertices.length / 3;
    var points = shape.extractPoints(curveSegments);
    var shapeVertices = points.shape;
    var shapeHoles = points.holes;
    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
      for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
        shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
    }
    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
    for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
      shapeHole = shapeHoles[i2];
      shapeVertices = shapeVertices.concat(shapeHole);
    }
    for (i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
      var vertex2 = shapeVertices[i2];
      vertices.push(vertex2.x, vertex2.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex2.x, vertex2.y);
    }
    for (i2 = 0, l = faces.length; i2 < l; i2++) {
      var face = faces[i2];
      var a = face[0] + indexOffset;
      var b = face[1] + indexOffset;
      var c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
function EdgesGeometry(geometry, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = "EdgesGeometry";
  this.parameters = {
    thresholdAngle
  };
  thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
  var vertices = [];
  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
  var edge = [0, 0], edges = {}, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var geometry2;
  if (geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
  } else {
    geometry2 = geometry.clone();
  }
  geometry2.mergeVertices();
  geometry2.computeFaceNormals();
  var sourceVertices = geometry2.vertices;
  var faces = geometry2.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + "," + edge[1];
      if (edges[key] === void 0) {
        edges[key] = {index1: edge[0], index2: edge[1], face1: i, face2: void 0};
      } else {
        edges[key].face2 = i;
      }
    }
  }
  for (key in edges) {
    var e = edges[key];
    if (e.face2 === void 0 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
      var vertex2 = sourceVertices[e.index1];
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      vertex2 = sourceVertices[e.index2];
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CylinderBufferGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== void 0 ? radiusTop : 20;
  radiusBottom = radiusBottom !== void 0 ? radiusBottom : 20;
  height = height !== void 0 ? height : 100;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== void 0 ? openEnded : false;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : 2 * Math.PI;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var index = 0;
  var indexArray = [];
  var halfHeight = height / 2;
  var groupStart = 0;
  generateTorso();
  if (openEnded === false) {
    if (radiusTop > 0) {
      generateCap(true);
    }
    if (radiusBottom > 0) {
      generateCap(false);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateTorso() {
    var x, y;
    var normal2 = new Vector3();
    var vertex2 = new Vector3();
    var groupCount = 0;
    var slope = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = -v * height + halfHeight;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal2.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal2.x, normal2.y, normal2.z);
        uvs.push(u, 1 - v);
        indexRow.push(index++);
      }
      indexArray.push(indexRow);
    }
    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        var a = indexArray[y][x];
        var b = indexArray[y + 1][x];
        var c = indexArray[y + 1][x + 1];
        var d = indexArray[y][x + 1];
        indices.push(a, b, d);
        indices.push(b, c, d);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, 0);
    groupStart += groupCount;
  }
  function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex2 = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1;
    centerIndexStart = index;
    for (x = 1; x <= radialSegments; x++) {
      vertices.push(0, halfHeight * sign, 0);
      normals.push(0, sign, 0);
      uvs.push(0.5, 0.5);
      index++;
    }
    centerIndexEnd = index;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta);
      vertex2.x = radius * sinTheta;
      vertex2.y = halfHeight * sign;
      vertex2.z = radius * cosTheta;
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, sign, 0);
      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y);
      index++;
    }
    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;
      if (top === true) {
        indices.push(i, i + 1, c);
      } else {
        indices.push(i + 1, i, c);
      }
      groupCount += 3;
    }
    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
    groupStart += groupCount;
  }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeBufferGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CircleGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CircleBufferGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  radius = radius || 50;
  segments = segments !== void 0 ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i, s;
  var vertex2 = new Vector3();
  var uv = new Vector2();
  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);
  for (s = 0, i = 3; s <= segments; s++, i += 3) {
    var segment = thetaStart + s / segments * thetaLength;
    vertex2.x = radius * Math.cos(segment);
    vertex2.y = radius * Math.sin(segment);
    vertices.push(vertex2.x, vertex2.y, vertex2.z);
    normals.push(0, 0, 1);
    uv.x = (vertices[i] / radius + 1) / 2;
    uv.y = (vertices[i + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  }
  for (i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = Object.freeze({
  WireframeGeometry,
  ParametricGeometry,
  ParametricBufferGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry,
  TubeGeometry,
  TubeBufferGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry,
  TorusGeometry,
  TorusBufferGeometry,
  TextGeometry,
  TextBufferGeometry,
  SphereGeometry,
  SphereBufferGeometry,
  RingGeometry,
  RingBufferGeometry,
  PlaneGeometry,
  PlaneBufferGeometry,
  LatheGeometry,
  LatheBufferGeometry,
  ShapeGeometry,
  ShapeBufferGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry,
  EdgesGeometry,
  ConeGeometry,
  ConeBufferGeometry,
  CylinderGeometry,
  CylinderBufferGeometry,
  CircleGeometry,
  CircleBufferGeometry,
  BoxGeometry,
  BoxBufferGeometry
});
function ShadowMaterial(parameters) {
  ShaderMaterial.call(this, {
    uniforms: UniformsUtils.merge([
      UniformsLib.lights,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk["shadow_vert"],
    fragmentShader: ShaderChunk["shadow_frag"]
  });
  this.lights = true;
  this.transparent = true;
  Object.defineProperties(this, {
    opacity: {
      enumerable: true,
      get: function() {
        return this.uniforms.opacity.value;
      },
      set: function(value2) {
        this.uniforms.opacity.value = value2;
      }
    }
  });
  this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {PHYSICAL: ""};
  this.type = "MeshPhysicalMaterial";
  this.reflectivity = 0.5;
  this.clearCoat = 0;
  this.clearCoatRoughness = 0;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {PHYSICAL: ""};
  this.reflectivity = source.reflectivity;
  this.clearCoat = source.clearCoat;
  this.clearCoatRoughness = source.clearCoatRoughness;
  return this;
};
function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = "MeshPhongMaterial";
  this.color = new Color(16777215);
  this.specular = new Color(1118481);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshToonMaterial(parameters) {
  MeshPhongMaterial.call(this);
  this.defines = {TOON: ""};
  this.type = "MeshToonMaterial";
  this.gradientMap = null;
  this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
  MeshPhongMaterial.prototype.copy.call(this, source);
  this.gradientMap = source.gradientMap;
  return this;
};
function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = "MeshNormalMaterial";
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = "MeshLambertMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function LineDashedMaterial(parameters) {
  Material.call(this);
  this.type = "LineDashedMaterial";
  this.color = new Color(16777215);
  this.linewidth = 1;
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.lights = false;
  this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(Material.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};
var Materials = Object.freeze({
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshBasicMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) {
      return;
    }
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) {
      return;
    }
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
}
var DefaultLoadingManager = new LoadingManager();
function FileLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FileLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var this$1 = this;
    if (url === void 0) {
      url = "";
    }
    if (this.path !== void 0) {
      url = this.path + url;
    }
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) {
          onLoad(cached);
        }
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex);
    if (dataUriRegexResult) {
      var mimeType = dataUriRegexResult[1];
      var isBase64 = !!dataUriRegexResult[2];
      var data = dataUriRegexResult[3];
      data = window.decodeURIComponent(data);
      if (isBase64) {
        data = window.atob(data);
      }
      try {
        var response;
        var responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            response = new ArrayBuffer(data.length);
            var view = new Uint8Array(response);
            for (var i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }
            if (responseType === "blob") {
              response = new Blob([response], {type: mimeType});
            }
            break;
          case "document":
            var parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        window.setTimeout(function() {
          if (onLoad) {
            onLoad(response);
          }
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        window.setTimeout(function() {
          if (onError) {
            onError(error);
          }
          scope.manager.itemEnd(url);
          scope.manager.itemError(url);
        }, 0);
      }
    } else {
      var request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        var response2 = event.target.response;
        Cache.add(url, response2);
        if (this.status === 200) {
          if (onLoad) {
            onLoad(response2);
          }
          scope.manager.itemEnd(url);
        } else if (this.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
          if (onLoad) {
            onLoad(response2);
          }
          scope.manager.itemEnd(url);
        } else {
          if (onError) {
            onError(event);
          }
          scope.manager.itemEnd(url);
          scope.manager.itemError(url);
        }
      }, false);
      if (onProgress !== void 0) {
        request.addEventListener("progress", function(event) {
          onProgress(event);
        }, false);
      }
      request.addEventListener("error", function(event) {
        if (onError) {
          onError(event);
        }
        scope.manager.itemEnd(url);
        scope.manager.itemError(url);
      }, false);
      if (this.responseType !== void 0) {
        request.responseType = this.responseType;
      }
      if (this.withCredentials !== void 0) {
        request.withCredentials = this.withCredentials;
      }
      if (request.overrideMimeType) {
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      }
      for (var header in this$1.requestHeader) {
        request.setRequestHeader(header, this$1.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setPath: function(value2) {
    this.path = value2;
    return this;
  },
  setResponseType: function(value2) {
    this.responseType = value2;
    return this;
  },
  setWithCredentials: function(value2) {
    this.withCredentials = value2;
    return this;
  },
  setMimeType: function(value2) {
    this.mimeType = value2;
    return this;
  },
  setRequestHeader: function(value2) {
    this.requestHeader = value2;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(CompressedTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var images = [];
    var texture = new CompressedTexture();
    texture.image = images;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    function loadTexture(i2) {
      loader.load(url[i2], function(buffer) {
        var texDatas = scope._parser(buffer, true);
        images[i2] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) {
            onLoad(texture);
          }
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      var loaded = 0;
      for (var i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer) {
        var texDatas = scope._parser(buffer, true);
        if (texDatas.isCubemap) {
          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (var f = 0; f < faces; f++) {
            images[f] = {mipmaps: []};
            for (var i2 = 0; i2 < texDatas.mipmapCount; i2++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) {
          onLoad(texture);
        }
      }, onProgress, onError);
    }
    return texture;
  },
  setPath: function(value2) {
    this.path = value2;
    return this;
  }
});
function DataTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(DataTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var texture = new DataTexture();
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.load(url, function(buffer) {
      var texData = scope._parser(buffer);
      if (!texData) {
        return;
      }
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearMipMapLinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad) {
        onLoad(texture, texData);
      }
    }, onProgress, onError);
    return texture;
  }
});
function ImageLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(ImageLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0) {
      url = "";
    }
    if (this.path !== void 0) {
      url = this.path + url;
    }
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) {
          onLoad(cached);
        }
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    image.addEventListener("load", function() {
      Cache.add(url, this);
      if (onLoad) {
        onLoad(this);
      }
      scope.manager.itemEnd(url);
    }, false);
    image.addEventListener("error", function(event) {
      if (onError) {
        onError(event);
      }
      scope.manager.itemEnd(url);
      scope.manager.itemError(url);
    }, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) {
        image.crossOrigin = this.crossOrigin;
      }
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  },
  setCrossOrigin: function(value2) {
    this.crossOrigin = value2;
    return this;
  },
  setPath: function(value2) {
    this.path = value2;
    return this;
  }
});
function CubeTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(CubeTextureLoader.prototype, {
  load: function(urls, onLoad, onProgress, onError) {
    var texture = new CubeTexture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) {
            onLoad(texture);
          }
        }
      }, void 0, onError);
    }
    for (var i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  },
  setCrossOrigin: function(value2) {
    this.crossOrigin = value2;
    return this;
  },
  setPath: function(value2) {
    this.path = value2;
    return this;
  }
});
function TextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(TextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var texture = new Texture();
    texture.image = loader.load(url, function() {
      var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function(value2) {
    this.crossOrigin = value2;
    return this;
  },
  setPath: function(value2) {
    this.path = value2;
    return this;
  }
});
function Light(color, intensity) {
  Object3D.call(this);
  this.type = "Light";
  this.color = new Color(color);
  this.intensity = intensity !== void 0 ? intensity : 1;
  this.receiveShadow = void 0;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) {
      data.object.groundColor = this.groundColor.getHex();
    }
    if (this.distance !== void 0) {
      data.object.distance = this.distance;
    }
    if (this.angle !== void 0) {
      data.object.angle = this.angle;
    }
    if (this.decay !== void 0) {
      data.object.decay = this.decay;
    }
    if (this.penumbra !== void 0) {
      data.object.penumbra = this.penumbra;
    }
    if (this.shadow !== void 0) {
      data.object.shadow = this.shadow.toJSON();
    }
    return data;
  }
});
function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = "HemisphereLight";
  this.castShadow = void 0;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.matrix = new Matrix4();
}
Object.assign(LightShadow.prototype, {
  copy: function(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var object = {};
    if (this.bias !== 0) {
      object.bias = this.bias;
    }
    if (this.radius !== 1) {
      object.radius = this.radius;
    }
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) {
      object.mapSize = this.mapSize.toArray();
    }
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  update: function(light) {
    var camera = this.camera;
    var fov = _Math.RAD2DEG * 2 * light.angle;
    var aspect = this.mapSize.width / this.mapSize.height;
    var far = light.distance || camera.far;
    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
  }
});
function SpotLight(color, intensity, distance3, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = "SpotLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(power) {
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance3 !== void 0 ? distance3 : 0;
  this.angle = angle !== void 0 ? angle : Math.PI / 3;
  this.penumbra = penumbra !== void 0 ? penumbra : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function PointLight(color, intensity, distance3, decay) {
  Light.call(this, color, intensity);
  this.type = "PointLight";
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(power) {
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance3 !== void 0 ? distance3 : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow
});
function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = "DirectionalLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = "AmbientLight";
  this.castShadow = void 0;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = "RectAreaLight";
  this.position.set(0, 1, 0);
  this.updateMatrix();
  this.width = width !== void 0 ? width : 10;
  this.height = height !== void 0 ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function(meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
var AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type2, forceClone) {
    if (!array || !forceClone && array.constructor === type2) {
      return array;
    }
    if (typeof type2.BYTES_PER_ELEMENT === "number") {
      return new type2(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j) {
      return times[i2] - times[j];
    }
    var n = times.length;
    var result = new Array(n);
    for (var i = 0; i !== n; ++i) {
      result[i] = i;
    }
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);
    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      var srcOffset = order[i] * stride;
      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    var i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0) {
      return;
    }
    var value2 = key[valuePropertyName];
    if (value2 === void 0) {
      return;
    }
    if (Array.isArray(value2)) {
      do {
        value2 = key[valuePropertyName];
        if (value2 !== void 0) {
          times.push(key.time);
          values.push.apply(values, value2);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value2.toArray !== void 0) {
      do {
        value2 = key[valuePropertyName];
        if (value2 !== void 0) {
          times.push(key.time);
          value2.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value2 = key[valuePropertyName];
        if (value2 !== void 0) {
          times.push(key.time);
          values.push(value2);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t) {
    var this$1 = this;
    var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        var right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (var giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0) {
                    break forward_scan;
                  }
                  i1 = pp.length;
                  this$1._cachedIndex = i1;
                  return this$1.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt) {
                  break;
                }
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            var t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (var giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this$1._cachedIndex = 0;
                return this$1.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt) {
                break;
              }
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          var mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  },
  interpolate_: function(i1, t0, t, t1) {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function(i1, t0, t1) {
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    var sP = -wP * ppp + 2 * wP * pp - wP * p;
    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    var sN = wN * ppp - wN * pp;
    for (var i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    return this.copySampleValue_(i1 - 1);
  }
});
var KeyframeTrackPrototype;
KeyframeTrackPrototype = {
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function(interpolation) {
    var factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrackPrototype:", message);
      return;
    }
    this.createInterpolant = factoryMethod;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  shift: function(timeOffset) {
    if (timeOffset !== 0) {
      var times = this.times;
      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  },
  scale: function(timeScale) {
    if (timeScale !== 1) {
      var times = this.times;
      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  },
  trim: function(startTime, endTime) {
    var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1), from = to - 1;
      }
      var stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  },
  validate: function() {
    var this$1 = this;
    var valid = true;
    var valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this);
      valid = false;
    }
    var times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrackPrototype: Track is empty.", this);
      valid = false;
    }
    var prevTime = null;
    for (var i = 0; i !== nKeys; i++) {
      var currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this$1, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this$1, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (var i = 0, n = values.length; i !== n; ++i) {
          var value2 = values[i];
          if (isNaN(value2)) {
            console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this$1, i, value2);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  },
  optimize: function() {
    var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
    for (var i = 1; i < lastIndex; ++i) {
      var keep = false;
      var time = times[i];
      var timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (var j = 0; j !== stride; ++j) {
            var value2 = values[offset + j];
            if (value2 !== values[offsetP + j] || value2 !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          var readOffset = i * stride, writeOffset = writeIndex * stride;
          for (var j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    }
    return this;
  }
};
function KeyframeTrackConstructor(name, times, values, interpolation) {
  if (name === void 0) {
    throw new Error("track name is undefined");
  }
  if (times === void 0 || times.length === 0) {
    throw new Error("no keyframes in track named " + name);
  }
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
  this.validate();
  this.optimize();
}
function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: "vector"
});
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
    for (var end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});
function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: "quaternion",
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: void 0
});
function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: "number"
});
function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrackConstructor.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: "color"
});
function KeyframeTrack(name, times, values, interpolation) {
  KeyframeTrackConstructor.apply(this, arguments);
}
KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;
Object.assign(KeyframeTrack, {
  parse: function(json) {
    if (json.type === void 0) {
      throw new Error("track type undefined, can not parse");
    }
    var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      var times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  },
  toJSON: function(track) {
    var trackType = track.constructor;
    var json;
    if (trackType.toJSON !== void 0) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      var interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  },
  _getTrackTypeForValueTypeName: function(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("Unsupported typeName: " + typeName);
  }
});
function AnimationClip(name, duration, tracks) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== void 0 ? duration : -1;
  this.uuid = _Math.generateUUID();
  if (this.duration < 0) {
    this.resetDuration();
  }
  this.optimize();
}
Object.assign(AnimationClip, {
  parse: function(json) {
    var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
    }
    return new AnimationClip(json.name, json.duration, tracks);
  },
  toJSON: function(clip) {
    var tracks = [], clipTracks = clip.tracks;
    var json = {
      name: clip.name,
      duration: clip.duration,
      tracks
    };
    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  },
  CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];
    for (var i = 0; i < numMorphTargets; i++) {
      var times = [];
      var values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      var order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
    }
    return new AnimationClip(name, -1, tracks);
  },
  findByName: function(objectOrClipArray, name) {
    var clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      var o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (var i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
    var animationToMorphTargets = {};
    var pattern = /^([\w-]*?)([\d]+)$/;
    for (var i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = morphTargets[i];
      var parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    var clips = [];
    for (var name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  },
  parseAnimation: function(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
      if (animationKeys2.length !== 0) {
        var times2 = [];
        var values2 = [];
        AnimationUtils.flattenJSON(animationKeys2, times2, values2, propertyName);
        if (times2.length !== 0) {
          destTracks.push(new trackType(trackName, times2, values2));
        }
      }
    };
    var tracks = [];
    var clipName = animation.name || "default";
    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];
    for (var h = 0; h < hierarchyTracks.length; h++) {
      var animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) {
        continue;
      }
      if (animationKeys[0].morphTargets) {
        var morphTargetNames = {};
        for (var k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (var m2 = 0; m2 < animationKeys[k].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k].morphTargets[m2]] = -1;
            }
          }
        }
        for (var morphTargetName in morphTargetNames) {
          var times = [];
          var values = [];
          for (var m2 = 0; m2 !== animationKeys[k].morphTargets.length; ++m2) {
            var animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        var boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    var clip = new AnimationClip(clipName, duration, tracks);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function() {
    var this$1 = this;
    var tracks = this.tracks, duration = 0;
    for (var i = 0, n = tracks.length; i !== n; ++i) {
      var track = this$1.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
  },
  trim: function() {
    var this$1 = this;
    for (var i = 0; i < this.tracks.length; i++) {
      this$1.tracks[i].trim(0, this$1.duration);
    }
    return this;
  },
  optimize: function() {
    var this$1 = this;
    for (var i = 0; i < this.tracks.length; i++) {
      this$1.tracks[i].optimize();
    }
    return this;
  }
});
function MaterialLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.textures = {};
}
Object.assign(MaterialLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.load(url, function(text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  setTextures: function(value2) {
    this.textures = value2;
  },
  parse: function(json) {
    var textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    var material = new Materials[json.type]();
    if (json.uuid !== void 0) {
      material.uuid = json.uuid;
    }
    if (json.name !== void 0) {
      material.name = json.name;
    }
    if (json.color !== void 0) {
      material.color.setHex(json.color);
    }
    if (json.roughness !== void 0) {
      material.roughness = json.roughness;
    }
    if (json.metalness !== void 0) {
      material.metalness = json.metalness;
    }
    if (json.emissive !== void 0) {
      material.emissive.setHex(json.emissive);
    }
    if (json.specular !== void 0) {
      material.specular.setHex(json.specular);
    }
    if (json.shininess !== void 0) {
      material.shininess = json.shininess;
    }
    if (json.clearCoat !== void 0) {
      material.clearCoat = json.clearCoat;
    }
    if (json.clearCoatRoughness !== void 0) {
      material.clearCoatRoughness = json.clearCoatRoughness;
    }
    if (json.uniforms !== void 0) {
      material.uniforms = json.uniforms;
    }
    if (json.vertexShader !== void 0) {
      material.vertexShader = json.vertexShader;
    }
    if (json.fragmentShader !== void 0) {
      material.fragmentShader = json.fragmentShader;
    }
    if (json.vertexColors !== void 0) {
      material.vertexColors = json.vertexColors;
    }
    if (json.fog !== void 0) {
      material.fog = json.fog;
    }
    if (json.shading !== void 0) {
      material.shading = json.shading;
    }
    if (json.blending !== void 0) {
      material.blending = json.blending;
    }
    if (json.side !== void 0) {
      material.side = json.side;
    }
    if (json.opacity !== void 0) {
      material.opacity = json.opacity;
    }
    if (json.transparent !== void 0) {
      material.transparent = json.transparent;
    }
    if (json.alphaTest !== void 0) {
      material.alphaTest = json.alphaTest;
    }
    if (json.depthTest !== void 0) {
      material.depthTest = json.depthTest;
    }
    if (json.depthWrite !== void 0) {
      material.depthWrite = json.depthWrite;
    }
    if (json.colorWrite !== void 0) {
      material.colorWrite = json.colorWrite;
    }
    if (json.wireframe !== void 0) {
      material.wireframe = json.wireframe;
    }
    if (json.wireframeLinewidth !== void 0) {
      material.wireframeLinewidth = json.wireframeLinewidth;
    }
    if (json.wireframeLinecap !== void 0) {
      material.wireframeLinecap = json.wireframeLinecap;
    }
    if (json.wireframeLinejoin !== void 0) {
      material.wireframeLinejoin = json.wireframeLinejoin;
    }
    if (json.skinning !== void 0) {
      material.skinning = json.skinning;
    }
    if (json.morphTargets !== void 0) {
      material.morphTargets = json.morphTargets;
    }
    if (json.size !== void 0) {
      material.size = json.size;
    }
    if (json.sizeAttenuation !== void 0) {
      material.sizeAttenuation = json.sizeAttenuation;
    }
    if (json.map !== void 0) {
      material.map = getTexture(json.map);
    }
    if (json.alphaMap !== void 0) {
      material.alphaMap = getTexture(json.alphaMap);
      material.transparent = true;
    }
    if (json.bumpMap !== void 0) {
      material.bumpMap = getTexture(json.bumpMap);
    }
    if (json.bumpScale !== void 0) {
      material.bumpScale = json.bumpScale;
    }
    if (json.normalMap !== void 0) {
      material.normalMap = getTexture(json.normalMap);
    }
    if (json.normalScale !== void 0) {
      var normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0) {
      material.displacementMap = getTexture(json.displacementMap);
    }
    if (json.displacementScale !== void 0) {
      material.displacementScale = json.displacementScale;
    }
    if (json.displacementBias !== void 0) {
      material.displacementBias = json.displacementBias;
    }
    if (json.roughnessMap !== void 0) {
      material.roughnessMap = getTexture(json.roughnessMap);
    }
    if (json.metalnessMap !== void 0) {
      material.metalnessMap = getTexture(json.metalnessMap);
    }
    if (json.emissiveMap !== void 0) {
      material.emissiveMap = getTexture(json.emissiveMap);
    }
    if (json.emissiveIntensity !== void 0) {
      material.emissiveIntensity = json.emissiveIntensity;
    }
    if (json.specularMap !== void 0) {
      material.specularMap = getTexture(json.specularMap);
    }
    if (json.envMap !== void 0) {
      material.envMap = getTexture(json.envMap);
    }
    if (json.reflectivity !== void 0) {
      material.reflectivity = json.reflectivity;
    }
    if (json.lightMap !== void 0) {
      material.lightMap = getTexture(json.lightMap);
    }
    if (json.lightMapIntensity !== void 0) {
      material.lightMapIntensity = json.lightMapIntensity;
    }
    if (json.aoMap !== void 0) {
      material.aoMap = getTexture(json.aoMap);
    }
    if (json.aoMapIntensity !== void 0) {
      material.aoMapIntensity = json.aoMapIntensity;
    }
    if (json.gradientMap !== void 0) {
      material.gradientMap = getTexture(json.gradientMap);
    }
    return material;
  }
});
function BufferGeometryLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(BufferGeometryLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.load(url, function(text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function(json) {
    var geometry = new BufferGeometry();
    var index = json.data.index;
    if (index !== void 0) {
      var typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    var attributes = json.data.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
    }
    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (var i = 0, n = groups.length; i !== n; ++i) {
        var group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    var boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      var center2 = new Vector3();
      if (boundingSphere.center !== void 0) {
        center2.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center2, boundingSphere.radius);
    }
    return geometry;
  }
});
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Loader() {
  this.onLoadStart = function() {
  };
  this.onLoadProgress = function() {
  };
  this.onLoadComplete = function() {
  };
}
Loader.Handlers = {
  handlers: [],
  add: function(regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function(file) {
    var handlers = this.handlers;
    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  }
};
Object.assign(Loader.prototype, {
  crossOrigin: void 0,
  extractUrlBase: function(url) {
    var parts = url.split("/");
    if (parts.length === 1) {
      return "./";
    }
    parts.pop();
    return parts.join("/") + "/";
  },
  initMaterials: function(materials, texturePath, crossOrigin) {
    var this$1 = this;
    var array = [];
    for (var i = 0; i < materials.length; ++i) {
      array[i] = this$1.createMaterial(materials[i], texturePath, crossOrigin);
    }
    return array;
  },
  createMaterial: function() {
    var BlendingMode = {
      NoBlending,
      NormalBlending,
      AdditiveBlending,
      SubtractiveBlending,
      MultiplyBlending,
      CustomBlending
    };
    var color = new Color();
    var textureLoader = new TextureLoader();
    var materialLoader = new MaterialLoader();
    return function createMaterial(m2, texturePath, crossOrigin) {
      var textures = {};
      function loadTexture(path, repeat, offset, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = Loader.Handlers.get(fullPath);
        var texture;
        if (loader !== null) {
          texture = loader.load(fullPath);
        } else {
          textureLoader.setCrossOrigin(crossOrigin);
          texture = textureLoader.load(fullPath);
        }
        if (repeat !== void 0) {
          texture.repeat.fromArray(repeat);
          if (repeat[0] !== 1) {
            texture.wrapS = RepeatWrapping;
          }
          if (repeat[1] !== 1) {
            texture.wrapT = RepeatWrapping;
          }
        }
        if (offset !== void 0) {
          texture.offset.fromArray(offset);
        }
        if (wrap !== void 0) {
          if (wrap[0] === "repeat") {
            texture.wrapS = RepeatWrapping;
          }
          if (wrap[0] === "mirror") {
            texture.wrapS = MirroredRepeatWrapping;
          }
          if (wrap[1] === "repeat") {
            texture.wrapT = RepeatWrapping;
          }
          if (wrap[1] === "mirror") {
            texture.wrapT = MirroredRepeatWrapping;
          }
        }
        if (anisotropy !== void 0) {
          texture.anisotropy = anisotropy;
        }
        var uuid2 = _Math.generateUUID();
        textures[uuid2] = texture;
        return uuid2;
      }
      var json = {
        uuid: _Math.generateUUID(),
        type: "MeshLambertMaterial"
      };
      for (var name in m2) {
        var value2 = m2[name];
        switch (name) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            json.name = value2;
            break;
          case "blending":
            json.blending = BlendingMode[value2];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
            break;
          case "colorDiffuse":
            json.color = color.fromArray(value2).getHex();
            break;
          case "colorSpecular":
            json.specular = color.fromArray(value2).getHex();
            break;
          case "colorEmissive":
            json.emissive = color.fromArray(value2).getHex();
            break;
          case "specularCoef":
            json.shininess = value2;
            break;
          case "shading":
            if (value2.toLowerCase() === "basic") {
              json.type = "MeshBasicMaterial";
            }
            if (value2.toLowerCase() === "phong") {
              json.type = "MeshPhongMaterial";
            }
            if (value2.toLowerCase() === "standard") {
              json.type = "MeshStandardMaterial";
            }
            break;
          case "mapDiffuse":
            json.map = loadTexture(value2, m2.mapDiffuseRepeat, m2.mapDiffuseOffset, m2.mapDiffuseWrap, m2.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            json.emissiveMap = loadTexture(value2, m2.mapEmissiveRepeat, m2.mapEmissiveOffset, m2.mapEmissiveWrap, m2.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            json.lightMap = loadTexture(value2, m2.mapLightRepeat, m2.mapLightOffset, m2.mapLightWrap, m2.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            json.aoMap = loadTexture(value2, m2.mapAORepeat, m2.mapAOOffset, m2.mapAOWrap, m2.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            json.bumpMap = loadTexture(value2, m2.mapBumpRepeat, m2.mapBumpOffset, m2.mapBumpWrap, m2.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            json.bumpScale = value2;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            json.normalMap = loadTexture(value2, m2.mapNormalRepeat, m2.mapNormalOffset, m2.mapNormalWrap, m2.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            json.normalScale = [value2, value2];
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            json.specularMap = loadTexture(value2, m2.mapSpecularRepeat, m2.mapSpecularOffset, m2.mapSpecularWrap, m2.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            json.metalnessMap = loadTexture(value2, m2.mapMetalnessRepeat, m2.mapMetalnessOffset, m2.mapMetalnessWrap, m2.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            json.roughnessMap = loadTexture(value2, m2.mapRoughnessRepeat, m2.mapRoughnessOffset, m2.mapRoughnessWrap, m2.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            json.alphaMap = loadTexture(value2, m2.mapAlphaRepeat, m2.mapAlphaOffset, m2.mapAlphaWrap, m2.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            json.side = BackSide;
            break;
          case "doubleSided":
            json.side = DoubleSide;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
            json.opacity = value2;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            json[name] = value2;
            break;
          case "vertexColors":
            if (value2 === true) {
              json.vertexColors = VertexColors;
            }
            if (value2 === "face") {
              json.vertexColors = FaceColors;
            }
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", name, value2);
            break;
        }
      }
      if (json.type === "MeshBasicMaterial") {
        delete json.emissive;
      }
      if (json.type !== "MeshPhongMaterial") {
        delete json.specular;
      }
      if (json.opacity < 1) {
        json.transparent = true;
      }
      materialLoader.setTextures(textures);
      return materialLoader.parse(json);
    };
  }()
});
function JSONLoader(manager) {
  if (typeof manager === "boolean") {
    console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor.");
    manager = void 0;
  }
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.withCredentials = false;
}
Object.assign(JSONLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var texturePath = this.texturePath && typeof this.texturePath === "string" ? this.texturePath : Loader.prototype.extractUrlBase(url);
    var loader = new FileLoader(this.manager);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      var json = JSON.parse(text);
      var metadata = json.metadata;
      if (metadata !== void 0) {
        var type2 = metadata.type;
        if (type2 !== void 0) {
          if (type2.toLowerCase() === "object") {
            console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
            return;
          }
          if (type2.toLowerCase() === "scene") {
            console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.");
            return;
          }
        }
      }
      var object = scope.parse(json, texturePath);
      onLoad(object.geometry, object.materials);
    }, onProgress, onError);
  },
  setTexturePath: function(value2) {
    this.texturePath = value2;
  },
  parse: function() {
    function parseModel(json, geometry) {
      function isBitSet(value2, position) {
        return value2 & 1 << position;
      }
      var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type2, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex2, face, faceA, faceB, hex, normal2, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, scale2 = json.scale, nUvLayers = 0;
      if (json.uvs !== void 0) {
        for (i = 0; i < json.uvs.length; i++) {
          if (json.uvs[i].length) {
            nUvLayers++;
          }
        }
        for (i = 0; i < nUvLayers; i++) {
          geometry.faceVertexUvs[i] = [];
        }
      }
      offset = 0;
      zLength = vertices.length;
      while (offset < zLength) {
        vertex2 = new Vector3();
        vertex2.x = vertices[offset++] * scale2;
        vertex2.y = vertices[offset++] * scale2;
        vertex2.z = vertices[offset++] * scale2;
        geometry.vertices.push(vertex2);
      }
      offset = 0;
      zLength = faces.length;
      while (offset < zLength) {
        type2 = faces[offset++];
        isQuad = isBitSet(type2, 0);
        hasMaterial = isBitSet(type2, 1);
        hasFaceVertexUv = isBitSet(type2, 3);
        hasFaceNormal = isBitSet(type2, 4);
        hasFaceVertexNormal = isBitSet(type2, 5);
        hasFaceColor = isBitSet(type2, 6);
        hasFaceVertexColor = isBitSet(type2, 7);
        if (isQuad) {
          faceA = new Face3();
          faceA.a = faces[offset];
          faceA.b = faces[offset + 1];
          faceA.c = faces[offset + 3];
          faceB = new Face3();
          faceB.a = faces[offset + 1];
          faceB.b = faces[offset + 2];
          faceB.c = faces[offset + 3];
          offset += 4;
          if (hasMaterial) {
            materialIndex = faces[offset++];
            faceA.materialIndex = materialIndex;
            faceB.materialIndex = materialIndex;
          }
          fi = geometry.faces.length;
          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];
              geometry.faceVertexUvs[i][fi + 1] = [];
              for (j = 0; j < 4; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new Vector2(u, v);
                if (j !== 2) {
                  geometry.faceVertexUvs[i][fi].push(uv);
                }
                if (j !== 0) {
                  geometry.faceVertexUvs[i][fi + 1].push(uv);
                }
              }
            }
          }
          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            faceB.normal.copy(faceA.normal);
          }
          if (hasFaceVertexNormal) {
            for (i = 0; i < 4; i++) {
              normalIndex = faces[offset++] * 3;
              normal2 = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              if (i !== 2) {
                faceA.vertexNormals.push(normal2);
              }
              if (i !== 0) {
                faceB.vertexNormals.push(normal2);
              }
            }
          }
          if (hasFaceColor) {
            colorIndex = faces[offset++];
            hex = colors[colorIndex];
            faceA.color.setHex(hex);
            faceB.color.setHex(hex);
          }
          if (hasFaceVertexColor) {
            for (i = 0; i < 4; i++) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              if (i !== 2) {
                faceA.vertexColors.push(new Color(hex));
              }
              if (i !== 0) {
                faceB.vertexColors.push(new Color(hex));
              }
            }
          }
          geometry.faces.push(faceA);
          geometry.faces.push(faceB);
        } else {
          face = new Face3();
          face.a = faces[offset++];
          face.b = faces[offset++];
          face.c = faces[offset++];
          if (hasMaterial) {
            materialIndex = faces[offset++];
            face.materialIndex = materialIndex;
          }
          fi = geometry.faces.length;
          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];
              for (j = 0; j < 3; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new Vector2(u, v);
                geometry.faceVertexUvs[i][fi].push(uv);
              }
            }
          }
          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
          }
          if (hasFaceVertexNormal) {
            for (i = 0; i < 3; i++) {
              normalIndex = faces[offset++] * 3;
              normal2 = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              face.vertexNormals.push(normal2);
            }
          }
          if (hasFaceColor) {
            colorIndex = faces[offset++];
            face.color.setHex(colors[colorIndex]);
          }
          if (hasFaceVertexColor) {
            for (i = 0; i < 3; i++) {
              colorIndex = faces[offset++];
              face.vertexColors.push(new Color(colors[colorIndex]));
            }
          }
          geometry.faces.push(face);
        }
      }
    }
    function parseSkin(json, geometry) {
      var influencesPerVertex = json.influencesPerVertex !== void 0 ? json.influencesPerVertex : 2;
      if (json.skinWeights) {
        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
          var x = json.skinWeights[i];
          var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
          var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
          var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
          geometry.skinWeights.push(new Vector4(x, y, z, w));
        }
      }
      if (json.skinIndices) {
        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
          var a = json.skinIndices[i];
          var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
          var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
          var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
          geometry.skinIndices.push(new Vector4(a, b, c, d));
        }
      }
      geometry.bones = json.bones;
      if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
        console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
      }
    }
    function parseMorphing(json, geometry) {
      var scale2 = json.scale;
      if (json.morphTargets !== void 0) {
        for (var i = 0, l = json.morphTargets.length; i < l; i++) {
          geometry.morphTargets[i] = {};
          geometry.morphTargets[i].name = json.morphTargets[i].name;
          geometry.morphTargets[i].vertices = [];
          var dstVertices = geometry.morphTargets[i].vertices;
          var srcVertices = json.morphTargets[i].vertices;
          for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
            var vertex2 = new Vector3();
            vertex2.x = srcVertices[v] * scale2;
            vertex2.y = srcVertices[v + 1] * scale2;
            vertex2.z = srcVertices[v + 2] * scale2;
            dstVertices.push(vertex2);
          }
        }
      }
      if (json.morphColors !== void 0 && json.morphColors.length > 0) {
        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        var faces = geometry.faces;
        var morphColors = json.morphColors[0].colors;
        for (var i = 0, l = faces.length; i < l; i++) {
          faces[i].color.fromArray(morphColors, i * 3);
        }
      }
    }
    function parseAnimations(json, geometry) {
      var outputAnimations = [];
      var animations = [];
      if (json.animation !== void 0) {
        animations.push(json.animation);
      }
      if (json.animations !== void 0) {
        if (json.animations.length) {
          animations = animations.concat(json.animations);
        } else {
          animations.push(json.animations);
        }
      }
      for (var i = 0; i < animations.length; i++) {
        var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
        if (clip) {
          outputAnimations.push(clip);
        }
      }
      if (geometry.morphTargets) {
        var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
        outputAnimations = outputAnimations.concat(morphAnimationClips);
      }
      if (outputAnimations.length > 0) {
        geometry.animations = outputAnimations;
      }
    }
    return function(json, texturePath) {
      if (json.data !== void 0) {
        json = json.data;
      }
      if (json.scale !== void 0) {
        json.scale = 1 / json.scale;
      } else {
        json.scale = 1;
      }
      var geometry = new Geometry();
      parseModel(json, geometry);
      parseSkin(json, geometry);
      parseMorphing(json, geometry);
      parseAnimations(json, geometry);
      geometry.computeFaceNormals();
      geometry.computeBoundingSphere();
      if (json.materials === void 0 || json.materials.length === 0) {
        return {geometry};
      } else {
        var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
        return {geometry, materials};
      }
    };
  }()
});
function ObjectLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.texturePath = "";
}
Object.assign(ObjectLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    if (this.texturePath === "") {
      this.texturePath = url.substring(0, url.lastIndexOf("/") + 1);
    }
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.load(url, function(text) {
      var json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0) {
          onError(error);
        }
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      var metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url + ". Use THREE.JSONLoader instead.");
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  setTexturePath: function(value2) {
    this.texturePath = value2;
  },
  setCrossOrigin: function(value2) {
    this.crossOrigin = value2;
  },
  parse: function(json, onLoad) {
    var geometries = this.parseGeometries(json.geometries);
    var images = this.parseImages(json.images, function() {
      if (onLoad !== void 0) {
        onLoad(object);
      }
    });
    var textures = this.parseTextures(json.textures, images);
    var materials = this.parseMaterials(json.materials, textures);
    var object = this.parseObject(json.object, geometries, materials);
    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }
    if (json.images === void 0 || json.images.length === 0) {
      if (onLoad !== void 0) {
        onLoad(object);
      }
    }
    return object;
  },
  parseGeometries: function(json) {
    var this$1 = this;
    var geometries = {};
    if (json !== void 0) {
      var geometryLoader = new JSONLoader();
      var bufferGeometryLoader = new BufferGeometryLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];
        switch (data.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "IcosahedronGeometry":
          case "OctahedronGeometry":
          case "TetrahedronGeometry":
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;
          case "BufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          case "Geometry":
            geometry = geometryLoader.parse(data, this$1.texturePath).geometry;
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0) {
          geometry.name = data.name;
        }
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  },
  parseMaterials: function(json, textures) {
    var materials = {};
    if (json !== void 0) {
      var loader = new MaterialLoader();
      loader.setTextures(textures);
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];
        if (data.type === "MultiMaterial") {
          var array = [];
          for (var j = 0; j < data.materials.length; j++) {
            array.push(loader.parse(data.materials[j]));
          }
          materials[data.uuid] = array;
        } else {
          materials[data.uuid] = loader.parse(data);
        }
      }
    }
    return materials;
  },
  parseAnimations: function(json) {
    var animations = [];
    for (var i = 0; i < json.length; i++) {
      var clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  },
  parseImages: function(json, onLoad) {
    var scope = this;
    var images = {};
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemEnd(url);
        scope.manager.itemError(url);
      });
    }
    if (json !== void 0 && json.length > 0) {
      var manager = new LoadingManager(onLoad);
      var loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (var i = 0, l = json.length; i < l; i++) {
        var image = json[i];
        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
        images[image.uuid] = loadImage(path);
      }
    }
    return images;
  },
  parseTextures: function(json, images) {
    function parseConstant(value2, type2) {
      if (typeof value2 === "number") {
        return value2;
      }
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value2);
      return type2[value2];
    }
    var textures = {};
    if (json !== void 0) {
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        var texture = new Texture(images[data.image]);
        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== void 0) {
          texture.name = data.name;
        }
        if (data.mapping !== void 0) {
          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        }
        if (data.offset !== void 0) {
          texture.offset.fromArray(data.offset);
        }
        if (data.repeat !== void 0) {
          texture.repeat.fromArray(data.repeat);
        }
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.minFilter !== void 0) {
          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        }
        if (data.magFilter !== void 0) {
          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        }
        if (data.anisotropy !== void 0) {
          texture.anisotropy = data.anisotropy;
        }
        if (data.flipY !== void 0) {
          texture.flipY = data.flipY;
        }
        textures[data.uuid] = texture;
      }
    }
    return textures;
  },
  parseObject: function() {
    var matrix2 = new Matrix4();
    return function parseObject(data, geometries, materials) {
      var this$1 = this;
      var object;
      function getGeometry(name) {
        if (geometries[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined geometry", name);
        }
        return geometries[name];
      }
      function getMaterial(name) {
        if (name === void 0) {
          return void 0;
        }
        if (Array.isArray(name)) {
          var array = [];
          for (var i = 0, l2 = name.length; i < l2; i++) {
            var uuid2 = name[i];
            if (materials[uuid2] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", uuid2);
            }
            array.push(materials[uuid2]);
          }
          return array;
        }
        if (materials[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined material", name);
        }
        return materials[name];
      }
      switch (data.type) {
        case "Scene":
          object = new Scene();
          if (data.background !== void 0) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            }
          }
          if (data.fog !== void 0) {
            if (data.fog.type === "Fog") {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === "FogExp2") {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
          }
          break;
        case "PerspectiveCamera":
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== void 0) {
            object.focus = data.focus;
          }
          if (data.zoom !== void 0) {
            object.zoom = data.zoom;
          }
          if (data.filmGauge !== void 0) {
            object.filmGauge = data.filmGauge;
          }
          if (data.filmOffset !== void 0) {
            object.filmOffset = data.filmOffset;
          }
          if (data.view !== void 0) {
            object.view = Object.assign({}, data.view);
          }
          break;
        case "OrthographicCamera":
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          break;
        case "AmbientLight":
          object = new AmbientLight(data.color, data.intensity);
          break;
        case "DirectionalLight":
          object = new DirectionalLight(data.color, data.intensity);
          break;
        case "PointLight":
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;
        case "RectAreaLight":
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;
        case "SpotLight":
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          break;
        case "HemisphereLight":
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;
        case "SkinnedMesh":
          console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
        case "Mesh":
          var geometry = getGeometry(data.geometry);
          var material = getMaterial(data.material);
          if (geometry.bones && geometry.bones.length > 0) {
            object = new SkinnedMesh(geometry, material);
          } else {
            object = new Mesh(geometry, material);
          }
          break;
        case "LOD":
          object = new LOD();
          break;
        case "Line":
          object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
          break;
        case "LineLoop":
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "LineSegments":
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "PointCloud":
        case "Points":
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "Sprite":
          object = new Sprite(getMaterial(data.material));
          break;
        case "Group":
          object = new Group();
          break;
        default:
          object = new Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== void 0) {
        object.name = data.name;
      }
      if (data.matrix !== void 0) {
        matrix2.fromArray(data.matrix);
        matrix2.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== void 0) {
          object.position.fromArray(data.position);
        }
        if (data.rotation !== void 0) {
          object.rotation.fromArray(data.rotation);
        }
        if (data.quaternion !== void 0) {
          object.quaternion.fromArray(data.quaternion);
        }
        if (data.scale !== void 0) {
          object.scale.fromArray(data.scale);
        }
      }
      if (data.castShadow !== void 0) {
        object.castShadow = data.castShadow;
      }
      if (data.receiveShadow !== void 0) {
        object.receiveShadow = data.receiveShadow;
      }
      if (data.shadow) {
        if (data.shadow.bias !== void 0) {
          object.shadow.bias = data.shadow.bias;
        }
        if (data.shadow.radius !== void 0) {
          object.shadow.radius = data.shadow.radius;
        }
        if (data.shadow.mapSize !== void 0) {
          object.shadow.mapSize.fromArray(data.shadow.mapSize);
        }
        if (data.shadow.camera !== void 0) {
          object.shadow.camera = this.parseObject(data.shadow.camera);
        }
      }
      if (data.visible !== void 0) {
        object.visible = data.visible;
      }
      if (data.userData !== void 0) {
        object.userData = data.userData;
      }
      if (data.children !== void 0) {
        for (var child in data.children) {
          object.add(this$1.parseObject(data.children[child], geometries, materials));
        }
      }
      if (data.type === "LOD") {
        var levels = data.levels;
        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty("uuid", level.object);
          if (child !== void 0) {
            object.addLevel(child, level.distance);
          }
        }
      }
      return object;
    };
  }()
});
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  SphericalReflectionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipMapNearestFilter,
  NearestMipMapLinearFilter,
  LinearFilter,
  LinearMipMapNearestFilter,
  LinearMipMapLinearFilter
};
function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function Curve() {
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t);
  },
  getPoints: function(divisions) {
    var this$1 = this;
    if (divisions === void 0) {
      divisions = 5;
    }
    var points = [];
    for (var d = 0; d <= divisions; d++) {
      points.push(this$1.getPoint(d / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions) {
    var this$1 = this;
    if (divisions === void 0) {
      divisions = 5;
    }
    var points = [];
    for (var d = 0; d <= divisions; d++) {
      points.push(this$1.getPointAt(d / divisions));
    }
    return points;
  },
  getLength: function() {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    var this$1 = this;
    if (divisions === void 0) {
      divisions = this.arcLengthDivisions;
    }
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    var cache = [];
    var current, last = this.getPoint(0);
    var p, sum = 0;
    cache.push(0);
    for (p = 1; p <= divisions; p++) {
      current = this$1.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u, distance3) {
    var arcLengths = this.getLengths();
    var i = 0, il = arcLengths.length;
    var targetArcLength;
    if (distance3) {
      targetArcLength = distance3;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    var low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore;
    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    var t = (i + segmentFraction) / (il - 1);
    return t;
  },
  getTangent: function(t) {
    var delta = 1e-4;
    var t1 = t - delta;
    var t2 = t + delta;
    if (t1 < 0) {
      t1 = 0;
    }
    if (t2 > 1) {
      t2 = 1;
    }
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
  },
  getTangentAt: function(u) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t);
  },
  computeFrenetFrames: function(segments, closed) {
    var this$1 = this;
    var normal2 = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4();
    var i, u, theta;
    for (i = 0; i <= segments; i++) {
      u = i / segments;
      tangents[i] = this$1.getTangentAt(u);
      tangents[i].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal2.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal2.set(0, 1, 0);
    }
    if (tz <= min) {
      normal2.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal2).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
});
function LineCurve(v1, v2) {
  Curve.call(this);
  this.v1 = v1;
  this.v2 = v2;
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t) {
  if (t === 1) {
    return this.v2.clone();
  }
  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar(t).add(this.v1);
  return point;
};
LineCurve.prototype.getPointAt = function(u) {
  return this.getPoint(u);
};
LineCurve.prototype.getTangent = function(t) {
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};
function CurvePath() {
  Curve.call(this);
  this.curves = [];
  this.autoClose = false;
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function(curve) {
    this.curves.push(curve);
  },
  closePath: function() {
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  getPoint: function(t) {
    var this$1 = this;
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        var diff = curveLengths[i] - d;
        var curve = this$1.curves[i];
        var segmentLength = curve.getLength();
        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;
  },
  getLength: function() {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  getCurveLengths: function() {
    var this$1 = this;
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    var lengths = [], sums = 0;
    for (var i = 0, l = this.curves.length; i < l; i++) {
      sums += this$1.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function(divisions) {
    var this$1 = this;
    if (divisions === void 0) {
      divisions = 40;
    }
    var points = [];
    for (var i = 0; i <= divisions; i++) {
      points.push(this$1.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  },
  getPoints: function(divisions) {
    divisions = divisions || 12;
    var points = [], last;
    for (var i = 0, curves = this.curves; i < curves.length; i++) {
      var curve = curves[i];
      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      var pts = curve.getPoints(resolution);
      for (var j = 0; j < pts.length; j++) {
        var point = pts[j];
        if (last && last.equals(point)) {
          continue;
        }
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  },
  createPointsGeometry: function(divisions) {
    var pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function(divisions) {
    var pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function(points) {
    var geometry = new Geometry();
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return geometry;
  }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.aX = aX;
  this.aY = aY;
  this.xRadius = xRadius;
  this.yRadius = yRadius;
  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;
  this.aClockwise = aClockwise;
  this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t) {
  var twoPi = Math.PI * 2;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
  while (deltaAngle < 0) {
    deltaAngle += twoPi;
  }
  while (deltaAngle > twoPi) {
    deltaAngle -= twoPi;
  }
  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }
  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }
  var angle = this.aStartAngle + t * deltaAngle;
  var x = this.aX + this.xRadius * Math.cos(angle);
  var y = this.aY + this.yRadius * Math.sin(angle);
  if (this.aRotation !== 0) {
    var cos2 = Math.cos(this.aRotation);
    var sin2 = Math.sin(this.aRotation);
    var tx = x - this.aX;
    var ty = y - this.aY;
    x = tx * cos2 - ty * sin2 + this.aX;
    y = tx * sin2 + ty * cos2 + this.aY;
  }
  return new Vector2(x, y);
};
function SplineCurve(points) {
  Curve.call(this);
  this.points = points === void 0 ? [] : points;
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t) {
  var points = this.points;
  var point = (points.length - 1) * t;
  var intPoint = Math.floor(point);
  var weight = point - intPoint;
  var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  var point1 = points[intPoint];
  var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  return new Vector2(CatmullRom(weight, point0.x, point1.x, point2.x, point3.x), CatmullRom(weight, point0.y, point1.y, point2.y, point3.y));
};
function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.getPoint = function(t) {
  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
  return new Vector2(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
};
function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.getPoint = function(t) {
  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
  return new Vector2(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
};
var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
  fromPoints: function(vectors) {
    var this$1 = this;
    this.moveTo(vectors[0].x, vectors[0].y);
    for (var i = 1, l = vectors.length; i < l; i++) {
      this$1.lineTo(vectors[i].x, vectors[i].y);
    }
  },
  moveTo: function(x, y) {
    this.currentPoint.set(x, y);
  },
  lineTo: function(x, y) {
    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  splineThru: function(pts) {
    var npts = [this.currentPoint.clone()].concat(pts);
    var curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
  },
  arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  },
  absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      var firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
  }
});
function Path(points) {
  CurvePath.call(this);
  this.currentPoint = new Vector2();
  if (points) {
    this.fromPoints(points);
  }
}
Path.prototype = PathPrototype;
PathPrototype.constructor = Path;
function Shape() {
  Path.apply(this, arguments);
  this.holes = [];
}
Shape.prototype = Object.assign(Object.create(PathPrototype), {
  constructor: Shape,
  getPointsHoles: function(divisions) {
    var this$1 = this;
    var holesPts = [];
    for (var i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this$1.holes[i].getPoints(divisions);
    }
    return holesPts;
  },
  extractAllPoints: function(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  extractPoints: function(divisions) {
    return this.extractAllPoints(divisions);
  }
});
function ShapePath() {
  this.subPaths = [];
  this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
  moveTo: function(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
  },
  lineTo: function(x, y) {
    this.currentPath.lineTo(x, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
  },
  splineThru: function(pts) {
    this.currentPath.splineThru(pts);
  },
  toShapes: function(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      var shapes2 = [];
      for (var i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
        var tmpPath2 = inSubpaths[i2];
        var tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length;
      var inside = false;
      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) {
            continue;
          }
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) {
              return true;
            }
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) {
              return true;
            }
            if (perpEdge < 0) {
              continue;
            }
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) {
            continue;
          }
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) {
            return true;
          }
        }
      }
      return inside;
    }
    var isClockWise = ShapeUtils.isClockWise;
    var subPaths = this.subPaths;
    if (subPaths.length === 0) {
      return [];
    }
    if (noHoles === true) {
      return toShapesNoHoles(subPaths);
    }
    var solid, tmpPath, tmpShape, shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (var i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) {
          mainIdx++;
        }
        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) {
          mainIdx++;
        }
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
      }
    }
    if (!newShapes[0]) {
      return toShapesNoHoles(subPaths);
    }
    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];
        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;
          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) {
                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
              }
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous) {
          newShapeHoles = betterShapeHoles;
        }
      }
    }
    var tmpHoles;
    for (var i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
});
function Font(data) {
  this.data = data;
}
Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function(text, size, divisions) {
    function createPaths(text2) {
      var chars2 = String(text2).split("");
      var scale2 = size / data.resolution;
      var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale2;
      var offsetX = 0, offsetY = 0;
      var paths2 = [];
      for (var i = 0; i < chars2.length; i++) {
        var char = chars2[i];
        if (char === "\n") {
          offsetX = 0;
          offsetY -= line_height;
        } else {
          var ret = createPath(char, scale2, offsetX, offsetY);
          offsetX += ret.offsetX;
          paths2.push(ret.path);
        }
      }
      return paths2;
    }
    function createPath(c, scale2, offsetX, offsetY) {
      var glyph = data.glyphs[c] || data.glyphs["?"];
      if (!glyph) {
        return;
      }
      var path = new ShapePath();
      var pts = [];
      var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2, laste;
      if (glyph.o) {
        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for (var i = 0, l = outline.length; i < l; ) {
          var action = outline[i++];
          switch (action) {
            case "m":
              x = outline[i++] * scale2 + offsetX;
              y = outline[i++] * scale2 + offsetY;
              path.moveTo(x, y);
              break;
            case "l":
              x = outline[i++] * scale2 + offsetX;
              y = outline[i++] * scale2 + offsetY;
              path.lineTo(x, y);
              break;
            case "q":
              cpx = outline[i++] * scale2 + offsetX;
              cpy = outline[i++] * scale2 + offsetY;
              cpx1 = outline[i++] * scale2 + offsetX;
              cpy1 = outline[i++] * scale2 + offsetY;
              path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
              laste = pts[pts.length - 1];
              if (laste) {
                laste.x;
                laste.y;
              }
              break;
            case "b":
              cpx = outline[i++] * scale2 + offsetX;
              cpy = outline[i++] * scale2 + offsetY;
              cpx1 = outline[i++] * scale2 + offsetX;
              cpy1 = outline[i++] * scale2 + offsetY;
              cpx2 = outline[i++] * scale2 + offsetX;
              cpy2 = outline[i++] * scale2 + offsetY;
              path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
              laste = pts[pts.length - 1];
              if (laste) {
                laste.x;
                laste.y;
              }
              break;
          }
        }
      }
      return {offsetX: glyph.ha * scale2, path};
    }
    if (size === void 0) {
      size = 100;
    }
    var data = this.data;
    var paths = createPaths(text);
    var shapes = [];
    for (var p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
});
function FontLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FontLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(this.manager);
    loader.load(url, function(text) {
      var json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json = JSON.parse(text.substring(65, text.length - 2));
      }
      var font = scope.parse(json);
      if (onLoad) {
        onLoad(font);
      }
    }, onProgress, onError);
  },
  parse: function(json) {
    return new Font(json);
  }
});
var context;
var AudioContext = {
  getContext: function() {
    if (context === void 0) {
      context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return context;
  },
  setContext: function(value2) {
    context = value2;
  }
};
function AudioLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(AudioLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.load(url, function(buffer) {
      var context2 = AudioContext.getContext();
      context2.decodeAudioData(buffer, function(audioBuffer) {
        onLoad(audioBuffer);
      });
    }, onProgress, onError);
  }
});
function StereoCamera() {
  this.type = "StereoCamera";
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
}
Object.assign(StereoCamera.prototype, {
  update: function() {
    var instance, focus, fov, aspect, near, far, zoom4, eyeSep;
    var eyeRight = new Matrix4();
    var eyeLeft = new Matrix4();
    return function update2(camera) {
      var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom4 !== camera.zoom || eyeSep !== this.eyeSep;
      if (needsUpdate) {
        instance = this;
        focus = camera.focus;
        fov = camera.fov;
        aspect = camera.aspect * this.aspect;
        near = camera.near;
        far = camera.far;
        zoom4 = camera.zoom;
        var projectionMatrix = camera.projectionMatrix.clone();
        eyeSep = this.eyeSep / 2;
        var eyeSepOnProjection = eyeSep * near / focus;
        var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom4;
        var xmin, xmax;
        eyeLeft.elements[12] = -eyeSep;
        eyeRight.elements[12] = eyeSep;
        xmin = -ymax * aspect + eyeSepOnProjection;
        xmax = ymax * aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * aspect - eyeSepOnProjection;
        xmax = ymax * aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }
      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
    };
  }()
});
function AudioListener() {
  Object3D.call(this);
  this.type = "AudioListener";
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(value2) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value2;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(value2) {
    this.gain.gain.value = value2;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale2 = new Vector3();
    var orientation = new Vector3();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up2 = this.up;
      this.matrixWorld.decompose(position, quaternion, scale2);
      orientation.set(0, 0, -1).applyQuaternion(quaternion);
      if (listener.positionX) {
        listener.positionX.setValueAtTime(position.x, this.context.currentTime);
        listener.positionY.setValueAtTime(position.y, this.context.currentTime);
        listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
        listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
        listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
        listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
        listener.upX.setValueAtTime(up2.x, this.context.currentTime);
        listener.upY.setValueAtTime(up2.y, this.context.currentTime);
        listener.upZ.setValueAtTime(up2.z, this.context.currentTime);
      } else {
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up2.x, up2.y, up2.z);
      }
    };
  }()
});
function Audio(listener) {
  Object3D.call(this);
  this.type = "Audio";
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.loop = false;
  this.startTime = 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = "empty";
  this.filters = [];
}
Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  },
  setBuffer: function(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) {
      this.play();
    }
    return this;
  },
  play: function() {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    var source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.onended = this.onEnded.bind(this);
    source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
    source.start(0, this.startTime);
    this.isPlaying = true;
    this.source = source;
    return this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.source.stop();
    this.startTime = this.context.currentTime;
    this.isPlaying = false;
    return this;
  },
  stop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.source.stop();
    this.startTime = 0;
    this.isPlaying = false;
    return this;
  },
  connect: function() {
    var this$1 = this;
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var i = 1, l = this.filters.length; i < l; i++) {
        this$1.filters[i - 1].connect(this$1.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  },
  disconnect: function() {
    var this$1 = this;
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var i = 1, l = this.filters.length; i < l; i++) {
        this$1.filters[i - 1].disconnect(this$1.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(value2) {
    if (!value2) {
      value2 = [];
    }
    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value2;
      this.connect();
    } else {
      this.filters = value2;
    }
    return this;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(filter) {
    return this.setFilters(filter ? [filter] : []);
  },
  setPlaybackRate: function(value2) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value2;
    if (this.isPlaying === true) {
      this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
    }
    return this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = false;
  },
  getLoop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  },
  setLoop: function(value2) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value2;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(value2) {
    this.gain.gain.value = value2;
    return this;
  }
});
function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
  constructor: PositionalAudio,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(value2) {
    this.panner.refDistance = value2;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(value2) {
    this.panner.rolloffFactor = value2;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(value2) {
    this.panner.distanceModel = value2;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(value2) {
    this.panner.maxDistance = value2;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      position.setFromMatrixPosition(this.matrixWorld);
      this.panner.setPosition(position.x, position.y, position.z);
    };
  }()
});
function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function() {
    var value2 = 0, data = this.getFrequencyData();
    for (var i = 0; i < data.length; i++) {
      value2 += data[i];
    }
    return value2 / data.length;
  }
});
function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  var bufferType = Float64Array, mixFunction;
  switch (typeName) {
    case "quaternion":
      mixFunction = this._slerp;
      break;
    case "string":
    case "bool":
      bufferType = Array;
      mixFunction = this._select;
      break;
    default:
      mixFunction = this._lerp;
  }
  this.buffer = new bufferType(valueSize * 4);
  this._mixBufferRegion = mixFunction;
  this.cumulativeWeight = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
  accumulate: function(accuIndex, weight) {
    var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (var i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      var mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  },
  apply: function(accuIndex) {
    var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
    this.cumulativeWeight = 0;
    if (weight < 1) {
      var originalValueOffset = stride * 3;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    for (var i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  saveOriginalState: function() {
    var binding = this.binding;
    var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
    binding.getValue(buffer, originalValueOffset);
    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this.cumulativeWeight = 0;
  },
  restoreOriginalState: function() {
    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  _select: function(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (var i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
    var s = 1 - t;
    for (var i = 0; i !== stride; ++i) {
      var j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
});
function Composite(targetGroup, path, optionalParsedPath) {
  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) {
      binding.getValue(array, offset);
    }
  },
  setValue: function(array, offset) {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function() {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function() {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name) {
    return name.replace(/\s/g, "_").replace(/[^\w-]/g, "");
  },
  parseTrackName: function() {
    var directoryRe = /((?:[\w-]+[\/:])*)/;
    var nodeRe = /([\w-\.]+)?/;
    var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;
    var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;
    var trackRe = new RegExp("^" + directoryRe.source + nodeRe.source + objectRe.source + propertyRe.source + "$");
    var supportedObjectNames = ["material", "materials", "bones"];
    return function(trackName) {
      var matches = trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      var results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1);
        if (supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    };
  }(),
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      var searchSkeleton = function(skeleton) {
        for (var i = 0; i < skeleton.bones.length; i++) {
          var bone2 = skeleton.bones[i];
          if (bone2.name === nodeName) {
            return bone2;
          }
        }
        return null;
      };
      var bone = searchSkeleton(root.skeleton);
      if (bone) {
        return bone;
      }
    }
    if (root.children) {
      var searchNodeSubtree = function(children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          var result = searchNodeSubtree(childNode.children);
          if (result) {
            return result;
          }
        }
        return null;
      };
      var subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset) {
      var source = this.resolvedProperty;
      for (var i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    },
    function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  bind: function() {
    var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      var objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    var nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      var nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    var versioning = this.Versioning.None;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
      this.targetObject = targetObject;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
      this.targetObject = targetObject;
    }
    var bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        } else {
          if (!targetObject.geometry.morphTargets) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
            return;
          }
          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
function AnimationObjectGroup(var_args) {
  var arguments$1 = arguments;
  this.uuid = _Math.generateUUID();
  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0;
  var indices = {};
  this._indicesByUUID = indices;
  for (var i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments$1[i].uuid] = i;
  }
  this._paths = [];
  this._parsedPaths = [];
  this._bindings = [];
  this._bindingsIndicesByPath = {};
  var scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },
      get inUse() {
        return this.total - scope.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return scope._bindings.length;
    }
  };
}
Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function(var_args) {
    var arguments$1 = arguments;
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments$1[i], uuid2 = object.uuid, index = indicesByUUID[uuid2], knownObject = void 0;
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid2] = index;
        objects.push(object);
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid2] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function(var_args) {
    var arguments$1 = arguments;
    var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments$1[i], uuid2 = object.uuid, index = indicesByUUID[uuid2];
      if (index !== void 0 && index >= nCachedObjects) {
        var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid2] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (var j = 0, m2 = nBindings; j !== m2; ++j) {
          var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  uncache: function(var_args) {
    var arguments$1 = arguments;
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments$1[i], uuid2 = object.uuid, index = indicesByUUID[uuid2];
      if (index !== void 0) {
        delete indicesByUUID[uuid2];
        if (index < nCachedObjects) {
          var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (var j = 0, m2 = nBindings; j !== m2; ++j) {
            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          var lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop();
          for (var j = 0, m2 = nBindings; j !== m2; ++j) {
            var bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  subscribe_: function(path, parsedPath) {
    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
    if (index !== void 0) {
      return bindings[index];
    }
    var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
      var object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  },
  unsubscribe_: function(path) {
    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
function AnimationAction(mixer, clip, localRoot) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
  var interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };
  for (var i = 0; i !== nTracks; ++i) {
    var interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
  }
  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants;
  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null;
  this._byClipCacheIndex = null;
  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1;
  this._startTime = null;
  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity;
  this.paused = false;
  this.enabled = true;
  this.clampWhenFinished = false;
  this.zeroSlopeAtStart = true;
  this.zeroSlopeAtEnd = true;
}
Object.assign(AnimationAction.prototype, {
  play: function() {
    this._mixer._activateAction(this);
    return this;
  },
  stop: function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  },
  reset: function() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(time) {
    this._startTime = time;
    return this;
  },
  setLoop: function(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  setEffectiveWeight: function(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function(duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  },
  crossFadeTo: function(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function() {
    var weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  },
  setEffectiveTimeScale: function(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function(startTimeScale, endTimeScale, duration) {
    var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function() {
    var timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  },
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  _update: function(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    var startTime = this._startTime;
    if (startTime !== null) {
      var timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    var clipTime = this._updateTime(deltaTime);
    var weight = this._updateWeight(time);
    if (weight > 0) {
      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;
      for (var j = 0, m2 = interpolants.length; j !== m2; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
      }
    }
  },
  _updateWeight: function(time) {
    var weight = 0;
    if (this.enabled) {
      weight = this.weight;
      var interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function(time) {
    var timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function(deltaTime) {
    var time = this.time + deltaTime;
    if (deltaTime === 0) {
      return time;
    }
    var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          break handle_stop;
        }
        if (this.clampWhenFinished) {
          this.paused = true;
        } else {
          this.enabled = false;
        }
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      var pingPong = loop === LoopPingPong;
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        var loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        var pending = this.repetitions - loopCount;
        if (pending < 0) {
          if (this.clampWhenFinished) {
            this.paused = true;
          } else {
            this.enabled = false;
          }
          time = deltaTime > 0 ? duration : 0;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 0) {
            var atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      }
      if (pingPong && (loopCount & 1) === 1) {
        this.time = time;
        return duration - time;
      }
    }
    this.time = time;
    return time;
  },
  _setEndings: function(atStart, atEnd, pingPong) {
    var settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function(duration, weightNow, weightThen) {
    var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
});
function AnimationMixer(root) {
  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1;
}
Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
  _bindAction: function(action, prototypeAction) {
    var this$1 = this;
    var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (var i = 0; i !== nTracks; ++i) {
      var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this$1._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this$1._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function(action) {
    var this$1 = this;
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (binding.useCount++ === 0) {
          this$1._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  },
  _deactivateAction: function(action) {
    var this$1 = this;
    if (this._isActiveAction(action)) {
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this$1._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  },
  _initMemoryManager: function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  },
  _isActiveAction: function(action) {
    var index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function(action, clipUuid, rootUuid) {
    var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      var knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function(action) {
    var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function(action) {
    var this$1 = this;
    var bindings = action._propertyBindings;
    for (var i = 0, n = bindings.length; i !== n; ++i) {
      var binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this$1._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  _addInactiveBinding: function(binding, rootUuid, trackName) {
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function(binding) {
    var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    remove_empty_map: {
      for (var _ in bindingByName) {
        break remove_empty_map;
      }
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  _lendControlInterpolant: function() {
    var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  },
  _takeBackControlInterpolant: function(interpolant) {
    var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  clipAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
    if (actionsForClip !== void 0) {
      var existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null) {
        clipObject = prototypeAction._clip;
      }
    }
    if (clipObject === null) {
      return null;
    }
    var newAction = new AnimationAction(this, clipObject, optionalRoot);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  },
  existingAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  },
  stopAllAction: function() {
    var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
    this._nActiveActions = 0;
    this._nActiveBindings = 0;
    for (var i = 0; i !== nActions; ++i) {
      actions[i].reset();
    }
    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].useCount = 0;
    }
    return this;
  },
  update: function(deltaTime) {
    deltaTime *= this.timeScale;
    var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (var i = 0; i !== nActions; ++i) {
      var action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    var bindings = this._bindings, nBindings = this._nActiveBindings;
    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  },
  getRoot: function() {
    return this._root;
  },
  uncacheClip: function(clip) {
    var this$1 = this;
    var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      var actionsToRemove = actionsForClip.knownActions;
      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
        var action = actionsToRemove[i];
        this$1._deactivateAction(action);
        var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this$1._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  },
  uncacheRoot: function(root) {
    var this$1 = this;
    var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (var clipUuid in actionsByClip) {
      var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this$1._deactivateAction(action);
        this$1._removeInactiveAction(action);
      }
    }
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (var trackName in bindingByName) {
        var binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this$1._removeInactiveBinding(binding);
      }
    }
  },
  uncacheAction: function(clip, optionalRoot) {
    var action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
});
function Uniform(value2) {
  if (typeof value2 === "string") {
    console.warn("THREE.Uniform: Type parameter is no longer needed.");
    value2 = arguments[1];
  }
  this.value = value2;
}
Uniform.prototype.clone = function() {
  return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.maxInstancedCount = void 0;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  addGroup: function(start, count2, materialIndex) {
    this.groups.push({
      start,
      count: count2,
      materialIndex
    });
  },
  copy: function(source) {
    var this$1 = this;
    var index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      this$1.addAttribute(name, attribute.clone());
    }
    var groups = source.groups;
    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this$1.addGroup(group.start, group.count, group.materialIndex);
    }
    return this;
  }
});
function InterleavedBufferAttribute(interleavedBuffer, itemSize2, offset, normalized) {
  this.uuid = _Math.generateUUID();
  this.data = interleavedBuffer;
  this.itemSize = itemSize2;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  setX: function(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
});
function InterleavedBuffer(array, stride) {
  this.uuid = _Math.generateUUID();
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.dynamic = false;
  this.updateRange = {offset: 0, count: -1};
  this.onUploadCallback = function() {
  };
  this.version = 0;
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value2) {
    if (value2 === true) {
      this.version++;
    }
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.stride : 0;
    this.array = array;
  },
  setDynamic: function(value2) {
    this.dynamic = value2;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    var this$1 = this;
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (var i = 0, l = this.stride; i < l; i++) {
      this$1.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function(value2, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.array.set(value2, offset);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  }
});
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
function InstancedBufferAttribute(array, itemSize2, meshPerAttribute) {
  BufferAttribute.call(this, array, itemSize2);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction);
  this.near = near || 0;
  this.far = far || Infinity;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.visible === false) {
    return;
  }
  object.raycast(raycaster, intersects2);
  if (recursive === true) {
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
    } else {
      console.error("THREE.Raycaster: Unsupported camera type.");
    }
  },
  intersectObject: function(object, recursive) {
    var intersects2 = [];
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive) {
    var this$1 = this;
    var intersects2 = [];
    if (Array.isArray(objects) === false) {
      console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
      return intersects2;
    }
    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this$1, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
function Clock(autoStart) {
  this.autoStart = autoStart !== void 0 ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}
Object.assign(Clock.prototype, {
  start: function() {
    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function() {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function() {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      var newTime = (typeof performance === "undefined" ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
});
function Spherical(radius, phi, theta) {
  this.radius = radius !== void 0 ? radius : 1;
  this.phi = phi !== void 0 ? phi : 0;
  this.theta = theta !== void 0 ? theta : 0;
  return this;
}
Object.assign(Spherical.prototype, {
  set: function(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  makeSafe: function() {
    var EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function(vec3) {
    this.radius = vec3.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(vec3.x, vec3.z);
      this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1));
    }
    return this;
  }
});
function Cylindrical(radius, theta, y) {
  this.radius = radius !== void 0 ? radius : 1;
  this.theta = theta !== void 0 ? theta : 0;
  this.y = y !== void 0 ? y : 0;
  return this;
}
Object.assign(Cylindrical.prototype, {
  set: function(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function(vec3) {
    this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
    this.theta = Math.atan2(vec3.x, vec3.z);
    this.y = vec3.y;
    return this;
  }
});
function VertexNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color = hex !== void 0 ? hex : 16711680;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
  }
  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute("position", positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({color, linewidth: width}));
  this.matrixAutoUpdate = false;
  this.update();
}
VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix2 = new Matrix3();
  return function update2() {
    var this$1 = this;
    var keys = ["a", "b", "c"];
    this.object.updateMatrixWorld(true);
    normalMatrix2.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;
      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          var vertex2 = vertices[face[keys[j]]];
          var normal2 = face.vertexNormals[j];
          v1.copy(vertex2).applyMatrix4(matrixWorld);
          v2.copy(normal2).applyMatrix3(normalMatrix2).normalize().multiplyScalar(this$1.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      var objPos = objGeometry.attributes.position;
      var objNorm = objGeometry.attributes.normal;
      var idx = 0;
      for (var j = 0, jl = objPos.count; j < jl; j++) {
        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
        v2.applyMatrix3(normalMatrix2).normalize().multiplyScalar(this$1.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  };
}();
function getBoneList(object) {
  var boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
function SkeletonHelper(object) {
  var bones = getBoneList(object);
  var geometry = new BufferGeometry();
  var vertices = [];
  var colors = [];
  var color1 = new Color(0, 0, 1);
  var color2 = new Color(0, 1, 0);
  for (var i = 0; i < bones.length; i++) {
    var bone = bones[i];
    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }
  geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true});
  LineSegments.call(this, geometry, material);
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
  this.onBeforeRender();
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.onBeforeRender = function() {
  var vector = new Vector3();
  var boneMatrix = new Matrix4();
  var matrixWorldInv = new Matrix4();
  return function onBeforeRender2() {
    var bones = this.bones;
    var geometry = this.geometry;
    var position = geometry.getAttribute("position");
    matrixWorldInv.getInverse(this.root.matrixWorld);
    for (var i = 0, j = 0; i < bones.length; i++) {
      var bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j, vector.x, vector.y, vector.z);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j + 1, vector.x, vector.y, vector.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
  };
}();
function HemisphereLightHelper(light, size) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  var geometry = new OctahedronBufferGeometry(size);
  geometry.rotateY(Math.PI * 0.5);
  var material = new MeshBasicMaterial({vertexColors: VertexColors, wireframe: true});
  var position = geometry.getAttribute("position");
  var colors = new Float32Array(position.count * 3);
  geometry.addAttribute("color", new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry, material));
  this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
  var vector = new Vector3();
  var color1 = new Color();
  var color2 = new Color();
  return function update2() {
    var mesh = this.children[0];
    var colors = mesh.geometry.getAttribute("color");
    color1.copy(this.light.color);
    color2.copy(this.light.groundColor);
    for (var i = 0, l = colors.count; i < l; i++) {
      var color = i < l / 2 ? color1 : color2;
      colors.setXYZ(i, color.r, color.g, color.b);
    }
    mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
    colors.needsUpdate = true;
  };
}();
function FaceNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color = hex !== void 0 ? hex : 16776960;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
  } else {
    console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
  }
  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute("position", positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({color, linewidth: width}));
  this.matrixAutoUpdate = false;
  this.update();
}
FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix2 = new Matrix3();
  return function update2() {
    var this$1 = this;
    this.object.updateMatrixWorld(true);
    normalMatrix2.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      var normal2 = face.normal;
      v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
      v2.copy(normal2).applyMatrix3(normalMatrix2).normalize().multiplyScalar(this$1.size).add(v1);
      position.setXYZ(idx, v1.x, v1.y, v1.z);
      idx = idx + 1;
      position.setXYZ(idx, v2.x, v2.y, v2.z);
      idx = idx + 1;
    }
    position.needsUpdate = true;
  };
}();
function CameraHelper(camera) {
  var geometry = new BufferGeometry();
  var material = new LineBasicMaterial({color: 16777215, vertexColors: FaceColors});
  var vertices = [];
  var colors = [];
  var pointMap = {};
  var colorFrustum = new Color(16755200);
  var colorCone = new Color(16711680);
  var colorUp = new Color(43775);
  var colorTarget = new Color(16777215);
  var colorCross = new Color(3355443);
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }
  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);
    if (pointMap[id] === void 0) {
      pointMap[id] = [];
    }
    pointMap[id].push(vertices.length / 3 - 1);
  }
  geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry, material);
  this.camera = camera;
  if (this.camera.updateProjectionMatrix) {
    this.camera.updateProjectionMatrix();
  }
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
  var geometry, pointMap;
  var vector = new Vector3();
  var camera = new Camera();
  function setPoint(point, x, y, z) {
    vector.set(x, y, z).unproject(camera);
    var points = pointMap[point];
    if (points !== void 0) {
      var position = geometry.getAttribute("position");
      for (var i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], vector.x, vector.y, vector.z);
      }
    }
  }
  return function update2() {
    geometry = this.geometry;
    pointMap = this.pointMap;
    var w = 1, h = 1;
    camera.projectionMatrix.copy(this.camera.projectionMatrix);
    setPoint("c", 0, 0, -1);
    setPoint("t", 0, 0, 1);
    setPoint("n1", -w, -h, -1);
    setPoint("n2", w, -h, -1);
    setPoint("n3", -w, h, -1);
    setPoint("n4", w, h, -1);
    setPoint("f1", -w, -h, 1);
    setPoint("f2", w, -h, 1);
    setPoint("f3", -w, h, 1);
    setPoint("f4", w, h, 1);
    setPoint("u1", w * 0.7, h * 1.1, -1);
    setPoint("u2", -w * 0.7, h * 1.1, -1);
    setPoint("u3", 0, h * 2, -1);
    setPoint("cf1", -w, 0, 1);
    setPoint("cf2", w, 0, 1);
    setPoint("cf3", 0, -h, 1);
    setPoint("cf4", 0, h, 1);
    setPoint("cn1", -w, 0, -1);
    setPoint("cn2", w, 0, -1);
    setPoint("cn3", 0, -h, -1);
    setPoint("cn4", 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  };
}();
function CubicPoly() {
  var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init3(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init3(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init3(x1, x2, t1, t2);
    },
    calc: function(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
function CatmullRomCurve3(points) {
  Curve.call(this);
  if (points.length < 2) {
    console.warn("THREE.CatmullRomCurve3: Points array needs at least two entries.");
  }
  this.points = points || [];
  this.closed = false;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.getPoint = function(t) {
  var points = this.points;
  var l = points.length;
  var point = (l - (this.closed ? 0 : 1)) * t;
  var intPoint = Math.floor(point);
  var weight = point - intPoint;
  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }
  var p0, p1, p2, p3;
  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }
  p1 = points[intPoint % l];
  p2 = points[(intPoint + 1) % l];
  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }
  if (this.type === void 0 || this.type === "centripetal" || this.type === "chordal") {
    var pow2 = this.type === "chordal" ? 0.5 : 0.25;
    var dt0 = Math.pow(p0.distanceToSquared(p1), pow2);
    var dt1 = Math.pow(p1.distanceToSquared(p2), pow2);
    var dt2 = Math.pow(p2.distanceToSquared(p3), pow2);
    if (dt1 < 1e-4) {
      dt1 = 1;
    }
    if (dt0 < 1e-4) {
      dt0 = dt1;
    }
    if (dt2 < 1e-4) {
      dt2 = dt1;
    }
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.type === "catmullrom") {
    var tension = this.tension !== void 0 ? this.tension : 0.5;
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
  }
  return new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
};
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
function Spline(points) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
  CatmullRomCurve3.call(this, points);
  this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function(a) {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function(optionalTarget) {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function(samplingCoef) {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Box2.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
_Math.random16 = function() {
  console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function(array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function(a) {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBuffer: function(buffer, offset, length) {
    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function(array, offset, length) {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function(m2) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m2);
  },
  flattenToArrayOffset: function(array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: function() {
    var v1;
    return function getPosition4() {
      if (v1 === void 0) {
        v1 = new Vector3();
      }
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return v1.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function(q) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function(a) {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(v) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v.transformDirection(this);
  },
  crossVector: function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBuffer: function(buffer, offset, length) {
    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function(array, offset, length) {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
  isIntersectionBox: function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Shape.prototype, {
  extrude: function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function(attribute, index, offset) {
    console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(m2) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m2);
  },
  getScaleFromMatrix: function(m2) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m2);
  },
  getColumnFromMatrix: function(index, matrix2) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix2, index);
  },
  applyProjection: function(m2) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m2);
  },
  fromAttribute: function(attribute, index, offset) {
    console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function(attribute, index, offset) {
    console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  }
});
Geometry.prototype.computeTangents = function() {
  console.warn("THREE.Geometry: .computeTangents() has been removed.");
};
Object.assign(Object3D.prototype, {
  getChildByName: function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(distance3, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance3);
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value2) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value2;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value2) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value2;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0) {
    this.filmGauge = filmGauge;
  }
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value2;
    }
  },
  shadowCameraLeft: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value2;
    }
  },
  shadowCameraRight: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value2;
    }
  },
  shadowCameraTop: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value2;
    }
  },
  shadowCameraBottom: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value2;
    }
  },
  shadowCameraNear: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value2;
    }
  },
  shadowCameraFar: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value2;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value2;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value2;
    }
  },
  shadowMapHeight: {
    set: function(value2) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value2;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function(index) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index);
  },
  addDrawCall: function(start, count2, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start, count2);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value2) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value2;
    }
  }
});
Object.assign(WebGLRenderer.prototype, {
  getCurrentRenderTarget: function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  },
  supportsFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(boolean2) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean2);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value2;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value2;
    }
  },
  shadowMapCullFace: {
    get: function() {
      return this.shadowMap.cullFace;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
      this.shadowMap.cullFace = value2;
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      return this.renderReverseSided ? CullFaceFront : CullFaceBack;
    },
    set: function(cullFace) {
      var value2 = cullFace !== CullFaceBack;
      console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value2 + ".");
      this.renderReverseSided = value2;
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value2;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value2;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value2;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value2;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value2;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value2;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value2;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value2;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value2;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value2) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value2;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
function getQuery(id) {
  if (typeof window === "undefined") {
    return void 0;
  }
  var a = new RegExp(id + "=([^&#=]*)");
  var m2 = a.exec(window.location.search);
  if (m2) {
    return decodeURIComponent(m2[1]);
  } else {
    return void 0;
  }
}
function boolean(value2) {
  if (!value2) {
    return false;
  }
  if (typeof value2 === "string") {
    return /^1|true|t|yes|y$/i.test(value2);
  }
  return true;
}
function defaults(value2, defaultValue) {
  return value2 !== void 0 ? value2 : defaultValue;
}
function getProtocol() {
  var protocol = window.location.protocol;
  return protocol.match(/http(s)?:/gi) === null ? "http:" : protocol;
}
function getBrowser() {
  if (typeof window === "undefined") {
    return false;
  }
  var ua = window.navigator.userAgent;
  if (/Opera|OPR/.test(ua)) {
    return "Opera";
  } else if (/Chrome/i.test(ua)) {
    return "Chrome";
  } else if (/Firefox/i.test(ua)) {
    return "Firefox";
  } else if (/Mobile(\/.*)? Safari/i.test(ua)) {
    return "Mobile Safari";
  } else if (/MSIE/i.test(ua)) {
    return "Internet Explorer";
  } else if (/Safari/i.test(ua)) {
    return "Safari";
  }
  return false;
}
function getAbsolutePath(relativePath) {
  var loc = window.location;
  var pn = loc.pathname;
  var basePath = pn.substring(0, pn.lastIndexOf("/") + 1);
  return loc.origin + basePath + relativePath;
}
function download(data, downloadName) {
  if (!data) {
    return;
  }
  downloadName = downloadName || "download";
  var isSafari = getBrowser() === "Safari";
  var isChromeIos = /CriOS\/[\d]+/.test(window.navigator.userAgent);
  var a = document.createElement("a");
  function openUrl(url) {
    var opened = window.open(url, "_blank");
    if (!opened) {
      window.location.href = url;
    }
  }
  function open(str) {
    openUrl(isChromeIos ? str : str.replace(/^data:[^;]*;/, "data:attachment/file;"));
  }
  if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(data, downloadName);
  } else if ((isSafari || isChromeIos) && window.FileReader) {
    if (data instanceof window.Blob) {
      var reader = new window.FileReader();
      reader.onloadend = function() {
        open(reader.result);
      };
      reader.readAsDataURL(data);
    } else {
      open(data);
    }
  } else {
    if (data instanceof window.Blob) {
      data = window.URL.createObjectURL(data);
    }
    if ("download" in a) {
      a.style.display = "hidden";
      document.body.appendChild(a);
      a.href = data;
      a.download = downloadName;
      a.target = "_blank";
      a.click();
      document.body.removeChild(a);
    } else {
      openUrl(data);
    }
    if (data instanceof window.Blob) {
      window.URL.revokeObjectURL(data);
    }
  }
}
function getFileInfo(file) {
  var compressedExtList = ["gz"];
  var path, compressed, protocol;
  if (typeof window !== "undefined" && file instanceof window.File || typeof window !== "undefined" && file instanceof window.Blob) {
    path = file.name || "";
  } else {
    path = file;
  }
  var queryIndex = path.lastIndexOf("?");
  path = path.substring(0, queryIndex === -1 ? path.length : queryIndex);
  var name = path.replace(/^.*[\\/]/, "");
  var base = name.substring(0, name.lastIndexOf("."));
  var nameSplit = name.split(".");
  var ext = nameSplit.length > 1 ? nameSplit.pop().toLowerCase() : "";
  var protocolMatch = path.match(/^(.+):\/\/(.+)$/);
  if (protocolMatch) {
    protocol = protocolMatch[1].toLowerCase();
    path = protocolMatch[2];
  }
  var dir = path.substring(0, path.lastIndexOf("/") + 1);
  if (compressedExtList.includes(ext)) {
    compressed = ext;
    var n = path.length - ext.length - 1;
    ext = path.substr(0, n).split(".").pop().toLowerCase();
    var m2 = base.length - ext.length - 1;
    base = base.substr(0, m2);
  } else {
    compressed = false;
  }
  return {
    path,
    name,
    ext,
    base,
    dir,
    compressed,
    protocol,
    src: file
  };
}
function throttle(func3, wait, options) {
  var context2, args, result;
  var timeout2 = null;
  var previous = 0;
  if (!options) {
    options = {};
  }
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func3.apply(context2, args);
    if (!timeout2) {
      context2 = args = null;
    }
  };
  return function throttle2() {
    var now = Date.now();
    if (!previous && options.leading === false) {
      previous = now;
    }
    var remaining = wait - (now - previous);
    context2 = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now;
      result = func3.apply(context2, args);
      if (!timeout2) {
        context2 = args = null;
      }
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
}
function lexicographicCompare(elm12, elm22) {
  if (elm12 < elm22) {
    return -1;
  }
  if (elm12 > elm22) {
    return 1;
  }
  return 0;
}
function binarySearchIndexOf(array, element, compareFunction) {
  if (compareFunction === void 0)
    compareFunction = lexicographicCompare;
  var low = 0;
  var high = array.length - 1;
  while (low <= high) {
    var mid = low + high >> 1;
    var cmp = compareFunction(element, array[mid]);
    if (cmp > 0) {
      low = mid + 1;
    } else if (cmp < 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -low - 1;
}
function binarySearchForLeftRange(array, leftRange) {
  var high = array.length - 1;
  if (array[high] < leftRange) {
    return -1;
  }
  var low = 0;
  while (low <= high) {
    var mid = low + high >> 1;
    if (array[mid] >= leftRange) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return high + 1;
}
function binarySearchForRightRange(array, rightRange) {
  if (array[0] > rightRange) {
    return -1;
  }
  var low = 0;
  var high = array.length - 1;
  while (low <= high) {
    var mid = low + high >> 1;
    if (array[mid] > rightRange) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return low - 1;
}
function rangeInSortedArray(array, min, max2) {
  var indexLeft = binarySearchForLeftRange(array, min);
  var indexRight = binarySearchForRightRange(array, max2);
  if (indexLeft === -1 || indexRight === -1 || indexLeft > indexRight) {
    return 0;
  } else {
    return indexRight - indexLeft + 1;
  }
}
function uniqueArray(array) {
  return array.sort().filter(function(value2, index, sorted) {
    return index === 0 || value2 !== sorted[index - 1];
  });
}
function uint8ToString(u8a) {
  var chunkSize = 28672;
  if (u8a.length > chunkSize) {
    var c = [];
    for (var i = 0; i < u8a.length; i += chunkSize) {
      c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + chunkSize)));
    }
    return c.join("");
  } else {
    return String.fromCharCode.apply(null, u8a);
  }
}
function uint8ToLines(u8a, chunkSize, newline) {
  chunkSize = chunkSize !== void 0 ? chunkSize : 1024 * 1024 * 10;
  newline = newline !== void 0 ? newline : "\n";
  var partialLine = "";
  var lines = [];
  for (var i = 0; i < u8a.length; i += chunkSize) {
    var str = uint8ToString(u8a.subarray(i, i + chunkSize));
    var idx = str.lastIndexOf(newline);
    if (idx === -1) {
      partialLine += str;
    } else {
      var str2 = partialLine + str.substr(0, idx);
      lines = lines.concat(str2.split(newline));
      if (idx === str.length - newline.length) {
        partialLine = "";
      } else {
        partialLine = str.substr(idx + newline.length);
      }
    }
  }
  if (partialLine !== "") {
    lines.push(partialLine);
  }
  return lines;
}
function getTypedArray(arrayType, arraySize) {
  switch (arrayType) {
    case "int8":
      return new Int8Array(arraySize);
    case "int16":
      return new Int16Array(arraySize);
    case "int32":
      return new Int32Array(arraySize);
    case "uint8":
      return new Uint8Array(arraySize);
    case "uint16":
      return new Uint16Array(arraySize);
    case "uint32":
      return new Uint32Array(arraySize);
    case "float32":
      return new Float32Array(arraySize);
    default:
      throw new Error("arrayType unknown: " + arrayType);
  }
}
function getUintArray(sizeOrArray, maxUnit) {
  var TypedArray = maxUnit > 65535 ? Uint32Array : Uint16Array;
  return new TypedArray(sizeOrArray);
}
function _ensureClassFromArg(arg, constructor) {
  return arg instanceof constructor ? arg : new constructor(arg);
}
function _ensureClassFromArray(array, constructor) {
  if (array === void 0) {
    array = new constructor();
  } else if (Array.isArray(array)) {
    array = new constructor().fromArray(array);
  }
  return array;
}
function ensureVector2(v) {
  return _ensureClassFromArray(v, Vector2);
}
function ensureVector3(v) {
  return _ensureClassFromArray(v, Vector3);
}
function ensureMatrix4(m2) {
  return _ensureClassFromArray(m2, Matrix4);
}
function ensureQuaternion(q) {
  return _ensureClassFromArray(q, Quaternion);
}
function ensureFloat32Array(a) {
  return _ensureClassFromArg(a, Float32Array);
}
function toLowerCaseString(value2) {
  return defaults(value2, "").toString().toLowerCase();
}
var Registry = function Registry2(name) {
  this.name = name;
  this._dict = {};
};
var prototypeAccessors = {names: {}};
Registry.prototype.add = function add(key, value2) {
  this._dict[toLowerCaseString(key)] = value2;
};
Registry.prototype.get = function get(key) {
  return this._dict[toLowerCaseString(key)];
};
prototypeAccessors.names.get = function() {
  return Object.keys(this._dict);
};
Object.defineProperties(Registry.prototype, prototypeAccessors);
function getWorkerDeps(vars) {
  var deps = vars;
  vars.forEach(function(sym) {
    if (sym.__deps) {
      Array.prototype.push.apply(deps, getWorkerDeps(sym.__deps));
    }
  });
  return deps;
}
function makeWorkerString(vars) {
  var deps = uniqueArray(getWorkerDeps(vars));
  return deps.map(function(sym) {
    return sym.toString();
  }).join("\n\n\n");
}
function onmessage(e) {
  var name = e.data.__name;
  var postId = e.data.__postId;
  if (name === void 0) {
    console.error("message __name undefined");
  } else if (self.func === void 0) {
    console.error("worker func undefined", name);
  } else {
    var callback = function(aMessage, transferList) {
      aMessage = aMessage || {};
      if (postId !== void 0) {
        aMessage.__postId = postId;
      }
      try {
        self.postMessage(aMessage, transferList);
      } catch (error) {
        console.error("self.postMessage:", error);
        self.postMessage(aMessage);
      }
    };
    self.func(e, callback);
  }
}
function makeWorkerBlob(func3, deps) {
  var str = "'use strict';\n\n" + makeWorkerString(deps);
  str += "\n\n\nself.func = " + func3.toString() + ";";
  str += "\n\n\nself.onmessage = " + onmessage.toString() + ";";
  return new window.Blob([str], {type: "application/javascript"});
}
var WorkerRegistry$1 = function WorkerRegistry() {
  this.activeWorkerCount = 0;
  this._funcDict = {};
  this._depsDict = {};
  this._blobDict = {};
};
WorkerRegistry$1.prototype.add = function add2(name, func3, deps) {
  this._funcDict[name] = func3;
  this._depsDict[name] = deps;
};
WorkerRegistry$1.prototype.get = function get2(name) {
  if (!this._blobDict[name]) {
    this._blobDict[name] = makeWorkerBlob(this._funcDict[name], this._depsDict[name]);
  }
  return this._blobDict[name];
};
function degToRad(deg) {
  return deg * 0.01745;
}
function radToDeg(rad) {
  return rad * 57.29578;
}
var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
var uuid = new Array(36);
function generateUUID() {
  var rnd2 = 0;
  var r;
  for (var i = 0; i < 36; i++) {
    if (i === 8 || i === 13 || i === 18 || i === 23) {
      uuid[i] = "-";
    } else if (i === 14) {
      uuid[i] = "4";
    } else {
      if (rnd2 <= 2) {
        rnd2 = 33554432 + Math.random() * 16777216 | 0;
      }
      r = rnd2 & 15;
      rnd2 = rnd2 >> 4;
      uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
    }
  }
  return uuid.join("");
}
function countSetBits(i) {
  i = i - (i >> 1 & 1431655765);
  i = (i & 858993459) + (i >> 2 & 858993459);
  return (i + (i >> 4) & 252645135) * 16843009 >> 24;
}
function normalize(value2, min, max2) {
  return (value2 - min) / (max2 - min);
}
function clamp(value2, min, max2) {
  return Math.max(min, Math.min(max2, value2));
}
function pclamp(value2) {
  return clamp(value2, 0, 100);
}
function saturate(value2) {
  return clamp(value2, 0, 1);
}
function lerp(start, stop2, alpha) {
  return start + (stop2 - start) * alpha;
}
function spline(p0, p1, p2, p3, t, tension) {
  var v0 = (p2 - p0) * tension;
  var v1 = (p3 - p1) * tension;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function smoothstep(min, max2, x) {
  x = saturate(normalize(x, min, max2));
  return x * x * (3 - 2 * x);
}
function almostIdentity(value2, start, stop2) {
  if (value2 > start) {
    return value2;
  }
  var a = 2 * stop2 - start;
  var b = 2 * start - 3 * stop2;
  var t = value2 / start;
  return (a * t + b) * t * t + stop2;
}
/**
 * @license
 *
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2015, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
var Color$1;
var DEG2RAD;
var LAB_CONSTANTS;
var PI;
var PITHIRD;
var RAD2DEG;
var TWOPI;
var _guess_formats;
var _guess_formats_sorted;
var _input;
var _interpolators;
var abs;
var atan2;
var bezier;
var blend;
var blend_f;
var brewer;
var burn;
var chroma;
var clip_rgb;
var cmyk2rgb;
var cos;
var css2rgb;
var darken;
var dodge;
var each;
var floor;
var hcg2rgb;
var hex2rgb;
var hsi2rgb;
var hsl2css;
var hsl2rgb;
var hsv2rgb;
var interpolate;
var interpolate_hsx;
var interpolate_lab;
var interpolate_num;
var interpolate_rgb;
var lab2lch;
var lab2rgb;
var lab_xyz;
var lch2lab;
var lch2rgb;
var lighten;
var limit;
var log;
var luminance_x;
var m;
var max;
var multiply;
var normal;
var num2rgb;
var overlay;
var pow;
var rgb2cmyk;
var rgb2css;
var rgb2hcg;
var rgb2hex;
var rgb2hsi;
var rgb2hsl;
var rgb2hsv;
var rgb2lab;
var rgb2lch;
var rgb2luminance;
var rgb2num;
var rgb2temperature;
var rgb2xyz;
var rgb_xyz;
var rnd;
var round;
var screen;
var sin;
var sqrt;
var temperature2rgb;
var type;
var unpack;
var w3cx11;
var xyz_lab;
var xyz_rgb;
var slice = [].slice;
type = function() {
  var classToType, len, name, o, ref;
  classToType = {};
  ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
  for (o = 0, len = ref.length; o < len; o++) {
    name = ref[o];
    classToType["[object " + name + "]"] = name.toLowerCase();
  }
  return function(obj) {
    var strType;
    strType = Object.prototype.toString.call(obj);
    return classToType[strType] || "object";
  };
}();
limit = function(x, min, max2) {
  if (min == null) {
    min = 0;
  }
  if (max2 == null) {
    max2 = 1;
  }
  if (x < min) {
    x = min;
  }
  if (x > max2) {
    x = max2;
  }
  return x;
};
unpack = function(args) {
  if (args.length >= 3) {
    return [].slice.call(args);
  } else {
    return args[0];
  }
};
clip_rgb = function(rgb) {
  var i, o;
  rgb._clipped = false;
  rgb._unclipped = rgb.slice(0);
  for (i = o = 0; o < 3; i = ++o) {
    if (i < 3) {
      if (rgb[i] < 0 || rgb[i] > 255) {
        rgb._clipped = true;
      }
      if (rgb[i] < 0) {
        rgb[i] = 0;
      }
      if (rgb[i] > 255) {
        rgb[i] = 255;
      }
    } else if (i === 3) {
      if (rgb[i] < 0) {
        rgb[i] = 0;
      }
      if (rgb[i] > 1) {
        rgb[i] = 1;
      }
    }
  }
  if (!rgb._clipped) {
    delete rgb._unclipped;
  }
  return rgb;
};
PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
TWOPI = PI * 2;
PITHIRD = PI / 3;
DEG2RAD = PI / 180;
RAD2DEG = 180 / PI;
chroma = function() {
  if (arguments[0] instanceof Color$1) {
    return arguments[0];
  }
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, arguments, function() {
  });
};
_interpolators = [];
chroma.version = "1.3.3";
_input = {};
_guess_formats = [];
_guess_formats_sorted = false;
Color$1 = function() {
  function Color2() {
    var arguments$1 = arguments;
    var arg, args, chk, len, len1, me, mode, o, w;
    me = this;
    args = [];
    for (o = 0, len = arguments.length; o < len; o++) {
      arg = arguments$1[o];
      if (arg != null) {
        args.push(arg);
      }
    }
    mode = args[args.length - 1];
    if (_input[mode] != null) {
      me._rgb = clip_rgb(_input[mode](unpack(args.slice(0, -1))));
    } else {
      if (!_guess_formats_sorted) {
        _guess_formats = _guess_formats.sort(function(a, b) {
          return b.p - a.p;
        });
        _guess_formats_sorted = true;
      }
      for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
        chk = _guess_formats[w];
        mode = chk.test.apply(chk, args);
        if (mode) {
          break;
        }
      }
      if (mode) {
        me._rgb = clip_rgb(_input[mode].apply(_input, args));
      }
    }
    if (me._rgb == null) {
      console.warn("unknown format: " + args);
    }
    if (me._rgb == null) {
      me._rgb = [0, 0, 0];
    }
    if (me._rgb.length === 3) {
      me._rgb.push(1);
    }
  }
  Color2.prototype.toString = function() {
    return this.hex();
  };
  return Color2;
}();
chroma._input = _input;
/**
    ColorBrewer colors for chroma.js

    Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
    Pennsylvania State University.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software distributed
    under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied. See the License for the
    specific language governing permissions and limitations under the License.

      @preserve
   */
chroma.brewer = brewer = {
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
};
(function() {
  var key, results;
  results = [];
  for (key in brewer) {
    results.push(brewer[key.toLowerCase()] = brewer[key]);
  }
  return results;
})();
w3cx11 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflower: "#6495ed",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
chroma.colors = w3cx11;
lab2rgb = function() {
  var a, args, b, g, l, r, x, y, z;
  args = unpack(arguments);
  l = args[0], a = args[1], b = args[2];
  y = (l + 16) / 116;
  x = isNaN(a) ? y : y + a / 500;
  z = isNaN(b) ? y : y - b / 200;
  y = LAB_CONSTANTS.Yn * lab_xyz(y);
  x = LAB_CONSTANTS.Xn * lab_xyz(x);
  z = LAB_CONSTANTS.Zn * lab_xyz(z);
  r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
  g = xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z);
  b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
  return [r, g, b, args.length > 3 ? args[3] : 1];
};
xyz_rgb = function(r) {
  return 255 * (r <= 304e-5 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055);
};
lab_xyz = function(t) {
  if (t > LAB_CONSTANTS.t1) {
    return t * t * t;
  } else {
    return LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
  }
};
LAB_CONSTANTS = {
  Kn: 18,
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  t1: 0.206896552,
  t2: 0.12841855,
  t3: 8856452e-9
};
rgb2lab = function() {
  var b, g, r, ref, ref1, x, y, z;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
  return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
};
rgb_xyz = function(r) {
  if ((r /= 255) <= 0.04045) {
    return r / 12.92;
  } else {
    return pow((r + 0.055) / 1.055, 2.4);
  }
};
xyz_lab = function(t) {
  if (t > LAB_CONSTANTS.t3) {
    return pow(t, 1 / 3);
  } else {
    return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
  }
};
rgb2xyz = function() {
  var b, g, r, ref, x, y, z;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  r = rgb_xyz(r);
  g = rgb_xyz(g);
  b = rgb_xyz(b);
  x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn);
  y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS.Yn);
  z = xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn);
  return [x, y, z];
};
chroma.lab = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["lab"]), function() {
  });
};
_input.lab = lab2rgb;
Color$1.prototype.lab = function() {
  return rgb2lab(this._rgb);
};
bezier = function(colors) {
  var I, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;
  colors = function() {
    var len, o, results;
    results = [];
    for (o = 0, len = colors.length; o < len; o++) {
      c = colors[o];
      results.push(chroma(c));
    }
    return results;
  }();
  if (colors.length === 2) {
    ref = function() {
      var len, o, results;
      results = [];
      for (o = 0, len = colors.length; o < len; o++) {
        c = colors[o];
        results.push(c.lab());
      }
      return results;
    }(), lab0 = ref[0], lab1 = ref[1];
    I = function(t) {
      var i, lab;
      lab = function() {
        var o, results;
        results = [];
        for (i = o = 0; o <= 2; i = ++o) {
          results.push(lab0[i] + t * (lab1[i] - lab0[i]));
        }
        return results;
      }();
      return chroma.lab.apply(chroma, lab);
    };
  } else if (colors.length === 3) {
    ref1 = function() {
      var len, o, results;
      results = [];
      for (o = 0, len = colors.length; o < len; o++) {
        c = colors[o];
        results.push(c.lab());
      }
      return results;
    }(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];
    I = function(t) {
      var i, lab;
      lab = function() {
        var o, results;
        results = [];
        for (i = o = 0; o <= 2; i = ++o) {
          results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
        }
        return results;
      }();
      return chroma.lab.apply(chroma, lab);
    };
  } else if (colors.length === 4) {
    ref2 = function() {
      var len, o, results;
      results = [];
      for (o = 0, len = colors.length; o < len; o++) {
        c = colors[o];
        results.push(c.lab());
      }
      return results;
    }(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];
    I = function(t) {
      var i, lab;
      lab = function() {
        var o, results;
        results = [];
        for (i = o = 0; o <= 2; i = ++o) {
          results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
        }
        return results;
      }();
      return chroma.lab.apply(chroma, lab);
    };
  } else if (colors.length === 5) {
    I0 = bezier(colors.slice(0, 3));
    I1 = bezier(colors.slice(2, 5));
    I = function(t) {
      if (t < 0.5) {
        return I0(t * 2);
      } else {
        return I1((t - 0.5) * 2);
      }
    };
  }
  return I;
};
chroma.bezier = function(colors) {
  var f;
  f = bezier(colors);
  f.scale = function() {
    return chroma.scale(f);
  };
  return f;
};
chroma.cubehelix = function(start, rotations, hue, gamma, lightness) {
  var dh, dl, f;
  if (start == null) {
    start = 300;
  }
  if (rotations == null) {
    rotations = -1.5;
  }
  if (hue == null) {
    hue = 1;
  }
  if (gamma == null) {
    gamma = 1;
  }
  if (lightness == null) {
    lightness = [0, 1];
  }
  dh = 0;
  if (type(lightness) === "array") {
    dl = lightness[1] - lightness[0];
  } else {
    dl = 0;
    lightness = [lightness, lightness];
  }
  f = function(fract) {
    var a, amp, b, cos_a, g, h, l, r, sin_a;
    a = TWOPI * ((start + 120) / 360 + rotations * fract);
    l = pow(lightness[0] + dl * fract, gamma);
    h = dh !== 0 ? hue[0] + fract * dh : hue;
    amp = h * l * (1 - l) / 2;
    cos_a = cos(a);
    sin_a = sin(a);
    r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
    g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
    b = l + amp * (1.97294 * cos_a);
    return chroma(clip_rgb([r * 255, g * 255, b * 255]));
  };
  f.start = function(s) {
    if (s == null) {
      return start;
    }
    start = s;
    return f;
  };
  f.rotations = function(r) {
    if (r == null) {
      return rotations;
    }
    rotations = r;
    return f;
  };
  f.gamma = function(g) {
    if (g == null) {
      return gamma;
    }
    gamma = g;
    return f;
  };
  f.hue = function(h) {
    if (h == null) {
      return hue;
    }
    hue = h;
    if (type(hue) === "array") {
      dh = hue[1] - hue[0];
      if (dh === 0) {
        hue = hue[1];
      }
    } else {
      dh = 0;
    }
    return f;
  };
  f.lightness = function(h) {
    if (h == null) {
      return lightness;
    }
    if (type(h) === "array") {
      lightness = h;
      dl = h[1] - h[0];
    } else {
      lightness = [h, h];
      dl = 0;
    }
    return f;
  };
  f.scale = function() {
    return chroma.scale(f);
  };
  f.hue(hue);
  return f;
};
chroma.random = function() {
  var code, digits, o;
  digits = "0123456789abcdef";
  code = "#";
  for (o = 0; o < 6; ++o) {
    code += digits.charAt(floor(Math.random() * 16));
  }
  return new Color$1(code);
};
chroma.average = function(colors, mode) {
  var A, alpha, c, cnt, dx, dy, first, i, l, len, o, xyz, xyz2;
  if (mode == null) {
    mode = "rgb";
  }
  l = colors.length;
  colors = colors.map(function(c2) {
    return chroma(c2);
  });
  first = colors.splice(0, 1)[0];
  xyz = first.get(mode);
  cnt = [];
  dx = 0;
  dy = 0;
  for (i in xyz) {
    xyz[i] = xyz[i] || 0;
    cnt.push(!isNaN(xyz[i]) ? 1 : 0);
    if (mode.charAt(i) === "h" && !isNaN(xyz[i])) {
      A = xyz[i] / 180 * PI;
      dx += cos(A);
      dy += sin(A);
    }
  }
  alpha = first.alpha();
  for (o = 0, len = colors.length; o < len; o++) {
    c = colors[o];
    xyz2 = c.get(mode);
    alpha += c.alpha();
    for (i in xyz) {
      if (!isNaN(xyz2[i])) {
        xyz[i] += xyz2[i];
        cnt[i] += 1;
        if (mode.charAt(i) === "h") {
          A = xyz[i] / 180 * PI;
          dx += cos(A);
          dy += sin(A);
        }
      }
    }
  }
  for (i in xyz) {
    xyz[i] = xyz[i] / cnt[i];
    if (mode.charAt(i) === "h") {
      A = atan2(dy / cnt[i], dx / cnt[i]) / PI * 180;
      while (A < 0) {
        A += 360;
      }
      while (A >= 360) {
        A -= 360;
      }
      xyz[i] = A;
    }
  }
  return chroma(xyz, mode).alpha(alpha / l);
};
_input.rgb = function() {
  var k, ref, results, v;
  ref = unpack(arguments);
  results = [];
  for (k in ref) {
    v = ref[k];
    results.push(v);
  }
  return results;
};
chroma.rgb = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["rgb"]), function() {
  });
};
Color$1.prototype.rgb = function(round2) {
  if (round2 == null) {
    round2 = true;
  }
  if (round2) {
    return this._rgb.map(Math.round).slice(0, 3);
  } else {
    return this._rgb.slice(0, 3);
  }
};
Color$1.prototype.rgba = function(round2) {
  if (round2 == null) {
    round2 = true;
  }
  if (!round2) {
    return this._rgb.slice(0);
  }
  return [Math.round(this._rgb[0]), Math.round(this._rgb[1]), Math.round(this._rgb[2]), this._rgb[3]];
};
_guess_formats.push({
  p: 3,
  test: function(n) {
    var a;
    a = unpack(arguments);
    if (type(a) === "array" && a.length === 3) {
      return "rgb";
    }
    if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
      return "rgb";
    }
  }
});
hex2rgb = function(hex) {
  var a, b, g, r, rgb, u;
  if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
    if (hex.length === 4 || hex.length === 7) {
      hex = hex.substr(1);
    }
    if (hex.length === 3) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    u = parseInt(hex, 16);
    r = u >> 16;
    g = u >> 8 & 255;
    b = u & 255;
    return [r, g, b, 1];
  }
  if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
    if (hex.length === 9) {
      hex = hex.substr(1);
    }
    u = parseInt(hex, 16);
    r = u >> 24 & 255;
    g = u >> 16 & 255;
    b = u >> 8 & 255;
    a = round((u & 255) / 255 * 100) / 100;
    return [r, g, b, a];
  }
  if (_input.css != null && (rgb = _input.css(hex))) {
    return rgb;
  }
  throw "unknown color: " + hex;
};
rgb2hex = function(channels, mode) {
  var a, b, g, hxa, r, str, u;
  if (mode == null) {
    mode = "rgb";
  }
  r = channels[0], g = channels[1], b = channels[2], a = channels[3];
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);
  u = r << 16 | g << 8 | b;
  str = "000000" + u.toString(16);
  str = str.substr(str.length - 6);
  hxa = "0" + round(a * 255).toString(16);
  hxa = hxa.substr(hxa.length - 2);
  return "#" + function() {
    switch (mode.toLowerCase()) {
      case "rgba":
        return str + hxa;
      case "argb":
        return hxa + str;
      default:
        return str;
    }
  }();
};
_input.hex = function(h) {
  return hex2rgb(h);
};
chroma.hex = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["hex"]), function() {
  });
};
Color$1.prototype.hex = function(mode) {
  if (mode == null) {
    mode = "rgb";
  }
  return rgb2hex(this._rgb, mode);
};
_guess_formats.push({
  p: 4,
  test: function(n) {
    if (arguments.length === 1 && type(n) === "string") {
      return "hex";
    }
  }
});
hsl2rgb = function() {
  var args, b, c, g, h, i, l, o, r, ref, s, t1, t2, t3;
  args = unpack(arguments);
  h = args[0], s = args[1], l = args[2];
  if (s === 0) {
    r = g = b = l * 255;
  } else {
    t3 = [0, 0, 0];
    c = [0, 0, 0];
    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    t1 = 2 * l - t2;
    h /= 360;
    t3[0] = h + 1 / 3;
    t3[1] = h;
    t3[2] = h - 1 / 3;
    for (i = o = 0; o <= 2; i = ++o) {
      if (t3[i] < 0) {
        t3[i] += 1;
      }
      if (t3[i] > 1) {
        t3[i] -= 1;
      }
      if (6 * t3[i] < 1) {
        c[i] = t1 + (t2 - t1) * 6 * t3[i];
      } else if (2 * t3[i] < 1) {
        c[i] = t2;
      } else if (3 * t3[i] < 2) {
        c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
      } else {
        c[i] = t1;
      }
    }
    ref = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref[0], g = ref[1], b = ref[2];
  }
  if (args.length > 3) {
    return [r, g, b, args[3]];
  } else {
    return [r, g, b];
  }
};
rgb2hsl = function(r, g, b) {
  var h, l, min, ref, s;
  if (r !== void 0 && r.length >= 3) {
    ref = r, r = ref[0], g = ref[1], b = ref[2];
  }
  r /= 255;
  g /= 255;
  b /= 255;
  min = Math.min(r, g, b);
  max = Math.max(r, g, b);
  l = (max + min) / 2;
  if (max === min) {
    s = 0;
    h = Number.NaN;
  } else {
    s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
  }
  if (r === max) {
    h = (g - b) / (max - min);
  } else if (g === max) {
    h = 2 + (b - r) / (max - min);
  } else if (b === max) {
    h = 4 + (r - g) / (max - min);
  }
  h *= 60;
  if (h < 0) {
    h += 360;
  }
  return [h, s, l];
};
chroma.hsl = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["hsl"]), function() {
  });
};
_input.hsl = hsl2rgb;
Color$1.prototype.hsl = function() {
  return rgb2hsl(this._rgb);
};
hsv2rgb = function() {
  var args, b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, t, v;
  args = unpack(arguments);
  h = args[0], s = args[1], v = args[2];
  v *= 255;
  if (s === 0) {
    r = g = b = v;
  } else {
    if (h === 360) {
      h = 0;
    }
    if (h > 360) {
      h -= 360;
    }
    if (h < 0) {
      h += 360;
    }
    h /= 60;
    i = floor(h);
    f = h - i;
    p = v * (1 - s);
    q = v * (1 - s * f);
    t = v * (1 - s * (1 - f));
    switch (i) {
      case 0:
        ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
        break;
      case 1:
        ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
        break;
      case 2:
        ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
        break;
      case 3:
        ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
        break;
      case 4:
        ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
        break;
      case 5:
        ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
    }
  }
  return [r, g, b, args.length > 3 ? args[3] : 1];
};
rgb2hsv = function() {
  var b, delta, g, h, min, r, ref, s, v;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  min = Math.min(r, g, b);
  max = Math.max(r, g, b);
  delta = max - min;
  v = max / 255;
  if (max === 0) {
    h = Number.NaN;
    s = 0;
  } else {
    s = delta / max;
    if (r === max) {
      h = (g - b) / delta;
    }
    if (g === max) {
      h = 2 + (b - r) / delta;
    }
    if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h *= 60;
    if (h < 0) {
      h += 360;
    }
  }
  return [h, s, v];
};
chroma.hsv = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["hsv"]), function() {
  });
};
_input.hsv = hsv2rgb;
Color$1.prototype.hsv = function() {
  return rgb2hsv(this._rgb);
};
num2rgb = function(num) {
  var b, g, r;
  if (type(num) === "number" && num >= 0 && num <= 16777215) {
    r = num >> 16;
    g = num >> 8 & 255;
    b = num & 255;
    return [r, g, b, 1];
  }
  console.warn("unknown num color: " + num);
  return [0, 0, 0, 1];
};
rgb2num = function() {
  var b, g, r, ref;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  return (r << 16) + (g << 8) + b;
};
chroma.num = function(num) {
  return new Color$1(num, "num");
};
Color$1.prototype.num = function(mode) {
  if (mode == null) {
    mode = "rgb";
  }
  return rgb2num(this._rgb, mode);
};
_input.num = num2rgb;
_guess_formats.push({
  p: 1,
  test: function(n) {
    if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 16777215) {
      return "num";
    }
  }
});
hcg2rgb = function() {
  var _c, _g, args, b, c, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, t, v;
  args = unpack(arguments);
  h = args[0], c = args[1], _g = args[2];
  c = c / 100;
  g = g / 100 * 255;
  _c = c * 255;
  if (c === 0) {
    r = g = b = _g;
  } else {
    if (h === 360) {
      h = 0;
    }
    if (h > 360) {
      h -= 360;
    }
    if (h < 0) {
      h += 360;
    }
    h /= 60;
    i = floor(h);
    f = h - i;
    p = _g * (1 - c);
    q = p + _c * (1 - f);
    t = p + _c * f;
    v = p + _c;
    switch (i) {
      case 0:
        ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
        break;
      case 1:
        ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
        break;
      case 2:
        ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
        break;
      case 3:
        ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
        break;
      case 4:
        ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
        break;
      case 5:
        ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
    }
  }
  return [r, g, b, args.length > 3 ? args[3] : 1];
};
rgb2hcg = function() {
  var _g, b, c, delta, g, h, min, r, ref;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  min = Math.min(r, g, b);
  max = Math.max(r, g, b);
  delta = max - min;
  c = delta * 100 / 255;
  _g = min / (255 - delta) * 100;
  if (delta === 0) {
    h = Number.NaN;
  } else {
    if (r === max) {
      h = (g - b) / delta;
    }
    if (g === max) {
      h = 2 + (b - r) / delta;
    }
    if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h *= 60;
    if (h < 0) {
      h += 360;
    }
  }
  return [h, c, _g];
};
chroma.hcg = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["hcg"]), function() {
  });
};
_input.hcg = hcg2rgb;
Color$1.prototype.hcg = function() {
  return rgb2hcg(this._rgb);
};
css2rgb = function(css) {
  var aa, ab, hsl, i, m2, o, rgb, w;
  css = css.toLowerCase();
  if (chroma.colors != null && chroma.colors[css]) {
    return hex2rgb(chroma.colors[css]);
  }
  if (m2 = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
    rgb = m2.slice(1, 4);
    for (i = o = 0; o <= 2; i = ++o) {
      rgb[i] = +rgb[i];
    }
    rgb[3] = 1;
  } else if (m2 = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
    rgb = m2.slice(1, 5);
    for (i = w = 0; w <= 3; i = ++w) {
      rgb[i] = +rgb[i];
    }
  } else if (m2 = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
    rgb = m2.slice(1, 4);
    for (i = aa = 0; aa <= 2; i = ++aa) {
      rgb[i] = round(rgb[i] * 2.55);
    }
    rgb[3] = 1;
  } else if (m2 = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
    rgb = m2.slice(1, 5);
    for (i = ab = 0; ab <= 2; i = ++ab) {
      rgb[i] = round(rgb[i] * 2.55);
    }
    rgb[3] = +rgb[3];
  } else if (m2 = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
    hsl = m2.slice(1, 4);
    hsl[1] *= 0.01;
    hsl[2] *= 0.01;
    rgb = hsl2rgb(hsl);
    rgb[3] = 1;
  } else if (m2 = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
    hsl = m2.slice(1, 4);
    hsl[1] *= 0.01;
    hsl[2] *= 0.01;
    rgb = hsl2rgb(hsl);
    rgb[3] = +m2[4];
  }
  return rgb;
};
rgb2css = function(rgba) {
  var mode;
  mode = rgba[3] < 1 ? "rgba" : "rgb";
  if (mode === "rgb") {
    return mode + "(" + rgba.slice(0, 3).map(round).join(",") + ")";
  } else if (mode === "rgba") {
    return mode + "(" + rgba.slice(0, 3).map(round).join(",") + "," + rgba[3] + ")";
  } else
    ;
};
rnd = function(a) {
  return round(a * 100) / 100;
};
hsl2css = function(hsl, alpha) {
  var mode;
  mode = alpha < 1 ? "hsla" : "hsl";
  hsl[0] = rnd(hsl[0] || 0);
  hsl[1] = rnd(hsl[1] * 100) + "%";
  hsl[2] = rnd(hsl[2] * 100) + "%";
  if (mode === "hsla") {
    hsl[3] = alpha;
  }
  return mode + "(" + hsl.join(",") + ")";
};
_input.css = function(h) {
  return css2rgb(h);
};
chroma.css = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["css"]), function() {
  });
};
Color$1.prototype.css = function(mode) {
  if (mode == null) {
    mode = "rgb";
  }
  if (mode.slice(0, 3) === "rgb") {
    return rgb2css(this._rgb);
  } else if (mode.slice(0, 3) === "hsl") {
    return hsl2css(this.hsl(), this.alpha());
  }
};
_input.named = function(name) {
  return hex2rgb(w3cx11[name]);
};
_guess_formats.push({
  p: 5,
  test: function(n) {
    if (arguments.length === 1 && w3cx11[n] != null) {
      return "named";
    }
  }
});
Color$1.prototype.name = function(n) {
  var h, k;
  if (arguments.length) {
    if (w3cx11[n]) {
      this._rgb = hex2rgb(w3cx11[n]);
    }
    this._rgb[3] = 1;
  }
  h = this.hex();
  for (k in w3cx11) {
    if (h === w3cx11[k]) {
      return k;
    }
  }
  return h;
};
lch2lab = function() {
  var c, h, l, ref;
  ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
  h = h * DEG2RAD;
  return [l, cos(h) * c, sin(h) * c];
};
lch2rgb = function() {
  var L, a, args, b, c, g, h, l, r, ref, ref1;
  args = unpack(arguments);
  l = args[0], c = args[1], h = args[2];
  ref = lch2lab(l, c, h), L = ref[0], a = ref[1], b = ref[2];
  ref1 = lab2rgb(L, a, b), r = ref1[0], g = ref1[1], b = ref1[2];
  return [r, g, b, args.length > 3 ? args[3] : 1];
};
lab2lch = function() {
  var a, b, c, h, l, ref;
  ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
  c = sqrt(a * a + b * b);
  h = (atan2(b, a) * RAD2DEG + 360) % 360;
  if (round(c * 1e4) === 0) {
    h = Number.NaN;
  }
  return [l, c, h];
};
rgb2lch = function() {
  var a, b, g, l, r, ref, ref1;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
  return lab2lch(l, a, b);
};
chroma.lch = function() {
  var args;
  args = unpack(arguments);
  return new Color$1(args, "lch");
};
chroma.hcl = function() {
  var args;
  args = unpack(arguments);
  return new Color$1(args, "hcl");
};
_input.lch = lch2rgb;
_input.hcl = function() {
  var c, h, l, ref;
  ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
  return lch2rgb([l, c, h]);
};
Color$1.prototype.lch = function() {
  return rgb2lch(this._rgb);
};
Color$1.prototype.hcl = function() {
  return rgb2lch(this._rgb).reverse();
};
rgb2cmyk = function(mode) {
  var b, c, f, g, k, m2, r, ref, y;
  if (mode == null) {
    mode = "rgb";
  }
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  r = r / 255;
  g = g / 255;
  b = b / 255;
  k = 1 - Math.max(r, Math.max(g, b));
  f = k < 1 ? 1 / (1 - k) : 0;
  c = (1 - r - k) * f;
  m2 = (1 - g - k) * f;
  y = (1 - b - k) * f;
  return [c, m2, y, k];
};
cmyk2rgb = function() {
  var alpha, args, b, c, g, k, m2, r, y;
  args = unpack(arguments);
  c = args[0], m2 = args[1], y = args[2], k = args[3];
  alpha = args.length > 4 ? args[4] : 1;
  if (k === 1) {
    return [0, 0, 0, alpha];
  }
  r = c >= 1 ? 0 : 255 * (1 - c) * (1 - k);
  g = m2 >= 1 ? 0 : 255 * (1 - m2) * (1 - k);
  b = y >= 1 ? 0 : 255 * (1 - y) * (1 - k);
  return [r, g, b, alpha];
};
_input.cmyk = function() {
  return cmyk2rgb(unpack(arguments));
};
chroma.cmyk = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["cmyk"]), function() {
  });
};
Color$1.prototype.cmyk = function() {
  return rgb2cmyk(this._rgb);
};
_input.gl = function() {
  var i, k, o, rgb, v;
  rgb = function() {
    var ref, results;
    ref = unpack(arguments);
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(v);
    }
    return results;
  }.apply(this, arguments);
  for (i = o = 0; o <= 2; i = ++o) {
    rgb[i] *= 255;
  }
  return rgb;
};
chroma.gl = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["gl"]), function() {
  });
};
Color$1.prototype.gl = function() {
  var rgb;
  rgb = this._rgb;
  return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
};
rgb2luminance = function(r, g, b) {
  var ref;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  r = luminance_x(r);
  g = luminance_x(g);
  b = luminance_x(b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
};
luminance_x = function(x) {
  x /= 255;
  if (x <= 0.03928) {
    return x / 12.92;
  } else {
    return pow((x + 0.055) / 1.055, 2.4);
  }
};
_interpolators = [];
interpolate = function(col1, col2, f, m2) {
  var interpol, len, o, res;
  if (f == null) {
    f = 0.5;
  }
  if (m2 == null) {
    m2 = "rgb";
  }
  if (type(col1) !== "object") {
    col1 = chroma(col1);
  }
  if (type(col2) !== "object") {
    col2 = chroma(col2);
  }
  for (o = 0, len = _interpolators.length; o < len; o++) {
    interpol = _interpolators[o];
    if (m2 === interpol[0]) {
      res = interpol[1](col1, col2, f, m2);
      break;
    }
  }
  if (res == null) {
    throw "color mode " + m2 + " is not supported";
  }
  return res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
};
chroma.interpolate = interpolate;
Color$1.prototype.interpolate = function(col2, f, m2) {
  return interpolate(this, col2, f, m2);
};
chroma.mix = interpolate;
Color$1.prototype.mix = Color$1.prototype.interpolate;
interpolate_rgb = function(col1, col2, f, m2) {
  var xyz0, xyz1;
  xyz0 = col1._rgb;
  xyz1 = col2._rgb;
  return new Color$1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m2);
};
_interpolators.push(["rgb", interpolate_rgb]);
Color$1.prototype.luminance = function(lum, mode) {
  var cur_lum, eps, max_iter, test;
  if (mode == null) {
    mode = "rgb";
  }
  if (!arguments.length) {
    return rgb2luminance(this._rgb);
  }
  if (lum === 0) {
    this._rgb = [0, 0, 0, this._rgb[3]];
  } else if (lum === 1) {
    this._rgb = [255, 255, 255, this._rgb[3]];
  } else {
    eps = 1e-7;
    max_iter = 20;
    test = function(l, h) {
      var lm, m2;
      m2 = l.interpolate(h, 0.5, mode);
      lm = m2.luminance();
      if (Math.abs(lum - lm) < eps || !max_iter--) {
        return m2;
      }
      if (lm > lum) {
        return test(l, m2);
      }
      return test(m2, h);
    };
    cur_lum = rgb2luminance(this._rgb);
    this._rgb = (cur_lum > lum ? test(chroma("black"), this) : test(this, chroma("white"))).rgba();
  }
  return this;
};
temperature2rgb = function(kelvin) {
  var b, g, r, temp;
  temp = kelvin / 100;
  if (temp < 66) {
    r = 255;
    g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
    b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
  } else {
    r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
    g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
    b = 255;
  }
  return [r, g, b];
};
rgb2temperature = function() {
  var b, eps, maxTemp, minTemp, r, ref, rgb, temp;
  ref = unpack(arguments), r = ref[0], ref[1], b = ref[2];
  minTemp = 1e3;
  maxTemp = 4e4;
  eps = 0.4;
  while (maxTemp - minTemp > eps) {
    temp = (maxTemp + minTemp) * 0.5;
    rgb = temperature2rgb(temp);
    if (rgb[2] / rgb[0] >= b / r) {
      maxTemp = temp;
    } else {
      minTemp = temp;
    }
  }
  return round(temp);
};
chroma.temperature = chroma.kelvin = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["temperature"]), function() {
  });
};
_input.temperature = _input.kelvin = _input.K = temperature2rgb;
Color$1.prototype.temperature = function() {
  return rgb2temperature(this._rgb);
};
Color$1.prototype.kelvin = Color$1.prototype.temperature;
chroma.contrast = function(a, b) {
  var l1, l2, ref, ref1;
  if ((ref = type(a)) === "string" || ref === "number") {
    a = new Color$1(a);
  }
  if ((ref1 = type(b)) === "string" || ref1 === "number") {
    b = new Color$1(b);
  }
  l1 = a.luminance();
  l2 = b.luminance();
  if (l1 > l2) {
    return (l1 + 0.05) / (l2 + 0.05);
  } else {
    return (l2 + 0.05) / (l1 + 0.05);
  }
};
chroma.distance = function(a, b, mode) {
  var d, i, l1, l2, ref, ref1, sum_sq;
  if (mode == null) {
    mode = "lab";
  }
  if ((ref = type(a)) === "string" || ref === "number") {
    a = new Color$1(a);
  }
  if ((ref1 = type(b)) === "string" || ref1 === "number") {
    b = new Color$1(b);
  }
  l1 = a.get(mode);
  l2 = b.get(mode);
  sum_sq = 0;
  for (i in l1) {
    d = (l1[i] || 0) - (l2[i] || 0);
    sum_sq += d * d;
  }
  return Math.sqrt(sum_sq);
};
chroma.deltaE = function(a, b, L, C) {
  var L1, L2, a1, a2, b1, b2, c1, c2, c4, dH2, delA, delB, delC, delL, f, h1, ref, ref1, ref2, ref3, sc, sh, sl, t, v1, v2, v3;
  if (L == null) {
    L = 1;
  }
  if (C == null) {
    C = 1;
  }
  if ((ref = type(a)) === "string" || ref === "number") {
    a = new Color$1(a);
  }
  if ((ref1 = type(b)) === "string" || ref1 === "number") {
    b = new Color$1(b);
  }
  ref2 = a.lab(), L1 = ref2[0], a1 = ref2[1], b1 = ref2[2];
  ref3 = b.lab(), L2 = ref3[0], a2 = ref3[1], b2 = ref3[2];
  c1 = sqrt(a1 * a1 + b1 * b1);
  c2 = sqrt(a2 * a2 + b2 * b2);
  sl = L1 < 16 ? 0.511 : 0.040975 * L1 / (1 + 0.01765 * L1);
  sc = 0.0638 * c1 / (1 + 0.0131 * c1) + 0.638;
  h1 = c1 < 1e-6 ? 0 : atan2(b1, a1) * 180 / PI;
  while (h1 < 0) {
    h1 += 360;
  }
  while (h1 >= 360) {
    h1 -= 360;
  }
  t = h1 >= 164 && h1 <= 345 ? 0.56 + abs(0.2 * cos(PI * (h1 + 168) / 180)) : 0.36 + abs(0.4 * cos(PI * (h1 + 35) / 180));
  c4 = c1 * c1 * c1 * c1;
  f = sqrt(c4 / (c4 + 1900));
  sh = sc * (f * t + 1 - f);
  delL = L1 - L2;
  delC = c1 - c2;
  delA = a1 - a2;
  delB = b1 - b2;
  dH2 = delA * delA + delB * delB - delC * delC;
  v1 = delL / (L * sl);
  v2 = delC / (C * sc);
  v3 = sh;
  return sqrt(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));
};
Color$1.prototype.get = function(modechan) {
  var channel, i, me, mode, ref, src;
  me = this;
  ref = modechan.split("."), mode = ref[0], channel = ref[1];
  src = me[mode]();
  if (channel) {
    i = mode.indexOf(channel);
    if (i > -1) {
      return src[i];
    } else {
      return console.warn("unknown channel " + channel + " in mode " + mode);
    }
  } else {
    return src;
  }
};
Color$1.prototype.set = function(modechan, value2) {
  var channel, i, me, mode, ref, src;
  me = this;
  ref = modechan.split("."), mode = ref[0], channel = ref[1];
  if (channel) {
    src = me[mode]();
    i = mode.indexOf(channel);
    if (i > -1) {
      if (type(value2) === "string") {
        switch (value2.charAt(0)) {
          case "+":
            src[i] += +value2;
            break;
          case "-":
            src[i] += +value2;
            break;
          case "*":
            src[i] *= +value2.substr(1);
            break;
          case "/":
            src[i] /= +value2.substr(1);
            break;
          default:
            src[i] = +value2;
        }
      } else {
        src[i] = value2;
      }
    } else {
      console.warn("unknown channel " + channel + " in mode " + mode);
    }
  } else {
    src = value2;
  }
  return chroma(src, mode).alpha(me.alpha());
};
Color$1.prototype.clipped = function() {
  return this._rgb._clipped || false;
};
Color$1.prototype.alpha = function(a) {
  if (arguments.length) {
    return chroma.rgb([this._rgb[0], this._rgb[1], this._rgb[2], a]);
  }
  return this._rgb[3];
};
Color$1.prototype.darken = function(amount) {
  var lab, me;
  if (amount == null) {
    amount = 1;
  }
  me = this;
  lab = me.lab();
  lab[0] -= LAB_CONSTANTS.Kn * amount;
  return chroma.lab(lab).alpha(me.alpha());
};
Color$1.prototype.brighten = function(amount) {
  if (amount == null) {
    amount = 1;
  }
  return this.darken(-amount);
};
Color$1.prototype.darker = Color$1.prototype.darken;
Color$1.prototype.brighter = Color$1.prototype.brighten;
Color$1.prototype.saturate = function(amount) {
  var lch, me;
  if (amount == null) {
    amount = 1;
  }
  me = this;
  lch = me.lch();
  lch[1] += amount * LAB_CONSTANTS.Kn;
  if (lch[1] < 0) {
    lch[1] = 0;
  }
  return chroma.lch(lch).alpha(me.alpha());
};
Color$1.prototype.desaturate = function(amount) {
  if (amount == null) {
    amount = 1;
  }
  return this.saturate(-amount);
};
Color$1.prototype.premultiply = function() {
  var a, rgb;
  rgb = this.rgb();
  a = this.alpha();
  return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
};
blend = function(bottom, top, mode) {
  if (!blend[mode]) {
    throw "unknown blend mode " + mode;
  }
  return blend[mode](bottom, top);
};
blend_f = function(f) {
  return function(bottom, top) {
    var c0, c1;
    c0 = chroma(top).rgb();
    c1 = chroma(bottom).rgb();
    return chroma(f(c0, c1), "rgb");
  };
};
each = function(f) {
  return function(c0, c1) {
    var i, o, out;
    out = [];
    for (i = o = 0; o <= 3; i = ++o) {
      out[i] = f(c0[i], c1[i]);
    }
    return out;
  };
};
normal = function(a, b) {
  return a;
};
multiply = function(a, b) {
  return a * b / 255;
};
darken = function(a, b) {
  if (a > b) {
    return b;
  } else {
    return a;
  }
};
lighten = function(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
};
screen = function(a, b) {
  return 255 * (1 - (1 - a / 255) * (1 - b / 255));
};
overlay = function(a, b) {
  if (b < 128) {
    return 2 * a * b / 255;
  } else {
    return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
  }
};
burn = function(a, b) {
  return 255 * (1 - (1 - b / 255) / (a / 255));
};
dodge = function(a, b) {
  if (a === 255) {
    return 255;
  }
  a = 255 * (b / 255) / (1 - a / 255);
  if (a > 255) {
    return 255;
  } else {
    return a;
  }
};
blend.normal = blend_f(each(normal));
blend.multiply = blend_f(each(multiply));
blend.screen = blend_f(each(screen));
blend.overlay = blend_f(each(overlay));
blend.darken = blend_f(each(darken));
blend.lighten = blend_f(each(lighten));
blend.dodge = blend_f(each(dodge));
blend.burn = blend_f(each(burn));
chroma.blend = blend;
chroma.analyze = function(data) {
  var len, o, r, val;
  r = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  for (o = 0, len = data.length; o < len; o++) {
    val = data[o];
    if (val != null && !isNaN(val)) {
      r.values.push(val);
      r.sum += val;
      if (val < r.min) {
        r.min = val;
      }
      if (val > r.max) {
        r.max = val;
      }
      r.count += 1;
    }
  }
  r.domain = [r.min, r.max];
  r.limits = function(mode, num) {
    return chroma.limits(r, mode, num);
  };
  return r;
};
chroma.scale = function(colors, positions) {
  var _classes, _colorCache, _colors, _correctLightness, _domain, _max, _min, _mode, _nacol, _out, _padding, _pos, _spread, _useCache, f, getClass, getColor2, resetCache2, setColors, tmap;
  _mode = "rgb";
  _nacol = chroma("#ccc");
  _spread = 0;
  _domain = [0, 1];
  _pos = [];
  _padding = [0, 0];
  _classes = false;
  _colors = [];
  _out = false;
  _min = 0;
  _max = 1;
  _correctLightness = false;
  _colorCache = {};
  _useCache = true;
  setColors = function(colors2) {
    var c, col, o, ref, ref1, w;
    if (colors2 == null) {
      colors2 = ["#fff", "#000"];
    }
    if (colors2 != null && type(colors2) === "string" && chroma.brewer != null) {
      colors2 = chroma.brewer[colors2] || chroma.brewer[colors2.toLowerCase()] || colors2;
    }
    if (type(colors2) === "array") {
      colors2 = colors2.slice(0);
      for (c = o = 0, ref = colors2.length - 1; 0 <= ref ? o <= ref : o >= ref; c = 0 <= ref ? ++o : --o) {
        col = colors2[c];
        if (type(col) === "string") {
          colors2[c] = chroma(col);
        }
      }
      _pos.length = 0;
      for (c = w = 0, ref1 = colors2.length - 1; 0 <= ref1 ? w <= ref1 : w >= ref1; c = 0 <= ref1 ? ++w : --w) {
        _pos.push(c / (colors2.length - 1));
      }
    }
    resetCache2();
    return _colors = colors2;
  };
  getClass = function(value2) {
    var i, n;
    if (_classes != null) {
      n = _classes.length - 1;
      i = 0;
      while (i < n && value2 >= _classes[i]) {
        i++;
      }
      return i - 1;
    }
    return 0;
  };
  tmap = function(t) {
    return t;
  };
  getColor2 = function(val, bypassMap) {
    var c, col, i, k, o, p, ref, t;
    if (bypassMap == null) {
      bypassMap = false;
    }
    if (isNaN(val)) {
      return _nacol;
    }
    if (!bypassMap) {
      if (_classes && _classes.length > 2) {
        c = getClass(val);
        t = c / (_classes.length - 2);
        t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
      } else if (_max !== _min) {
        t = (val - _min) / (_max - _min);
        t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
        t = Math.min(1, Math.max(0, t));
      } else {
        t = 1;
      }
    } else {
      t = val;
    }
    if (!bypassMap) {
      t = tmap(t);
    }
    k = Math.floor(t * 1e4);
    if (_useCache && _colorCache[k]) {
      col = _colorCache[k];
    } else {
      if (type(_colors) === "array") {
        for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
          p = _pos[i];
          if (t <= p) {
            col = _colors[i];
            break;
          }
          if (t >= p && i === _pos.length - 1) {
            col = _colors[i];
            break;
          }
          if (t > p && t < _pos[i + 1]) {
            t = (t - p) / (_pos[i + 1] - p);
            col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
            break;
          }
        }
      } else if (type(_colors) === "function") {
        col = _colors(t);
      }
      if (_useCache) {
        _colorCache[k] = col;
      }
    }
    return col;
  };
  resetCache2 = function() {
    return _colorCache = {};
  };
  setColors(colors);
  f = function(v) {
    var c;
    c = chroma(getColor2(v));
    if (_out && c[_out]) {
      return c[_out]();
    } else {
      return c;
    }
  };
  f.classes = function(classes) {
    var d;
    if (classes != null) {
      if (type(classes) === "array") {
        _classes = classes;
        _domain = [classes[0], classes[classes.length - 1]];
      } else {
        d = chroma.analyze(_domain);
        if (classes === 0) {
          _classes = [d.min, d.max];
        } else {
          _classes = chroma.limits(d, "e", classes);
        }
      }
      return f;
    }
    return _classes;
  };
  f.domain = function(domain) {
    var c, d, k, len, o, ref, w;
    if (!arguments.length) {
      return _domain;
    }
    _min = domain[0];
    _max = domain[domain.length - 1];
    _pos = [];
    k = _colors.length;
    if (domain.length === k && _min !== _max) {
      for (o = 0, len = domain.length; o < len; o++) {
        d = domain[o];
        _pos.push((d - _min) / (_max - _min));
      }
    } else {
      for (c = w = 0, ref = k - 1; 0 <= ref ? w <= ref : w >= ref; c = 0 <= ref ? ++w : --w) {
        _pos.push(c / (k - 1));
      }
    }
    _domain = [_min, _max];
    return f;
  };
  f.mode = function(_m2) {
    if (!arguments.length) {
      return _mode;
    }
    _mode = _m2;
    resetCache2();
    return f;
  };
  f.range = function(colors2, _pos2) {
    setColors(colors2, _pos2);
    return f;
  };
  f.out = function(_o) {
    _out = _o;
    return f;
  };
  f.spread = function(val) {
    if (!arguments.length) {
      return _spread;
    }
    _spread = val;
    return f;
  };
  f.correctLightness = function(v) {
    if (v == null) {
      v = true;
    }
    _correctLightness = v;
    resetCache2();
    if (_correctLightness) {
      tmap = function(t) {
        var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
        L0 = getColor2(0, true).lab()[0];
        L1 = getColor2(1, true).lab()[0];
        pol = L0 > L1;
        L_actual = getColor2(t, true).lab()[0];
        L_ideal = L0 + (L1 - L0) * t;
        L_diff = L_actual - L_ideal;
        t0 = 0;
        t1 = 1;
        max_iter = 20;
        while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
          (function() {
            if (pol) {
              L_diff *= -1;
            }
            if (L_diff < 0) {
              t0 = t;
              t += (t1 - t) * 0.5;
            } else {
              t1 = t;
              t += (t0 - t) * 0.5;
            }
            L_actual = getColor2(t, true).lab()[0];
            return L_diff = L_actual - L_ideal;
          })();
        }
        return t;
      };
    } else {
      tmap = function(t) {
        return t;
      };
    }
    return f;
  };
  f.padding = function(p) {
    if (p != null) {
      if (type(p) === "number") {
        p = [p, p];
      }
      _padding = p;
      return f;
    } else {
      return _padding;
    }
  };
  f.colors = function(numColors, out) {
    var dd, dm, i, ref, results, samples, w;
    if (out == null) {
      out = "hex";
    }
    if (arguments.length === 0) {
      return _colors.map(function(c) {
        return c[out]();
      });
    }
    if (numColors) {
      if (numColors === 1) {
        return f(0.5)[out]();
      }
      dm = _domain[0];
      dd = _domain[1] - dm;
      return function() {
        results = [];
        for (var o = 0; 0 <= numColors ? o < numColors : o > numColors; 0 <= numColors ? o++ : o--) {
          results.push(o);
        }
        return results;
      }.apply(this).map(function(i2) {
        return f(dm + i2 / (numColors - 1) * dd)[out]();
      });
    }
    colors = [];
    samples = [];
    if (_classes && _classes.length > 2) {
      for (i = w = 1, ref = _classes.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
        samples.push((_classes[i - 1] + _classes[i]) * 0.5);
      }
    } else {
      samples = _domain;
    }
    return samples.map(function(v) {
      return f(v)[out]();
    });
  };
  f.cache = function(c) {
    if (c != null) {
      return _useCache = c;
    } else {
      return _useCache;
    }
  };
  return f;
};
if (chroma.scales == null) {
  chroma.scales = {};
}
chroma.scales.cool = function() {
  return chroma.scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);
};
chroma.scales.hot = function() {
  return chroma.scale(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode("rgb");
};
chroma.analyze = function(data, key, filter) {
  var add8, k, len, o, r, val, visit;
  r = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  if (filter == null) {
    filter = function() {
      return true;
    };
  }
  add8 = function(val2) {
    if (val2 != null && !isNaN(val2)) {
      r.values.push(val2);
      r.sum += val2;
      if (val2 < r.min) {
        r.min = val2;
      }
      if (val2 > r.max) {
        r.max = val2;
      }
      r.count += 1;
    }
  };
  visit = function(val2, k2) {
    if (filter(val2, k2)) {
      if (key != null && type(key) === "function") {
        return add8(key(val2));
      } else if (key != null && type(key) === "string" || type(key) === "number") {
        return add8(val2[key]);
      } else {
        return add8(val2);
      }
    }
  };
  if (type(data) === "array") {
    for (o = 0, len = data.length; o < len; o++) {
      val = data[o];
      visit(val);
    }
  } else {
    for (k in data) {
      val = data[k];
      visit(val, k);
    }
  }
  r.domain = [r.min, r.max];
  r.limits = function(mode, num) {
    return chroma.limits(r, mode, num);
  };
  return r;
};
chroma.limits = function(data, mode, num) {
  var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, tmpKMeansBreaks, v, value2, values, w;
  if (mode == null) {
    mode = "equal";
  }
  if (num == null) {
    num = 7;
  }
  if (type(data) === "array") {
    data = chroma.analyze(data);
  }
  min = data.min;
  max = data.max;
  data.sum;
  values = data.values.sort(function(a, b) {
    return a - b;
  });
  if (num === 1) {
    return [min, max];
  }
  limits = [];
  if (mode.substr(0, 1) === "c") {
    limits.push(min);
    limits.push(max);
  }
  if (mode.substr(0, 1) === "e") {
    limits.push(min);
    for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
      limits.push(min + i / num * (max - min));
    }
    limits.push(max);
  } else if (mode.substr(0, 1) === "l") {
    if (min <= 0) {
      throw "Logarithmic scales are only possible for values > 0";
    }
    min_log = Math.LOG10E * log(min);
    max_log = Math.LOG10E * log(max);
    limits.push(min);
    for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
      limits.push(pow(10, min_log + i / num * (max_log - min_log)));
    }
    limits.push(max);
  } else if (mode.substr(0, 1) === "q") {
    limits.push(min);
    for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
      p = (values.length - 1) * i / num;
      pb = floor(p);
      if (pb === p) {
        limits.push(values[pb]);
      } else {
        pr = p - pb;
        limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
      }
    }
    limits.push(max);
  } else if (mode.substr(0, 1) === "k") {
    n = values.length;
    assignments = new Array(n);
    clusterSizes = new Array(num);
    repeat = true;
    nb_iters = 0;
    centroids = null;
    centroids = [];
    centroids.push(min);
    for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
      centroids.push(min + i / num * (max - min));
    }
    centroids.push(max);
    while (repeat) {
      for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
        clusterSizes[j] = 0;
      }
      for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
        value2 = values[i];
        mindist = Number.MAX_VALUE;
        for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
          dist = abs(centroids[j] - value2);
          if (dist < mindist) {
            mindist = dist;
            best = j;
          }
        }
        clusterSizes[best]++;
        assignments[i] = best;
      }
      newCentroids = new Array(num);
      for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
        newCentroids[j] = null;
      }
      for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
        cluster = assignments[i];
        if (newCentroids[cluster] === null) {
          newCentroids[cluster] = values[i];
        } else {
          newCentroids[cluster] += values[i];
        }
      }
      for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
        newCentroids[j] *= 1 / clusterSizes[j];
      }
      repeat = false;
      for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
        if (newCentroids[j] !== centroids[i]) {
          repeat = true;
          break;
        }
      }
      centroids = newCentroids;
      nb_iters++;
      if (nb_iters > 200) {
        repeat = false;
      }
    }
    kClusters = {};
    for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
      kClusters[j] = [];
    }
    for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
      cluster = assignments[i];
      kClusters[cluster].push(values[i]);
    }
    tmpKMeansBreaks = [];
    for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
      tmpKMeansBreaks.push(kClusters[j][0]);
      tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
    }
    tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
      return a - b;
    });
    limits.push(tmpKMeansBreaks[0]);
    for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
      v = tmpKMeansBreaks[i];
      if (!isNaN(v) && limits.indexOf(v) === -1) {
        limits.push(v);
      }
    }
  }
  return limits;
};
hsi2rgb = function(h, s, i) {
  var args, b, g, r;
  args = unpack(arguments);
  h = args[0], s = args[1], i = args[2];
  if (isNaN(h)) {
    h = 0;
  }
  h /= 360;
  if (h < 1 / 3) {
    b = (1 - s) / 3;
    r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
    g = 1 - (b + r);
  } else if (h < 2 / 3) {
    h -= 1 / 3;
    r = (1 - s) / 3;
    g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
    b = 1 - (r + g);
  } else {
    h -= 2 / 3;
    g = (1 - s) / 3;
    b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
    r = 1 - (g + b);
  }
  r = limit(i * r * 3);
  g = limit(i * g * 3);
  b = limit(i * b * 3);
  return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
};
rgb2hsi = function() {
  var b, g, h, i, min, r, ref, s;
  ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
  TWOPI = Math.PI * 2;
  r /= 255;
  g /= 255;
  b /= 255;
  min = Math.min(r, g, b);
  i = (r + g + b) / 3;
  s = 1 - min / i;
  if (s === 0) {
    h = 0;
  } else {
    h = (r - g + (r - b)) / 2;
    h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
    h = Math.acos(h);
    if (b > g) {
      h = TWOPI - h;
    }
    h /= TWOPI;
  }
  return [h * 360, s, i];
};
chroma.hsi = function() {
  return function(func3, args, ctor) {
    ctor.prototype = func3.prototype;
    var child = new ctor(), result = func3.apply(child, args);
    return Object(result) === result ? result : child;
  }(Color$1, slice.call(arguments).concat(["hsi"]), function() {
  });
};
_input.hsi = hsi2rgb;
Color$1.prototype.hsi = function() {
  return rgb2hsi(this._rgb);
};
interpolate_hsx = function(col1, col2, f, m2) {
  var dh, hue, hue0, hue1, lbv, lbv0, lbv1, sat, sat0, sat1, xyz0, xyz1;
  if (m2 === "hsl") {
    xyz0 = col1.hsl();
    xyz1 = col2.hsl();
  } else if (m2 === "hsv") {
    xyz0 = col1.hsv();
    xyz1 = col2.hsv();
  } else if (m2 === "hcg") {
    xyz0 = col1.hcg();
    xyz1 = col2.hcg();
  } else if (m2 === "hsi") {
    xyz0 = col1.hsi();
    xyz1 = col2.hsi();
  } else if (m2 === "lch" || m2 === "hcl") {
    m2 = "hcl";
    xyz0 = col1.hcl();
    xyz1 = col2.hcl();
  }
  if (m2.substr(0, 1) === "h") {
    hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
    hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
  }
  if (!isNaN(hue0) && !isNaN(hue1)) {
    if (hue1 > hue0 && hue1 - hue0 > 180) {
      dh = hue1 - (hue0 + 360);
    } else if (hue1 < hue0 && hue0 - hue1 > 180) {
      dh = hue1 + 360 - hue0;
    } else {
      dh = hue1 - hue0;
    }
    hue = hue0 + f * dh;
  } else if (!isNaN(hue0)) {
    hue = hue0;
    if ((lbv1 === 1 || lbv1 === 0) && m2 !== "hsv") {
      sat = sat0;
    }
  } else if (!isNaN(hue1)) {
    hue = hue1;
    if ((lbv0 === 1 || lbv0 === 0) && m2 !== "hsv") {
      sat = sat1;
    }
  } else {
    hue = Number.NaN;
  }
  if (sat == null) {
    sat = sat0 + f * (sat1 - sat0);
  }
  lbv = lbv0 + f * (lbv1 - lbv0);
  return chroma[m2](hue, sat, lbv);
};
_interpolators = _interpolators.concat(function() {
  var len, o, ref, results;
  ref = ["hsv", "hsl", "hsi", "hcl", "lch", "hcg"];
  results = [];
  for (o = 0, len = ref.length; o < len; o++) {
    m = ref[o];
    results.push([m, interpolate_hsx]);
  }
  return results;
}());
interpolate_num = function(col1, col2, f, m2) {
  var n1, n2;
  n1 = col1.num();
  n2 = col2.num();
  return chroma.num(n1 + (n2 - n1) * f, "num");
};
_interpolators.push(["num", interpolate_num]);
interpolate_lab = function(col1, col2, f, m2) {
  var xyz0, xyz1;
  xyz0 = col1.lab();
  xyz1 = col2.lab();
  return new Color$1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m2);
};
_interpolators.push(["lab", interpolate_lab]);
var chroma$1 = chroma;
var Colormaker = function Colormaker2(params) {
  var p = params || {};
  this.scale = defaults(p.scale, "uniform");
  this.mode = defaults(p.mode, "hcl");
  this.domain = defaults(p.domain, [0, 1]);
  this.value = new Color(defaults(p.value, 16777215)).getHex();
  this.reverse = defaults(p.reverse, false);
  this.structure = p.structure;
  this.volume = p.volume;
  this.surface = p.surface;
  if (this.structure) {
    this.atomProxy = this.structure.getAtomProxy();
  }
};
Colormaker.prototype.getScale = function getScale(params) {
  var p = params || {};
  var scale2 = defaults(p.scale, this.scale);
  if (scale2 === "rainbow") {
    scale2 = ["red", "orange", "yellow", "green", "blue"];
  } else if (scale2 === "rwb") {
    scale2 = ["red", "white", "blue"];
  }
  var domain = defaults(p.domain, this.domain);
  if (this.reverse) {
    domain = domain.slice().reverse();
  }
  return chroma$1.scale(scale2).mode(defaults(p.mode, this.mode)).domain(domain).out("num");
};
Colormaker.prototype.colorToArray = function colorToArray(color, array, offset) {
  if (array === void 0) {
    array = [];
  }
  if (offset === void 0) {
    offset = 0;
  }
  array[offset + 0] = (color >> 16 & 255) / 255;
  array[offset + 1] = (color >> 8 & 255) / 255;
  array[offset + 2] = (color & 255) / 255;
  return array;
};
Colormaker.prototype.atomColorToArray = function atomColorToArray(atom, array, offset) {
  return this.colorToArray(this.atomColor(atom), array, offset);
};
Colormaker.prototype.bondColor = function bondColor(bond, fromTo) {
  this.atomProxy.index = fromTo ? bond.atomIndex1 : bond.atomIndex2;
  return this.atomColor(this.atomProxy);
};
Colormaker.prototype.bondColorToArray = function bondColorToArray(bond, fromTo, array, offset) {
  return this.colorToArray(this.bondColor(bond, fromTo), array, offset);
};
Colormaker.prototype.volumeColorToArray = function volumeColorToArray(index, array, offset) {
  return this.colorToArray(this.volumeColor(index), array, offset);
};
Colormaker.prototype.positionColorToArray = function positionColorToArray(coords, array, offset) {
  return this.colorToArray(this.positionColor(coords), array, offset);
};
/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */
function SignalBinding(signal, listener, isOnce, listenerContext, priority) {
  this._listener = listener;
  this._isOnce = isOnce;
  this.context = listenerContext;
  this._signal = signal;
  this._priority = priority || 0;
}
SignalBinding.prototype = {
  active: true,
  params: null,
  execute: function(paramsArr) {
    var handlerReturn, params;
    if (this.active && !!this._listener) {
      params = this.params ? this.params.concat(paramsArr) : paramsArr;
      handlerReturn = this._listener.apply(this.context, params);
      if (this._isOnce) {
        this.detach();
      }
    }
    return handlerReturn;
  },
  detach: function() {
    return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
  },
  isBound: function() {
    return !!this._signal && !!this._listener;
  },
  isOnce: function() {
    return this._isOnce;
  },
  getListener: function() {
    return this._listener;
  },
  getSignal: function() {
    return this._signal;
  },
  _destroy: function() {
    delete this._signal;
    delete this._listener;
    delete this.context;
  },
  toString: function() {
    return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
  }
};
function validateListener(listener, fnName) {
  if (typeof listener !== "function") {
    throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
  }
}
function Signal() {
  this._bindings = [];
  this._prevParams = null;
  var self2 = this;
  this.dispatch = function() {
    Signal.prototype.dispatch.apply(self2, arguments);
  };
}
Signal.prototype = {
  VERSION: "1.0.0",
  memorize: false,
  _shouldPropagate: true,
  active: true,
  _registerListener: function(listener, isOnce, listenerContext, priority) {
    var prevIndex = this._indexOfListener(listener, listenerContext), binding;
    if (prevIndex !== -1) {
      binding = this._bindings[prevIndex];
      if (binding.isOnce() !== isOnce) {
        throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
      }
    } else {
      binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
      this._addBinding(binding);
    }
    if (this.memorize && this._prevParams) {
      binding.execute(this._prevParams);
    }
    return binding;
  },
  _addBinding: function(binding) {
    var n = this._bindings.length;
    do {
      --n;
    } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
    this._bindings.splice(n + 1, 0, binding);
  },
  _indexOfListener: function(listener, context2) {
    var this$1 = this;
    var n = this._bindings.length, cur;
    while (n--) {
      cur = this$1._bindings[n];
      if (cur._listener === listener && cur.context === context2) {
        return n;
      }
    }
    return -1;
  },
  has: function(listener, context2) {
    return this._indexOfListener(listener, context2) !== -1;
  },
  add: function(listener, listenerContext, priority) {
    validateListener(listener, "add");
    return this._registerListener(listener, false, listenerContext, priority);
  },
  addOnce: function(listener, listenerContext, priority) {
    validateListener(listener, "addOnce");
    return this._registerListener(listener, true, listenerContext, priority);
  },
  remove: function(listener, context2) {
    validateListener(listener, "remove");
    var i = this._indexOfListener(listener, context2);
    if (i !== -1) {
      this._bindings[i]._destroy();
      this._bindings.splice(i, 1);
    }
    return listener;
  },
  removeAll: function() {
    var this$1 = this;
    var n = this._bindings.length;
    while (n--) {
      this$1._bindings[n]._destroy();
    }
    this._bindings.length = 0;
  },
  getNumListeners: function() {
    return this._bindings.length;
  },
  halt: function() {
    this._shouldPropagate = false;
  },
  dispatch: function(params) {
    if (!this.active) {
      return;
    }
    var paramsArr = Array.prototype.slice.call(arguments), n = this._bindings.length, bindings;
    if (this.memorize) {
      this._prevParams = paramsArr;
    }
    if (!n) {
      return;
    }
    bindings = this._bindings.slice();
    this._shouldPropagate = true;
    do {
      n--;
    } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
  },
  forget: function() {
    this._prevParams = null;
  },
  dispose: function() {
    this.removeAll();
    delete this._bindings;
    delete this._prevParams;
  },
  toString: function() {
    return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
  }
};
var kwd = {
  PROTEIN: 1,
  NUCLEIC: 2,
  RNA: 3,
  DNA: 4,
  POLYMER: 5,
  WATER: 6,
  HELIX: 7,
  SHEET: 8,
  TURN: 9,
  BACKBONE: 10,
  SIDECHAIN: 11,
  ALL: 12,
  HETERO: 13,
  ION: 14,
  SACCHARIDE: 15,
  SUGAR: 15,
  BONDED: 16,
  RING: 17
};
var SelectAllKeyword = ["*", "", "ALL"];
var AtomOnlyKeywords = [
  kwd.BACKBONE,
  kwd.SIDECHAIN,
  kwd.BONDED,
  kwd.RING
];
var ChainKeywords = [
  kwd.POLYMER,
  kwd.WATER
];
var SmallResname = ["ALA", "GLY", "SER"];
var NucleophilicResname = ["CYS", "SER", "THR"];
var HydrophobicResname = ["ALA", "ILE", "LEU", "MET", "PHE", "PRO", "TRP", "VAL"];
var AromaticResname = ["PHE", "TRP", "TYR", "HIS"];
var AmideResname = ["ASN", "GLN"];
var AcidicResname = ["ASP", "GLU"];
var BasicResname = ["ARG", "HIS", "LYS"];
var ChargedResname = ["ARG", "ASP", "GLU", "HIS", "LYS"];
var PolarResname = ["ASN", "ARG", "ASP", "CYS", "GLY", "GLN", "GLU", "HIS", "LYS", "SER", "THR", "TYR"];
var NonpolarResname = ["ALA", "ILE", "LEU", "MET", "PHE", "PRO", "TRP", "VAL"];
var CyclicResname = ["HIS", "PHE", "PRO", "TRP", "TYR"];
var AliphaticResname = ["ALA", "GLY", "ILE", "LEU", "VAL"];
function atomTestFn(a, s) {
  if (s.atomname === void 0 && s.element === void 0 && s.altloc === void 0 && s.atomindex === void 0 && s.keyword === void 0 && s.inscode === void 0 && s.resname === void 0 && s.sstruc === void 0 && s.resno === void 0 && s.chainname === void 0 && s.model === void 0) {
    return -1;
  }
  if (s.keyword !== void 0) {
    if (s.keyword === kwd.BACKBONE && !a.isBackbone()) {
      return false;
    }
    if (s.keyword === kwd.SIDECHAIN && !a.isSidechain()) {
      return false;
    }
    if (s.keyword === kwd.BONDED && !a.isBonded()) {
      return false;
    }
    if (s.keyword === kwd.RING && !a.isRing()) {
      return false;
    }
    if (s.keyword === kwd.HETERO && !a.isHetero()) {
      return false;
    }
    if (s.keyword === kwd.PROTEIN && !a.isProtein()) {
      return false;
    }
    if (s.keyword === kwd.NUCLEIC && !a.isNucleic()) {
      return false;
    }
    if (s.keyword === kwd.RNA && !a.isRna()) {
      return false;
    }
    if (s.keyword === kwd.DNA && !a.isDna()) {
      return false;
    }
    if (s.keyword === kwd.POLYMER && !a.isPolymer()) {
      return false;
    }
    if (s.keyword === kwd.WATER && !a.isWater()) {
      return false;
    }
    if (s.keyword === kwd.HELIX && !a.isHelix()) {
      return false;
    }
    if (s.keyword === kwd.SHEET && !a.isSheet()) {
      return false;
    }
    if (s.keyword === kwd.TURN && !a.isTurn()) {
      return false;
    }
    if (s.keyword === kwd.ION && !a.isIon()) {
      return false;
    }
    if (s.keyword === kwd.SACCHARIDE && !a.isSaccharide()) {
      return false;
    }
  }
  if (s.atomname !== void 0 && s.atomname !== a.atomname) {
    return false;
  }
  if (s.element !== void 0 && s.element !== a.element) {
    return false;
  }
  if (s.altloc !== void 0 && s.altloc !== a.altloc) {
    return false;
  }
  if (s.atomindex !== void 0 && binarySearchIndexOf(s.atomindex, a.index) < 0) {
    return false;
  }
  if (s.resname !== void 0) {
    if (Array.isArray(s.resname)) {
      if (!s.resname.includes(a.resname)) {
        return false;
      }
    } else {
      if (s.resname !== a.resname) {
        return false;
      }
    }
  }
  if (s.sstruc !== void 0 && s.sstruc !== a.sstruc) {
    return false;
  }
  if (s.resno !== void 0) {
    if (Array.isArray(s.resno) && s.resno.length === 2) {
      if (s.resno[0] > a.resno || s.resno[1] < a.resno) {
        return false;
      }
    } else {
      if (s.resno !== a.resno) {
        return false;
      }
    }
  }
  if (s.inscode !== void 0 && s.inscode !== a.inscode) {
    return false;
  }
  if (s.chainname !== void 0 && s.chainname !== a.chainname) {
    return false;
  }
  if (s.model !== void 0 && s.model !== a.modelIndex) {
    return false;
  }
  return true;
}
function residueTestFn(r, s) {
  if (s.resname === void 0 && s.resno === void 0 && s.inscode === void 0 && s.sstruc === void 0 && s.model === void 0 && s.chainname === void 0 && s.atomindex === void 0 && (s.keyword === void 0 || AtomOnlyKeywords.includes(s.keyword))) {
    return -1;
  }
  if (s.keyword !== void 0) {
    if (s.keyword === kwd.HETERO && !r.isHetero()) {
      return false;
    }
    if (s.keyword === kwd.PROTEIN && !r.isProtein()) {
      return false;
    }
    if (s.keyword === kwd.NUCLEIC && !r.isNucleic()) {
      return false;
    }
    if (s.keyword === kwd.RNA && !r.isRna()) {
      return false;
    }
    if (s.keyword === kwd.DNA && !r.isDna()) {
      return false;
    }
    if (s.keyword === kwd.POLYMER && !r.isPolymer()) {
      return false;
    }
    if (s.keyword === kwd.WATER && !r.isWater()) {
      return false;
    }
    if (s.keyword === kwd.HELIX && !r.isHelix()) {
      return false;
    }
    if (s.keyword === kwd.SHEET && !r.isSheet()) {
      return false;
    }
    if (s.keyword === kwd.TURN && !r.isTurn()) {
      return false;
    }
    if (s.keyword === kwd.ION && !r.isIon()) {
      return false;
    }
    if (s.keyword === kwd.SACCHARIDE && !r.isSaccharide()) {
      return false;
    }
  }
  if (s.atomindex !== void 0 && rangeInSortedArray(s.atomindex, r.atomOffset, r.atomEnd) === 0) {
    return false;
  }
  if (s.resname !== void 0) {
    if (Array.isArray(s.resname)) {
      if (!s.resname.includes(r.resname)) {
        return false;
      }
    } else {
      if (s.resname !== r.resname) {
        return false;
      }
    }
  }
  if (s.sstruc !== void 0 && s.sstruc !== r.sstruc) {
    return false;
  }
  if (s.resno !== void 0) {
    if (Array.isArray(s.resno) && s.resno.length === 2) {
      if (s.resno[0] > r.resno || s.resno[1] < r.resno) {
        return false;
      }
    } else {
      if (s.resno !== r.resno) {
        return false;
      }
    }
  }
  if (s.inscode !== void 0 && s.inscode !== r.inscode) {
    return false;
  }
  if (s.chainname !== void 0 && s.chainname !== r.chainname) {
    return false;
  }
  if (s.model !== void 0 && s.model !== r.modelIndex) {
    return false;
  }
  return true;
}
function chainTestFn(c, s) {
  if (s.chainname === void 0 && s.model === void 0 && s.atomindex === void 0 && (s.keyword === void 0 || !ChainKeywords.includes(s.keyword) || !c.entity)) {
    return -1;
  }
  if (s.keyword !== void 0) {
    if (s.keyword === kwd.POLYMER && !c.entity.isPolymer()) {
      return false;
    }
    if (s.keyword === kwd.WATER && !c.entity.isWater()) {
      return false;
    }
  }
  if (s.atomindex !== void 0 && rangeInSortedArray(s.atomindex, c.atomOffset, c.atomEnd) === 0) {
    return false;
  }
  if (s.chainname !== void 0 && s.chainname !== c.chainname) {
    return false;
  }
  if (s.model !== void 0 && s.model !== c.modelIndex) {
    return false;
  }
  return true;
}
function modelTestFn(m2, s) {
  if (s.model === void 0 && s.atomindex === void 0) {
    return -1;
  }
  if (s.atomindex !== void 0 && rangeInSortedArray(s.atomindex, m2.atomOffset, m2.atomEnd) === 0) {
    return false;
  }
  if (s.model !== void 0 && s.model !== m2.index) {
    return false;
  }
  return true;
}
var Selection = function Selection2(string) {
  this.signals = {
    stringChanged: new Signal()
  };
  this.setString(string);
};
var prototypeAccessors$1 = {type: {}};
prototypeAccessors$1.type.get = function() {
  return "selection";
};
Selection.prototype.setString = function setString(string, silent) {
  if (string === void 0) {
    string = this.string || "";
  }
  if (string === this.string) {
    return;
  }
  try {
    this.parse(string);
  } catch (e) {
    this.selection = {error: e.message};
  }
  this.string = string;
  this.test = this.makeAtomTest();
  this.residueTest = this.makeResidueTest();
  this.chainTest = this.makeChainTest();
  this.modelTest = this.makeModelTest();
  this.atomOnlyTest = this.makeAtomTest(true);
  this.residueOnlyTest = this.makeResidueTest(true);
  this.chainOnlyTest = this.makeChainTest(true);
  this.modelOnlyTest = this.makeModelTest(true);
  if (!silent) {
    this.signals.stringChanged.dispatch(this.string);
  }
};
Selection.prototype.parse = function parse(string) {
  var this$1 = this;
  this.selection = {
    operator: void 0,
    rules: []
  };
  if (!string) {
    return;
  }
  var selection = this.selection;
  var newSelection, oldSelection;
  var selectionStack = [];
  string = string.replace(/\(/g, " ( ").replace(/\)/g, " ) ").trim();
  if (string.charAt(0) === "(" && string.substr(-1) === ")") {
    string = string.slice(1, -1).trim();
  }
  var chunks = string.split(/\s+/);
  var createNewContext = function(operator) {
    newSelection = {
      operator,
      rules: []
    };
    if (selection === void 0) {
      selection = newSelection;
      this$1.selection = newSelection;
    } else {
      selection.rules.push(newSelection);
      selectionStack.push(selection);
      selection = newSelection;
    }
  };
  var getPrevContext = function(operator) {
    oldSelection = selection;
    selection = selectionStack.pop();
    if (selection === void 0) {
      createNewContext(operator);
      pushRule(oldSelection);
    }
  };
  var pushRule = function(rule) {
    selection.rules.push(rule);
  };
  var not;
  for (var i = 0; i < chunks.length; ++i) {
    var c = chunks[i];
    var cu = c.toUpperCase();
    if (c === "(") {
      not = false;
      createNewContext();
      continue;
    } else if (c === ")") {
      getPrevContext();
      if (selection.negate) {
        getPrevContext();
      }
      continue;
    }
    if (not > 0) {
      if (cu === "NOT") {
        not = 1;
      } else if (not === 1) {
        not = 2;
      } else if (not === 2) {
        not = false;
        getPrevContext();
      } else {
        throw new Error("something went wrong with 'not'");
      }
    }
    if (cu === "AND") {
      if (selection.operator === "OR") {
        var lastRule = selection.rules.pop();
        createNewContext("AND");
        pushRule(lastRule);
      } else {
        selection.operator = "AND";
      }
      continue;
    } else if (cu === "OR") {
      if (selection.operator === "AND") {
        getPrevContext("OR");
      } else {
        selection.operator = "OR";
      }
      continue;
    } else if (c.toUpperCase() === "NOT") {
      not = 1;
      createNewContext();
      selection.negate = true;
      continue;
    } else
      ;
    var keyword = kwd[cu];
    if (keyword !== void 0) {
      pushRule({keyword});
      continue;
    }
    if (cu === "HYDROGEN") {
      pushRule({element: "H"});
      continue;
    }
    if (cu === "SMALL") {
      pushRule({resname: SmallResname});
      continue;
    }
    if (cu === "NUCLEOPHILIC") {
      pushRule({resname: NucleophilicResname});
      continue;
    }
    if (cu === "HYDROPHOBIC") {
      pushRule({resname: HydrophobicResname});
      continue;
    }
    if (cu === "AROMATIC") {
      pushRule({resname: AromaticResname});
      continue;
    }
    if (cu === "AMIDE") {
      pushRule({resname: AmideResname});
      continue;
    }
    if (cu === "ACIDIC") {
      pushRule({resname: AcidicResname});
      continue;
    }
    if (cu === "BASIC") {
      pushRule({resname: BasicResname});
      continue;
    }
    if (cu === "CHARGED") {
      pushRule({resname: ChargedResname});
      continue;
    }
    if (cu === "POLAR") {
      pushRule({resname: PolarResname});
      continue;
    }
    if (cu === "NONPOLAR") {
      pushRule({resname: NonpolarResname});
      continue;
    }
    if (cu === "CYCLIC") {
      pushRule({resname: CyclicResname});
      continue;
    }
    if (cu === "ALIPHATIC") {
      pushRule({resname: AliphaticResname});
      continue;
    }
    if (cu === "SIDECHAINATTACHED") {
      pushRule({
        operator: "OR",
        rules: [
          {keyword: kwd.SIDECHAIN},
          {
            operator: "AND",
            negate: false,
            rules: [
              {keyword: kwd.PROTEIN},
              {
                operator: "OR",
                negate: false,
                rules: [
                  {atomname: "CA"},
                  {atomname: "BB"}
                ]
              }
            ]
          },
          {
            operator: "AND",
            negate: false,
            rules: [
              {resname: "PRO"},
              {atomname: "N"}
            ]
          },
          {
            operator: "AND",
            negate: false,
            rules: [
              {keyword: kwd.NUCLEIC},
              {
                operator: "OR",
                negate: true,
                rules: [
                  {atomname: "P"},
                  {atomname: "OP1"},
                  {atomname: "OP2"},
                  {atomname: "O3'"},
                  {atomname: "O3*"},
                  {atomname: "O5'"},
                  {atomname: "O5*"},
                  {atomname: "C5'"},
                  {atomname: "C5*"}
                ]
              }
            ]
          }
        ]
      });
      continue;
    }
    if (cu === "LIGAND") {
      pushRule({
        operator: "AND",
        rules: [
          {
            operator: "OR",
            rules: [
              {keyword: kwd.HETERO},
              {
                negate: true,
                operator: void 0,
                rules: [
                  {keyword: kwd.POLYMER}
                ]
              }
            ]
          },
          {
            negate: true,
            operator: void 0,
            rules: [
              {
                operator: "OR",
                rules: [
                  {keyword: kwd.WATER},
                  {keyword: kwd.ION}
                ]
              }
            ]
          }
        ]
      });
      continue;
    }
    if (SelectAllKeyword.indexOf(cu) !== -1) {
      pushRule({keyword: kwd.ALL});
      continue;
    }
    if (c.charAt(0) === "@") {
      var indexList = c.substr(1).split(",");
      for (var k = 0, kl = indexList.length; k < kl; ++k) {
        indexList[k] = parseInt(indexList[k]);
      }
      indexList.sort(function(a, b) {
        return a - b;
      });
      pushRule({atomindex: indexList});
      continue;
    }
    if (c.charAt(0) === "#") {
      console.error("# for element selection deprecated, use _");
      pushRule({element: cu.substr(1)});
      continue;
    }
    if (c.charAt(0) === "_") {
      pushRule({element: cu.substr(1)});
      continue;
    }
    if (c[0] === "[" && c[c.length - 1] === "]") {
      var resnameList = cu.substr(1, c.length - 2).split(",");
      var resname = resnameList.length > 1 ? resnameList : resnameList[0];
      pushRule({resname});
      continue;
    } else if (c.length >= 1 && c.length <= 4 && c[0] !== "^" && c[0] !== ":" && c[0] !== "." && c[0] !== "%" && c[0] !== "/" && isNaN(parseInt(c))) {
      pushRule({resname: cu});
      continue;
    }
    var sele = {
      operator: "AND",
      rules: []
    };
    var model = c.split("/");
    if (model.length > 1 && model[1]) {
      if (isNaN(parseInt(model[1]))) {
        throw new Error("model must be an integer");
      }
      sele.rules.push({
        model: parseInt(model[1])
      });
    }
    var altloc = model[0].split("%");
    if (altloc.length > 1) {
      sele.rules.push({
        altloc: altloc[1]
      });
    }
    var atomname = altloc[0].split(".");
    if (atomname.length > 1 && atomname[1]) {
      if (atomname[1].length > 4) {
        throw new Error("atomname must be one to four characters");
      }
      sele.rules.push({
        atomname: atomname[1].substring(0, 4).toUpperCase()
      });
    }
    var chain = atomname[0].split(":");
    if (chain.length > 1 && chain[1]) {
      sele.rules.push({
        chainname: chain[1]
      });
    }
    var inscode = chain[0].split("^");
    if (inscode.length > 1) {
      sele.rules.push({
        inscode: inscode[1]
      });
    }
    if (inscode[0]) {
      var negate = void 0, negate2 = void 0;
      if (inscode[0][0] === "-") {
        inscode[0] = inscode[0].substr(1);
        negate = true;
      }
      if (inscode[0].includes("--")) {
        inscode[0] = inscode[0].replace("--", "-");
        negate2 = true;
      }
      var resi = inscode[0].split("-");
      if (resi.length === 1) {
        resi = parseInt(resi[0]);
        if (isNaN(resi)) {
          throw new Error("resi must be an integer");
        }
        if (negate) {
          resi *= -1;
        }
        sele.rules.push({
          resno: resi
        });
      } else if (resi.length === 2) {
        if (negate) {
          resi[0] *= -1;
        }
        if (negate2) {
          resi[1] *= -1;
        }
        sele.rules.push({
          resno: [parseInt(resi[0]), parseInt(resi[1])]
        });
      } else {
        throw new Error("resi range must contain one '-'");
      }
    }
    if (sele.rules.length === 1) {
      pushRule(sele.rules[0]);
    } else if (sele.rules.length > 1) {
      pushRule(sele);
    } else {
      throw new Error("empty selection chunk");
    }
  }
  if (this.selection.operator === void 0 && this.selection.rules.length === 1 && this.selection.rules[0].hasOwnProperty("operator")) {
    this.selection = this.selection.rules[0];
  }
};
Selection.prototype._makeTest = function _makeTest(fn, selection) {
  var this$1 = this;
  if (selection === void 0) {
    selection = this.selection;
  }
  if (selection === null) {
    return false;
  }
  if (selection.error) {
    return false;
  }
  var n = selection.rules.length;
  if (n === 0) {
    return false;
  }
  var t = !selection.negate;
  var f = !!selection.negate;
  var subTests = [];
  for (var i = 0; i < n; ++i) {
    var s = selection.rules[i];
    if (s.hasOwnProperty("operator")) {
      subTests[i] = this$1._makeTest(fn, s);
    }
  }
  return function test(entity) {
    var and = selection.operator === "AND";
    var na = false;
    for (var i2 = 0; i2 < n; ++i2) {
      var s2 = selection.rules[i2];
      var ret = void 0;
      if (s2.hasOwnProperty("operator")) {
        if (subTests[i2]) {
          ret = subTests[i2](entity);
        } else {
          ret = -1;
        }
        if (ret === -1) {
          na = true;
          continue;
        } else if (ret === true) {
          if (and) {
            continue;
          } else {
            return t;
          }
        } else {
          if (and) {
            return f;
          } else {
            continue;
          }
        }
      } else {
        if (s2.keyword === kwd.ALL) {
          if (and) {
            continue;
          } else {
            return t;
          }
        }
        ret = fn(entity, s2);
        if (ret === -1) {
          na = true;
          continue;
        } else if (ret === true) {
          if (and) {
            continue;
          } else {
            return t;
          }
        } else {
          if (and) {
            return f;
          } else {
            continue;
          }
        }
      }
    }
    if (na) {
      return -1;
    } else {
      if (and) {
        return t;
      } else {
        return f;
      }
    }
  };
};
Selection.prototype._filter = function _filter(fn, selection) {
  var this$1 = this;
  if (selection === void 0) {
    selection = this.selection;
  }
  if (selection.error) {
    return selection;
  }
  var n = selection.rules.length;
  if (n === 0) {
    return selection;
  }
  var filtered = {
    operator: selection.operator,
    rules: []
  };
  if (selection.hasOwnProperty("negate")) {
    filtered.negate = selection.negate;
  }
  for (var i = 0; i < n; ++i) {
    var s = selection.rules[i];
    if (s.hasOwnProperty("operator")) {
      var fs = this$1._filter(fn, s);
      if (fs !== null) {
        filtered.rules.push(fs);
      }
    } else if (!fn(s)) {
      filtered.rules.push(s);
    }
  }
  if (filtered.rules.length > 0) {
    return selection;
  } else {
    return null;
  }
};
Selection.prototype.makeAtomTest = function makeAtomTest(atomOnly) {
  var selection;
  if (atomOnly) {
    selection = this._filter(function(s) {
      if (s.keyword !== void 0 && !AtomOnlyKeywords.includes(s.keyword)) {
        return true;
      }
      if (s.model !== void 0) {
        return true;
      }
      if (s.chainname !== void 0) {
        return true;
      }
      if (s.resname !== void 0) {
        return true;
      }
      if (s.resno !== void 0) {
        return true;
      }
      if (s.sstruc !== void 0) {
        return true;
      }
      return false;
    });
  } else {
    selection = this.selection;
  }
  return this._makeTest(atomTestFn, selection);
};
Selection.prototype.makeResidueTest = function makeResidueTest(residueOnly) {
  var selection;
  if (residueOnly) {
    selection = this._filter(function(s) {
      if (s.keyword !== void 0 && AtomOnlyKeywords.includes(s.keyword)) {
        return true;
      }
      if (s.model !== void 0) {
        return true;
      }
      if (s.chainname !== void 0) {
        return true;
      }
      if (s.atomname !== void 0) {
        return true;
      }
      if (s.element !== void 0) {
        return true;
      }
      if (s.altloc !== void 0) {
        return true;
      }
      return false;
    });
  } else {
    selection = this.selection;
  }
  return this._makeTest(residueTestFn, selection);
};
Selection.prototype.makeChainTest = function makeChainTest(chainOnly) {
  var selection;
  if (chainOnly) {
    selection = this._filter(function(s) {
      if (s.keyword !== void 0 && !ChainKeywords.includes(s.keyword)) {
        return true;
      }
      if (s.resname !== void 0) {
        return true;
      }
      if (s.resno !== void 0) {
        return true;
      }
      if (s.atomname !== void 0) {
        return true;
      }
      if (s.element !== void 0) {
        return true;
      }
      if (s.altloc !== void 0) {
        return true;
      }
      if (s.sstruc !== void 0) {
        return true;
      }
      if (s.inscode !== void 0) {
        return true;
      }
      return false;
    });
  } else {
    selection = this.selection;
  }
  return this._makeTest(chainTestFn, selection);
};
Selection.prototype.makeModelTest = function makeModelTest(modelOnly) {
  var selection;
  if (modelOnly) {
    selection = this._filter(function(s) {
      if (s.keyword !== void 0) {
        return true;
      }
      if (s.chainname !== void 0) {
        return true;
      }
      if (s.resname !== void 0) {
        return true;
      }
      if (s.resno !== void 0) {
        return true;
      }
      if (s.atomname !== void 0) {
        return true;
      }
      if (s.element !== void 0) {
        return true;
      }
      if (s.altloc !== void 0) {
        return true;
      }
      if (s.sstruc !== void 0) {
        return true;
      }
      if (s.inscode !== void 0) {
        return true;
      }
      return false;
    });
  } else {
    selection = this.selection;
  }
  return this._makeTest(modelTestFn, selection);
};
Object.defineProperties(Selection.prototype, prototypeAccessors$1);
var SelectionColormaker = function(Colormaker$$1) {
  function SelectionColormaker2(params) {
    var this$1 = this;
    Colormaker$$1.call(this, params);
    var dataList = params.dataList || [];
    this.colormakerList = [];
    this.selectionList = [];
    dataList.forEach(function(pair) {
      var scheme = pair[0];
      var sele = pair[1];
      var params2 = pair[2];
      if (params2 === void 0)
        params2 = {};
      if (ColormakerRegistry2.hasScheme(scheme)) {
        Object.assign(params2, {
          scheme,
          structure: this$1.structure
        });
      } else {
        Object.assign(params2, {
          scheme: "uniform",
          value: new Color(scheme).getHex()
        });
      }
      this$1.colormakerList.push(ColormakerRegistry2.getScheme(params2));
      this$1.selectionList.push(new Selection(sele));
    });
  }
  if (Colormaker$$1)
    SelectionColormaker2.__proto__ = Colormaker$$1;
  SelectionColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  SelectionColormaker2.prototype.constructor = SelectionColormaker2;
  SelectionColormaker2.prototype.atomColor = function atomColor(a) {
    var this$1 = this;
    for (var i = 0, n = this.selectionList.length; i < n; ++i) {
      if (this$1.selectionList[i].test(a)) {
        return this$1.colormakerList[i].atomColor(a);
      }
    }
    return 16777215;
  };
  return SelectionColormaker2;
}(Colormaker);
var ColormakerScales = {
  "": "",
  OrRd: "[S] Orange-Red",
  PuBu: "[S] Purple-Blue",
  BuPu: "[S] Blue-Purple",
  Oranges: "[S] Oranges",
  BuGn: "[S] Blue-Green",
  YlOrBr: "[S] Yellow-Orange-Brown",
  YlGn: "[S] Yellow-Green",
  Reds: "[S] Reds",
  RdPu: "[S] Red-Purple",
  Greens: "[S] Greens",
  YlGnBu: "[S] Yellow-Green-Blue",
  Purples: "[S] Purples",
  GnBu: "[S] Green-Blue",
  Greys: "[S] Greys",
  YlOrRd: "[S] Yellow-Orange-Red",
  PuRd: "[S] Purple-Red",
  Blues: "[S] Blues",
  PuBuGn: "[S] Purple-Blue-Green",
  Viridis: "[D] Viridis",
  Spectral: "[D] Spectral",
  RdYlGn: "[D] Red-Yellow-Green",
  RdBu: "[D] Red-Blue",
  PiYG: "[D] Pink-Yellowgreen",
  PRGn: "[D] Purplered-Green",
  RdYlBu: "[D] Red-Yellow-Blue",
  BrBG: "[D] Brown-Bluegreen",
  RdGy: "[D] Red-Grey",
  PuOr: "[D] Purple-Orange",
  Set1: "[Q] Set1",
  Set2: "[Q] Set2",
  Set3: "[Q] Set3",
  Dark2: "[Q] Dark2",
  Paired: "[Q] Paired",
  Pastel1: "[Q] Pastel1",
  Pastel2: "[Q] Pastel2",
  Accent: "[Q] Accent",
  rainbow: "[?] Rainbow",
  rwb: "[?] Red-White-Blue"
};
var ColormakerModes = {
  "": "",
  rgb: "Red Green Blue",
  hsv: "Hue Saturation Value",
  hsl: "Hue Saturation Lightness",
  hsi: "Hue Saturation Intensity",
  lab: "CIE L*a*b*",
  hcl: "Hue Chroma Lightness"
};
var ColormakerRegistry$1 = function ColormakerRegistry() {
  this.schemes = {};
  this.userSchemes = {};
};
ColormakerRegistry$1.prototype.getScheme = function getScheme(params) {
  var p = params || {};
  var id = p.scheme || "";
  var SchemeClass;
  if (id in this.schemes) {
    SchemeClass = this.schemes[id];
  } else if (id in this.userSchemes) {
    SchemeClass = this.userSchemes[id];
  } else {
    SchemeClass = Colormaker;
  }
  return new SchemeClass(params);
};
ColormakerRegistry$1.prototype.getSchemes = function getSchemes() {
  var types = {};
  Object.keys(this.schemes).forEach(function(k) {
    types[k] = k;
  });
  Object.keys(this.userSchemes).forEach(function(k) {
    types[k] = k.split("|")[1];
  });
  return types;
};
ColormakerRegistry$1.prototype.getScales = function getScales() {
  return ColormakerScales;
};
ColormakerRegistry$1.prototype.getModes = function getModes() {
  return ColormakerModes;
};
ColormakerRegistry$1.prototype.add = function add3(id, scheme) {
  this.schemes[id] = scheme;
};
ColormakerRegistry$1.prototype.addScheme = function addScheme(scheme, label) {
  if (!(scheme instanceof Colormaker)) {
    scheme = this._createScheme(scheme, label);
  }
  return this._addUserScheme(scheme, label);
};
ColormakerRegistry$1.prototype._addUserScheme = function _addUserScheme(scheme, label) {
  label = label || "";
  var id = "" + generateUUID() + "|" + label;
  this.userSchemes[id] = scheme;
  return id;
};
ColormakerRegistry$1.prototype.removeScheme = function removeScheme(id) {
  delete this.userSchemes[id];
};
ColormakerRegistry$1.prototype._createScheme = function _createScheme(constructor, label) {
  var _Colormaker = function(params) {
    Colormaker.call(this, params);
    this.label = label || "";
    constructor.call(this, params);
  };
  _Colormaker.prototype = Colormaker.prototype;
  _Colormaker.prototype.constructor = Colormaker;
  return _Colormaker;
};
ColormakerRegistry$1.prototype.addSelectionScheme = function addSelectionScheme(dataList, label) {
  var MySelectionColormaker = function(SelectionColormaker$$1) {
    function MySelectionColormaker2(params) {
      SelectionColormaker$$1.call(this, Object.assign({dataList}, params));
    }
    if (SelectionColormaker$$1)
      MySelectionColormaker2.__proto__ = SelectionColormaker$$1;
    MySelectionColormaker2.prototype = Object.create(SelectionColormaker$$1 && SelectionColormaker$$1.prototype);
    MySelectionColormaker2.prototype.constructor = MySelectionColormaker2;
    return MySelectionColormaker2;
  }(SelectionColormaker);
  return this._addUserScheme(MySelectionColormaker, label);
};
ColormakerRegistry$1.prototype.hasScheme = function hasScheme(id) {
  return id in this.schemes || id in this.userSchemes;
};
var Browser = getBrowser();
var Mobile = typeof window !== "undefined" ? typeof window.orientation !== "undefined" : false;
var SupportsReadPixelsFloat = false;
function setSupportsReadPixelsFloat(value2) {
  SupportsReadPixelsFloat = value2;
}
var ExtensionFragDepth = false;
function setExtensionFragDepth(value2) {
  ExtensionFragDepth = value2;
}
var Log = {
  log: Function.prototype.bind.call(console.log, console),
  info: Function.prototype.bind.call(console.info, console),
  warn: Function.prototype.bind.call(console.warn, console),
  error: Function.prototype.bind.call(console.error, console),
  time: Function.prototype.bind.call(console.time, console),
  timeEnd: Function.prototype.bind.call(console.timeEnd, console)
};
var Debug = boolean(getQuery("debug"));
function setDebug(value2) {
  Debug = value2;
}
var WebglErrorMessage = '<div style="display:flex;align-items:center;justify-content:center;height:100%;"><p style="padding:15px;text-align:center;">Your browser/graphics card does not seem to support <a target="_blank" href="https://en.wikipedia.org/wiki/WebGL">WebGL</a>.<br/><br/>Find out how to get it <a target="_blank" href="http://get.webgl.org/">here</a>.</p></div>';
var WorkerRegistry2 = new WorkerRegistry$1();
var ColormakerRegistry2 = new ColormakerRegistry$1();
var DatasourceRegistry = new Registry("datasource");
var RepresentationRegistry = new Registry("representatation");
var ParserRegistry = new Registry("parser");
var ShaderRegistry = new Registry("shader");
var DecompressorRegistry = new Registry("decompressor");
var ComponentRegistry = new Registry("component");
var Streamer = function Streamer2(src, params) {
  var p = params || {};
  this.compressed = defaults(p.compressed, false);
  this.binary = defaults(p.binary, false);
  this.json = defaults(p.json, false);
  this.xml = defaults(p.xml, false);
  this.src = src;
  this.chunkSize = 1024 * 1024 * 10;
  this.newline = "\n";
  this.__pointer = 0;
  this.__partialLine = "";
  if (this.__srcName) {
    this[this.__srcName] = src;
  }
};
var prototypeAccessors$2 = {type: {}, __srcName: {}};
prototypeAccessors$2.type.get = function() {
  return "";
};
prototypeAccessors$2.__srcName.get = function() {
  return void 0;
};
Streamer.prototype.isBinary = function isBinary() {
  return this.binary || this.compressed;
};
Streamer.prototype.onload = function onload() {
};
Streamer.prototype.onprogress = function onprogress() {
};
Streamer.prototype.onerror = function onerror() {
};
Streamer.prototype.read = function read() {
  var this$1 = this;
  return new Promise(function(resolve2, reject2) {
    try {
      this$1._read(function(data) {
        var decompressFn = DecompressorRegistry.get(this$1.compressed);
        if (this$1.compressed && decompressFn) {
          this$1.data = decompressFn(data);
        } else {
          if ((this$1.binary || this$1.compressed) && data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
          }
          this$1.data = data;
        }
        resolve2(this$1.data);
      });
    } catch (e) {
      reject2(e);
    }
  });
};
Streamer.prototype._read = function _read(callback) {
  callback(this.src);
};
Streamer.prototype._chunk = function _chunk(start, end) {
  end = Math.min(this.data.length, end);
  if (start === 0 && this.data.length === end) {
    return this.data;
  } else {
    if (this.isBinary()) {
      return this.data.subarray(start, end);
    } else {
      return this.data.substring(start, end);
    }
  }
};
Streamer.prototype.chunk = function chunk(start) {
  var end = start + this.chunkSize;
  return this._chunk(start, end);
};
Streamer.prototype.peekLines = function peekLines(m2) {
  var data = this.data;
  var n = data.length;
  var newline = this.isBinary() ? this.newline.charCodeAt(0) : this.newline;
  var i;
  var count2 = 0;
  for (i = 0; i < n; ++i) {
    if (data[i] === newline) {
      ++count2;
    }
    if (count2 === m2) {
      break;
    }
  }
  var chunk2 = this._chunk(0, i + 1);
  var d = this.chunkToLines(chunk2, "", i > n);
  return d.lines;
};
Streamer.prototype.chunkCount = function chunkCount() {
  return Math.floor(this.data.length / this.chunkSize) + 1;
};
Streamer.prototype.asText = function asText() {
  return this.isBinary() ? uint8ToString(this.data) : this.data;
};
Streamer.prototype.chunkToLines = function chunkToLines(chunk2, partialLine, isLast) {
  var newline = this.newline;
  if (!this.isBinary() && chunk2.length === this.data.length) {
    return {
      lines: chunk2.split(newline),
      partialLine: ""
    };
  }
  var lines = [];
  var str = this.isBinary() ? uint8ToString(chunk2) : chunk2;
  var idx = str.lastIndexOf(newline);
  if (idx === -1) {
    partialLine += str;
  } else {
    var str2 = partialLine + str.substr(0, idx);
    lines = lines.concat(str2.split(newline));
    if (idx === str.length - newline.length) {
      partialLine = "";
    } else {
      partialLine = str.substr(idx + newline.length);
    }
  }
  if (isLast && partialLine !== "") {
    lines.push(partialLine);
  }
  return {
    lines,
    partialLine
  };
};
Streamer.prototype.nextChunk = function nextChunk() {
  var start = this.__pointer;
  if (start > this.data.length) {
    return void 0;
  }
  this.__pointer += this.chunkSize;
  return this.chunk(start);
};
Streamer.prototype.nextChunkOfLines = function nextChunkOfLines() {
  var chunk2 = this.nextChunk();
  if (chunk2 === void 0) {
    return void 0;
  }
  var isLast = this.__pointer > this.data.length;
  var d = this.chunkToLines(chunk2, this.__partialLine, isLast);
  this.__partialLine = d.partialLine;
  return d.lines;
};
Streamer.prototype.eachChunk = function eachChunk(callback) {
  var this$1 = this;
  var chunkSize = this.chunkSize;
  var n = this.data.length;
  var chunkCount2 = this.chunkCount();
  for (var i = 0; i < n; i += chunkSize) {
    var chunk2 = this$1.chunk(i);
    var chunkNo = Math.round(i / chunkSize);
    callback(chunk2, chunkNo, chunkCount2);
  }
};
Streamer.prototype.eachChunkOfLines = function eachChunkOfLines(callback) {
  var this$1 = this;
  this.eachChunk(function(chunk2, chunkNo, chunkCount2) {
    var isLast = chunkNo === chunkCount2 + 1;
    var d = this$1.chunkToLines(chunk2, this$1.__partialLine, isLast);
    this$1.__partialLine = d.partialLine;
    callback(d.lines, chunkNo, chunkCount2);
  });
};
Streamer.prototype.dispose = function dispose() {
  delete this.src;
  if (this.__srcName) {
    delete this[this.__srcName];
  }
};
Object.defineProperties(Streamer.prototype, prototypeAccessors$2);
var FileStreamer = function(Streamer$$1) {
  function FileStreamer2() {
    Streamer$$1.apply(this, arguments);
  }
  if (Streamer$$1)
    FileStreamer2.__proto__ = Streamer$$1;
  FileStreamer2.prototype = Object.create(Streamer$$1 && Streamer$$1.prototype);
  FileStreamer2.prototype.constructor = FileStreamer2;
  var prototypeAccessors2 = {type: {}, __srcName: {}};
  prototypeAccessors2.type.get = function() {
    return "file";
  };
  prototypeAccessors2.__srcName.get = function() {
    return "file";
  };
  FileStreamer2.prototype._read = function _read2(callback) {
    var this$1 = this;
    var reader;
    if (typeof importScripts === "function") {
      reader = new window.FileReaderSync();
      var data;
      if (this.binary || this.compressed) {
        data = reader.readAsArrayBuffer(this.file);
      } else {
        data = reader.readAsText(this.file);
      }
      callback(data);
    } else {
      reader = new window.FileReader();
      reader.onload = function(event) {
        callback(event.target.result);
      };
      if (typeof this.onprogress === "function") {
        reader.onprogress = function(event) {
          this$1.onprogress(event);
        };
      }
      if (typeof this.onerror === "function") {
        reader.onerror = function(event) {
          this$1.onerror(event);
        };
      }
      if (this.binary || this.compressed) {
        reader.readAsArrayBuffer(this.file);
      } else {
        reader.readAsText(this.file);
      }
    }
  };
  Object.defineProperties(FileStreamer2.prototype, prototypeAccessors2);
  return FileStreamer2;
}(Streamer);
var NetworkStreamer = function(Streamer$$1) {
  function NetworkStreamer2() {
    Streamer$$1.apply(this, arguments);
  }
  if (Streamer$$1)
    NetworkStreamer2.__proto__ = Streamer$$1;
  NetworkStreamer2.prototype = Object.create(Streamer$$1 && Streamer$$1.prototype);
  NetworkStreamer2.prototype.constructor = NetworkStreamer2;
  var prototypeAccessors2 = {type: {}, __srcName: {}};
  prototypeAccessors2.type.get = function() {
    return "network";
  };
  prototypeAccessors2.__srcName.get = function() {
    return "url";
  };
  NetworkStreamer2.prototype._read = function _read2(callback) {
    var url = this.src;
    if (typeof importScripts === "function") {
      if (url.substr(0, 3) === "../") {
        url = "../" + url;
      }
    }
    var xhr = new window.XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.addEventListener("load", function() {
      if (xhr.status === 200 || xhr.status === 304 || xhr.status === 0) {
        try {
          callback(xhr.response);
        } catch (e) {
          this.onerror(e);
        }
      } else {
        if (typeof this.onerror === "function") {
          this.onerror(xhr.status);
        }
        throw new Error("NetworkStreamer._read: status code " + xhr.status);
      }
    }.bind(this), false);
    if (typeof this.onerror === "function") {
      xhr.addEventListener("error", function(event) {
        this.onerror(event);
      }.bind(this), false);
    }
    if (this.isBinary()) {
      xhr.responseType = "arraybuffer";
    } else if (this.json) {
      xhr.responseType = "json";
    } else if (this.xml) {
      xhr.responseType = "document";
    } else {
      xhr.responseType = "text";
    }
    xhr.send(null);
  };
  Object.defineProperties(NetworkStreamer2.prototype, prototypeAccessors2);
  return NetworkStreamer2;
}(Streamer);
var binaryFileExtensions = [
  "mmtf",
  "dcd",
  "mrc",
  "ccp4",
  "map",
  "dsn6",
  "brix",
  "dxbin"
];
var jsonFileTypes = [
  "json"
];
var xmlFileTypes = [
  "xml",
  "validation"
];
var Loader$1 = function Loader2(src, params) {
  var p = Object.assign({}, params);
  var binary = binaryFileExtensions.includes(p.ext);
  this.compressed = defaults(p.compressed, false);
  this.binary = defaults(p.binary, binary);
  this.name = defaults(p.name, "");
  this.ext = defaults(p.ext, "");
  this.dir = defaults(p.dir, "");
  this.path = defaults(p.path, "");
  this.protocol = defaults(p.protocol, "");
  this.params = params;
  var streamerParams = {
    compressed: this.compressed,
    binary: this.binary,
    json: jsonFileTypes.includes(this.ext),
    xml: xmlFileTypes.includes(this.ext)
  };
  if (typeof File !== "undefined" && src instanceof window.File || typeof Blob !== "undefined" && src instanceof window.Blob) {
    this.streamer = new FileStreamer(src, streamerParams);
  } else {
    this.streamer = new NetworkStreamer(src, streamerParams);
  }
  if (typeof p.onProgress === "function") {
    this.streamer.onprogress = p.onprogress;
  }
};
Loader$1.prototype.load = function load() {
  return Promise.reject(new Error("not implemented"));
};
var ParserLoader = function(Loader3) {
  function ParserLoader2() {
    Loader3.apply(this, arguments);
  }
  if (Loader3)
    ParserLoader2.__proto__ = Loader3;
  ParserLoader2.prototype = Object.create(Loader3 && Loader3.prototype);
  ParserLoader2.prototype.constructor = ParserLoader2;
  ParserLoader2.prototype.load = function load2() {
    var ParserClass = ParserRegistry.get(this.ext);
    var parser = new ParserClass(this.streamer, this.params);
    return parser.parse();
  };
  return ParserLoader2;
}(Loader$1);
var Script = function Script2(functionBody, name, path) {
  this.signals = {
    elementAdded: new Signal(),
    elementRemoved: new Signal(),
    nameChanged: new Signal()
  };
  this.name = name;
  this.path = path;
  this.dir = path.substring(0, path.lastIndexOf("/") + 1);
  try {
    this.fn = new Function("stage", "panel", "__name__", "__path__", "__dir__", functionBody);
  } catch (e) {
    Log.error("Script compilation failed", e);
    this.fn = function() {
    };
  }
};
var prototypeAccessors$3 = {type: {}};
prototypeAccessors$3.type.get = function() {
  return "Script";
};
Script.prototype.call = function call(stage) {
  var this$1 = this;
  var panel = {
    add: function() {
      this.signals.elementAdded.dispatch(arguments);
    }.bind(this),
    remove: function() {
      this.signals.elementRemoved.dispatch(arguments);
    }.bind(this),
    setName: function(value2) {
      this.signals.nameChanged.dispatch(value2);
    }.bind(this)
  };
  return new Promise(function(resolve2, reject2) {
    var args = [
      stage,
      panel,
      this$1.name,
      this$1.path,
      this$1.dir
    ];
    try {
      this$1.fn.apply(null, args);
      resolve2();
    } catch (e) {
      Log.error("Script.fn", e);
      reject2(e);
    }
  });
};
Object.defineProperties(Script.prototype, prototypeAccessors$3);
var ScriptLoader = function(Loader3) {
  function ScriptLoader2() {
    Loader3.apply(this, arguments);
  }
  if (Loader3)
    ScriptLoader2.__proto__ = Loader3;
  ScriptLoader2.prototype = Object.create(Loader3 && Loader3.prototype);
  ScriptLoader2.prototype.constructor = ScriptLoader2;
  ScriptLoader2.prototype.load = function load2() {
    var this$1 = this;
    return this.streamer.read().then(function() {
      return new Script(this$1.streamer.asText(), this$1.name, this$1.path);
    });
  };
  return ScriptLoader2;
}(Loader$1);
var PluginLoader = function(Loader3) {
  function PluginLoader2() {
    Loader3.apply(this, arguments);
  }
  if (Loader3)
    PluginLoader2.__proto__ = Loader3;
  PluginLoader2.prototype = Object.create(Loader3 && Loader3.prototype);
  PluginLoader2.prototype.constructor = PluginLoader2;
  PluginLoader2.prototype.load = function load2() {
    var this$1 = this;
    var basePath;
    if (this.protocol) {
      basePath = this.protocol + "://" + this.dir;
    } else {
      basePath = this.dir;
    }
    return this.streamer.read().then(function() {
      var manifest = JSON.parse(this$1.streamer.asText());
      var promiseList = [];
      manifest.files.map(function(name) {
        promiseList.push(autoLoad(basePath + name, {
          ext: "text",
          useWorker: false
        }));
      });
      return Promise.all(promiseList).then(function(dataList) {
        var text = dataList.reduce(function(text2, value2) {
          return text2 + "\n\n" + value2.data;
        }, "");
        text += manifest.source || "";
        return new Script(text, this$1.name, this$1.path);
      });
    });
  };
  return PluginLoader2;
}(Loader$1);
function getDataInfo(src) {
  var info = getFileInfo(src);
  var datasource = DatasourceRegistry.get(info.protocol);
  if (datasource) {
    info = getFileInfo(datasource.getUrl(info.src));
    if (!info.ext && datasource.getExt) {
      info.ext = datasource.getExt(src);
    }
  }
  return info;
}
function autoLoad(file, params) {
  var p = Object.assign(getDataInfo(file), params);
  var LoaderClass;
  if (ParserRegistry.names.includes(p.ext)) {
    LoaderClass = ParserLoader;
  } else if (["ngl", "js"].includes(p.ext)) {
    LoaderClass = ScriptLoader;
  } else if (p.ext === "plugin") {
    LoaderClass = PluginLoader;
  }
  if (LoaderClass) {
    var loader = new LoaderClass(p.src, p);
    return loader.load();
  } else {
    return Promise.reject(new Error("autoLoad: ext '" + p.ext + "' unknown"));
  }
}
/*! sprintf-js v1.0.3 | Copyright (c) 2007-present, Alexandru Marasteanu <hello@alexei.ro> | BSD-3-Clause */
var re = {
  not_string: /[^s]/,
  not_bool: /[^t]/,
  not_type: /[^T]/,
  not_primitive: /[^v]/,
  number: /[diefg]/,
  numeric_arg: /bcdiefguxX/,
  json: /[j]/,
  not_json: /[^j]/,
  text: /^[^\x25]+/,
  modulo: /^\x25{2}/,
  placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
  key: /^([a-z_][a-z_\d]*)/i,
  key_access: /^\.([a-z_][a-z_\d]*)/i,
  index_access: /^\[(\d+)\]/,
  sign: /^[\+\-]/
};
function sprintf() {
  var key = arguments[0], cache = sprintf.cache;
  if (!(cache[key] && cache.hasOwnProperty(key))) {
    cache[key] = sprintf.parse(key);
  }
  return sprintf.format.call(null, cache[key], arguments);
}
sprintf.format = function(parse_tree, argv) {
  var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = "";
  for (i = 0; i < tree_length; i++) {
    node_type = get_type(parse_tree[i]);
    if (node_type === "string") {
      output[output.length] = parse_tree[i];
    } else if (node_type === "array") {
      match = parse_tree[i];
      if (match[2]) {
        arg = argv[cursor];
        for (k = 0; k < match[2].length; k++) {
          if (!arg.hasOwnProperty(match[2][k])) {
            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
          }
          arg = arg[match[2][k]];
        }
      } else if (match[1]) {
        arg = argv[match[1]];
      } else {
        arg = argv[cursor++];
      }
      if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == "function") {
        arg = arg();
      }
      if (re.numeric_arg.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
        throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)));
      }
      if (re.number.test(match[8])) {
        is_positive = arg >= 0;
      }
      switch (match[8]) {
        case "b":
          arg = parseInt(arg, 10).toString(2);
          break;
        case "c":
          arg = String.fromCharCode(parseInt(arg, 10));
          break;
        case "d":
        case "i":
          arg = parseInt(arg, 10);
          break;
        case "j":
          arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
          break;
        case "e":
          arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
          break;
        case "f":
          arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
          break;
        case "g":
          arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);
          break;
        case "o":
          arg = arg.toString(8);
          break;
        case "s":
          arg = String(arg);
          arg = match[7] ? arg.substring(0, match[7]) : arg;
          break;
        case "t":
          arg = String(!!arg);
          arg = match[7] ? arg.substring(0, match[7]) : arg;
          break;
        case "T":
          arg = get_type(arg);
          arg = match[7] ? arg.substring(0, match[7]) : arg;
          break;
        case "u":
          arg = parseInt(arg, 10) >>> 0;
          break;
        case "v":
          arg = arg.valueOf();
          arg = match[7] ? arg.substring(0, match[7]) : arg;
          break;
        case "x":
          arg = parseInt(arg, 10).toString(16);
          break;
        case "X":
          arg = parseInt(arg, 10).toString(16).toUpperCase();
          break;
      }
      if (re.json.test(match[8])) {
        output[output.length] = arg;
      } else {
        if (re.number.test(match[8]) && (!is_positive || match[3])) {
          sign = is_positive ? "+" : "-";
          arg = arg.toString().replace(re.sign, "");
        } else {
          sign = "";
        }
        pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " ";
        pad_length = match[6] - (sign + arg).length;
        pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : "" : "";
        output[output.length] = match[5] ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
      }
    }
  }
  return output.join("");
};
sprintf.cache = {};
sprintf.parse = function(fmt) {
  var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
  while (_fmt) {
    if ((match = re.text.exec(_fmt)) !== null) {
      parse_tree[parse_tree.length] = match[0];
    } else if ((match = re.modulo.exec(_fmt)) !== null) {
      parse_tree[parse_tree.length] = "%";
    } else if ((match = re.placeholder.exec(_fmt)) !== null) {
      if (match[2]) {
        arg_names |= 1;
        var field_list = [], replacement_field = match[2], field_match = [];
        if ((field_match = re.key.exec(replacement_field)) !== null) {
          field_list[field_list.length] = field_match[1];
          while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
              field_list[field_list.length] = field_match[1];
            } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
              field_list[field_list.length] = field_match[1];
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
          }
        } else {
          throw new SyntaxError("[sprintf] failed to parse named argument key");
        }
        match[2] = field_list;
      } else {
        arg_names |= 2;
      }
      if (arg_names === 3) {
        throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
      }
      parse_tree[parse_tree.length] = match;
    } else {
      throw new SyntaxError("[sprintf] unexpected placeholder");
    }
    _fmt = _fmt.substring(match[0].length);
  }
  return parse_tree;
};
function get_type(variable) {
  if (typeof variable === "number") {
    return "number";
  } else if (typeof variable === "string") {
    return "string";
  } else {
    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
  }
}
var preformattedPadding = {
  "0": ["", "0", "00", "000", "0000", "00000", "000000", "0000000"],
  " ": ["", " ", "  ", "   ", "    ", "     ", "      ", "       "],
  _: ["", "_", "__", "___", "____", "_____", "______", "_______"]
};
function str_repeat(input, multiplier) {
  if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
    return preformattedPadding[input][multiplier];
  }
  return Array(multiplier + 1).join(input);
}
function PdbWriter(structure, params) {
  var p = Object.assign({}, params);
  var renumberSerial = p.renumberSerial !== void 0 ? p.renumberSerial : true;
  var remarks = p.remarks || [];
  if (!Array.isArray(remarks)) {
    remarks = [remarks];
  }
  var records;
  function writeRecords() {
    records = [];
    writeTitle();
    writeRemarks();
    writeAtoms();
  }
  function DEF(x, y) {
    return x !== void 0 ? x : y;
  }
  var atomFormat = "ATOM  %5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s";
  var hetatmFormat = "HETATM%5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s";
  function writeTitle() {
    records.push(sprintf("TITEL %-74s", structure.name));
  }
  function writeRemarks() {
    remarks.forEach(function(str) {
      records.push(sprintf("REMARK %-73s", str));
    });
    if (structure.trajectory) {
      records.push(sprintf("REMARK %-73s", "Trajectory '" + structure.trajectory.name + "'"));
      records.push(sprintf("REMARK %-73s", "Frame " + structure.trajectory.frame + ""));
    }
  }
  function writeAtoms() {
    var ia = 1;
    var im = 1;
    structure.eachModel(function(m2) {
      records.push(sprintf("MODEL %-74d", im++));
      m2.eachAtom(function(a) {
        var formatString = a.hetero ? hetatmFormat : atomFormat;
        var serial = renumberSerial ? ia : a.serial;
        var atomname = a.atomname;
        if (atomname.length === 1) {
          atomname = " " + atomname;
        }
        records.push(sprintf(formatString, serial, atomname, a.resname, DEF(a.chainname, " "), a.resno, a.x, a.y, a.z, DEF(a.occurence, 1), DEF(a.bfactor, 0), DEF(a.segid, ""), DEF(a.element, "")));
        ia += 1;
      });
      records.push(sprintf("%-80s", "ENDMDL"));
      im += 1;
    });
    records.push(sprintf("%-80s", "END"));
  }
  function getString() {
    writeRecords();
    return records.join("\n");
  }
  function getBlob() {
    return new window.Blob([getString()], {type: "text/plain"});
  }
  function _download(name, ext) {
    name = name || "structure";
    ext = ext || "pdb";
    var file = name + "." + ext;
    var blob = getBlob();
    download(blob, file);
  }
  this.getString = getString;
  this.getBlob = getBlob;
  this.download = _download;
}
var Counter = function Counter2() {
  this.count = 0;
  this.signals = {
    countChanged: new Signal()
  };
};
Counter.prototype.clear = function clear() {
  this.change(-this.count);
};
Counter.prototype.change = function change(delta) {
  this.count += delta;
  this.signals.countChanged.dispatch(delta, this.count);
  if (this.count < 0) {
    Log.warn("Counter.count below zero", this.count);
  }
};
Counter.prototype.increment = function increment() {
  this.change(1);
};
Counter.prototype.decrement = function decrement() {
  this.change(-1);
};
Counter.prototype.listen = function listen(counter) {
  this.change(counter.count);
  counter.signals.countChanged.add(this.change, this);
};
Counter.prototype.unlisten = function unlisten(counter) {
  var countChanged = counter.signals.countChanged;
  if (countChanged.has(this.change, this)) {
    countChanged.remove(this.change, this);
  }
};
Counter.prototype.onZeroOnce = function onZeroOnce(callback, context2) {
  if (this.count === 0) {
    callback.call(context2, 0, 0);
  } else {
    var fn = function() {
      if (this.count === 0) {
        this.signals.countChanged.remove(fn, this);
        callback.apply(context2, arguments);
      }
    };
    this.signals.countChanged.add(fn, this);
  }
};
Counter.prototype.dispose = function dispose2() {
  this.clear();
  this.signals.countChanged.dispose();
};
ShaderRegistry.add("shader/BasicLine.vert", "void main(){\n#include begin_vertex\n#include project_vertex\n}");
ShaderRegistry.add("shader/BasicLine.frag", "uniform vec3 uColor;\n#include common\n#include fog_pars_fragment\nvoid main(){\ngl_FragColor = vec4( uColor, 1.0 );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n}");
ShaderRegistry.add("shader/Quad.vert", "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}");
ShaderRegistry.add("shader/Quad.frag", "varying vec2 vUv;\nuniform sampler2D tForeground;\nuniform float scale;\nvoid main() {\nvec4 foreground = texture2D( tForeground, vUv );\ngl_FragColor = foreground * scale;\n}");
function Stats() {
  this.signals = {
    updated: new Signal()
  };
  this.begin();
  this.maxDuration = -Infinity;
  this.minDuration = Infinity;
  this.avgDuration = 14;
  this.lastDuration = Infinity;
  this.prevFpsTime = 0;
  this.lastFps = Infinity;
  this.lastFrames = 1;
  this.frames = 0;
  this.count = 0;
}
Stats.prototype = {
  update: function() {
    this.startTime = this.end();
    this.currentTime = this.startTime;
    this.signals.updated.dispatch();
  },
  begin: function() {
    this.startTime = window.performance.now();
    this.lastFrames = this.frames;
  },
  end: function() {
    var time = window.performance.now();
    this.count += 1;
    this.frames += 1;
    this.lastDuration = time - this.startTime;
    this.minDuration = Math.min(this.minDuration, this.lastDuration);
    this.maxDuration = Math.max(this.maxDuration, this.lastDuration);
    this.avgDuration -= this.avgDuration / 30;
    this.avgDuration += this.lastDuration / 30;
    if (time > this.prevFpsTime + 1e3) {
      this.lastFps = this.frames;
      this.prevFpsTime = time;
      this.frames = 0;
    }
    return time;
  }
};
ShaderRegistry.add("shader/chunk/dull_interior_fragment.glsl", "#ifdef DULL_INTERIOR\nif( gl_FrontFacing == false ){\nnormal = vec3( 0.0, 0.0, 0.4 );\n}\n#endif");
ShaderRegistry.add("shader/chunk/fog_fragment.glsl", "#ifdef USE_FOG\nfloat depth = length( vViewPosition );\n#ifdef FOG_EXP2\nfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif");
ShaderRegistry.add("shader/chunk/matrix_scale.glsl", "float matrixScale( in mat4 m ){\nvec4 r = m[ 0 ];\nreturn sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );\n}");
ShaderRegistry.add("shader/chunk/nearclip_vertex.glsl", "#ifdef NEAR_CLIP\nif( vViewPosition.z < nearClip - 5.0 )\ngl_Position.z = 2.0 * gl_Position.w;\n#endif");
ShaderRegistry.add("shader/chunk/nearclip_fragment.glsl", "#ifdef NEAR_CLIP\nif( vViewPosition.z < nearClip )\ndiscard;\n#endif");
ShaderRegistry.add("shader/chunk/opaque_back_fragment.glsl", "#ifdef OPAQUE_BACK\n#ifdef FLIP_SIDED\nif( gl_FrontFacing == true ){\ngl_FragColor.a = 1.0;\n}\n#else\nif( gl_FrontFacing == false ){\ngl_FragColor.a = 1.0;\n}\n#endif\n#endif");
ShaderRegistry.add("shader/chunk/radiusclip_vertex.glsl", "#ifdef RADIUS_CLIP\nif( distance( vViewPosition, vClipCenter ) > clipRadius + 5.0 )\ngl_Position.z = 2.0 * gl_Position.w;\n#endif");
ShaderRegistry.add("shader/chunk/radiusclip_fragment.glsl", "#ifdef RADIUS_CLIP\nif( distance( vViewPosition, vClipCenter ) > clipRadius )\ndiscard;\n#endif");
ShaderRegistry.add("shader/chunk/unpack_color.glsl", "vec3 unpackColor(float f) {\nvec3 color;\ncolor.r = floor(f / 256.0 / 256.0);\ncolor.g = floor((f - color.r * 256.0 * 256.0) / 256.0);\ncolor.b = floor(f - color.r * 256.0 * 256.0 - color.g * 256.0);\nreturn color / 255.0;\n}");
function getDefines(defines) {
  if (defines === void 0) {
    return "";
  }
  var lines = [];
  for (var name in defines) {
    var value2 = defines[name];
    if (value2 === false) {
      continue;
    }
    lines.push("#define " + name + " " + value2);
  }
  return lines.join("\n") + "\n";
}
var reInclude = /^(?!\/\/)\s*#include\s+(\S+)/gmi;
var shaderCache = {};
function getShader(name, defines) {
  defines = defines || {};
  var hash = name + "|";
  for (var key in defines) {
    hash += key + ":" + defines[key];
  }
  if (!shaderCache[hash]) {
    var definesText = getDefines(defines);
    var shaderText = ShaderRegistry.get("shader/" + name);
    if (!shaderText) {
      throw new Error("empty shader, '" + name + "'");
    }
    shaderText = shaderText.replace(reInclude, function(match, p1) {
      var path = "shader/chunk/" + p1 + ".glsl";
      var chunk2 = ShaderRegistry.get(path) || ShaderChunk[p1];
      return chunk2 || "";
    });
    shaderCache[hash] = definesText + shaderText;
  }
  return shaderCache[hash];
}
if (typeof window !== "undefined" && window.WebGLRenderingContext) {
  var wrcp = window.WebGLRenderingContext.prototype;
  var _getShaderParameter = wrcp.getShaderParameter;
  wrcp.getShaderParameter = function getShaderParameter() {
    if (Debug) {
      return _getShaderParameter.apply(this, arguments);
    } else {
      return true;
    }
  };
  var _getShaderInfoLog = wrcp.getShaderInfoLog;
  wrcp.getShaderInfoLog = function getShaderInfoLog() {
    if (Debug) {
      return _getShaderInfoLog.apply(this, arguments);
    } else {
      return "";
    }
  };
  var _getProgramParameter = wrcp.getProgramParameter;
  wrcp.getProgramParameter = function getProgramParameter(program, pname) {
    if (Debug || pname !== wrcp.LINK_STATUS) {
      return _getProgramParameter.apply(this, arguments);
    } else {
      return true;
    }
  };
  var _getProgramInfoLog = wrcp.getProgramInfoLog;
  wrcp.getProgramInfoLog = function getProgramInfoLog() {
    if (Debug) {
      return _getProgramInfoLog.apply(this, arguments);
    } else {
      return "";
    }
  };
}
var JitterVectors = [
  [
    [0, 0]
  ],
  [
    [4, 4],
    [-4, -4]
  ],
  [
    [-2, -6],
    [6, -2],
    [-6, 2],
    [2, 6]
  ],
  [
    [1, -3],
    [-1, 3],
    [5, 1],
    [-3, -5],
    [-5, 5],
    [-7, -1],
    [3, 7],
    [7, -7]
  ],
  [
    [1, 1],
    [-1, -3],
    [-3, 2],
    [4, -1],
    [-5, -2],
    [2, 5],
    [5, 3],
    [3, -5],
    [-2, 6],
    [0, -7],
    [-4, -6],
    [-6, 4],
    [-8, 0],
    [7, -4],
    [6, 7],
    [-7, -8]
  ],
  [
    [-4, -7],
    [-7, -5],
    [-3, -5],
    [-5, -4],
    [-1, -4],
    [-2, -2],
    [-6, -1],
    [-4, 0],
    [-7, 1],
    [-1, 2],
    [-6, 3],
    [-3, 3],
    [-7, 6],
    [-3, 6],
    [-5, 7],
    [-1, 7],
    [5, -7],
    [1, -6],
    [6, -5],
    [4, -4],
    [2, -3],
    [7, -2],
    [1, -1],
    [4, -1],
    [2, 1],
    [6, 2],
    [0, 4],
    [4, 4],
    [2, 5],
    [7, 5],
    [5, 6],
    [3, 7]
  ]
];
JitterVectors.forEach(function(offsetList) {
  offsetList.forEach(function(offset) {
    offset[0] *= 0.0625;
    offset[1] *= 0.0625;
  });
});
function TiledRenderer(renderer, camera, viewer, params) {
  var p = params || {};
  var factor = p.factor !== void 0 ? p.factor : 2;
  var antialias = p.antialias !== void 0 ? p.antialias : false;
  var onProgress = p.onProgress;
  var onFinish = p.onFinish;
  if (antialias) {
    factor *= 2;
  }
  var n = factor * factor;
  var canvas = document.createElement("canvas");
  var width = viewer.width;
  var height = viewer.height;
  if (antialias) {
    canvas.width = width * factor / 2;
    canvas.height = height * factor / 2;
  } else {
    canvas.width = width * factor;
    canvas.height = height * factor;
  }
  var ctx = canvas.getContext("2d");
  var viewerSampleLevel = viewer.sampleLevel;
  viewer.setSampling(-1);
  function renderTile(i) {
    var x = i % factor;
    var y = Math.floor(i / factor);
    var offsetX = x * width;
    var offsetY = y * height;
    viewer.camera.setViewOffset(width * factor, height * factor, offsetX, offsetY, width, height);
    viewer.render();
    if (antialias) {
      ctx.drawImage(renderer.domElement, Math.floor(offsetX / 2), Math.floor(offsetY / 2), Math.ceil(width / 2), Math.ceil(height / 2));
    } else {
      ctx.drawImage(renderer.domElement, Math.floor(offsetX), Math.floor(offsetY), Math.ceil(width), Math.ceil(height));
    }
    if (typeof onProgress === "function") {
      onProgress(i + 1, n, false);
    }
  }
  function finalize() {
    viewer.setSampling(viewerSampleLevel);
    viewer.camera.view = null;
    if (typeof onFinish === "function") {
      onFinish(n + 1, n, false);
    }
  }
  function render() {
    for (var i = 0; i <= n; ++i) {
      if (i === n) {
        finalize();
      } else {
        renderTile(i);
      }
    }
  }
  function renderAsync() {
    var count2 = 0;
    function fn() {
      if (count2 === n) {
        finalize();
      } else {
        renderTile(count2);
      }
      count2 += 1;
    }
    for (var i = 0; i <= n; ++i) {
      setTimeout(fn, 0, i);
    }
  }
  this.render = render;
  this.renderAsync = renderAsync;
  this.canvas = canvas;
}
TiledRenderer.prototype.constructor = TiledRenderer;
var TwoPI = 2 * Math.PI;
function circularMean(array, max2, stride, offset, indices) {
  stride = stride || 1;
  offset = offset || 0;
  var n = indices ? indices.length : array.length / stride;
  var angle, i, c;
  var cosMean = 0;
  var sinMean = 0;
  if (indices) {
    for (i = 0; i < n; ++i) {
      c = (array[indices[i] * stride + offset] + max2) % max2;
      angle = c / max2 * TwoPI - Math.PI;
      cosMean += Math.cos(angle);
      sinMean += Math.sin(angle);
    }
  } else {
    for (i = offset; i < n; i += stride) {
      c = (array[i] + max2) % max2;
      angle = c / max2 * TwoPI - Math.PI;
      cosMean += Math.cos(angle);
      sinMean += Math.sin(angle);
    }
  }
  cosMean /= n;
  sinMean /= n;
  var meanAngle = Math.atan2(sinMean, cosMean);
  var mean = (meanAngle + Math.PI) / TwoPI * max2;
  return mean;
}
function calculateCenterArray(array1, array2, center2, offset) {
  var n = array1.length;
  center2 = center2 || new Float32Array(n);
  offset = offset || 0;
  for (var i = 0; i < n; i += 3) {
    center2[offset + i + 0] = (array1[i + 0] + array2[i + 0]) / 2;
    center2[offset + i + 1] = (array1[i + 1] + array2[i + 1]) / 2;
    center2[offset + i + 2] = (array1[i + 2] + array2[i + 2]) / 2;
  }
  return center2;
}
function uniformArray(n, a, optionalTarget) {
  var array = optionalTarget || new Float32Array(n);
  for (var i = 0; i < n; ++i) {
    array[i] = a;
  }
  return array;
}
function uniformArray3(n, a, b, c, optionalTarget) {
  var array = optionalTarget || new Float32Array(n * 3);
  var j;
  for (var i = 0; i < n; ++i) {
    j = i * 3;
    array[j + 0] = a;
    array[j + 1] = b;
    array[j + 2] = c;
  }
  return array;
}
function centerArray3(array, center2) {
  var n = array.length;
  center2 = center2 || new Vector3();
  for (var i = 0; i < n; i += 3) {
    center2.x += array[i];
    center2.y += array[i + 1];
    center2.z += array[i + 2];
  }
  center2.divideScalar(n / 3);
  return center2;
}
function serialArray(n) {
  var array = new Float32Array(n);
  for (var i = 0; i < n; ++i) {
    array[i] = i;
  }
  return array;
}
function serialBlockArray(n, b, offset, optionalTarget) {
  if (offset === void 0)
    offset = 0;
  var array = optionalTarget || new Float32Array(n * b);
  for (var i = 0; i < n; ++i) {
    var k = offset + i * b;
    for (var j = 0; j < b; ++j) {
      array[k + j] = i;
    }
  }
  return array;
}
function calculateMinArray(array1, array2) {
  var n = array1.length;
  var min = new Float32Array(n);
  for (var i = 0; i < n; i++) {
    min[i] = Math.min(array1[i], array2[i]);
  }
  return min;
}
function copyArray(src, dst, srcOffset, dstOffset, length) {
  for (var i = 0; i < length; ++i) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
}
function copyWithin(array, srcOffset, dstOffset, length) {
  copyArray(array, array, srcOffset, dstOffset, length);
}
function quicksortCmp(arr, cmp, begin, end) {
  cmp = cmp || function cmp2(a, b) {
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    return 0;
  };
  begin = begin || 0;
  end = (end || arr.length) - 1;
  var stack = [];
  var sp = -1;
  var left = begin;
  var right = end;
  var tmp2 = 0;
  var tmp22 = 0;
  function swap(a, b) {
    tmp22 = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp22;
  }
  var i, j;
  while (true) {
    if (right - left <= 25) {
      for (j = left + 1; j <= right; ++j) {
        tmp2 = arr[j];
        i = j - 1;
        while (i >= left && cmp(arr[i], tmp2) > 0) {
          arr[i + 1] = arr[i];
          --i;
        }
        arr[i + 1] = tmp2;
      }
      if (sp === -1) {
        break;
      }
      right = stack[sp--];
      left = stack[sp--];
    } else {
      var median = left + right >> 1;
      i = left + 1;
      j = right;
      swap(median, i);
      if (cmp(arr[left], arr[right]) > 0) {
        swap(left, right);
      }
      if (cmp(arr[i], arr[right]) > 0) {
        swap(i, right);
      }
      if (cmp(arr[left], arr[i]) > 0) {
        swap(left, i);
      }
      tmp2 = arr[i];
      while (true) {
        do {
          i++;
        } while (cmp(arr[i], tmp2) < 0);
        do {
          j--;
        } while (cmp(arr[j], tmp2) > 0);
        if (j < i) {
          break;
        }
        swap(i, j);
      }
      arr[left + 1] = arr[j];
      arr[j] = tmp2;
      if (right - i + 1 >= j - left) {
        stack[++sp] = i;
        stack[++sp] = right;
        right = j - 1;
      } else {
        stack[++sp] = left;
        stack[++sp] = j - 1;
        left = i;
      }
    }
  }
  return arr;
}
function arrayMax$1(array) {
  var max2 = -Infinity;
  for (var i = 0, il = array.length; i < il; ++i) {
    if (array[i] > max2) {
      max2 = array[i];
    }
  }
  return max2;
}
function arrayMin(array) {
  var min = Infinity;
  for (var i = 0, il = array.length; i < il; ++i) {
    if (array[i] < min) {
      min = array[i];
    }
  }
  return min;
}
function arraySum(array) {
  var n = array.length;
  var sum = 0;
  for (var i = 0; i < n; ++i) {
    sum += array[i];
  }
  return sum;
}
function arrayMean(array) {
  return arraySum(array) / array.length;
}
function arrayRms(array) {
  var n = array.length;
  var sumSq = 0;
  for (var i = 0; i < n; ++i) {
    var di = array[i];
    sumSq += di * di;
  }
  return Math.sqrt(sumSq / n);
}
function _trimCanvas(canvas, r, g, b, a) {
  var canvasHeight = canvas.height;
  var canvasWidth = canvas.width;
  var ctx = canvas.getContext("2d");
  var pixels = ctx.getImageData(0, 0, canvasWidth, canvasHeight).data;
  var x, y, doBreak, off;
  doBreak = false;
  for (y = 0; y < canvasHeight; y++) {
    for (x = 0; x < canvasWidth; x++) {
      off = (y * canvasWidth + x) * 4;
      if (pixels[off] !== r || pixels[off + 1] !== g || pixels[off + 2] !== b || pixels[off + 3] !== a) {
        doBreak = true;
        break;
      }
    }
    if (doBreak) {
      break;
    }
  }
  var topY = y;
  doBreak = false;
  for (x = 0; x < canvasWidth; x++) {
    for (y = 0; y < canvasHeight; y++) {
      off = (y * canvasWidth + x) * 4;
      if (pixels[off] !== r || pixels[off + 1] !== g || pixels[off + 2] !== b || pixels[off + 3] !== a) {
        doBreak = true;
        break;
      }
    }
    if (doBreak) {
      break;
    }
  }
  var topX = x;
  doBreak = false;
  for (y = canvasHeight - 1; y >= 0; y--) {
    for (x = canvasWidth - 1; x >= 0; x--) {
      off = (y * canvasWidth + x) * 4;
      if (pixels[off] !== r || pixels[off + 1] !== g || pixels[off + 2] !== b || pixels[off + 3] !== a) {
        doBreak = true;
        break;
      }
    }
    if (doBreak) {
      break;
    }
  }
  var bottomY = y;
  doBreak = false;
  for (x = canvasWidth - 1; x >= 0; x--) {
    for (y = canvasHeight - 1; y >= 0; y--) {
      off = (y * canvasWidth + x) * 4;
      if (pixels[off] !== r || pixels[off + 1] !== g || pixels[off + 2] !== b || pixels[off + 3] !== a) {
        doBreak = true;
        break;
      }
    }
    if (doBreak) {
      break;
    }
  }
  var bottomX = x;
  var trimedCanvas = document.createElement("canvas");
  trimedCanvas.width = bottomX - topX;
  trimedCanvas.height = bottomY - topY;
  var trimedCtx = trimedCanvas.getContext("2d");
  trimedCtx.drawImage(canvas, topX, topY, trimedCanvas.width, trimedCanvas.height, 0, 0, trimedCanvas.width, trimedCanvas.height);
  return trimedCanvas;
}
function makeImage(viewer, params) {
  var p = params || {};
  var trim = defaults(p.trim, false);
  var factor = defaults(p.factor, 1);
  var antialias = defaults(p.antialias, false);
  var transparent = defaults(p.transparent, false);
  var renderer = viewer.renderer;
  var camera = viewer.camera;
  var originalClearAlpha = renderer.getClearAlpha();
  var backgroundColor = renderer.getClearColor();
  function setLineWidthAndPixelSize(invert) {
    var _factor = factor;
    if (antialias) {
      _factor *= 2;
    }
    if (invert) {
      _factor = 1 / _factor;
    }
    viewer.scene.traverse(function(o) {
      var m2 = o.material;
      if (m2 && m2.linewidth) {
        m2.linewidth *= _factor;
      }
      if (m2 && m2.uniforms && m2.uniforms.size) {
        if (m2.uniforms.size.__seen === void 0) {
          m2.uniforms.size.value *= _factor;
          m2.uniforms.size.__seen = true;
        }
      }
    });
    viewer.scene.traverse(function(o) {
      var m2 = o.material;
      if (m2 && m2.uniforms && m2.uniforms.size) {
        delete m2.uniforms.size.__seen;
      }
    });
  }
  function trimCanvas(canvas) {
    if (trim) {
      var bg = backgroundColor;
      var r = transparent ? 0 : bg.r * 255;
      var g = transparent ? 0 : bg.g * 255;
      var b = transparent ? 0 : bg.b * 255;
      var a = transparent ? 0 : 255;
      return _trimCanvas(canvas, r, g, b, a);
    } else {
      return canvas;
    }
  }
  function onProgress(i, n, finished) {
    if (typeof p.onProgress === "function") {
      p.onProgress(i, n, finished);
    }
  }
  return new Promise(function(resolve2) {
    var tiledRenderer = new TiledRenderer(renderer, camera, viewer, {
      factor,
      antialias,
      onProgress,
      onFinish
    });
    renderer.setClearAlpha(transparent ? 0 : 1);
    setLineWidthAndPixelSize();
    tiledRenderer.renderAsync();
    function onFinish(i, n) {
      var canvas = trimCanvas(tiledRenderer.canvas);
      canvas.toBlob(function(blob) {
        renderer.setClearAlpha(originalClearAlpha);
        setLineWidthAndPixelSize(true);
        viewer.requestRender();
        onProgress(n, n, true);
        resolve2(blob);
      }, "image/png");
    }
  });
}
var vertex = new Vector3();
var matrix = new Matrix4();
var modelViewProjectionMatrix = new Matrix4();
function sortProjectedPosition(scene, camera) {
  scene.traverseVisible(function(o) {
    if (!(o instanceof Points) || !o.sortParticles) {
      return;
    }
    var attributes = o.geometry.attributes;
    var n = attributes.position.count;
    if (n === 0) {
      return;
    }
    matrix.multiplyMatrices(camera.matrixWorldInverse, o.matrixWorld);
    modelViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, matrix);
    var sortData, sortArray, zArray, cmpFn;
    if (!o.userData.sortData) {
      zArray = new Float32Array(n);
      sortArray = new Uint32Array(n);
      cmpFn = function(ai, bi) {
        var a = zArray[ai];
        var b = zArray[bi];
        if (a > b) {
          return 1;
        }
        if (a < b) {
          return -1;
        }
        return 0;
      };
      sortData = {
        __zArray: zArray,
        __sortArray: sortArray,
        __cmpFn: cmpFn
      };
      o.userData.sortData = sortData;
    } else {
      sortData = o.userData.sortData;
      zArray = sortData.__zArray;
      sortArray = sortData.__sortArray;
      cmpFn = sortData.__cmpFn;
    }
    for (var i = 0; i < n; ++i) {
      vertex.fromArray(attributes.position.array, i * 3);
      vertex.applyMatrix4(modelViewProjectionMatrix);
      zArray[i] = -vertex.z;
      sortArray[i] = i;
    }
    quicksortCmp(sortArray, cmpFn);
    var index, indexSrc, indexDst, tmpTab;
    for (var name in attributes) {
      var attr = attributes[name];
      var array = attr.array;
      var itemSize2 = attr.itemSize;
      if (!sortData[name]) {
        sortData[name] = new Float32Array(itemSize2 * n);
      }
      tmpTab = sortData[name];
      sortData[name] = array;
      for (var i$1 = 0; i$1 < n; ++i$1) {
        index = sortArray[i$1];
        for (var j = 0; j < itemSize2; ++j) {
          indexSrc = index * itemSize2 + j;
          indexDst = i$1 * itemSize2 + j;
          tmpTab[indexDst] = array[indexSrc];
        }
      }
      attributes[name].array = tmpTab;
      attributes[name].needsUpdate = true;
    }
  });
}
var projectionMatrixInverse = new Matrix4();
var projectionMatrixTranspose = new Matrix4();
function updateMaterialUniforms(group, camera, renderer, cDist, bRadius) {
  var canvasHeight = renderer.getSize().height;
  var pixelRatio = renderer.getPixelRatio();
  var ortho = camera.type === "OrthographicCamera";
  projectionMatrixInverse.getInverse(camera.projectionMatrix);
  projectionMatrixTranspose.copy(camera.projectionMatrix).transpose();
  group.traverse(function(o) {
    var m2 = o.material;
    if (!m2) {
      return;
    }
    var u = o.material.uniforms;
    if (!u) {
      return;
    }
    if (m2.clipNear) {
      var nearFactor = (50 - m2.clipNear) / 50;
      var nearClip = cDist - bRadius * nearFactor;
      u.nearClip.value = nearClip;
    }
    if (u.canvasHeight) {
      u.canvasHeight.value = canvasHeight;
    }
    if (u.pixelRatio) {
      u.pixelRatio.value = pixelRatio;
    }
    if (u.projectionMatrixInverse) {
      u.projectionMatrixInverse.value.copy(projectionMatrixInverse);
    }
    if (u.projectionMatrixTranspose) {
      u.projectionMatrixTranspose.value.copy(projectionMatrixTranspose);
    }
    if (u.ortho) {
      u.ortho.value = ortho;
    }
  });
}
var pixelBufferFloat = new Float32Array(4);
var pixelBufferUint = new Uint8Array(4);
var tmpMatrix = new Matrix4();
function onBeforeRender(renderer, scene, camera, geometry, material) {
  var u = material.uniforms;
  var updateList = [];
  if (u.objectId) {
    u.objectId.value = SupportsReadPixelsFloat ? this.id : this.id / 255;
    updateList.push("objectId");
  }
  if (u.modelViewMatrixInverse || u.modelViewMatrixInverseTranspose || u.modelViewProjectionMatrix || u.modelViewProjectionMatrixInverse) {
    this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
  }
  if (u.modelViewMatrixInverse) {
    u.modelViewMatrixInverse.value.getInverse(this.modelViewMatrix);
    updateList.push("modelViewMatrixInverse");
  }
  if (u.modelViewMatrixInverseTranspose) {
    if (u.modelViewMatrixInverse) {
      u.modelViewMatrixInverseTranspose.value.copy(u.modelViewMatrixInverse.value).transpose();
    } else {
      u.modelViewMatrixInverseTranspose.value.getInverse(this.modelViewMatrix).transpose();
    }
    updateList.push("modelViewMatrixInverseTranspose");
  }
  if (u.modelViewProjectionMatrix) {
    camera.updateProjectionMatrix();
    u.modelViewProjectionMatrix.value.multiplyMatrices(camera.projectionMatrix, this.modelViewMatrix);
    updateList.push("modelViewProjectionMatrix");
  }
  if (u.modelViewProjectionMatrixInverse) {
    if (u.modelViewProjectionMatrix) {
      tmpMatrix.copy(u.modelViewProjectionMatrix.value);
      u.modelViewProjectionMatrixInverse.value.getInverse(tmpMatrix);
    } else {
      camera.updateProjectionMatrix();
      tmpMatrix.multiplyMatrices(camera.projectionMatrix, this.modelViewMatrix);
      u.modelViewProjectionMatrixInverse.value.getInverse(tmpMatrix);
    }
    updateList.push("modelViewProjectionMatrixInverse");
  }
  if (updateList.length) {
    var materialProperties = renderer.properties.get(material);
    if (materialProperties.program) {
      var gl = renderer.getContext();
      var p = materialProperties.program;
      gl.useProgram(p.program);
      var pu = p.getUniforms();
      updateList.forEach(function(name) {
        pu.setValue(gl, name, u[name].value);
      });
    }
  }
}
function Viewer(idOrElement) {
  var signals = {
    ticked: new Signal()
  };
  var container;
  if (typeof idOrElement === "string") {
    container = document.getElementById(idOrElement);
  } else if (idOrElement instanceof window.Element) {
    container = idOrElement;
  } else {
    container = document.createElement("div");
  }
  var width, height;
  if (container === document.body) {
    width = window.innerWidth || 1;
    height = window.innerHeight || 1;
  } else {
    var box = container.getBoundingClientRect();
    width = box.width || 1;
    height = box.height || 1;
  }
  var rendering, renderPending, lastRenderedPicking, isStill;
  var sampleLevel, cDist, bRadius;
  var parameters;
  initParams();
  var stats;
  initStats();
  var perspectiveCamera, orthographicCamera, camera;
  initCamera();
  var scene, pointLight, ambientLight;
  var rotationGroup, translationGroup, modelGroup, pickingGroup, backgroundGroup, helperGroup;
  initScene();
  var renderer, supportsHalfFloat;
  var pickingTarget, sampleTarget, holdTarget;
  var compositeUniforms, compositeMaterial, compositeCamera, compositeScene;
  if (initRenderer() === false) {
    this.container = container;
    Log.error("Viewer: could not initialize renderer");
    return;
  }
  var boundingBoxMesh;
  var boundingBox = new Box3();
  var boundingBoxSize = new Vector3();
  var boundingBoxLength = 0;
  initHelper();
  setBackground();
  setFog();
  var distVector = new Vector3();
  var info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  function initParams() {
    parameters = {
      fogColor: new Color(0),
      fogNear: 50,
      fogFar: 100,
      backgroundColor: new Color(0),
      cameraType: "perspective",
      cameraFov: 40,
      cameraZ: -80,
      clipNear: 0,
      clipFar: 100,
      clipDist: 10,
      lightColor: new Color(14540253),
      lightIntensity: 1,
      ambientColor: new Color(14540253),
      ambientIntensity: 0.2,
      sampleLevel: 0
    };
  }
  function initCamera() {
    var lookAt = new Vector3(0, 0, 0);
    perspectiveCamera = new PerspectiveCamera(parameters.cameraFov, width / height);
    perspectiveCamera.position.z = parameters.cameraZ;
    perspectiveCamera.lookAt(lookAt);
    orthographicCamera = new OrthographicCamera(width / -2, width / 2, height / 2, height / -2);
    orthographicCamera.position.z = parameters.cameraZ;
    orthographicCamera.lookAt(lookAt);
    if (parameters.cameraType === "orthographic") {
      camera = orthographicCamera;
    } else {
      camera = perspectiveCamera;
    }
    camera.updateProjectionMatrix();
  }
  function initRenderer() {
    var dpr = window.devicePixelRatio;
    try {
      renderer = new WebGLRenderer({
        preserveDrawingBuffer: true,
        alpha: true,
        antialias: true
      });
    } catch (e) {
      container.innerHTML = WebglErrorMessage;
      return false;
    }
    renderer.setPixelRatio(dpr);
    renderer.setSize(width, height);
    renderer.autoClear = false;
    renderer.sortObjects = true;
    setExtensionFragDepth(renderer.extensions.get("EXT_frag_depth"));
    renderer.extensions.get("OES_element_index_uint");
    setSupportsReadPixelsFloat(renderer.extensions.get("OES_texture_float") && renderer.extensions.get("WEBGL_color_buffer_float") || Browser === "Chrome" && renderer.extensions.get("OES_texture_float"));
    container.appendChild(renderer.domElement);
    var dprWidth = width * dpr;
    var dprHeight = height * dpr;
    renderer.extensions.get("OES_texture_float");
    supportsHalfFloat = renderer.extensions.get("OES_texture_half_float");
    renderer.extensions.get("WEBGL_color_buffer_float");
    pickingTarget = new WebGLRenderTarget(dprWidth, dprHeight, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      stencilBuffer: false,
      format: RGBAFormat,
      type: SupportsReadPixelsFloat ? FloatType : UnsignedByteType
    });
    pickingTarget.texture.generateMipmaps = false;
    sampleTarget = new WebGLRenderTarget(dprWidth, dprHeight, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    });
    holdTarget = new WebGLRenderTarget(dprWidth, dprHeight, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: Mobile ? UnsignedByteType : supportsHalfFloat ? HalfFloatType : SupportsReadPixelsFloat ? FloatType : UnsignedByteType
    });
    compositeUniforms = {
      tForeground: {type: "t", value: null},
      scale: {type: "f", value: 1}
    };
    compositeMaterial = new ShaderMaterial({
      uniforms: compositeUniforms,
      vertexShader: getShader("Quad.vert"),
      fragmentShader: getShader("Quad.frag"),
      premultipliedAlpha: true,
      transparent: true,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false
    });
    compositeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    compositeScene = new Scene().add(new Mesh(new PlaneGeometry(2, 2), compositeMaterial));
  }
  function initScene() {
    if (!scene) {
      scene = new Scene();
    }
    rotationGroup = new Group();
    rotationGroup.name = "rotationGroup";
    scene.add(rotationGroup);
    translationGroup = new Group();
    translationGroup.name = "translationGroup";
    rotationGroup.add(translationGroup);
    modelGroup = new Group();
    modelGroup.name = "modelGroup";
    translationGroup.add(modelGroup);
    pickingGroup = new Group();
    pickingGroup.name = "pickingGroup";
    translationGroup.add(pickingGroup);
    backgroundGroup = new Group();
    backgroundGroup.name = "backgroundGroup";
    translationGroup.add(backgroundGroup);
    helperGroup = new Group();
    helperGroup.name = "helperGroup";
    translationGroup.add(helperGroup);
    scene.fog = new Fog();
    pointLight = new SpotLight(parameters.lightColor, parameters.lightIntensity);
    scene.add(pointLight);
    ambientLight = new AmbientLight(parameters.ambientLight, parameters.ambientIntensity);
    scene.add(ambientLight);
  }
  function initHelper() {
    var indices = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var positions = new Float32Array(8 * 3);
    var bbGeometry = new BufferGeometry();
    bbGeometry.setIndex(new BufferAttribute(indices, 1));
    bbGeometry.addAttribute("position", new BufferAttribute(positions, 3));
    var bbMaterial = new ShaderMaterial({
      uniforms: {uColor: {value: new Color("skyblue")}},
      vertexShader: getShader("BasicLine.vert"),
      fragmentShader: getShader("BasicLine.frag"),
      linewidth: 2
    });
    boundingBoxMesh = new LineSegments(bbGeometry, bbMaterial);
    helperGroup.add(boundingBoxMesh);
  }
  function updateHelper() {
    var position = boundingBoxMesh.geometry.attributes.position;
    var array = position.array;
    var min = boundingBox.min;
    var max2 = boundingBox.max;
    array[0] = max2.x;
    array[1] = max2.y;
    array[2] = max2.z;
    array[3] = min.x;
    array[4] = max2.y;
    array[5] = max2.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max2.z;
    array[9] = max2.x;
    array[10] = min.y;
    array[11] = max2.z;
    array[12] = max2.x;
    array[13] = max2.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max2.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max2.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    if (!boundingBox.isEmpty()) {
      boundingBoxMesh.geometry.computeBoundingSphere();
    }
  }
  function initStats() {
    stats = new Stats();
  }
  function add8(buffer, instanceList) {
    if (instanceList) {
      instanceList.forEach(function(instance) {
        addBuffer2(buffer, instance);
      });
    } else {
      addBuffer2(buffer);
    }
    if (buffer.background) {
      backgroundGroup.add(buffer.group);
      backgroundGroup.add(buffer.wireframeGroup);
    } else {
      modelGroup.add(buffer.group);
      modelGroup.add(buffer.wireframeGroup);
    }
    if (buffer.pickable) {
      pickingGroup.add(buffer.pickingGroup);
    }
    if (Debug) {
      updateHelper();
    }
  }
  function addBuffer2(buffer, instance) {
    function setUserData(object) {
      if (object instanceof Group) {
        object.children.forEach(setUserData);
      } else {
        object.userData.buffer = buffer;
        object.userData.instance = instance;
        object.onBeforeRender = onBeforeRender;
      }
    }
    var mesh = buffer.getMesh();
    if (instance) {
      mesh.applyMatrix(instance.matrix);
    }
    setUserData(mesh);
    buffer.group.add(mesh);
    var wireframeMesh = buffer.getWireframeMesh();
    if (instance) {
      wireframeMesh.matrix.copy(mesh.matrix);
      wireframeMesh.position.copy(mesh.position);
      wireframeMesh.quaternion.copy(mesh.quaternion);
      wireframeMesh.scale.copy(mesh.scale);
    }
    setUserData(wireframeMesh);
    buffer.wireframeGroup.add(wireframeMesh);
    if (buffer.pickable) {
      var pickingMesh = buffer.getPickingMesh();
      if (instance) {
        pickingMesh.matrix.copy(mesh.matrix);
        pickingMesh.position.copy(mesh.position);
        pickingMesh.quaternion.copy(mesh.quaternion);
        pickingMesh.scale.copy(mesh.scale);
      }
      setUserData(pickingMesh);
      buffer.pickingGroup.add(pickingMesh);
    }
    if (instance) {
      updateBoundingBox(buffer.geometry, buffer.matrix, instance.matrix);
    } else {
      updateBoundingBox(buffer.geometry, buffer.matrix);
    }
  }
  function remove3(buffer) {
    translationGroup.children.forEach(function(group) {
      group.remove(buffer.group);
      group.remove(buffer.wireframeGroup);
    });
    if (buffer.pickable) {
      pickingGroup.remove(buffer.pickingGroup);
    }
    updateBoundingBox();
    if (Debug) {
      updateHelper();
    }
  }
  function updateBoundingBox(geometry, matrix2, instanceMatrix) {
    function updateGeometry(geometry2, matrix3, instanceMatrix2) {
      if (!geometry2.boundingBox) {
        geometry2.computeBoundingBox();
      }
      var geoBoundingBox = geometry2.boundingBox.clone();
      if (matrix3) {
        geoBoundingBox.applyMatrix4(matrix3);
      }
      if (instanceMatrix2) {
        geoBoundingBox.applyMatrix4(instanceMatrix2);
      }
      if (geoBoundingBox.min.equals(geoBoundingBox.max)) {
        geoBoundingBox.expandByScalar(5);
      }
      boundingBox.union(geoBoundingBox);
    }
    function updateNode(node) {
      if (node.geometry !== void 0) {
        var matrix3, instanceMatrix2;
        if (node.userData.buffer) {
          matrix3 = node.userData.buffer.matrix;
        }
        if (node.userData.instance) {
          instanceMatrix2 = node.userData.instance.matrix;
        }
        updateGeometry(node.geometry, matrix3, instanceMatrix2);
      }
    }
    if (geometry) {
      updateGeometry(geometry, matrix2, instanceMatrix);
    } else {
      boundingBox.makeEmpty();
      modelGroup.traverse(updateNode);
      backgroundGroup.traverse(updateNode);
    }
    boundingBox.getSize(boundingBoxSize);
    boundingBoxLength = boundingBoxSize.length();
  }
  function getPickingPixels() {
    var n = width * height * 4;
    var imgBuffer = SupportsReadPixelsFloat ? new Float32Array(n) : new Uint8Array(n);
    render(true);
    renderer.readRenderTargetPixels(pickingTarget, 0, 0, width, height, imgBuffer);
    return imgBuffer;
  }
  function getImage(picking) {
    return new Promise(function(resolve2) {
      if (picking) {
        var n = width * height * 4;
        var imgBuffer = getPickingPixels();
        if (SupportsReadPixelsFloat) {
          var imgBuffer2 = new Uint8Array(n);
          for (var i = 0; i < n; ++i) {
            imgBuffer2[i] = Math.round(imgBuffer[i] * 255);
          }
          imgBuffer = imgBuffer2;
        }
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext("2d");
        var imgData = ctx.getImageData(0, 0, width, height);
        imgData.data.set(imgBuffer);
        ctx.putImageData(imgData, 0, 0);
        canvas.toBlob(resolve2, "image/png");
      } else {
        renderer.domElement.toBlob(resolve2, "image/png");
      }
    });
  }
  function makeImage$$1(params) {
    return makeImage(this, params);
  }
  function setLight(color, intensity, ambientColor, ambientIntensity) {
    var p = parameters;
    if (color !== void 0) {
      p.lightColor.set(color);
    }
    if (intensity !== void 0) {
      p.lightIntensity = intensity;
    }
    if (ambientColor !== void 0) {
      p.ambientColor.set(ambientColor);
    }
    if (ambientIntensity !== void 0) {
      p.ambientIntensity = ambientIntensity;
    }
    requestRender();
  }
  function setFog(color, near, far) {
    var p = parameters;
    if (color !== void 0) {
      p.fogColor.set(color);
    }
    if (near !== void 0) {
      p.fogNear = near;
    }
    if (far !== void 0) {
      p.fogFar = far;
    }
    requestRender();
  }
  function setBackground(color) {
    var p = parameters;
    if (color) {
      p.backgroundColor.set(color);
    }
    setFog(p.backgroundColor);
    renderer.setClearColor(p.backgroundColor, 0);
    renderer.domElement.style.backgroundColor = p.backgroundColor.getStyle();
    requestRender();
  }
  function setSampling(level) {
    if (level !== void 0) {
      parameters.sampleLevel = level;
      sampleLevel = level;
    }
    requestRender();
  }
  function setCamera(type2, fov) {
    var p = parameters;
    if (type2) {
      p.cameraType = type2;
    }
    if (fov) {
      p.cameraFov = fov;
    }
    if (p.cameraType === "orthographic") {
      if (camera !== orthographicCamera) {
        camera = orthographicCamera;
        camera.position.copy(perspectiveCamera.position);
        camera.up.copy(perspectiveCamera.up);
        updateZoom();
      }
    } else {
      if (camera !== perspectiveCamera) {
        camera = perspectiveCamera;
        camera.position.copy(orthographicCamera.position);
        camera.up.copy(orthographicCamera.up);
      }
    }
    perspectiveCamera.fov = p.cameraFov;
    camera.updateProjectionMatrix();
    requestRender();
  }
  function setClip(near, far, dist) {
    var p = parameters;
    if (near !== void 0) {
      p.clipNear = near;
    }
    if (far !== void 0) {
      p.clipFar = far;
    }
    if (dist !== void 0) {
      p.clipDist = dist;
    }
    requestRender();
  }
  function setSize2(_width, _height) {
    width = _width || 1;
    height = _height || 1;
    perspectiveCamera.aspect = width / height;
    orthographicCamera.left = -width / 2;
    orthographicCamera.right = width / 2;
    orthographicCamera.top = height / 2;
    orthographicCamera.bottom = -height / 2;
    camera.updateProjectionMatrix();
    var dpr = window.devicePixelRatio;
    renderer.setPixelRatio(dpr);
    renderer.setSize(width, height);
    var dprWidth = width * dpr;
    var dprHeight = height * dpr;
    pickingTarget.setSize(dprWidth, dprHeight);
    sampleTarget.setSize(dprWidth, dprHeight);
    holdTarget.setSize(dprWidth, dprHeight);
    requestRender();
  }
  function handleResize2() {
    if (container === document.body) {
      setSize2(window.innerWidth, window.innerHeight);
    } else {
      var box2 = container.getBoundingClientRect();
      setSize2(box2.width, box2.height);
    }
  }
  function updateInfo(reset) {
    var memory = info.memory;
    var render2 = info.render;
    if (reset) {
      memory.programs = 0;
      memory.geometries = 0;
      memory.textures = 0;
      render2.calls = 0;
      render2.vertices = 0;
      render2.faces = 0;
      render2.points = 0;
    } else {
      var rInfo = renderer.info;
      var rMemory = rInfo.memory;
      var rRender = rInfo.render;
      memory.programs = rMemory.programs;
      memory.geometries = rMemory.geometries;
      memory.textures = rMemory.textures;
      render2.calls += rRender.calls;
      render2.vertices += rRender.vertices;
      render2.faces += rRender.faces;
      render2.points += rRender.points;
    }
  }
  function animate() {
    signals.ticked.dispatch(stats);
    var delta = window.performance.now() - stats.startTime;
    if (delta > 500 && !isStill && sampleLevel < 3 && sampleLevel !== -1) {
      var currentSampleLevel = sampleLevel;
      sampleLevel = 3;
      renderPending = true;
      render();
      isStill = true;
      sampleLevel = currentSampleLevel;
      if (Debug) {
        Log.log("rendered still frame");
      }
    }
    window.requestAnimationFrame(animate);
  }
  function pick2(x, y) {
    x *= window.devicePixelRatio;
    y *= window.devicePixelRatio;
    var pid, instance, picker;
    var pixelBuffer = SupportsReadPixelsFloat ? pixelBufferFloat : pixelBufferUint;
    render(true);
    renderer.readRenderTargetPixels(pickingTarget, x, y, 1, 1, pixelBuffer);
    if (SupportsReadPixelsFloat) {
      pid = Math.round(pixelBuffer[0] * 255) << 16 & 16711680 | Math.round(pixelBuffer[1] * 255) << 8 & 65280 | Math.round(pixelBuffer[2] * 255) & 255;
    } else {
      pid = pixelBuffer[0] << 16 | pixelBuffer[1] << 8 | pixelBuffer[2];
    }
    var oid = Math.round(pixelBuffer[3]);
    var object = pickingGroup.getObjectById(oid);
    if (object) {
      instance = object.userData.instance;
      picker = object.userData.buffer.picking;
    }
    return {
      pid,
      instance,
      picker
    };
  }
  function requestRender() {
    if (renderPending) {
      return;
    }
    if (window.performance.now() - stats.startTime > 22) {
      stats.begin();
      isStill = false;
    }
    renderPending = true;
    window.requestAnimationFrame(function requestRenderAnimation() {
      render();
      stats.update();
    });
  }
  function updateZoom() {
    var fov = degToRad(perspectiveCamera.fov);
    var _height = 2 * Math.tan(fov / 2) * -camera.position.z;
    orthographicCamera.zoom = height / _height;
  }
  function __updateClipping() {
    var p = parameters;
    cDist = distVector.copy(camera.position).length();
    if (!cDist) {
      camera.position.set(0, 0, p.cameraZ);
      cDist = Math.abs(p.cameraZ);
    }
    bRadius = Math.max(10, boundingBoxLength * 0.5);
    bRadius += boundingBox.getCenter(distVector).length();
    if (bRadius === Infinity || bRadius === -Infinity || isNaN(bRadius)) {
      bRadius = 50;
    }
    var nearFactor = (50 - p.clipNear) / 50;
    var farFactor = -(50 - p.clipFar) / 50;
    camera.near = cDist - bRadius * nearFactor;
    camera.far = cDist + bRadius * farFactor;
    var fogNearFactor = (50 - p.fogNear) / 50;
    var fogFarFactor = -(50 - p.fogFar) / 50;
    var fog = scene.fog;
    fog.color.set(p.fogColor);
    fog.near = cDist - bRadius * fogNearFactor;
    fog.far = cDist + bRadius * fogFarFactor;
    if (camera.type === "PerspectiveCamera") {
      camera.near = Math.max(0.1, p.clipDist, camera.near);
      camera.far = Math.max(1, camera.far);
      fog.near = Math.max(0.1, fog.near);
      fog.far = Math.max(1, fog.far);
    } else if (camera.type === "OrthographicCamera") {
      if (p.clipNear === 0 && p.clipDist > 0 && cDist + camera.zoom > 2 * -p.clipDist) {
        camera.near += camera.zoom + p.clipDist;
      }
    }
  }
  function __updateCamera() {
    camera.updateMatrix();
    camera.updateMatrixWorld(true);
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    camera.updateProjectionMatrix();
    updateMaterialUniforms(scene, camera, renderer, cDist, bRadius);
    sortProjectedPosition(scene, camera);
  }
  function __setVisibility(model, picking, background, helper) {
    modelGroup.visible = model;
    pickingGroup.visible = picking;
    backgroundGroup.visible = background;
    helperGroup.visible = helper;
  }
  function __updateLights() {
    distVector.copy(camera.position).setLength(boundingBoxLength * 100);
    pointLight.position.copy(camera.position).add(distVector);
    pointLight.color.set(parameters.lightColor);
    pointLight.intensity = parameters.lightIntensity;
    ambientLight.color.set(parameters.ambientColor);
    ambientLight.intensity = parameters.ambientIntensity;
  }
  function __renderPickingGroup() {
    renderer.clearTarget(pickingTarget);
    __setVisibility(false, true, false, false);
    renderer.render(scene, camera, pickingTarget);
    updateInfo();
    renderer.setRenderTarget(null);
  }
  function __renderModelGroup(renderTarget) {
    if (renderTarget) {
      renderer.clearTarget(renderTarget);
    } else {
      renderer.clear();
    }
    __setVisibility(false, false, true, false);
    renderer.render(scene, camera, renderTarget);
    if (renderTarget) {
      renderer.clearTarget(renderTarget, false, true, false);
    } else {
      renderer.clearDepth();
    }
    updateInfo();
    __setVisibility(true, false, false, Debug);
    renderer.render(scene, camera, renderTarget);
    updateInfo();
  }
  function __renderSuperSample() {
    var offsetList = JitterVectors[Math.max(0, Math.min(sampleLevel, 5))];
    var baseSampleWeight = 1 / offsetList.length;
    var roundingRange = 1 / 32;
    compositeUniforms.tForeground.value = sampleTarget.texture;
    var _width = sampleTarget.width;
    var _height = sampleTarget.height;
    for (var i = 0; i < offsetList.length; ++i) {
      var offset = offsetList[i];
      camera.setViewOffset(_width, _height, offset[0], offset[1], _width, _height);
      __updateCamera();
      var sampleWeight = baseSampleWeight;
      var uniformCenteredDistribution = -0.5 + (i + 0.5) / offsetList.length;
      sampleWeight += roundingRange * uniformCenteredDistribution;
      compositeUniforms.scale.value = sampleWeight;
      __renderModelGroup(sampleTarget);
      renderer.render(compositeScene, compositeCamera, holdTarget, i === 0);
    }
    compositeUniforms.scale.value = 1;
    compositeUniforms.tForeground.value = holdTarget.texture;
    renderer.render(compositeScene, compositeCamera, null, true);
    camera.view = null;
  }
  function render(picking) {
    if (rendering) {
      Log.warn("tried to call 'render' from within 'render'");
      return;
    }
    rendering = true;
    __updateClipping();
    __updateCamera();
    __updateLights();
    updateInfo(true);
    if (picking) {
      if (!lastRenderedPicking) {
        __renderPickingGroup();
      }
    } else if (sampleLevel > 0) {
      __renderSuperSample();
    } else {
      __renderModelGroup();
    }
    lastRenderedPicking = picking;
    rendering = false;
    renderPending = false;
  }
  function clear7() {
    Log.log("scene cleared");
    scene.remove(rotationGroup);
    initScene();
    renderer.clear();
  }
  this.container = container;
  this.stats = stats;
  this.signals = signals;
  this.rotationGroup = rotationGroup;
  this.translationGroup = translationGroup;
  this.add = add8;
  this.remove = remove3;
  this.clear = clear7;
  this.getPickingPixels = getPickingPixels;
  this.getImage = getImage;
  this.makeImage = makeImage$$1;
  this.setLight = setLight;
  this.setFog = setFog;
  this.setBackground = setBackground;
  this.setSampling = setSampling;
  this.setCamera = setCamera;
  this.setClip = setClip;
  this.setSize = setSize2;
  this.handleResize = handleResize2;
  this.pick = pick2;
  this.requestRender = requestRender;
  this.render = render;
  this.animate = animate;
  this.updateZoom = updateZoom;
  this.updateHelper = updateHelper;
  this.renderer = renderer;
  this.scene = scene;
  this.perspectiveCamera = perspectiveCamera;
  this.boundingBox = boundingBox;
  this.updateBoundingBox = function() {
    updateBoundingBox();
    if (Debug) {
      updateHelper();
    }
  };
  Object.defineProperties(this, {
    camera: {get: function() {
      return camera;
    }},
    width: {get: function() {
      return width;
    }},
    height: {get: function() {
      return height;
    }},
    sampleLevel: {get: function() {
      return sampleLevel;
    }}
  });
}
Viewer.prototype.constructor = Viewer;
var LeftMouseButton = 1;
var MiddleMouseButton = 2;
var RightMouseButton = 3;
function getTouchDistance(event) {
  var dx = event.touches[0].pageX - event.touches[1].pageX;
  var dy = event.touches[0].pageY - event.touches[1].pageY;
  return Math.sqrt(dx * dx + dy * dy);
}
function getMouseButtons(event) {
  if (typeof event === "object") {
    if ("buttons" in event) {
      return event.buttons;
    } else if ("which" in event) {
      var b = event.which;
      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ("button" in event) {
      var b$1 = event.button;
      if (b$1 === 1) {
        return 4;
      } else if (b$1 === 2) {
        return 2;
      } else if (b$1 >= 0) {
        return 1 << b$1;
      }
    }
  }
  return 0;
}
var MouseObserver = function MouseObserver2(domElement, params) {
  this.signals = {
    moved: new Signal(),
    scrolled: new Signal(),
    dragged: new Signal(),
    dropped: new Signal(),
    clicked: new Signal(),
    hovered: new Signal()
  };
  var p = Object.assign({}, params);
  this.hoverTimeout = defaults(p.hoverTimeout, 50);
  this.handleScroll = defaults(p.handleScroll, true);
  this.domElement = domElement;
  this.position = new Vector2();
  this.prevPosition = new Vector2();
  this.down = new Vector2();
  this.canvasPosition = new Vector2();
  this.moving = false;
  this.hovering = true;
  this.scrolled = false;
  this.lastMoved = Infinity;
  this.which = void 0;
  this.buttons = void 0;
  this.pressed = void 0;
  this.altKey = void 0;
  this.ctrlKey = void 0;
  this.metaKey = void 0;
  this.shiftKey = void 0;
  this._listen = this._listen.bind(this);
  this._onMousewheel = this._onMousewheel.bind(this);
  this._onMousemove = this._onMousemove.bind(this);
  this._onMousedown = this._onMousedown.bind(this);
  this._onMouseup = this._onMouseup.bind(this);
  this._onContextmenu = this._onContextmenu.bind(this);
  this._onTouchstart = this._onTouchstart.bind(this);
  this._onTouchend = this._onTouchend.bind(this);
  this._onTouchmove = this._onTouchmove.bind(this);
  this._listen();
  document.addEventListener("mousewheel", this._onMousewheel);
  document.addEventListener("wheel", this._onMousewheel);
  document.addEventListener("MozMousePixelScroll", this._onMousewheel);
  document.addEventListener("mousemove", this._onMousemove);
  document.addEventListener("mousedown", this._onMousedown);
  document.addEventListener("mouseup", this._onMouseup);
  document.addEventListener("contextmenu", this._onContextmenu);
  document.addEventListener("touchstart", this._onTouchstart);
  document.addEventListener("touchend", this._onTouchend);
  document.addEventListener("touchmove", this._onTouchmove);
};
var prototypeAccessors$4 = {key: {}};
prototypeAccessors$4.key.get = function() {
  var key = 0;
  if (this.altKey) {
    key += 1;
  }
  if (this.ctrlKey) {
    key += 2;
  }
  if (this.metaKey) {
    key += 4;
  }
  if (this.shiftKey) {
    key += 8;
  }
  return key;
};
MouseObserver.prototype.setParameters = function setParameters(params) {
  var p = Object.assign({}, params);
  this.hoverTimeout = defaults(p.hoverTimeout, this.hoverTimeout);
};
MouseObserver.prototype._listen = function _listen() {
  if (window.performance.now() - this.lastMoved > this.hoverTimeout) {
    this.moving = false;
  }
  if (this.scrolled || !this.moving && !this.hovering) {
    this.scrolled = false;
    if (this.hoverTimeout !== -1 && this.overElement) {
      this.hovering = true;
      var cp = this.canvasPosition;
      this.signals.hovered.dispatch(cp.x, cp.y);
    }
  }
  window.requestAnimationFrame(this._listen);
};
MouseObserver.prototype._onMousewheel = function _onMousewheel(event) {
  var this$1 = this;
  if (event.target !== this.domElement || !this.handleScroll) {
    return;
  }
  event.preventDefault();
  this._setKeys(event);
  var delta = 0;
  if (event.wheelDelta) {
    delta = event.wheelDelta / 40;
  } else if (event.detail) {
    delta = -event.detail / 3;
  } else {
    delta = -event.deltaY / (event.deltaMode ? 0.33 : 30);
  }
  this.signals.scrolled.dispatch(delta);
  setTimeout(function() {
    this$1.scrolled = true;
  }, this.hoverTimeout);
};
MouseObserver.prototype._onMousemove = function _onMousemove(event) {
  if (event.target === this.domElement) {
    event.preventDefault();
    this.overElement = true;
  } else {
    this.overElement = false;
  }
  this._setKeys(event);
  this.moving = true;
  this.hovering = false;
  this.lastMoved = window.performance.now();
  this.prevPosition.copy(this.position);
  this.position.set(event.clientX, event.clientY);
  this._setCanvasPosition(event);
  var dx = this.prevPosition.x - this.position.x;
  var dy = this.prevPosition.y - this.position.y;
  this.signals.moved.dispatch(dx, dy);
  if (this.pressed) {
    this.signals.dragged.dispatch(dx, dy);
  }
};
MouseObserver.prototype._onMousedown = function _onMousedown(event) {
  if (event.target !== this.domElement) {
    return;
  }
  event.preventDefault();
  this._setKeys(event);
  this.moving = false;
  this.hovering = false;
  this.down.set(event.clientX, event.clientY);
  this.position.set(event.clientX, event.clientY);
  this.which = event.which;
  this.buttons = getMouseButtons(event);
  this.pressed = true;
  this._setCanvasPosition(event);
};
MouseObserver.prototype._onMouseup = function _onMouseup(event) {
  if (event.target === this.domElement) {
    event.preventDefault();
  }
  this._setKeys(event);
  var cp = this.canvasPosition;
  this.signals.clicked.dispatch(cp.x, cp.y);
  this.which = void 0;
  this.buttons = void 0;
  this.pressed = void 0;
};
MouseObserver.prototype._onContextmenu = function _onContextmenu(event) {
  if (event.target === this.domElement) {
    event.preventDefault();
  }
};
MouseObserver.prototype._onTouchstart = function _onTouchstart(event) {
  if (event.target !== this.domElement) {
    return;
  }
  event.preventDefault();
  this.pressed = true;
  switch (event.touches.length) {
    case 1: {
      this.moving = false;
      this.hovering = false;
      this.down.set(event.touches[0].pageX, event.touches[0].pageY);
      this.position.set(event.touches[0].pageX, event.touches[0].pageY);
      this._setCanvasPosition(event.touches[0]);
      break;
    }
    case 2: {
      this.down.set((event.touches[0].pageX + event.touches[1].pageX) / 2, (event.touches[0].pageY + event.touches[1].pageY) / 2);
      this.position.set((event.touches[0].pageX + event.touches[1].pageX) / 2, (event.touches[0].pageY + event.touches[1].pageY) / 2);
      this.lastTouchDistance = getTouchDistance(event);
    }
  }
};
MouseObserver.prototype._onTouchend = function _onTouchend(event) {
  if (event.target === this.domElement) {
    event.preventDefault();
  }
  this.pressed = false;
};
MouseObserver.prototype._onTouchmove = function _onTouchmove(event) {
  if (event.target === this.domElement) {
    event.preventDefault();
    this.overElement = true;
  } else {
    this.overElement = false;
  }
  switch (event.touches.length) {
    case 1: {
      this._setKeys(event);
      this.which = void 0;
      this.buttons = void 0;
      this.moving = true;
      this.hovering = false;
      this.lastMoved = window.performance.now();
      this.prevPosition.copy(this.position);
      this.position.set(event.touches[0].pageX, event.touches[0].pageY);
      this._setCanvasPosition(event.touches[0]);
      var dx = this.prevPosition.x - this.position.x;
      var dy = this.prevPosition.y - this.position.y;
      this.signals.moved.dispatch(dx, dy);
      if (this.pressed) {
        this.signals.dragged.dispatch(dx, dy);
      }
      break;
    }
    case 2: {
      this.which = RightMouseButton;
      this.buttons = 2;
      var touchDistance = getTouchDistance(event);
      var delta = touchDistance - this.lastTouchDistance;
      this.lastTouchDistance = touchDistance;
      if (Math.abs(delta) > 1) {
        this.signals.scrolled.dispatch(delta / 2);
      } else {
        this.prevPosition.copy(this.position);
        this.position.set((event.touches[0].pageX + event.touches[1].pageX) / 2, (event.touches[0].pageY + event.touches[1].pageY) / 2);
        var dx$1 = this.prevPosition.x - this.position.x;
        var dy$1 = this.prevPosition.y - this.position.y;
        this.signals.moved.dispatch(dx$1, dy$1);
        if (this.pressed) {
          this.signals.dragged.dispatch(dx$1, dy$1);
        }
      }
    }
  }
};
MouseObserver.prototype._distance = function _distance() {
  return this.position.distanceTo(this.down);
};
MouseObserver.prototype._setCanvasPosition = function _setCanvasPosition(event) {
  var box = this.domElement.getBoundingClientRect();
  var offsetX, offsetY;
  if ("offsetX" in event && "offsetY" in event) {
    offsetX = event.offsetX;
    offsetY = event.offsetY;
  } else {
    offsetX = event.clientX - box.left;
    offsetY = event.clientY - box.top;
  }
  this.canvasPosition.set(offsetX, box.height - offsetY);
};
MouseObserver.prototype._setKeys = function _setKeys(event) {
  this.altKey = event.altKey;
  this.ctrlKey = event.ctrlKey;
  this.metaKey = event.metaKey;
  this.shiftKey = event.shiftKey;
};
MouseObserver.prototype.dispose = function dispose3() {
  document.removeEventListener("mousewheel", this._onMousewheel);
  document.removeEventListener("wheel", this._onMousewheel);
  document.removeEventListener("MozMousePixelScroll", this._onMousewheel);
  document.removeEventListener("mousemove", this._onMousemove);
  document.removeEventListener("mousedown", this._onMousedown);
  document.removeEventListener("mouseup", this._onMouseup);
  document.removeEventListener("contextmenu", this._onContextmenu);
  document.removeEventListener("touchstart", this._onTouchstart);
  document.removeEventListener("touchend", this._onTouchend);
  document.removeEventListener("touchmove", this._onTouchmove);
};
Object.defineProperties(MouseObserver.prototype, prototypeAccessors$4);
var tmpRotateXMatrix = new Matrix4();
var tmpRotateYMatrix = new Matrix4();
var tmpRotateMatrix = new Matrix4();
var tmpRotateVector = new Vector3();
var tmpRotateQuaternion = new Quaternion();
var tmpPanMatrix = new Matrix4();
var tmpPanVector = new Vector3();
var TrackballControls = function TrackballControls2(stage, params) {
  var p = params || {};
  this.rotateSpeed = defaults(p.rotateSpeed, 2);
  this.zoomSpeed = defaults(p.zoomSpeed, 1.2);
  this.panSpeed = defaults(p.panSpeed, 1);
  this.stage = stage;
  this.viewer = stage.viewer;
  this.mouse = stage.mouseObserver;
  this.controls = stage.viewerControls;
};
var prototypeAccessors$5 = {component: {}};
prototypeAccessors$5.component.get = function() {
  return this.stage.transformComponent;
};
TrackballControls.prototype._setPanVector = function _setPanVector(x, y) {
  var scaleFactor;
  var camera = this.viewer.camera;
  if (camera.type === "OrthographicCamera") {
    scaleFactor = 1 / camera.zoom;
  } else {
    var fov = degToRad(camera.fov);
    var unitHeight = -2 * camera.position.z * Math.tan(fov / 2);
    scaleFactor = unitHeight / this.viewer.height;
  }
  tmpPanVector.set(x, y, 0);
  tmpPanVector.multiplyScalar(this.panSpeed * scaleFactor);
};
TrackballControls.prototype._getRotateXY = function _getRotateXY(x, y) {
  return [
    this.rotateSpeed * -x * 0.01,
    this.rotateSpeed * y * 0.01
  ];
};
TrackballControls.prototype.zoom = function zoom(delta) {
  this.controls.zoom(this.zoomSpeed * delta * 0.02);
};
TrackballControls.prototype.pan = function pan(x, y) {
  this._setPanVector(x, y);
  tmpPanMatrix.getInverse(this.viewer.rotationGroup.matrix);
  tmpPanVector.applyMatrix4(tmpPanMatrix);
  this.controls.translate(tmpPanVector);
};
TrackballControls.prototype.panComponent = function panComponent(x, y) {
  if (!this.component) {
    return;
  }
  this._setPanVector(x, y);
  tmpPanMatrix.extractRotation(this.component.transform);
  tmpPanMatrix.premultiply(this.viewer.rotationGroup.matrix);
  tmpPanMatrix.getInverse(tmpPanMatrix);
  tmpPanVector.applyMatrix4(tmpPanMatrix);
  this.component.position.add(tmpPanVector);
  this.component.updateMatrix();
};
TrackballControls.prototype.rotate = function rotate(x, y) {
  var ref = this._getRotateXY(x, y);
  var dx = ref[0];
  var dy = ref[1];
  tmpRotateXMatrix.makeRotationX(dy);
  tmpRotateYMatrix.makeRotationY(dx);
  tmpRotateXMatrix.multiply(tmpRotateYMatrix);
  this.controls.applyMatrix(tmpRotateXMatrix);
};
TrackballControls.prototype.rotateComponent = function rotateComponent(x, y) {
  if (!this.component) {
    return;
  }
  var ref = this._getRotateXY(x, y);
  var dx = ref[0];
  var dy = ref[1];
  tmpRotateMatrix.extractRotation(this.component.transform);
  tmpRotateMatrix.premultiply(this.viewer.rotationGroup.matrix);
  tmpRotateMatrix.getInverse(tmpRotateMatrix);
  tmpRotateVector.set(1, 0, 0);
  tmpRotateVector.applyMatrix4(tmpRotateMatrix);
  tmpRotateXMatrix.makeRotationAxis(tmpRotateVector, dy);
  tmpRotateVector.set(0, 1, 0);
  tmpRotateVector.applyMatrix4(tmpRotateMatrix);
  tmpRotateYMatrix.makeRotationAxis(tmpRotateVector, dx);
  tmpRotateXMatrix.multiply(tmpRotateYMatrix);
  tmpRotateQuaternion.setFromRotationMatrix(tmpRotateXMatrix);
  this.component.quaternion.premultiply(tmpRotateQuaternion);
  this.component.updateMatrix();
};
Object.defineProperties(TrackballControls.prototype, prototypeAccessors$5);
function closer(x, a, b) {
  return x.distanceTo(a) < x.distanceTo(b);
}
var PickingProxy = function PickingProxy2(pickingData, stage) {
  this.pid = pickingData.pid;
  this.picker = pickingData.picker;
  this.instance = pickingData.instance;
  this.stage = stage;
  this.controls = stage.viewerControls;
  this.mouse = stage.mouseObserver;
};
var prototypeAccessors$6 = {type: {}, altKey: {}, ctrlKey: {}, metaKey: {}, shiftKey: {}, canvasPosition: {}, component: {}, object: {}, position: {}, closestBondAtom: {}, arrow: {}, atom: {}, axes: {}, bond: {}, cone: {}, clash: {}, contact: {}, cylinder: {}, distance: {}, ellipsoid: {}, mesh: {}, slice: {}, sphere: {}, surface: {}, unitcell: {}, unknown: {}, volume: {}};
prototypeAccessors$6.type.get = function() {
  return this.picker.type;
};
prototypeAccessors$6.altKey.get = function() {
  return this.mouse.altKey;
};
prototypeAccessors$6.ctrlKey.get = function() {
  return this.mouse.ctrlKey;
};
prototypeAccessors$6.metaKey.get = function() {
  return this.mouse.metaKey;
};
prototypeAccessors$6.shiftKey.get = function() {
  return this.mouse.shiftKey;
};
prototypeAccessors$6.canvasPosition.get = function() {
  return this.mouse.canvasPosition;
};
prototypeAccessors$6.component.get = function() {
  return this.stage.getComponentsByObject(this.picker.data).list[0];
};
prototypeAccessors$6.object.get = function() {
  return this.picker.getObject(this.pid);
};
prototypeAccessors$6.position.get = function() {
  return this.picker.getPosition(this.pid, this.instance, this.component);
};
prototypeAccessors$6.closestBondAtom.get = function() {
  if (this.type !== "bond") {
    return void 0;
  }
  var bond = this.bond;
  var controls = this.controls;
  var cp = this.canvasPosition;
  var acp1 = controls.getPositionOnCanvas(bond.atom1);
  var acp2 = controls.getPositionOnCanvas(bond.atom2);
  return closer(cp, acp1, acp2) ? bond.atom1 : bond.atom2;
};
prototypeAccessors$6.arrow.get = function() {
  return this._objectIfType("arrow");
};
prototypeAccessors$6.atom.get = function() {
  return this._objectIfType("atom");
};
prototypeAccessors$6.axes.get = function() {
  return this._objectIfType("axes");
};
prototypeAccessors$6.bond.get = function() {
  return this._objectIfType("bond");
};
prototypeAccessors$6.cone.get = function() {
  return this._objectIfType("cone");
};
prototypeAccessors$6.clash.get = function() {
  return this._objectIfType("clash");
};
prototypeAccessors$6.contact.get = function() {
  return this._objectIfType("contact");
};
prototypeAccessors$6.cylinder.get = function() {
  return this._objectIfType("cylinder");
};
prototypeAccessors$6.distance.get = function() {
  return this._objectIfType("distance");
};
prototypeAccessors$6.ellipsoid.get = function() {
  return this._objectIfType("ellipsoid");
};
prototypeAccessors$6.mesh.get = function() {
  return this._objectIfType("mesh");
};
prototypeAccessors$6.slice.get = function() {
  return this._objectIfType("slice");
};
prototypeAccessors$6.sphere.get = function() {
  return this._objectIfType("sphere");
};
prototypeAccessors$6.surface.get = function() {
  return this._objectIfType("surface");
};
prototypeAccessors$6.unitcell.get = function() {
  return this._objectIfType("unitcell");
};
prototypeAccessors$6.unknown.get = function() {
  return this._objectIfType("unknown");
};
prototypeAccessors$6.volume.get = function() {
  return this._objectIfType("volume");
};
PickingProxy.prototype._objectIfType = function _objectIfType(type2) {
  return this.type === type2 ? this.object : void 0;
};
PickingProxy.prototype.getLabel = function getLabel() {
  var msg = "nothing";
  if (this.arrow) {
    msg = "arrow: " + (this.arrow.name || this.pid) + " (" + this.arrow.shape.name + ")";
  } else if (this.atom) {
    msg = "atom: " + this.atom.qualifiedName() + " (" + this.atom.structure.name + ")";
  } else if (this.axes) {
    msg = "axes";
  } else if (this.bond) {
    msg = "bond: " + this.bond.atom1.qualifiedName() + " - " + this.bond.atom2.qualifiedName() + " (" + this.bond.structure.name + ")";
  } else if (this.cone) {
    msg = "cone: " + (this.cone.name || this.pid) + " (" + this.cone.shape.name + ")";
  } else if (this.clash) {
    msg = "clash: " + this.clash.clash.sele1 + " - " + this.clash.clash.sele2;
  } else if (this.contact) {
    msg = "contact: " + this.contact.atom1.qualifiedName() + " - " + this.contact.atom2.qualifiedName() + " (" + this.contact.structure.name + ")";
  } else if (this.cylinder) {
    msg = "cylinder: " + (this.cylinder.name || this.pid) + " (" + this.cylinder.shape.name + ")";
  } else if (this.distance) {
    msg = "distance: " + this.distance.atom1.qualifiedName() + " - " + this.distance.atom2.qualifiedName() + " (" + this.distance.structure.name + ")";
  } else if (this.ellipsoid) {
    msg = "ellipsoid: " + (this.ellipsoid.name || this.pid) + " (" + this.ellipsoid.shape.name + ")";
  } else if (this.mesh) {
    msg = "mesh: " + (this.mesh.name || this.mesh.serial) + " (" + this.mesh.shape.name + ")";
  } else if (this.slice) {
    msg = "slice: " + this.slice.value.toPrecision(3) + " (" + this.slice.volume.name + ")";
  } else if (this.sphere) {
    msg = "sphere: " + (this.sphere.name || this.pid) + " (" + this.sphere.shape.name + ")";
  } else if (this.surface) {
    msg = "surface: " + this.surface.surface.name;
  } else if (this.unitcell) {
    msg = "unitcell: " + this.unitcell.unitcell.spacegroup + " (" + this.unitcell.structure.name + ")";
  } else if (this.unknown) {
    msg = "unknown";
  } else if (this.volume) {
    msg = "volume: " + this.volume.value.toPrecision(3) + " (" + this.volume.volume.name + ")";
  }
  return msg;
};
Object.defineProperties(PickingProxy.prototype, prototypeAccessors$6);
var PickingControls = function PickingControls2(stage) {
  this.stage = stage;
  this.viewer = stage.viewer;
};
PickingControls.prototype.pick = function pick(x, y) {
  var pickingData = this.viewer.pick(x, y);
  if (pickingData.picker && pickingData.picker.type !== "ignore" && pickingData.pid !== void 0) {
    var pickerArray = pickingData.picker.array;
    if (pickerArray && pickingData.pid >= pickerArray.length) {
      console.error("pid >= picker.array.length");
    } else {
      return new PickingProxy(pickingData, this.stage);
    }
  }
};
var tmpQ = new Quaternion();
var tmpP = new Vector3();
var tmpS = new Vector3();
var tmpCanvasVector = new Vector3();
var tmpScaleVector = new Vector3();
var tmpRotateMatrix$1 = new Matrix4();
var tmpRotateVector$1 = new Vector3();
var tmpAlignMatrix = new Matrix4();
var ViewerControls = function ViewerControls2(stage) {
  this.stage = stage;
  this.viewer = stage.viewer;
  this.signals = {
    changed: new Signal()
  };
};
var prototypeAccessors$7 = {position: {}, rotation: {}};
prototypeAccessors$7.position.get = function() {
  return this.viewer.translationGroup.position;
};
prototypeAccessors$7.rotation.get = function() {
  return this.viewer.rotationGroup.quaternion;
};
ViewerControls.prototype.changed = function changed() {
  this.viewer.requestRender();
  this.signals.changed.dispatch();
};
ViewerControls.prototype.getPositionOnCanvas = function getPositionOnCanvas(position, optionalTarget) {
  var canvasPosition = ensureVector2(optionalTarget);
  var viewer = this.viewer;
  tmpCanvasVector.copy(position).add(viewer.translationGroup.position).applyMatrix4(viewer.rotationGroup.matrix).project(viewer.camera);
  return canvasPosition.set((tmpCanvasVector.x + 1) * viewer.width / 2, (tmpCanvasVector.y + 1) * viewer.height / 2);
};
ViewerControls.prototype.getOrientation = function getOrientation(optionalTarget) {
  var m2 = ensureMatrix4(optionalTarget);
  m2.copy(this.viewer.rotationGroup.matrix);
  var z = -this.viewer.camera.position.z;
  m2.scale(tmpScaleVector.set(z, z, z));
  m2.setPosition(this.viewer.translationGroup.position);
  return m2;
};
ViewerControls.prototype.orient = function orient(orientation) {
  ensureMatrix4(orientation).decompose(tmpP, tmpQ, tmpS);
  var v = this.viewer;
  v.rotationGroup.setRotationFromQuaternion(tmpQ);
  v.translationGroup.position.copy(tmpP);
  v.camera.position.z = -tmpS.z;
  v.updateZoom();
  this.changed();
};
ViewerControls.prototype.translate = function translate(vector) {
  this.viewer.translationGroup.position.add(ensureVector3(vector));
  this.changed();
};
ViewerControls.prototype.center = function center(position) {
  this.viewer.translationGroup.position.copy(ensureVector3(position)).negate();
  this.changed();
};
ViewerControls.prototype.zoom = function zoom2(delta) {
  this.distance(this.viewer.camera.position.z * (1 - delta));
};
ViewerControls.prototype.distance = function distance(z) {
  this.viewer.camera.position.z = z;
  this.viewer.updateZoom();
  this.changed();
};
ViewerControls.prototype.spin = function spin(axis, angle) {
  tmpRotateMatrix$1.getInverse(this.viewer.rotationGroup.matrix);
  tmpRotateVector$1.copy(ensureVector3(axis)).applyMatrix4(tmpRotateMatrix$1);
  this.viewer.rotationGroup.rotateOnAxis(tmpRotateVector$1, angle);
  this.changed();
};
ViewerControls.prototype.rotate = function rotate2(quaternion) {
  this.viewer.rotationGroup.setRotationFromQuaternion(ensureQuaternion(quaternion));
  this.changed();
};
ViewerControls.prototype.align = function align(basis) {
  tmpAlignMatrix.getInverse(ensureMatrix4(basis));
  this.viewer.rotationGroup.setRotationFromMatrix(tmpAlignMatrix);
  this.changed();
};
ViewerControls.prototype.applyMatrix = function applyMatrix(matrix2) {
  this.viewer.rotationGroup.applyMatrix(ensureMatrix4(matrix2));
  this.changed();
};
Object.defineProperties(ViewerControls.prototype, prototypeAccessors$7);
var Animation = function Animation2(duration, controls) {
  var args = [], len = arguments.length - 2;
  while (len-- > 0)
    args[len] = arguments[len + 2];
  this.duration = defaults(duration, 1e3);
  this.controls = controls;
  this.startTime = window.performance.now();
  this.pausedTime = -1;
  this.elapsedDuration = 0;
  this.pausedDuration = 0;
  this.ignoreGlobalToggle = false;
  this._paused = false;
  this._resolveList = [];
  (ref = this)._init.apply(ref, args);
  var ref;
};
var prototypeAccessors$9 = {done: {}, paused: {}};
prototypeAccessors$9.done.get = function() {
  return this.alpha === 1;
};
prototypeAccessors$9.paused.get = function() {
  return this._paused;
};
Animation.prototype._init = function _init() {
};
Animation.prototype._tick = function _tick() {
};
Animation.prototype.tick = function tick(stats) {
  if (this._paused) {
    return;
  }
  this.elapsedDuration = stats.currentTime - this.startTime - this.pausedDuration;
  if (this.duration === 0) {
    this.alpha = 1;
  } else {
    this.alpha = smoothstep(0, 1, this.elapsedDuration / this.duration);
  }
  this._tick(stats);
  if (this.done) {
    this._resolveList.forEach(function(resolve2) {
      return resolve2();
    });
  }
  return this.done;
};
Animation.prototype.pause = function pause(hold) {
  if (hold) {
    this._hold = true;
  }
  if (this.pausedTime === -1) {
    this.pausedTime = window.performance.now();
  }
  this._paused = true;
};
Animation.prototype.resume = function resume(releaseHold) {
  if (!releaseHold && this._hold) {
    return;
  }
  this.pausedDuration += window.performance.now() - this.pausedTime;
  this._paused = false;
  this._hold = false;
  this.pausedTime = -1;
};
Animation.prototype.toggle = function toggle() {
  if (this._paused) {
    this.resume();
  } else {
    this.pause();
  }
};
Animation.prototype.then = function then(callback) {
  var this$1 = this;
  var p;
  if (this.done) {
    p = Promise.resolve();
  } else {
    p = new Promise(function(resolve2) {
      return this$1._resolveList.push(resolve2);
    });
  }
  return p.then(callback);
};
Object.defineProperties(Animation.prototype, prototypeAccessors$9);
var SpinAnimation = function(Animation3) {
  function SpinAnimation2(duration) {
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    Animation3.apply(this, [defaults(duration, Infinity)].concat(args));
  }
  if (Animation3)
    SpinAnimation2.__proto__ = Animation3;
  SpinAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  SpinAnimation2.prototype.constructor = SpinAnimation2;
  SpinAnimation2.prototype._init = function _init3(axis, angle) {
    if (Array.isArray(axis)) {
      this.axis = new Vector3().fromArray(axis);
    } else {
      this.axis = defaults(axis, new Vector3(0, 1, 0));
    }
    this.angle = defaults(angle, 0.01);
  };
  SpinAnimation2.prototype._tick = function _tick2(stats) {
    if (!this.axis || !this.angle) {
      return;
    }
    this.controls.spin(this.axis, this.angle * stats.lastDuration / 16);
  };
  return SpinAnimation2;
}(Animation);
var RockAnimation = function(Animation3) {
  function RockAnimation2(duration) {
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    Animation3.apply(this, [defaults(duration, Infinity)].concat(args));
  }
  if (Animation3)
    RockAnimation2.__proto__ = Animation3;
  RockAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  RockAnimation2.prototype.constructor = RockAnimation2;
  RockAnimation2.prototype._init = function _init3(axis, angleStep, angleEnd) {
    if (Array.isArray(axis)) {
      this.axis = new Vector3().fromArray(axis);
    } else {
      this.axis = defaults(axis, new Vector3(0, 1, 0));
    }
    this.angleStep = defaults(angleStep, 0.01);
    this.angleEnd = defaults(angleEnd, 0.2);
    this.angleSum = 0;
    this.direction = 1;
  };
  RockAnimation2.prototype._tick = function _tick2(stats) {
    if (!this.axis || !this.angleStep || !this.angleEnd) {
      return;
    }
    var alpha = smoothstep(0, 1, Math.abs(this.angleSum) / this.angleEnd);
    var angle = this.angleStep * this.direction * (1.1 - alpha);
    this.controls.spin(this.axis, angle * stats.lastDuration / 16);
    this.angleSum += this.angleStep;
    if (this.angleSum >= this.angleEnd) {
      this.direction *= -1;
      this.angleSum = -this.angleEnd;
    }
  };
  return RockAnimation2;
}(Animation);
var MoveAnimation = function(Animation3) {
  function MoveAnimation2() {
    Animation3.apply(this, arguments);
  }
  if (Animation3)
    MoveAnimation2.__proto__ = Animation3;
  MoveAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  MoveAnimation2.prototype.constructor = MoveAnimation2;
  MoveAnimation2.prototype._init = function _init3(moveFrom, moveTo) {
    this.moveFrom = ensureVector3(defaults(moveFrom, new Vector3()));
    this.moveTo = ensureVector3(defaults(moveTo, new Vector3()));
  };
  MoveAnimation2.prototype._tick = function _tick2() {
    this.controls.position.lerpVectors(this.moveFrom, this.moveTo, this.alpha).negate();
    this.controls.changed();
  };
  return MoveAnimation2;
}(Animation);
var ZoomAnimation = function(Animation3) {
  function ZoomAnimation2() {
    Animation3.apply(this, arguments);
  }
  if (Animation3)
    ZoomAnimation2.__proto__ = Animation3;
  ZoomAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  ZoomAnimation2.prototype.constructor = ZoomAnimation2;
  ZoomAnimation2.prototype._init = function _init3(zoomFrom, zoomTo) {
    this.zoomFrom = zoomFrom;
    this.zoomTo = zoomTo;
  };
  ZoomAnimation2.prototype._tick = function _tick2() {
    this.controls.distance(lerp(this.zoomFrom, this.zoomTo, this.alpha));
  };
  return ZoomAnimation2;
}(Animation);
var RotateAnimation = function(Animation3) {
  function RotateAnimation2() {
    Animation3.apply(this, arguments);
  }
  if (Animation3)
    RotateAnimation2.__proto__ = Animation3;
  RotateAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  RotateAnimation2.prototype.constructor = RotateAnimation2;
  RotateAnimation2.prototype._init = function _init3(rotateFrom, rotateTo) {
    this.rotateFrom = ensureQuaternion(rotateFrom);
    this.rotateTo = ensureQuaternion(rotateTo);
    this._currentRotation = new Quaternion();
  };
  RotateAnimation2.prototype._tick = function _tick2() {
    this._currentRotation.copy(this.rotateFrom).slerp(this.rotateTo, this.alpha);
    this.controls.rotate(this._currentRotation);
  };
  return RotateAnimation2;
}(Animation);
var ValueAnimation = function(Animation3) {
  function ValueAnimation2() {
    Animation3.apply(this, arguments);
  }
  if (Animation3)
    ValueAnimation2.__proto__ = Animation3;
  ValueAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  ValueAnimation2.prototype.constructor = ValueAnimation2;
  ValueAnimation2.prototype._init = function _init3(valueFrom, valueTo, callback) {
    this.valueFrom = valueFrom;
    this.valueTo = valueTo;
    this.callback = callback;
  };
  ValueAnimation2.prototype._tick = function _tick2() {
    this.callback(lerp(this.valueFrom, this.valueTo, this.alpha));
  };
  return ValueAnimation2;
}(Animation);
var TimeoutAnimation = function(Animation3) {
  function TimeoutAnimation2() {
    Animation3.apply(this, arguments);
  }
  if (Animation3)
    TimeoutAnimation2.__proto__ = Animation3;
  TimeoutAnimation2.prototype = Object.create(Animation3 && Animation3.prototype);
  TimeoutAnimation2.prototype.constructor = TimeoutAnimation2;
  TimeoutAnimation2.prototype._init = function _init3(callback) {
    this.callback = callback;
  };
  TimeoutAnimation2.prototype._tick = function _tick2() {
    if (this.alpha === 1) {
      this.callback();
    }
  };
  return TimeoutAnimation2;
}(Animation);
var AnimationList = function AnimationList2(list) {
  this._list = list || [];
  this._resolveList = [];
};
var prototypeAccessors$1$1 = {done: {}};
prototypeAccessors$1$1.done.get = function() {
  return this._list.every(function(animation) {
    return animation.done;
  });
};
AnimationList.prototype.then = function then2(callback) {
  var this$1 = this;
  var p;
  if (this.done) {
    p = Promise.resolve();
  } else {
    p = new Promise(function(resolve2) {
      this$1._resolveList.push(resolve2);
      this$1._list.forEach(function(animation) {
        animation.then(function() {
          this$1._resolveList.forEach(function(callback2) {
            callback2();
          });
          this$1._resolveList.length = 0;
        });
      });
    });
  }
  return p.then(callback);
};
Object.defineProperties(AnimationList.prototype, prototypeAccessors$1$1);
var AnimationControls = function AnimationControls2(stage) {
  this.stage = stage;
  this.viewer = stage.viewer;
  this.controls = stage.viewerControls;
  this.animationList = [];
  this.finishedList = [];
};
var prototypeAccessors$8 = {paused: {}};
prototypeAccessors$8.paused.get = function() {
  return this.animationList.every(function(animation) {
    return animation.paused;
  });
};
AnimationControls.prototype.add = function add4(animation) {
  if (animation.duration === 0) {
    animation.tick(this.viewer.stats);
  } else {
    this.animationList.push(animation);
  }
  return animation;
};
AnimationControls.prototype.remove = function remove(animation) {
  var list = this.animationList;
  var index = list.indexOf(animation);
  if (index > -1) {
    list.splice(index, 1);
  }
};
AnimationControls.prototype.run = function run(stats) {
  var this$1 = this;
  var finishedList = this.finishedList;
  var animationList = this.animationList;
  var n = animationList.length;
  for (var i = 0; i < n; ++i) {
    var animation = animationList[i];
    if (animation.tick(stats)) {
      finishedList.push(animation);
    }
  }
  var m2 = finishedList.length;
  if (m2) {
    for (var j = 0; j < m2; ++j) {
      this$1.remove(finishedList[j]);
    }
    finishedList.length = 0;
  }
};
AnimationControls.prototype.spin = function spin2(axis, angle, duration) {
  return this.add(new SpinAnimation(duration, this.controls, axis, angle));
};
AnimationControls.prototype.rock = function rock(axis, angle, end, duration) {
  return this.add(new RockAnimation(duration, this.controls, axis, angle, end));
};
AnimationControls.prototype.rotate = function rotate3(rotateTo, duration) {
  var rotateFrom = this.viewer.rotationGroup.quaternion.clone();
  return this.add(new RotateAnimation(duration, this.controls, rotateFrom, rotateTo));
};
AnimationControls.prototype.move = function move(moveTo, duration) {
  var moveFrom = this.controls.position.clone().negate();
  return this.add(new MoveAnimation(duration, this.controls, moveFrom, moveTo));
};
AnimationControls.prototype.zoom = function zoom3(zoomTo, duration) {
  var zoomFrom = this.viewer.camera.position.z;
  return this.add(new ZoomAnimation(duration, this.controls, zoomFrom, zoomTo));
};
AnimationControls.prototype.zoomMove = function zoomMove(moveTo, zoomTo, duration) {
  return new AnimationList([
    this.move(moveTo, duration),
    this.zoom(zoomTo, duration)
  ]);
};
AnimationControls.prototype.orient = function orient2(orientTo, duration) {
  var p = new Vector3();
  var q = new Quaternion();
  var s = new Vector3();
  ensureMatrix4(orientTo).decompose(p, q, s);
  return new AnimationList([
    this.move(p.negate(), duration),
    this.rotate(q, duration),
    this.zoom(-s.x, duration)
  ]);
};
AnimationControls.prototype.value = function value(valueFrom, valueTo, callback, duration) {
  return this.add(new ValueAnimation(duration, this.controls, valueFrom, valueTo, callback));
};
AnimationControls.prototype.timeout = function timeout(callback, duration) {
  return this.add(new TimeoutAnimation(duration, this.controls, callback));
};
AnimationControls.prototype.spinComponent = function spinComponent(component, axis, angle, duration) {
  return this.add(new SpinAnimation(duration, component.controls, axis, angle));
};
AnimationControls.prototype.rockComponent = function rockComponent(component, axis, angle, end, duration) {
  return this.add(new RockAnimation(duration, component.controls, axis, angle, end));
};
AnimationControls.prototype.moveComponent = function moveComponent(component, moveTo, duration) {
  var moveFrom = component.controls.position.clone().negate();
  return this.add(new MoveAnimation(duration, component.controls, moveFrom, moveTo));
};
AnimationControls.prototype.pause = function pause2() {
  this.animationList.forEach(function(animation) {
    return animation.pause();
  });
};
AnimationControls.prototype.resume = function resume2() {
  this.animationList.forEach(function(animation) {
    return animation.resume();
  });
};
AnimationControls.prototype.toggle = function toggle2() {
  if (this.paused) {
    this.resume();
  } else {
    this.pause();
  }
};
AnimationControls.prototype.clear = function clear2() {
  this.animationList.length = 0;
};
AnimationControls.prototype.dispose = function dispose4() {
  this.clear();
};
Object.defineProperties(AnimationControls.prototype, prototypeAccessors$8);
var MouseActions = function MouseActions2() {
};
MouseActions.zoomScroll = function zoomScroll(stage, delta) {
  stage.trackballControls.zoom(delta);
};
MouseActions.clipNearScroll = function clipNearScroll(stage, delta) {
  var sp = stage.getParameters();
  stage.setParameters({clipNear: sp.clipNear + delta / 10});
};
MouseActions.focusScroll = function focusScroll(stage, delta) {
  var sp = stage.getParameters();
  var focus = sp.clipNear * 2;
  var sign = Math.sign(delta);
  var step = sign * almostIdentity((100 - focus) / 10, 5, 0.2);
  stage.setFocus(focus + step);
};
MouseActions.isolevelScroll = function isolevelScroll(stage, delta) {
  var d = Math.sign(delta) / 5;
  stage.eachRepresentation(function(reprComp) {
    if (reprComp.repr.type !== "surface") {
      return;
    }
    var l = reprComp.getParameters().isolevel;
    reprComp.setParameters({isolevel: l + d});
  }, "volume");
};
MouseActions.panDrag = function panDrag(stage, dx, dy) {
  stage.trackballControls.pan(dx, dy);
};
MouseActions.rotateDrag = function rotateDrag(stage, dx, dy) {
  stage.trackballControls.rotate(dx, dy);
};
MouseActions.zoomDrag = function zoomDrag(stage, dx, dy) {
  stage.trackballControls.zoom((dx + dy) / -2);
};
MouseActions.zoomFocusDrag = function zoomFocusDrag(stage, dx, dy) {
  stage.trackballControls.zoom((dx + dy) / -2);
  var z = stage.viewer.camera.position.z;
  stage.setFocus(100 - Math.abs(z / 8));
};
MouseActions.panComponentDrag = function panComponentDrag(stage, dx, dy) {
  stage.trackballControls.panComponent(dx, dy);
};
MouseActions.rotateComponentDrag = function rotateComponentDrag(stage, dx, dy) {
  stage.trackballControls.rotateComponent(dx, dy);
};
MouseActions.movePick = function movePick(stage, pickingProxy) {
  if (pickingProxy) {
    stage.animationControls.move(pickingProxy.position.clone());
  }
};
MouseActions.tooltipPick = function tooltipPick(stage, pickingProxy) {
  var tt = stage.tooltip;
  var sp = stage.getParameters();
  if (sp.tooltip && pickingProxy) {
    var mp = pickingProxy.mouse.position;
    tt.innerText = pickingProxy.getLabel();
    tt.style.bottom = window.innerHeight - mp.y + 3 + "px";
    tt.style.left = mp.x + 3 + "px";
    tt.style.display = "block";
  } else {
    tt.style.display = "none";
  }
};
var ActionPresets = {
  default: [
    ["scroll", MouseActions.zoomScroll],
    ["scroll-ctrl", MouseActions.clipNearScroll],
    ["scroll-shift", MouseActions.focusScroll],
    ["scroll-alt", MouseActions.isolevelScroll],
    ["drag-right", MouseActions.panDrag],
    ["drag-left", MouseActions.rotateDrag],
    ["drag-middle", MouseActions.zoomDrag],
    ["drag-shift-right", MouseActions.zoomDrag],
    ["drag-left+right", MouseActions.zoomDrag],
    ["drag-ctrl-right", MouseActions.panComponentDrag],
    ["drag-ctrl-left", MouseActions.rotateComponentDrag],
    ["clickPick-middle", MouseActions.movePick],
    ["hoverPick", MouseActions.tooltipPick]
  ],
  pymol: [
    ["drag-left", MouseActions.rotateDrag],
    ["drag-middle", MouseActions.panDrag],
    ["drag-right", MouseActions.zoomDrag],
    ["drag-shift-right", MouseActions.focusScroll],
    ["clickPick-ctrl+shift-middle", MouseActions.movePick],
    ["hoverPick", MouseActions.tooltipPick]
  ],
  coot: [
    ["scroll", MouseActions.isolevelScroll],
    ["drag-left", MouseActions.rotateDrag],
    ["drag-middle", MouseActions.panDrag],
    ["drag-ctrl-left", MouseActions.panDrag],
    ["drag-right", MouseActions.zoomFocusDrag],
    ["drag-ctrl-right", MouseActions.focusScroll],
    ["clickPick-middle", MouseActions.movePick],
    ["hoverPick", MouseActions.tooltipPick]
  ]
};
function triggerFromString(str) {
  var tokens = str.split(/[-+]/);
  var type2 = "";
  if (tokens.includes("scroll")) {
    type2 = "scroll";
  }
  if (tokens.includes("drag")) {
    type2 = "drag";
  }
  if (tokens.includes("click")) {
    type2 = "click";
  }
  if (tokens.includes("hover")) {
    type2 = "hover";
  }
  if (tokens.includes("clickPick")) {
    type2 = "clickPick";
  }
  if (tokens.includes("hoverPick")) {
    type2 = "hoverPick";
  }
  var key = 0;
  if (tokens.includes("alt")) {
    key += 1;
  }
  if (tokens.includes("ctrl")) {
    key += 2;
  }
  if (tokens.includes("meta")) {
    key += 4;
  }
  if (tokens.includes("shift")) {
    key += 8;
  }
  var button = 0;
  if (tokens.includes("left")) {
    button += 1;
  }
  if (tokens.includes("right")) {
    button += 2;
  }
  if (tokens.includes("middle")) {
    button += 4;
  }
  return [type2, key, button];
}
var MouseControls = function MouseControls2(stage, params) {
  var p = params || {};
  this.stage = stage;
  this.mouse = stage.mouseObserver;
  this.actionList = [];
  this.preset(p.preset || "default");
};
MouseControls.prototype.run = function run2(type2) {
  var this$1 = this;
  var args = [], len = arguments.length - 1;
  while (len-- > 0)
    args[len] = arguments[len + 1];
  var key = this.mouse.key || 0;
  var button = this.mouse.buttons || 0;
  this.actionList.forEach(function(a) {
    if (a.type === type2 && a.key === key && a.button === button) {
      a.callback.apply(a, [this$1.stage].concat(args));
    }
  });
};
MouseControls.prototype.add = function add5(triggerStr, callback) {
  var ref = triggerFromString(triggerStr);
  var type2 = ref[0];
  var key = ref[1];
  var button = ref[2];
  this.actionList.push({type: type2, key, button, callback});
};
MouseControls.prototype.remove = function remove2(triggerStr, callback) {
  var wildcard = triggerStr.includes("*");
  var ref = triggerFromString(triggerStr);
  var type2 = ref[0];
  var key = ref[1];
  var button = ref[2];
  var actionList = this.actionList.filter(function(a) {
    return !((a.type === type2 || wildcard && type2 === "") && (a.key === key || wildcard && key === 0) && (a.button === button || wildcard && button === 0) && (a.callback === callback || callback === void 0));
  });
  this.actionList = actionList;
};
MouseControls.prototype.preset = function preset(name) {
  var this$1 = this;
  this.clear();
  var list = ActionPresets[name] || [];
  list.forEach(function(action) {
    (ref = this$1).add.apply(ref, action);
    var ref;
  });
};
MouseControls.prototype.clear = function clear3() {
  this.actionList.length = 0;
};
var PickingBehavior = function PickingBehavior2(stage) {
  this.stage = stage;
  this.mouse = stage.mouseObserver;
  this.controls = stage.mouseControls;
  this.mouse.signals.clicked.add(this._onClick, this);
  this.mouse.signals.hovered.add(this._onHover, this);
};
PickingBehavior.prototype._onClick = function _onClick(x, y) {
  var pickingProxy = this.stage.pickingControls.pick(x, y);
  this.stage.signals.clicked.dispatch(pickingProxy);
  this.controls.run("clickPick", pickingProxy);
};
PickingBehavior.prototype._onHover = function _onHover(x, y) {
  var pickingProxy = this.stage.pickingControls.pick(x, y);
  if (pickingProxy && this.mouse.down.equals(this.mouse.position)) {
    this.stage.transformComponent = pickingProxy.component;
  }
  this.stage.signals.hovered.dispatch(pickingProxy);
  this.controls.run("hoverPick", pickingProxy);
};
PickingBehavior.prototype.dispose = function dispose5() {
  this.mouse.signals.clicked.remove(this._onClick, this);
  this.mouse.signals.hovered.remove(this._onHover, this);
};
var MouseBehavior = function MouseBehavior2(stage) {
  this.stage = stage;
  this.mouse = stage.mouseObserver;
  this.controls = stage.mouseControls;
  this.mouse.signals.moved.add(this._onMove, this);
  this.mouse.signals.scrolled.add(this._onScroll, this);
  this.mouse.signals.dragged.add(this._onDrag, this);
  this.mouse.signals.clicked.add(this._onClick, this);
  this.mouse.signals.hovered.add(this._onHover, this);
};
MouseBehavior.prototype._onMove = function _onMove() {
  this.stage.tooltip.style.display = "none";
};
MouseBehavior.prototype._onScroll = function _onScroll(delta) {
  this.controls.run("scroll", delta);
};
MouseBehavior.prototype._onDrag = function _onDrag(dx, dy) {
  this.controls.run("drag", dx, dy);
};
MouseBehavior.prototype._onClick = function _onClick2(x, y) {
  this.controls.run("click", x, y);
};
MouseBehavior.prototype._onHover = function _onHover2(x, y) {
  this.controls.run("hover", x, y);
};
MouseBehavior.prototype.dispose = function dispose6() {
  this.mouse.signals.moved.remove(this._onMove, this);
  this.mouse.signals.scrolled.remove(this._onScroll, this);
  this.mouse.signals.dragged.remove(this._onDrag, this);
  this.mouse.signals.clicked.remove(this._onClick, this);
  this.mouse.signals.hovered.remove(this._onHover, this);
};
var AnimationBehavior = function AnimationBehavior2(stage) {
  this.viewer = stage.viewer;
  this.animationControls = stage.animationControls;
  this.viewer.signals.ticked.add(this._onTick, this);
};
AnimationBehavior.prototype._onTick = function _onTick(stats) {
  this.animationControls.run(stats);
};
AnimationBehavior.prototype.dispose = function dispose7() {
  this.viewer.signals.ticked.remove(this._onTick, this);
};
var KeyBehavior = function KeyBehavior2(stage) {
  this.stage = stage;
  this._onKeydown = this._onKeydown.bind(this);
  this._onKeyup = this._onKeyup.bind(this);
  this._onKeypress = this._onKeypress.bind(this);
  document.addEventListener("keydown", this._onKeydown);
  document.addEventListener("keyup", this._onKeyup);
  document.addEventListener("keypress", this._onKeypress);
};
KeyBehavior.prototype._onKeydown = function _onKeydown() {
};
KeyBehavior.prototype._onKeyup = function _onKeyup() {
};
KeyBehavior.prototype._onKeypress = function _onKeypress(event) {
  switch (event.keyCode) {
    case 73:
    case 105:
      this.stage.toggleSpin();
      break;
    case 75:
    case 107:
      this.stage.toggleRock();
      break;
    case 80:
    case 112:
      this.stage.animationControls.toggle();
      break;
  }
};
KeyBehavior.prototype.dispose = function dispose8() {
  document.removeEventListener("keydown", this._onKeypress);
  document.removeEventListener("keyup", this._onKeypress);
  document.removeEventListener("keypress", this._onKeypress);
};
var Annotation = function Annotation2(component, position, content, params) {
  var p = params || {};
  this.offsetX = defaults(p.offsetX, 0);
  this.offsetY = defaults(p.offsetY, 0);
  this.visible = defaults(p.visible, true);
  this.component = component;
  this.stage = component.stage;
  this.viewer = this.stage.viewer;
  this.position = position;
  this._viewerPosition = new Vector3();
  this._updateViewerPosition();
  this._canvasPosition = new Vector3();
  this._cameraPosition = new Vector3();
  this.element = document.createElement("div");
  Object.assign(this.element.style, {
    display: "block",
    position: "fixed",
    zIndex: 1 + (parseInt(this.viewer.container.style.zIndex) || 0),
    pointerEvents: "none",
    backgroundColor: "rgba( 0, 0, 0, 0.6 )",
    color: "lightgrey",
    padding: "8px",
    fontFamily: "sans-serif",
    left: "-10000px"
  });
  this.viewer.container.appendChild(this.element);
  this.setContent(content);
  this.updateVisibility();
  this.viewer.signals.ticked.add(this._update, this);
  this.component.signals.matrixChanged.add(this._updateViewerPosition, this);
};
Annotation.prototype.setContent = function setContent(value2) {
  var displayValue = this.element.style.display;
  if (displayValue === "none") {
    this.element.style.left = "-10000px";
    this.element.style.display = "block";
  }
  if (value2 instanceof window.Element) {
    this.element.innerHTML = "";
    this.element.appendChild(value2);
  } else {
    this.element.innerHTML = value2;
  }
  this._clientRect = this.element.getBoundingClientRect();
  if (displayValue === "none") {
    this.element.style.display = displayValue;
  }
};
Annotation.prototype.setVisibility = function setVisibility(value2) {
  this.visible = value2;
  this.updateVisibility();
};
Annotation.prototype.getVisibility = function getVisibility() {
  return this.visible && this.component.visible;
};
Annotation.prototype.updateVisibility = function updateVisibility() {
  this.element.style.display = this.getVisibility() ? "block" : "none";
};
Annotation.prototype._updateViewerPosition = function _updateViewerPosition() {
  this._viewerPosition.copy(this.position).applyMatrix4(this.component.matrix);
};
Annotation.prototype._update = function _update() {
  if (!this.getVisibility()) {
    return;
  }
  var s = this.element.style;
  var cp = this._canvasPosition;
  var vp = this._viewerPosition;
  var cr = this._clientRect;
  this._cameraPosition.copy(vp).add(this.viewer.translationGroup.position).applyMatrix4(this.viewer.rotationGroup.matrix).sub(this.viewer.camera.position);
  if (this._cameraPosition.z < 0) {
    s.display = "none";
    return;
  } else {
    s.display = "block";
  }
  s.opacity = 1 - smoothstep(this.viewer.scene.fog.near, this.viewer.scene.fog.far, this._cameraPosition.length());
  this.stage.viewerControls.getPositionOnCanvas(vp, cp);
  s.bottom = this.offsetX + cp.y + cr.height / 2 + "px";
  s.left = this.offsetY + cp.x - cr.width / 2 + "px";
};
Annotation.prototype.dispose = function dispose9() {
  this.viewer.container.removeChild(this.element);
  this.viewer.signals.ticked.remove(this._update, this);
  this.component.signals.matrixChanged.remove(this._updateViewerPosition, this);
};
var tmpRotateMatrix$2 = new Matrix4();
var tmpRotateVector$2 = new Vector3();
var tmpRotateQuaternion$1 = new Quaternion();
var ComponentControls = function ComponentControls2(component) {
  this.component = component;
  this.stage = component.stage;
  this.viewer = component.stage.viewer;
  this.signals = {
    changed: new Signal()
  };
};
var prototypeAccessors$11 = {position: {}, rotation: {}};
prototypeAccessors$11.position.get = function() {
  return this.component.position;
};
prototypeAccessors$11.rotation.get = function() {
  return this.component.quaternion;
};
ComponentControls.prototype.changed = function changed2() {
  this.component.updateMatrix();
  this.viewer.requestRender();
  this.signals.changed.dispatch();
};
ComponentControls.prototype.spin = function spin3(axis, angle) {
  tmpRotateMatrix$2.getInverse(this.viewer.rotationGroup.matrix);
  tmpRotateVector$2.copy(ensureVector3(axis)).applyMatrix4(tmpRotateMatrix$2);
  tmpRotateMatrix$2.extractRotation(this.component.transform);
  tmpRotateMatrix$2.premultiply(this.viewer.rotationGroup.matrix);
  tmpRotateMatrix$2.getInverse(tmpRotateMatrix$2);
  tmpRotateVector$2.copy(ensureVector3(axis));
  tmpRotateVector$2.applyMatrix4(tmpRotateMatrix$2);
  tmpRotateMatrix$2.makeRotationAxis(tmpRotateVector$2, angle);
  tmpRotateQuaternion$1.setFromRotationMatrix(tmpRotateMatrix$2);
  this.component.quaternion.premultiply(tmpRotateQuaternion$1);
  this.changed();
};
Object.defineProperties(ComponentControls.prototype, prototypeAccessors$11);
function calculateMeanVector3(array) {
  var n = array.length;
  var m2 = array.length / 3;
  var x = 0;
  var y = 0;
  var z = 0;
  var i;
  for (i = 0; i < n; i += 3) {
    x += array[i + 0];
    y += array[i + 1];
    z += array[i + 2];
  }
  return new Vector3(x / m2, y / m2, z / m2);
}
function projectPointOnVector(point, vector, origin) {
  if (origin) {
    point.sub(origin).projectOnVector(vector).add(origin);
  } else {
    point.projectOnVector(vector);
  }
  return point;
}
function computeBoundingBox(array) {
  var minX = Infinity;
  var minY = Infinity;
  var minZ = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  var maxZ = -Infinity;
  for (var i = 0, l = array.length; i < l; i += 3) {
    var x = array[i];
    var y = array[i + 1];
    var z = array[i + 2];
    if (x < minX) {
      minX = x;
    }
    if (y < minY) {
      minY = y;
    }
    if (z < minZ) {
      minZ = z;
    }
    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
    if (z > maxZ) {
      maxZ = z;
    }
  }
  return [
    v3new([minX, minY, minZ]),
    v3new([maxX, maxY, maxZ])
  ];
}
function applyMatrix4toVector3array(m2, a) {
  for (var i = 0, il = a.length; i < il; i += 3) {
    var x = a[i];
    var y = a[i + 1];
    var z = a[i + 2];
    a[i] = m2[0] * x + m2[4] * y + m2[8] * z + m2[12];
    a[i + 1] = m2[1] * x + m2[5] * y + m2[9] * z + m2[13];
    a[i + 2] = m2[2] * x + m2[6] * y + m2[10] * z + m2[14];
  }
}
function applyMatrix3toVector3array(m2, a) {
  for (var i = 0, il = a.length; i < il; i += 3) {
    var x = a[i];
    var y = a[i + 1];
    var z = a[i + 2];
    a[i] = m2[0] * x + m2[3] * y + m2[6] * z;
    a[i + 1] = m2[1] * x + m2[4] * y + m2[7] * z;
    a[i + 2] = m2[2] * x + m2[5] * y + m2[8] * z;
  }
}
function normalizeVector3array(a) {
  for (var i = 0, il = a.length; i < il; i += 3) {
    var x = a[i];
    var y = a[i + 1];
    var z = a[i + 2];
    var s = 1 / Math.sqrt(x * x + y * y + z * z);
    a[i] = x * s;
    a[i + 1] = y * s;
    a[i + 2] = z * s;
  }
}
function v3new(array) {
  return new Float32Array(array || 3);
}
function v3cross(out, a, b) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var bx = b[0];
  var by = b[1];
  var bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
}
function v3sub(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
}
function v3fromArray(out, array, offset) {
  out[0] = array[offset];
  out[1] = array[offset + 1];
  out[2] = array[offset + 2];
}
function v3length(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
}
function v3divideScalar(out, a, s) {
  v3multiplyScalar(out, a, 1 / s);
}
v3divideScalar.__deps = [v3multiplyScalar];
function v3multiplyScalar(out, a, s) {
  out[0] = a[0] * s;
  out[1] = a[1] * s;
  out[2] = a[2] * s;
}
function v3normalize(out, a) {
  v3multiplyScalar(out, a, 1 / v3length(a));
}
v3normalize.__deps = [v3multiplyScalar, v3length];
function v3subScalar(out, a, s) {
  out[0] = a[0] - s;
  out[1] = a[1] - s;
  out[2] = a[2] - s;
}
function v3addScalar(out, a, s) {
  out[0] = a[0] + s;
  out[1] = a[1] + s;
  out[2] = a[2] + s;
}
function v3floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
}
function v3ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
}
function v3negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
}
var Picker = function Picker2(array) {
  this.array = array;
};
Picker.prototype.getIndex = function getIndex(pid) {
  return this.array ? this.array[pid] : pid;
};
Picker.prototype.getObject = function getObject() {
  return {};
};
Picker.prototype._applyTransformations = function _applyTransformations(vector, instance, component) {
  if (instance) {
    vector.applyMatrix4(instance.matrix);
  }
  if (component) {
    vector.applyMatrix4(component.matrix);
  }
  return vector;
};
Picker.prototype._getPosition = function _getPosition() {
  return new Vector3();
};
Picker.prototype.getPosition = function getPosition(pid, instance, component) {
  return this._applyTransformations(this._getPosition(pid), instance, component);
};
var ShapePicker = function(Picker3) {
  function ShapePicker2(shape) {
    Picker3.call(this);
    this.shape = shape;
  }
  if (Picker3)
    ShapePicker2.__proto__ = Picker3;
  ShapePicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  ShapePicker2.prototype.constructor = ShapePicker2;
  var prototypeAccessors2 = {data: {}};
  prototypeAccessors2.data.get = function() {
    return this.shape;
  };
  Object.defineProperties(ShapePicker2.prototype, prototypeAccessors2);
  return ShapePicker2;
}(Picker);
var CylinderPicker = function(ShapePicker2) {
  function CylinderPicker2() {
    ShapePicker2.apply(this, arguments);
  }
  if (ShapePicker2)
    CylinderPicker2.__proto__ = ShapePicker2;
  CylinderPicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  CylinderPicker2.prototype.constructor = CylinderPicker2;
  var prototypeAccessors$110 = {type: {}};
  prototypeAccessors$110.type.get = function() {
    return "cylinder";
  };
  CylinderPicker2.prototype.getObject = function getObject2(pid) {
    var s = this.shape;
    return {
      shape: s,
      color: new Color().fromArray(s.cylinderColor, 3 * pid),
      radius: s.cylinderRadius[pid],
      position1: new Vector3().fromArray(s.cylinderPosition1, 3 * pid),
      position2: new Vector3().fromArray(s.cylinderPosition2, 3 * pid),
      name: s.cylinderName[pid]
    };
  };
  CylinderPicker2.prototype._getPosition = function _getPosition2(pid) {
    var s = this.shape;
    var p1 = new Vector3().fromArray(s.cylinderPosition1, 3 * pid);
    var p2 = new Vector3().fromArray(s.cylinderPosition2, 3 * pid);
    return p1.add(p2).multiplyScalar(0.5);
  };
  Object.defineProperties(CylinderPicker2.prototype, prototypeAccessors$110);
  return CylinderPicker2;
}(ShapePicker);
var ArrowPicker = function(ShapePicker2) {
  function ArrowPicker2() {
    ShapePicker2.apply(this, arguments);
  }
  if (ShapePicker2)
    ArrowPicker2.__proto__ = ShapePicker2;
  ArrowPicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  ArrowPicker2.prototype.constructor = ArrowPicker2;
  var prototypeAccessors$210 = {type: {}};
  prototypeAccessors$210.type.get = function() {
    return "arrow";
  };
  ArrowPicker2.prototype.getObject = function getObject2(pid) {
    var s = this.shape;
    return {
      shape: s,
      position: this._getPosition(pid),
      position1: new Vector3().fromArray(s.arrowPosition1, 3 * pid),
      position2: new Vector3().fromArray(s.arrowPosition2, 3 * pid),
      color: new Color().fromArray(s.arrowColor, 3 * pid),
      radius: s.arrowRadius[pid],
      name: s.arrowName[pid]
    };
  };
  ArrowPicker2.prototype._getPosition = function _getPosition2(pid) {
    var s = this.shape;
    var p1 = new Vector3().fromArray(s.arrowPosition1, 3 * pid);
    var p2 = new Vector3().fromArray(s.arrowPosition2, 3 * pid);
    return p1.add(p2).multiplyScalar(0.5);
  };
  Object.defineProperties(ArrowPicker2.prototype, prototypeAccessors$210);
  return ArrowPicker2;
}(ShapePicker);
var AtomPicker = function(Picker3) {
  function AtomPicker2(array, structure) {
    Picker3.call(this, array);
    this.structure = structure;
  }
  if (Picker3)
    AtomPicker2.__proto__ = Picker3;
  AtomPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  AtomPicker2.prototype.constructor = AtomPicker2;
  var prototypeAccessors$32 = {type: {}, data: {}};
  prototypeAccessors$32.type.get = function() {
    return "atom";
  };
  prototypeAccessors$32.data.get = function() {
    return this.structure;
  };
  AtomPicker2.prototype.getObject = function getObject2(pid) {
    return this.structure.getAtomProxy(this.getIndex(pid));
  };
  AtomPicker2.prototype._getPosition = function _getPosition2(pid) {
    return new Vector3().copy(this.getObject(pid));
  };
  Object.defineProperties(AtomPicker2.prototype, prototypeAccessors$32);
  return AtomPicker2;
}(Picker);
var AxesPicker = function(Picker3) {
  function AxesPicker2(axes) {
    Picker3.call(this);
    this.axes = axes;
  }
  if (Picker3)
    AxesPicker2.__proto__ = Picker3;
  AxesPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  AxesPicker2.prototype.constructor = AxesPicker2;
  var prototypeAccessors$42 = {type: {}, data: {}};
  prototypeAccessors$42.type.get = function() {
    return "axes";
  };
  prototypeAccessors$42.data.get = function() {
    return this.axes;
  };
  AxesPicker2.prototype.getObject = function getObject2() {
    return {
      axes: this.axes
    };
  };
  AxesPicker2.prototype._getPosition = function _getPosition2() {
    return this.axes.center.clone();
  };
  Object.defineProperties(AxesPicker2.prototype, prototypeAccessors$42);
  return AxesPicker2;
}(Picker);
var BondPicker = function(Picker3) {
  function BondPicker2(array, structure, bondStore) {
    Picker3.call(this, array);
    this.structure = structure;
    this.bondStore = bondStore || structure.bondStore;
  }
  if (Picker3)
    BondPicker2.__proto__ = Picker3;
  BondPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  BondPicker2.prototype.constructor = BondPicker2;
  var prototypeAccessors$52 = {type: {}, data: {}};
  prototypeAccessors$52.type.get = function() {
    return "bond";
  };
  prototypeAccessors$52.data.get = function() {
    return this.structure;
  };
  BondPicker2.prototype.getObject = function getObject2(pid) {
    var bp = this.structure.getBondProxy(this.getIndex(pid));
    bp.bondStore = this.bondStore;
    return bp;
  };
  BondPicker2.prototype._getPosition = function _getPosition2(pid) {
    var b = this.getObject(pid);
    return new Vector3().copy(b.atom1).add(b.atom2).multiplyScalar(0.5);
  };
  Object.defineProperties(BondPicker2.prototype, prototypeAccessors$52);
  return BondPicker2;
}(Picker);
var ContactPicker = function(BondPicker2) {
  function ContactPicker2() {
    BondPicker2.apply(this, arguments);
  }
  if (BondPicker2)
    ContactPicker2.__proto__ = BondPicker2;
  ContactPicker2.prototype = Object.create(BondPicker2 && BondPicker2.prototype);
  ContactPicker2.prototype.constructor = ContactPicker2;
  var prototypeAccessors$62 = {type: {}};
  prototypeAccessors$62.type.get = function() {
    return "contact";
  };
  Object.defineProperties(ContactPicker2.prototype, prototypeAccessors$62);
  return ContactPicker2;
}(BondPicker);
var ConePicker = function(ShapePicker2) {
  function ConePicker2() {
    ShapePicker2.apply(this, arguments);
  }
  if (ShapePicker2)
    ConePicker2.__proto__ = ShapePicker2;
  ConePicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  ConePicker2.prototype.constructor = ConePicker2;
  var prototypeAccessors$72 = {type: {}};
  prototypeAccessors$72.type.get = function() {
    return "cone";
  };
  ConePicker2.prototype.getObject = function getObject2(pid) {
    var s = this.shape;
    return {
      shape: s,
      position: this._getPosition(pid),
      position1: new Vector3().fromArray(s.conePosition1, 3 * pid),
      position2: new Vector3().fromArray(s.conePosition2, 3 * pid),
      color: new Color().fromArray(s.coneColor, 3 * pid),
      radius: s.coneRadius[pid],
      name: s.coneName[pid]
    };
  };
  ConePicker2.prototype._getPosition = function _getPosition2(pid) {
    var s = this.shape;
    var p1 = new Vector3().fromArray(s.conePosition1, 3 * pid);
    var p2 = new Vector3().fromArray(s.conePosition2, 3 * pid);
    return p1.add(p2).multiplyScalar(0.5);
  };
  Object.defineProperties(ConePicker2.prototype, prototypeAccessors$72);
  return ConePicker2;
}(ShapePicker);
var ClashPicker = function(Picker3) {
  function ClashPicker2(array, validation, structure) {
    Picker3.call(this, array);
    this.validation = validation;
    this.structure = structure;
  }
  if (Picker3)
    ClashPicker2.__proto__ = Picker3;
  ClashPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  ClashPicker2.prototype.constructor = ClashPicker2;
  var prototypeAccessors$82 = {type: {}, data: {}};
  prototypeAccessors$82.type.get = function() {
    return "clash";
  };
  prototypeAccessors$82.data.get = function() {
    return this.validation;
  };
  ClashPicker2.prototype.getObject = function getObject2(pid) {
    var val = this.validation;
    var idx = this.getIndex(pid);
    return {
      validation: val,
      index: idx,
      clash: val.clashArray[idx]
    };
  };
  ClashPicker2.prototype._getAtomProxyFromSele = function _getAtomProxyFromSele(sele) {
    var selection = new Selection(sele);
    var idx = this.structure.getAtomIndices(selection)[0];
    return this.structure.getAtomProxy(idx);
  };
  ClashPicker2.prototype._getPosition = function _getPosition2(pid) {
    var clash = this.getObject(pid).clash;
    var ap1 = this._getAtomProxyFromSele(clash.sele1);
    var ap2 = this._getAtomProxyFromSele(clash.sele2);
    return new Vector3().copy(ap1).add(ap2).multiplyScalar(0.5);
  };
  Object.defineProperties(ClashPicker2.prototype, prototypeAccessors$82);
  return ClashPicker2;
}(Picker);
var DistancePicker = function(BondPicker2) {
  function DistancePicker2() {
    BondPicker2.apply(this, arguments);
  }
  if (BondPicker2)
    DistancePicker2.__proto__ = BondPicker2;
  DistancePicker2.prototype = Object.create(BondPicker2 && BondPicker2.prototype);
  DistancePicker2.prototype.constructor = DistancePicker2;
  var prototypeAccessors$92 = {type: {}};
  prototypeAccessors$92.type.get = function() {
    return "distance";
  };
  Object.defineProperties(DistancePicker2.prototype, prototypeAccessors$92);
  return DistancePicker2;
}(BondPicker);
var EllipsoidPicker = function(ShapePicker2) {
  function EllipsoidPicker2() {
    ShapePicker2.apply(this, arguments);
  }
  if (ShapePicker2)
    EllipsoidPicker2.__proto__ = ShapePicker2;
  EllipsoidPicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  EllipsoidPicker2.prototype.constructor = EllipsoidPicker2;
  var prototypeAccessors$102 = {type: {}};
  prototypeAccessors$102.type.get = function() {
    return "ellipsoid";
  };
  EllipsoidPicker2.prototype.getObject = function getObject2(pid) {
    var s = this.shape;
    return {
      shape: s,
      position: this._getPosition(pid),
      color: new Color().fromArray(s.ellipsoidColor, 3 * pid),
      radius: s.ellipsoidRadius[pid],
      majorAxis: new Vector3().fromArray(s.ellipsoidMajorAxis, 3 * pid),
      minorAxis: new Vector3().fromArray(s.ellipsoidMinorAxis, 3 * pid),
      name: s.ellipsoidName[pid]
    };
  };
  EllipsoidPicker2.prototype._getPosition = function _getPosition2(pid) {
    return new Vector3().fromArray(this.shape.ellipsoidPosition, 3 * pid);
  };
  Object.defineProperties(EllipsoidPicker2.prototype, prototypeAccessors$102);
  return EllipsoidPicker2;
}(ShapePicker);
var IgnorePicker = function(Picker3) {
  function IgnorePicker2() {
    Picker3.apply(this, arguments);
  }
  if (Picker3)
    IgnorePicker2.__proto__ = Picker3;
  IgnorePicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  IgnorePicker2.prototype.constructor = IgnorePicker2;
  var prototypeAccessors$112 = {type: {}};
  prototypeAccessors$112.type.get = function() {
    return "ignore";
  };
  Object.defineProperties(IgnorePicker2.prototype, prototypeAccessors$112);
  return IgnorePicker2;
}(Picker);
var MeshPicker = function(ShapePicker2) {
  function MeshPicker2(shape, mesh) {
    ShapePicker2.call(this, shape);
    this.mesh = mesh;
  }
  if (ShapePicker2)
    MeshPicker2.__proto__ = ShapePicker2;
  MeshPicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  MeshPicker2.prototype.constructor = MeshPicker2;
  var prototypeAccessors$122 = {type: {}};
  prototypeAccessors$122.type.get = function() {
    return "mesh";
  };
  MeshPicker2.prototype.getObject = function getObject2() {
    var m2 = this.mesh;
    return {
      shape: this.shape,
      name: m2.name,
      serial: m2.serial
    };
  };
  MeshPicker2.prototype._getPosition = function _getPosition2() {
    if (!this.__position) {
      this.__position = calculateMeanVector3(this.mesh.position);
    }
    return this.__position;
  };
  Object.defineProperties(MeshPicker2.prototype, prototypeAccessors$122);
  return MeshPicker2;
}(ShapePicker);
var SpherePicker = function(ShapePicker2) {
  function SpherePicker2() {
    ShapePicker2.apply(this, arguments);
  }
  if (ShapePicker2)
    SpherePicker2.__proto__ = ShapePicker2;
  SpherePicker2.prototype = Object.create(ShapePicker2 && ShapePicker2.prototype);
  SpherePicker2.prototype.constructor = SpherePicker2;
  var prototypeAccessors$132 = {type: {}};
  prototypeAccessors$132.type.get = function() {
    return "sphere";
  };
  SpherePicker2.prototype.getObject = function getObject2(pid) {
    var s = this.shape;
    return {
      shape: s,
      position: this._getPosition(pid),
      color: new Color().fromArray(s.sphereColor, 3 * pid),
      radius: s.sphereRadius[pid],
      name: s.sphereName[pid]
    };
  };
  SpherePicker2.prototype._getPosition = function _getPosition2(pid) {
    return new Vector3().fromArray(this.shape.spherePosition, 3 * pid);
  };
  Object.defineProperties(SpherePicker2.prototype, prototypeAccessors$132);
  return SpherePicker2;
}(ShapePicker);
var SurfacePicker = function(Picker3) {
  function SurfacePicker2(array, surface) {
    Picker3.call(this, array);
    this.surface = surface;
  }
  if (Picker3)
    SurfacePicker2.__proto__ = Picker3;
  SurfacePicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  SurfacePicker2.prototype.constructor = SurfacePicker2;
  var prototypeAccessors$142 = {type: {}, data: {}};
  prototypeAccessors$142.type.get = function() {
    return "surface";
  };
  prototypeAccessors$142.data.get = function() {
    return this.surface;
  };
  SurfacePicker2.prototype.getObject = function getObject2(pid) {
    return {
      surface: this.surface,
      index: this.getIndex(pid)
    };
  };
  SurfacePicker2.prototype._getPosition = function _getPosition2() {
    return this.surface.center.clone();
  };
  Object.defineProperties(SurfacePicker2.prototype, prototypeAccessors$142);
  return SurfacePicker2;
}(Picker);
var UnitcellPicker = function(Picker3) {
  function UnitcellPicker2(unitcell, structure) {
    Picker3.call(this);
    this.unitcell = unitcell;
    this.structure = structure;
  }
  if (Picker3)
    UnitcellPicker2.__proto__ = Picker3;
  UnitcellPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  UnitcellPicker2.prototype.constructor = UnitcellPicker2;
  var prototypeAccessors$152 = {type: {}, data: {}};
  prototypeAccessors$152.type.get = function() {
    return "unitcell";
  };
  prototypeAccessors$152.data.get = function() {
    return this.unitcell;
  };
  UnitcellPicker2.prototype.getObject = function getObject2() {
    return {
      unitcell: this.unitcell,
      structure: this.structure
    };
  };
  UnitcellPicker2.prototype._getPosition = function _getPosition2() {
    return this.unitcell.getCenter(this.structure);
  };
  Object.defineProperties(UnitcellPicker2.prototype, prototypeAccessors$152);
  return UnitcellPicker2;
}(Picker);
var UnknownPicker = function(Picker3) {
  function UnknownPicker2() {
    Picker3.apply(this, arguments);
  }
  if (Picker3)
    UnknownPicker2.__proto__ = Picker3;
  UnknownPicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  UnknownPicker2.prototype.constructor = UnknownPicker2;
  var prototypeAccessors$162 = {type: {}};
  prototypeAccessors$162.type.get = function() {
    return "unknown";
  };
  Object.defineProperties(UnknownPicker2.prototype, prototypeAccessors$162);
  return UnknownPicker2;
}(Picker);
var VolumePicker = function(Picker3) {
  function VolumePicker2(array, volume) {
    Picker3.call(this, array);
    this.volume = volume;
  }
  if (Picker3)
    VolumePicker2.__proto__ = Picker3;
  VolumePicker2.prototype = Object.create(Picker3 && Picker3.prototype);
  VolumePicker2.prototype.constructor = VolumePicker2;
  var prototypeAccessors$172 = {type: {}, data: {}};
  prototypeAccessors$172.type.get = function() {
    return "volume";
  };
  prototypeAccessors$172.data.get = function() {
    return this.volume;
  };
  VolumePicker2.prototype.getObject = function getObject2(pid) {
    var vol = this.volume;
    var idx = this.getIndex(pid);
    return {
      volume: vol,
      index: idx,
      value: vol.data[idx]
    };
  };
  VolumePicker2.prototype._getPosition = function _getPosition2(pid) {
    var dp = this.volume.position;
    var idx = this.getIndex(pid);
    return new Vector3(dp[idx * 3], dp[idx * 3 + 1], dp[idx * 3 + 2]);
  };
  Object.defineProperties(VolumePicker2.prototype, prototypeAccessors$172);
  return VolumePicker2;
}(Picker);
var SlicePicker = function(VolumePicker2) {
  function SlicePicker2() {
    VolumePicker2.apply(this, arguments);
  }
  if (VolumePicker2)
    SlicePicker2.__proto__ = VolumePicker2;
  SlicePicker2.prototype = Object.create(VolumePicker2 && VolumePicker2.prototype);
  SlicePicker2.prototype.constructor = SlicePicker2;
  var prototypeAccessors$182 = {type: {}};
  prototypeAccessors$182.type.get = function() {
    return "slice";
  };
  Object.defineProperties(SlicePicker2.prototype, prototypeAccessors$182);
  return SlicePicker2;
}(VolumePicker);
function hammingWeight(v) {
  v -= v >>> 1 & 1431655765;
  v = (v & 858993459) + (v >>> 2 & 858993459);
  return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
}
var BitArray = function BitArray2(length, setAll2) {
  this.length = length;
  this._words = new Uint32Array(length + 32 >>> 5);
  if (setAll2 === true) {
    this.setAll();
  }
};
BitArray.prototype.get = function get3(index) {
  return (this._words[index >>> 5] & 1 << index) !== 0;
};
BitArray.prototype.set = function set(index) {
  this._words[index >>> 5] |= 1 << index;
};
BitArray.prototype.clear = function clear4(index) {
  this._words[index >>> 5] &= ~(1 << index);
};
BitArray.prototype.flip = function flip(index) {
  this._words[index >>> 5] ^= 1 << index;
};
BitArray.prototype._assignRange = function _assignRange(start, end, value2) {
  var words = this._words;
  var wordValue = value2 === true ? 4294967295 : 0;
  var wordStart = start >>> 5;
  var wordEnd = end >>> 5;
  for (var k = wordStart; k < wordEnd; ++k) {
    words[k] = wordValue;
  }
  var startWord = wordStart << 5;
  var endWord = wordEnd << 5;
  if (value2 === true) {
    if (end - start < 32) {
      for (var i = start, n = end + 1; i < n; ++i) {
        words[i >>> 5] |= 1 << i;
      }
    } else {
      for (var i$1 = start, n$1 = startWord; i$1 < n$1; ++i$1) {
        words[i$1 >>> 5] |= 1 << i$1;
      }
      for (var i$2 = endWord, n$2 = end + 1; i$2 < n$2; ++i$2) {
        words[i$2 >>> 5] |= 1 << i$2;
      }
    }
  } else {
    if (end - start < 32) {
      for (var i$3 = start, n$3 = end + 1; i$3 < n$3; ++i$3) {
        words[i$3 >>> 5] &= ~(1 << i$3);
      }
    } else {
      for (var i$4 = start, n$4 = startWord; i$4 < n$4; ++i$4) {
        words[i$4 >>> 5] &= ~(1 << i$4);
      }
      for (var i$5 = endWord, n$5 = end + 1; i$5 < n$5; ++i$5) {
        words[i$5 >>> 5] &= ~(1 << i$5);
      }
    }
  }
  return this;
};
BitArray.prototype.setRange = function setRange(start, end) {
  return this._assignRange(start, end, true);
};
BitArray.prototype.clearRange = function clearRange(start, end) {
  return this._assignRange(start, end, false);
};
BitArray.prototype.setBits = function setBits() {
  var arguments$1 = arguments;
  var words = this._words;
  var n = arguments.length;
  for (var i = 0; i < n; ++i) {
    var index = arguments$1[i];
    words[index >>> 5] |= 1 << index;
  }
  return this;
};
BitArray.prototype.clearBits = function clearBits() {
  var arguments$1 = arguments;
  var words = this._words;
  var n = arguments.length;
  for (var i = 0; i < n; ++i) {
    var index = arguments$1[i];
    words[index >>> 5] &= ~(1 << index);
  }
  return this;
};
BitArray.prototype.setAll = function setAll() {
  return this._assignRange(0, this.length - 1, true);
};
BitArray.prototype.clearAll = function clearAll() {
  return this._assignRange(0, this.length - 1, false);
};
BitArray.prototype.flipAll = function flipAll() {
  var count2 = this._words.length;
  var words = this._words;
  var bs = 32 - this.length % 32;
  for (var k = 0; k < count2 - 1; ++k) {
    words[k] = ~words[k];
  }
  words[count2 - 1] = ~(words[count2 - 1] << bs) >>> bs;
  return this;
};
BitArray.prototype._isRangeValue = function _isRangeValue(start, end, value2) {
  var words = this._words;
  var wordValue = value2 === true ? 4294967295 : 0;
  var wordStart = start >>> 5;
  var wordEnd = end >>> 5;
  for (var k = wordStart; k < wordEnd; ++k) {
    if (words[k] !== wordValue) {
      return false;
    }
  }
  if (end - start < 32) {
    for (var i = start, n = end + 1; i < n; ++i) {
      if (!!(words[i >>> 5] & 1 << i) !== value2) {
        return false;
      }
    }
  } else {
    var startWord = wordStart << 5;
    var endWord = wordEnd << 5;
    for (var i$1 = start, n$1 = startWord << 5; i$1 < n$1; ++i$1) {
      if (!!(words[i$1 >>> 5] & 1 << i$1) !== value2) {
        return false;
      }
    }
    for (var i$2 = endWord, n$2 = end + 1; i$2 < n$2; ++i$2) {
      if (!!(words[i$2 >>> 5] & 1 << i$2) !== value2) {
        return false;
      }
    }
  }
  return true;
};
BitArray.prototype.isRangeSet = function isRangeSet(start, end) {
  return this._isRangeValue(start, end, true);
};
BitArray.prototype.isRangeClear = function isRangeClear(start, end) {
  return this._isRangeValue(start, end, false);
};
BitArray.prototype.isAllSet = function isAllSet() {
  return this._isRangeValue(0, this.length - 1, true);
};
BitArray.prototype.isAllClear = function isAllClear() {
  return this._isRangeValue(0, this.length - 1, false);
};
BitArray.prototype.isSet = function isSet() {
  var arguments$1 = arguments;
  var words = this._words;
  var n = arguments.length;
  for (var i = 0; i < n; ++i) {
    var index = arguments$1[i];
    if ((words[index >>> 5] & 1 << index) === 0) {
      return false;
    }
  }
  return true;
};
BitArray.prototype.isClear = function isClear() {
  var arguments$1 = arguments;
  var words = this._words;
  var n = arguments.length;
  for (var i = 0; i < n; ++i) {
    var index = arguments$1[i];
    if ((words[index >>> 5] & 1 << index) !== 0) {
      return false;
    }
  }
  return true;
};
BitArray.prototype.isEqualTo = function isEqualTo(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  for (var k = 0; k < count2; ++k) {
    if (words1[k] !== words2[k]) {
      return false;
    }
  }
  return true;
};
BitArray.prototype.getSize = function getSize() {
  var count2 = this._words.length;
  var words = this._words;
  var size = 0;
  for (var i = 0; i < count2; ++i) {
    size += hammingWeight(words[i]);
  }
  return size;
};
BitArray.prototype.difference = function difference(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  for (var k = 0; k < count2; ++k) {
    words1[k] = words1[k] & ~words2[k];
  }
  for (var k$1 = words1.length; k$1 < count2; ++k$1) {
    words1[k$1] = 0;
  }
  return this;
};
BitArray.prototype.union = function union(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  for (var k = 0; k < count2; ++k) {
    words1[k] |= words2[k];
  }
  for (var k$1 = words1.length; k$1 < count2; ++k$1) {
    words1[k$1] = 0;
  }
  return this;
};
BitArray.prototype.intersection = function intersection(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  for (var k = 0; k < count2; ++k) {
    words1[k] &= words2[k];
  }
  for (var k$1 = words1.length; k$1 < count2; ++k$1) {
    words1[k$1] = 0;
  }
  return this;
};
BitArray.prototype.intersects = function intersects(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  for (var k = 0; k < count2; ++k) {
    if ((words1[k] & words2[k]) !== 0) {
      return true;
    }
  }
  return false;
};
BitArray.prototype.getIntersectionSize = function getIntersectionSize(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  var size = 0;
  for (var k = 0; k < count2; ++k) {
    size += hammingWeight(words1[k] & words2[k]);
  }
  return size;
};
BitArray.prototype.makeIntersection = function makeIntersection(otherBitarray) {
  var words1 = this._words;
  var words2 = otherBitarray._words;
  var count2 = Math.min(words1.length, words2.length);
  var wordsA = new Uint32Array(count2);
  var intersection2 = Object.create(BitArray.prototype);
  intersection2._words = wordsA;
  intersection2.length = Math.min(this.length, otherBitarray.length);
  for (var k = 0; k < count2; ++k) {
    wordsA[k] = words1[k] & words2[k];
  }
  return intersection2;
};
BitArray.prototype.forEach = function forEach(callback) {
  var count2 = this._words.length;
  var words = this._words;
  var i = 0;
  for (var k = 0; k < count2; ++k) {
    var w = words[k];
    while (w !== 0) {
      var t = w & -w;
      var index = (k << 5) + hammingWeight(t - 1);
      callback(index, i);
      w ^= t;
      ++i;
    }
  }
};
BitArray.prototype.toArray = function toArray() {
  var words = this._words;
  var answer = new Array(this.getSize());
  var count2 = this._words.length;
  var pos = 0;
  for (var k = 0; k < count2; ++k) {
    var w = words[k];
    while (w !== 0) {
      var t = w & -w;
      answer[pos++] = (k << 5) + hammingWeight(t - 1);
      w ^= t;
    }
  }
  return answer;
};
BitArray.prototype.toString = function toString() {
  return "{" + this.toArray().join(",") + "}";
};
BitArray.prototype.toSeleString = function toSeleString() {
  var sele = this.toArray().join(",");
  return sele ? "@" + sele : "NONE";
};
BitArray.prototype.clone = function clone() {
  var clone8 = Object.create(BitArray.prototype);
  clone8.length = this.length;
  clone8._words = new Uint32Array(this._words);
  return clone8;
};
var UnknownEntity = 0;
var PolymerEntity = 1;
var NonPolymerEntity = 2;
var MacrolideEntity = 3;
var WaterEntity = 4;
var UnknownType = 0;
var WaterType = 1;
var IonType = 2;
var ProteinType = 3;
var RnaType = 4;
var DnaType = 5;
var SaccharideType = 6;
var UnknownBackboneType = 0;
var ProteinBackboneType = 1;
var RnaBackboneType = 2;
var DnaBackboneType = 3;
var CgProteinBackboneType = 4;
var CgRnaBackboneType = 5;
var CgDnaBackboneType = 6;
var ChemCompProtein = [
  "D-BETA-PEPTIDE, C-GAMMA LINKING",
  "D-GAMMA-PEPTIDE, C-DELTA LINKING",
  "D-PEPTIDE COOH CARBOXY TERMINUS",
  "D-PEPTIDE NH3 AMINO TERMINUS",
  "D-PEPTIDE LINKING",
  "L-BETA-PEPTIDE, C-GAMMA LINKING",
  "L-GAMMA-PEPTIDE, C-DELTA LINKING",
  "L-PEPTIDE COOH CARBOXY TERMINUS",
  "L-PEPTIDE NH3 AMINO TERMINUS",
  "L-PEPTIDE LINKING",
  "PEPTIDE LINKING",
  "PEPTIDE-LIKE"
];
var ChemCompRna = [
  "RNA OH 3 PRIME TERMINUS",
  "RNA OH 5 PRIME TERMINUS",
  "RNA LINKING"
];
var ChemCompDna = [
  "DNA OH 3 PRIME TERMINUS",
  "DNA OH 5 PRIME TERMINUS",
  "DNA LINKING",
  "L-DNA LINKING",
  "L-RNA LINKING"
];
var ChemCompSaccharide = [
  "D-SACCHARIDE",
  "D-SACCHARIDE 1,4 AND 1,4 LINKING",
  "D-SACCHARIDE 1,4 AND 1,6 LINKING",
  "L-SACCHARIDE",
  "L-SACCHARIDE 1,4 AND 1,4 LINKING",
  "L-SACCHARIDE 1,4 AND 1,6 LINKING",
  "SACCHARIDE"
];
var ChemCompOther = [
  "OTHER"
];
var ChemCompNonPolymer = [
  "NON-POLYMER"
];
var ChemCompHetero = ChemCompNonPolymer.concat(ChemCompOther, ChemCompSaccharide);
var SecStrucHelix = ["h", "g", "i"];
var SecStrucSheet = ["e", "b"];
var SecStrucTurn = ["s", "t", "l", ""];
var VdwRadii = {
  H: 1.1,
  HE: 1.4,
  LI: 1.81,
  BE: 1.53,
  B: 1.92,
  C: 1.7,
  N: 1.55,
  O: 1.52,
  F: 1.47,
  NE: 1.54,
  NA: 2.27,
  MG: 1.73,
  AL: 1.84,
  SI: 2.1,
  P: 1.8,
  S: 1.8,
  CL: 1.75,
  AR: 1.88,
  K: 2.75,
  CA: 2.31,
  SC: 2.3,
  TI: 2.15,
  V: 2.05,
  CR: 2.05,
  MN: 2.05,
  FE: 2.05,
  CO: 2,
  NI: 2,
  CU: 2,
  ZN: 2.1,
  GA: 1.87,
  GE: 2.11,
  AS: 1.85,
  SE: 1.9,
  BR: 1.83,
  KR: 2.02,
  RB: 3.03,
  SR: 2.49,
  Y: 2.4,
  ZR: 2.3,
  NB: 2.15,
  MO: 2.1,
  TC: 2.05,
  RU: 2.05,
  RH: 2,
  PD: 2.05,
  AG: 2.1,
  CD: 2.2,
  IN: 2.2,
  SN: 1.93,
  SB: 2.17,
  TE: 2.06,
  I: 1.98,
  XE: 2.16,
  CS: 3.43,
  BA: 2.68,
  LA: 2.5,
  CE: 2.48,
  PR: 2.47,
  ND: 2.45,
  PM: 2.43,
  SM: 2.42,
  EU: 2.4,
  GD: 2.38,
  TB: 2.37,
  DY: 2.35,
  HO: 2.33,
  ER: 2.32,
  TM: 2.3,
  YB: 2.28,
  LU: 2.27,
  HF: 2.25,
  TA: 2.2,
  W: 2.1,
  RE: 2.05,
  OS: 2,
  IR: 2,
  PT: 2.05,
  AU: 2.1,
  HG: 2.05,
  TL: 1.96,
  PB: 2.02,
  BI: 2.07,
  PO: 1.97,
  AT: 2.02,
  RN: 2.2,
  FR: 3.48,
  RA: 2.83,
  AC: 2,
  TH: 2.4,
  PA: 2,
  U: 2.3,
  NP: 2,
  PU: 2,
  AM: 2,
  CM: 2,
  BK: 2,
  CF: 2,
  ES: 2,
  FM: 2,
  MD: 2,
  NO: 2,
  LR: 2,
  RF: 2,
  DB: 2,
  SG: 2,
  BH: 2,
  HS: 2,
  MT: 2,
  DS: 2,
  RG: 2,
  CN: 2,
  UUT: 2,
  FL: 2,
  UUP: 2,
  LV: 2,
  UUH: 2
};
var DefaultVdwRadius = 2;
var CovalentRadii = {
  H: 0.31,
  HE: 0.28,
  LI: 1.28,
  BE: 0.96,
  B: 0.84,
  C: 0.76,
  N: 0.71,
  O: 0.66,
  F: 0.57,
  NE: 0.58,
  NA: 1.66,
  MG: 1.41,
  AL: 1.21,
  SI: 1.11,
  P: 1.07,
  S: 1.05,
  CL: 1.02,
  AR: 1.06,
  K: 2.03,
  CA: 1.76,
  SC: 1.7,
  TI: 1.6,
  V: 1.53,
  CR: 1.39,
  MN: 1.39,
  FE: 1.32,
  CO: 1.26,
  NI: 1.24,
  CU: 1.32,
  ZN: 1.22,
  GA: 1.22,
  GE: 1.2,
  AS: 1.19,
  SE: 1.2,
  BR: 1.2,
  KR: 1.16,
  RB: 2.2,
  SR: 1.95,
  Y: 1.9,
  ZR: 1.75,
  NB: 1.64,
  MO: 1.54,
  TC: 1.47,
  RU: 1.46,
  RH: 1.42,
  PD: 1.39,
  AG: 1.45,
  CD: 1.44,
  IN: 1.42,
  SN: 1.39,
  SB: 1.39,
  TE: 1.38,
  I: 1.39,
  XE: 1.4,
  CS: 2.44,
  BA: 2.15,
  LA: 2.07,
  CE: 2.04,
  PR: 2.03,
  ND: 2.01,
  PM: 1.99,
  SM: 1.98,
  EU: 1.98,
  GD: 1.96,
  TB: 1.94,
  DY: 1.92,
  HO: 1.92,
  ER: 1.89,
  TM: 1.9,
  YB: 1.87,
  LU: 1.87,
  HF: 1.75,
  TA: 1.7,
  W: 1.62,
  RE: 1.51,
  OS: 1.44,
  IR: 1.41,
  PT: 1.36,
  AU: 1.36,
  HG: 1.32,
  TL: 1.45,
  PB: 1.46,
  BI: 1.48,
  PO: 1.4,
  AT: 1.5,
  RN: 1.5,
  FR: 2.6,
  RA: 2.21,
  AC: 2.15,
  TH: 2.06,
  PA: 2,
  U: 1.96,
  NP: 1.9,
  PU: 1.87,
  AM: 1.8,
  CM: 1.69,
  BK: 1.6,
  CF: 1.6,
  ES: 1.6,
  FM: 1.6,
  MD: 1.6,
  NO: 1.6,
  LR: 1.6,
  RF: 1.6,
  DB: 1.6,
  SG: 1.6,
  BH: 1.6,
  HS: 1.6,
  MT: 1.6,
  DS: 1.6,
  RG: 1.6,
  CN: 1.6,
  UUT: 1.6,
  FL: 1.6,
  UUP: 1.6,
  LV: 1.6,
  UUH: 1.6
};
var DefaultCovalentRadius = 1.6;
var ResidueHydrophobicity = {
  ALA: [0.17, 0.5, 0.33],
  ARG: [0.81, 1.81, 1],
  ASN: [0.42, 0.85, 0.43],
  ASP: [1.23, 3.64, 2.41],
  ASH: [-0.07, 0.43, 0.5],
  CYS: [-0.24, -0.02, 0.22],
  GLN: [0.58, 0.77, 0.19],
  GLU: [2.02, 3.63, 1.61],
  GLH: [-0.01, 0.11, 0.12],
  GLY: [0.01, 1.15, 1.14],
  HIS: [0.17, 0.11, -0.06],
  ILE: [-0.31, -1.12, -0.81],
  LEU: [-0.56, -1.25, -0.69],
  LYS: [0.99, 2.8, 1.81],
  MET: [-0.23, -0.67, -0.44],
  PHE: [-1.13, -1.71, -0.58],
  PRO: [0.45, 0.14, -0.31],
  SER: [0.13, 0.46, 0.33],
  THR: [0.14, 0.25, 0.11],
  TRP: [-1.85, -2.09, -0.24],
  TYR: [-0.94, -0.71, 0.23],
  VAL: [0.07, -0.46, -0.53]
};
var DefaultResidueHydrophobicity = [0, 0, 0];
var AA1 = {
  HIS: "H",
  ARG: "R",
  LYS: "K",
  ILE: "I",
  PHE: "F",
  LEU: "L",
  TRP: "W",
  ALA: "A",
  MET: "M",
  PRO: "P",
  CYS: "C",
  ASN: "N",
  VAL: "V",
  GLY: "G",
  SER: "S",
  GLN: "Q",
  TYR: "Y",
  ASP: "D",
  GLU: "E",
  THR: "T",
  ASH: "D",
  GLH: "E",
  UNK: ""
};
var AA3 = Object.keys(AA1);
var RnaBases = ["A", "C", "T", "G", "U"];
var DnaBases = ["DA", "DC", "DT", "DG", "DU", "TCY", "MCY", "5CM"];
var PurinBases = ["A", "G", "DA", "DG"];
var WaterNames = [
  "SOL",
  "WAT",
  "HOH",
  "H2O",
  "W",
  "DOD",
  "D3O",
  "TIP3",
  "TIP4"
];
var IonNames = [
  "118",
  "119",
  "1AL",
  "1CU",
  "2FK",
  "2HP",
  "2OF",
  "3CO",
  "3MT",
  "3NI",
  "3OF",
  "3P8",
  "4MO",
  "4PU",
  "543",
  "6MO",
  "ACT",
  "AG",
  "AL",
  "ALF",
  "AM",
  "ATH",
  "AU",
  "AU3",
  "AUC",
  "AZI",
  "BA",
  "BCT",
  "BEF",
  "BF4",
  "BO4",
  "BR",
  "BS3",
  "BSY",
  "CA",
  "CAC",
  "CD",
  "CD1",
  "CD3",
  "CD5",
  "CE",
  "CHT",
  "CL",
  "CO",
  "CO3",
  "CO5",
  "CON",
  "CR",
  "CS",
  "CSB",
  "CU",
  "CU1",
  "CU3",
  "CUA",
  "CUZ",
  "CYN",
  "DME",
  "DMI",
  "DSC",
  "DTI",
  "DY",
  "E4N",
  "EDR",
  "EMC",
  "ER3",
  "EU",
  "EU3",
  "F",
  "FE",
  "FE2",
  "FPO",
  "GA",
  "GD3",
  "GEP",
  "HAI",
  "HG",
  "HGC",
  "IN",
  "IOD",
  "IR",
  "IR3",
  "IRI",
  "IUM",
  "K",
  "KO4",
  "LA",
  "LCO",
  "LCP",
  "LI",
  "LU",
  "MAC",
  "MG",
  "MH2",
  "MH3",
  "MLI",
  "MLT",
  "MMC",
  "MN",
  "MN3",
  "MN5",
  "MN6",
  "MO1",
  "MO2",
  "MO3",
  "MO4",
  "MO5",
  "MO6",
  "MOO",
  "MOS",
  "MOW",
  "MW1",
  "MW2",
  "MW3",
  "NA",
  "NA2",
  "NA5",
  "NA6",
  "NAO",
  "NAW",
  "NCO",
  "NET",
  "NH4",
  "NI",
  "NI1",
  "NI2",
  "NI3",
  "NO2",
  "NO3",
  "NRU",
  "O4M",
  "OAA",
  "OC1",
  "OC2",
  "OC3",
  "OC4",
  "OC5",
  "OC6",
  "OC7",
  "OC8",
  "OCL",
  "OCM",
  "OCN",
  "OCO",
  "OF1",
  "OF2",
  "OF3",
  "OH",
  "OS",
  "OS4",
  "OXL",
  "PB",
  "PBM",
  "PD",
  "PDV",
  "PER",
  "PI",
  "PO3",
  "PO4",
  "PR",
  "PT",
  "PT4",
  "PTN",
  "RB",
  "RH3",
  "RHD",
  "RU",
  "SB",
  "SCN",
  "SE4",
  "SEK",
  "SM",
  "SMO",
  "SO3",
  "SO4",
  "SR",
  "T1A",
  "TB",
  "TBA",
  "TCN",
  "TEA",
  "TH",
  "THE",
  "TL",
  "TMA",
  "TRA",
  "UNX",
  "V",
  "VN3",
  "VO4",
  "W",
  "WO5",
  "Y1",
  "YB",
  "YB2",
  "YH",
  "YT3",
  "ZCM",
  "ZN",
  "ZN2",
  "ZN3",
  "ZNO",
  "ZO3",
  "OHX"
];
var SaccharideNames = [
  "045",
  "0AT",
  "0BD",
  "0MK",
  "0NZ",
  "0TS",
  "0V4",
  "0XY",
  "0YT",
  "10M",
  "147",
  "149",
  "14T",
  "15L",
  "16G",
  "18T",
  "18Y",
  "1AR",
  "1BW",
  "1GL",
  "1GN",
  "1JB",
  "1LL",
  "1NA",
  "1S3",
  "26M",
  "26Q",
  "26R",
  "26V",
  "26W",
  "26Y",
  "27C",
  "289",
  "291",
  "293",
  "2DG",
  "2F8",
  "2FG",
  "2FL",
  "2FP",
  "2GL",
  "2M4",
  "2M5",
  "32O",
  "34V",
  "3CM",
  "3DO",
  "3DY",
  "3FM",
  "3LR",
  "3MF",
  "3MG",
  "3SA",
  "3ZW",
  "46D",
  "46M",
  "46Z",
  "48Z",
  "4CQ",
  "4GC",
  "4NN",
  "50A",
  "5DI",
  "5GF",
  "5MM",
  "5RP",
  "5SA",
  "5SP",
  "64K",
  "6PG",
  "6SA",
  "7JZ",
  "7SA",
  "A1Q",
  "A2G",
  "AAB",
  "AAL",
  "AAO",
  "ABC",
  "ABD",
  "ABE",
  "ABF",
  "ABL",
  "ACG",
  "ACI",
  "ACR",
  "ACX",
  "ADA",
  "ADG",
  "ADR",
  "AF1",
  "AFD",
  "AFL",
  "AFO",
  "AFP",
  "AFR",
  "AGC",
  "AGH",
  "AGL",
  "AHR",
  "AIG",
  "ALL",
  "ALX",
  "AMU",
  "AOG",
  "AOS",
  "ARA",
  "ARB",
  "ARE",
  "ARI",
  "ASG",
  "ASO",
  "AXP",
  "AXR",
  "B0D",
  "B16",
  "B2G",
  "B4G",
  "B6D",
  "B8D",
  "B9D",
  "BBK",
  "BCD",
  "BDG",
  "BDP",
  "BDR",
  "BEM",
  "BFP",
  "BGC",
  "BGL",
  "BGP",
  "BGS",
  "BHG",
  "BMA",
  "BMX",
  "BNG",
  "BNX",
  "BOG",
  "BRI",
  "BXF",
  "BXP",
  "BXX",
  "BXY",
  "C3X",
  "C4X",
  "C5X",
  "CAP",
  "CBI",
  "CBK",
  "CBS",
  "CDR",
  "CEG",
  "CGF",
  "CHO",
  "CR1",
  "CR6",
  "CRA",
  "CT3",
  "CTO",
  "CTR",
  "CTT",
  "D6G",
  "DAF",
  "DAG",
  "DDA",
  "DDB",
  "DDL",
  "DEL",
  "DFR",
  "DFX",
  "DG0",
  "DGC",
  "DGD",
  "DGM",
  "DGS",
  "DIG",
  "DLF",
  "DLG",
  "DMU",
  "DNO",
  "DOM",
  "DP5",
  "DQQ",
  "DQR",
  "DR2",
  "DR3",
  "DR4",
  "DRI",
  "DSR",
  "DT6",
  "DVC",
  "E4P",
  "E5G",
  "EAG",
  "EBG",
  "EBQ",
  "EGA",
  "EJT",
  "EPG",
  "ERE",
  "ERI",
  "F1P",
  "F1X",
  "F6P",
  "FBP",
  "FCA",
  "FCB",
  "FCT",
  "FDP",
  "FDQ",
  "FFC",
  "FIX",
  "FMO",
  "FRU",
  "FSI",
  "FU4",
  "FUB",
  "FUC",
  "FUD",
  "FUL",
  "FXP",
  "G16",
  "G1P",
  "G2F",
  "G3I",
  "G4D",
  "G4S",
  "G6D",
  "G6P",
  "G6S",
  "GAC",
  "GAD",
  "GAL",
  "GC1",
  "GC4",
  "GCD",
  "GCN",
  "GCO",
  "GCS",
  "GCT",
  "GCU",
  "GCV",
  "GCW",
  "GCX",
  "GE1",
  "GFG",
  "GFP",
  "GIV",
  "GL0",
  "GL2",
  "GL5",
  "GL6",
  "GL7",
  "GL9",
  "GLA",
  "GLB",
  "GLC",
  "GLD",
  "GLF",
  "GLG",
  "GLO",
  "GLP",
  "GLS",
  "GLT",
  "GLW",
  "GMH",
  "GN1",
  "GNX",
  "GP1",
  "GP4",
  "GPH",
  "GPM",
  "GQ1",
  "GQ2",
  "GQ4",
  "GS1",
  "GS4",
  "GSA",
  "GSD",
  "GTE",
  "GTH",
  "GTK",
  "GTR",
  "GTZ",
  "GU0",
  "GU1",
  "GU2",
  "GU3",
  "GU4",
  "GU5",
  "GU6",
  "GU8",
  "GU9",
  "GUF",
  "GUP",
  "GUZ",
  "GYP",
  "GYV",
  "H2P",
  "HDL",
  "HMS",
  "HS2",
  "HSD",
  "HSG",
  "HSH",
  "HSJ",
  "HSQ",
  "HSR",
  "HSU",
  "HSX",
  "HSY",
  "HSZ",
  "IAB",
  "IDG",
  "IDR",
  "IDS",
  "IDT",
  "IDU",
  "IDX",
  "IDY",
  "IMK",
  "IN1",
  "IPT",
  "ISL",
  "KBG",
  "KD2",
  "KDA",
  "KDM",
  "KDO",
  "KFN",
  "KO1",
  "KO2",
  "KTU",
  "L6S",
  "LAG",
  "LAI",
  "LAK",
  "LAO",
  "LAT",
  "LB2",
  "LBT",
  "LCN",
  "LDY",
  "LGC",
  "LGU",
  "LM2",
  "LMT",
  "LMU",
  "LOG",
  "LOX",
  "LPK",
  "LSM",
  "LTM",
  "LVZ",
  "LXB",
  "LXZ",
  "M1F",
  "M3M",
  "M6P",
  "M8C",
  "MA1",
  "MA2",
  "MA3",
  "MAB",
  "MAG",
  "MAL",
  "MAN",
  "MAT",
  "MAV",
  "MAW",
  "MBG",
  "MCU",
  "MDA",
  "MDM",
  "MDP",
  "MFA",
  "MFB",
  "MFU",
  "MG5",
  "MGA",
  "MGL",
  "MLB",
  "MMA",
  "MMN",
  "MN0",
  "MRP",
  "MTT",
  "MUG",
  "MVP",
  "MXY",
  "N1L",
  "N9S",
  "NAA",
  "NAG",
  "NBG",
  "NDG",
  "NED",
  "NG1",
  "NG6",
  "NGA",
  "NGB",
  "NGC",
  "NGE",
  "NGF",
  "NGL",
  "NGS",
  "NGY",
  "NHF",
  "NM6",
  "NM9",
  "NTF",
  "NTO",
  "NTP",
  "NXD",
  "NYT",
  "OPG",
  "OPM",
  "ORP",
  "OX2",
  "P3M",
  "P53",
  "P6P",
  "PA5",
  "PNA",
  "PNG",
  "PNW",
  "PRP",
  "PSJ",
  "PSV",
  "PTQ",
  "QDK",
  "QPS",
  "QV4",
  "R1P",
  "R1X",
  "R2B",
  "R5P",
  "RAA",
  "RAE",
  "RAF",
  "RAM",
  "RAO",
  "RAT",
  "RB5",
  "RBL",
  "RCD",
  "RDP",
  "REL",
  "RER",
  "RF5",
  "RG1",
  "RGG",
  "RHA",
  "RIB",
  "RIP",
  "RNS",
  "RNT",
  "ROB",
  "ROR",
  "RPA",
  "RST",
  "RUB",
  "RUU",
  "RZM",
  "S6P",
  "S7P",
  "SA0",
  "SCR",
  "SDD",
  "SF6",
  "SF9",
  "SG4",
  "SG5",
  "SG6",
  "SG7",
  "SGA",
  "SGC",
  "SGD",
  "SGN",
  "SGS",
  "SHB",
  "SHG",
  "SI3",
  "SIO",
  "SOE",
  "SOL",
  "SSG",
  "SUC",
  "SUP",
  "SUS",
  "T6P",
  "T6T",
  "TAG",
  "TCB",
  "TDG",
  "TGK",
  "TGY",
  "TH1",
  "TIA",
  "TM5",
  "TM6",
  "TM9",
  "TMR",
  "TMX",
  "TOA",
  "TOC",
  "TRE",
  "TYV",
  "UCD",
  "UDC",
  "VG1",
  "X0X",
  "X1X",
  "X2F",
  "X4S",
  "X5S",
  "X6X",
  "XBP",
  "XDN",
  "XDP",
  "XIF",
  "XIM",
  "XLF",
  "XLS",
  "XMM",
  "XUL",
  "XXR",
  "XYP",
  "XYS",
  "YO5",
  "Z3Q",
  "Z6J",
  "Z9M",
  "ZDC",
  "ZDM"
];
var ProteinBackboneAtoms = [
  "CA",
  "C",
  "N",
  "O",
  "O1",
  "O2",
  "OC1",
  "OC2",
  "OX1",
  "OXT",
  "H",
  "H1",
  "H2",
  "H3",
  "HA",
  "BB"
];
var NucleicBackboneAtoms = [
  "P",
  "O3'",
  "O5'",
  "C5'",
  "C4'",
  "C3'",
  "OP1",
  "OP2",
  "O3*",
  "O5*",
  "C5*",
  "C4*",
  "C3*"
];
var ResidueTypeAtoms = {};
ResidueTypeAtoms[ProteinBackboneType] = {
  trace: "CA",
  direction1: "C",
  direction2: ["O", "OC1", "O1", "OX1", "OXT"],
  backboneStart: "N",
  backboneEnd: "C"
};
ResidueTypeAtoms[RnaBackboneType] = {
  trace: ["C4'", "C4*"],
  direction1: ["C1'", "C1*"],
  direction2: ["C3'", "C3*"],
  backboneStart: "P",
  backboneEnd: ["O3'", "O3*"]
};
ResidueTypeAtoms[DnaBackboneType] = {
  trace: ["C3'", "C3*"],
  direction1: ["C2'", "C2*"],
  direction2: ["O4'", "O4*"],
  backboneStart: "P",
  backboneEnd: ["O3'", "O3*"]
};
ResidueTypeAtoms[CgProteinBackboneType] = {
  trace: ["CA", "BB"],
  backboneStart: ["CA", "BB"],
  backboneEnd: ["CA", "BB"]
};
ResidueTypeAtoms[CgRnaBackboneType] = {
  trace: ["C4'", "C4*", "P"],
  backboneStart: ["C4'", "C4*", "P"],
  backboneEnd: ["C4'", "C4*", "P"]
};
ResidueTypeAtoms[CgDnaBackboneType] = {
  trace: ["C3'", "C3*", "C2'", "P"],
  backboneStart: ["C3'", "C3*", "C2'", "P"],
  backboneEnd: ["C3'", "C3*", "C2'", "P"]
};
ResidueTypeAtoms[UnknownBackboneType] = {};
function RadiusFactory(type2, scale2) {
  this.type = type2;
  this.scale = scale2 || 1;
  this.max = 10;
}
RadiusFactory.prototype = {
  constructor: RadiusFactory,
  atomRadius: function(a) {
    var type2 = this.type;
    var scale2 = this.scale;
    var r;
    switch (type2) {
      case "vdw":
        r = VdwRadii[a.element] || DefaultVdwRadius;
        break;
      case "covalent":
        r = CovalentRadii[a.element] || DefaultCovalentRadius;
        break;
      case "bfactor":
        r = a.bfactor || 1;
        break;
      case "sstruc":
        var sstruc = a.sstruc;
        if (sstruc === "h") {
          r = 0.25;
        } else if (sstruc === "g") {
          r = 0.25;
        } else if (sstruc === "i") {
          r = 0.25;
        } else if (sstruc === "e") {
          r = 0.25;
        } else if (sstruc === "b") {
          r = 0.25;
        } else if (NucleicBackboneAtoms.includes(a.atomname)) {
          r = 0.4;
        } else {
          r = 0.1;
        }
        break;
      default:
        r = type2 || 1;
        break;
    }
    return Math.min(r * scale2, this.max);
  }
};
RadiusFactory.types = {
  "": "",
  vdw: "by vdW radius",
  covalent: "by covalent radius",
  sstruc: "by secondary structure",
  bfactor: "by bfactor",
  size: "size"
};
function Matrix(columns, rows) {
  this.cols = columns;
  this.rows = rows;
  this.size = this.cols * this.rows;
  this.data = new Float32Array(this.size);
}
Matrix.prototype = {
  copyTo: function(matrix2) {
    matrix2.data.set(this.data);
  }
};
function transpose(At, A) {
  var i = 0;
  var j = 0;
  var nrows = A.rows;
  var ncols = A.cols;
  var Ai = 0;
  var Ati = 0;
  var pAt = 0;
  var ad = A.data;
  var atd = At.data;
  for (; i < nrows; Ati += 1, Ai += ncols, i++) {
    pAt = Ati;
    for (j = 0; j < ncols; pAt += nrows, j++) {
      atd[pAt] = ad[Ai + j];
    }
  }
}
function multiplyABt(C, A, B) {
  var i = 0;
  var j = 0;
  var k = 0;
  var Ap = 0;
  var pA = 0;
  var pB = 0;
  var Cp = 0;
  var ncols = A.cols;
  var nrows = A.rows;
  var mrows = B.rows;
  var ad = A.data;
  var bd = B.data;
  var cd = C.data;
  var sum = 0;
  for (; i < nrows; Ap += ncols, i++) {
    for (pB = 0, j = 0; j < mrows; Cp++, j++) {
      pA = Ap;
      sum = 0;
      for (k = 0; k < ncols; pA++, pB++, k++) {
        sum += ad[pA] * bd[pB];
      }
      cd[Cp] = sum;
    }
  }
}
function invert3x3(from, to) {
  var A = from.data;
  var invA = to.data;
  var t1 = A[4];
  var t2 = A[8];
  var t4 = A[5];
  var t5 = A[7];
  var t8 = A[0];
  var t9 = t8 * t1;
  var t11 = t8 * t4;
  var t13 = A[3];
  var t14 = A[1];
  var t15 = t13 * t14;
  var t17 = A[2];
  var t18 = t13 * t17;
  var t20 = A[6];
  var t21 = t20 * t14;
  var t23 = t20 * t17;
  var t26 = 1 / (t9 * t2 - t11 * t5 - t15 * t2 + t18 * t5 + t21 * t4 - t23 * t1);
  invA[0] = (t1 * t2 - t4 * t5) * t26;
  invA[1] = -(t14 * t2 - t17 * t5) * t26;
  invA[2] = -(-t14 * t4 + t17 * t1) * t26;
  invA[3] = -(t13 * t2 - t4 * t20) * t26;
  invA[4] = (t8 * t2 - t23) * t26;
  invA[5] = -(t11 - t18) * t26;
  invA[6] = -(-t13 * t5 + t1 * t20) * t26;
  invA[7] = -(t8 * t5 - t21) * t26;
  invA[8] = (t9 - t15) * t26;
}
function mat3x3determinant(M) {
  var md = M.data;
  return md[0] * md[4] * md[8] - md[0] * md[5] * md[7] - md[3] * md[1] * md[8] + md[3] * md[2] * md[7] + md[6] * md[1] * md[5] - md[6] * md[2] * md[4];
}
function multiply3x3(C, A, B) {
  var Cd = C.data;
  var Ad = A.data;
  var Bd = B.data;
  var m10 = Ad[0];
  var m11 = Ad[1];
  var m12 = Ad[2];
  var m13 = Ad[3];
  var m14 = Ad[4];
  var m15 = Ad[5];
  var m16 = Ad[6];
  var m17 = Ad[7];
  var m18 = Ad[8];
  var m20 = Bd[0];
  var m21 = Bd[1];
  var m22 = Bd[2];
  var m23 = Bd[3];
  var m24 = Bd[4];
  var m25 = Bd[5];
  var m26 = Bd[6];
  var m27 = Bd[7];
  var m28 = Bd[8];
  Cd[0] = m10 * m20 + m11 * m23 + m12 * m26;
  Cd[1] = m10 * m21 + m11 * m24 + m12 * m27;
  Cd[2] = m10 * m22 + m11 * m25 + m12 * m28;
  Cd[3] = m13 * m20 + m14 * m23 + m15 * m26;
  Cd[4] = m13 * m21 + m14 * m24 + m15 * m27;
  Cd[5] = m13 * m22 + m14 * m25 + m15 * m28;
  Cd[6] = m16 * m20 + m17 * m23 + m18 * m26;
  Cd[7] = m16 * m21 + m17 * m24 + m18 * m27;
  Cd[8] = m16 * m22 + m17 * m25 + m18 * m28;
}
function meanRows(A) {
  var i, j;
  var p = 0;
  var nrows = A.rows;
  var ncols = A.cols;
  var Ad = A.data;
  var mean = new Array(ncols);
  for (j = 0; j < ncols; ++j) {
    mean[j] = 0;
  }
  for (i = 0; i < nrows; ++i) {
    for (j = 0; j < ncols; ++j, ++p) {
      mean[j] += Ad[p];
    }
  }
  for (j = 0; j < ncols; ++j) {
    mean[j] /= nrows;
  }
  return mean;
}
function subRows(A, row) {
  var i, j;
  var p = 0;
  var nrows = A.rows;
  var ncols = A.cols;
  var Ad = A.data;
  for (i = 0; i < nrows; ++i) {
    for (j = 0; j < ncols; ++j, ++p) {
      Ad[p] -= row[j];
    }
  }
}
function addRows(A, row) {
  var i, j;
  var p = 0;
  var nrows = A.rows;
  var ncols = A.cols;
  var Ad = A.data;
  for (i = 0; i < nrows; ++i) {
    for (j = 0; j < ncols; ++j, ++p) {
      Ad[p] += row[j];
    }
  }
}
function swap$1(A, i0, i1, t) {
  t = A[i0];
  A[i0] = A[i1];
  A[i1] = t;
}
function hypot(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  if (a > b) {
    b /= a;
    return a * Math.sqrt(1 + b * b);
  }
  if (b > 0) {
    a /= b;
    return b * Math.sqrt(1 + a * a);
  }
  return 0;
}
var EPSILON = 1192092896e-16;
var FLT_MIN = 1e-37;
function JacobiSVDImpl(At, astep, _W, Vt, vstep, m2, n, n1) {
  var eps = EPSILON * 2;
  var minval = FLT_MIN;
  var i = 0;
  var j = 0;
  var k = 0;
  var iter = 0;
  var maxIter = Math.max(m2, 30);
  var Ai = 0;
  var Aj = 0;
  var Vi = 0;
  var Vj = 0;
  var changed3 = 0;
  var c = 0;
  var s = 0;
  var t = 0;
  var t0 = 0;
  var t1 = 0;
  var sd = 0;
  var beta = 0;
  var gamma = 0;
  var delta = 0;
  var a = 0;
  var p = 0;
  var b = 0;
  var seed = 4660;
  var val = 0;
  var val0 = 0;
  var asum = 0;
  var W = new Float64Array(n << 3);
  for (; i < n; i++) {
    for (k = 0, sd = 0; k < m2; k++) {
      t = At[i * astep + k];
      sd += t * t;
    }
    W[i] = sd;
    if (Vt) {
      for (k = 0; k < n; k++) {
        Vt[i * vstep + k] = 0;
      }
      Vt[i * vstep + i] = 1;
    }
  }
  for (; iter < maxIter; iter++) {
    changed3 = 0;
    for (i = 0; i < n - 1; i++) {
      for (j = i + 1; j < n; j++) {
        Ai = i * astep | 0;
        Aj = j * astep | 0;
        a = W[i];
        p = 0;
        b = W[j];
        k = 2;
        p += At[Ai] * At[Aj];
        p += At[Ai + 1] * At[Aj + 1];
        for (; k < m2; k++) {
          p += At[Ai + k] * At[Aj + k];
        }
        if (Math.abs(p) <= eps * Math.sqrt(a * b)) {
          continue;
        }
        p *= 2;
        beta = a - b;
        gamma = hypot(p, beta);
        if (beta < 0) {
          delta = (gamma - beta) * 0.5;
          s = Math.sqrt(delta / gamma);
          c = p / (gamma * s * 2);
        } else {
          c = Math.sqrt((gamma + beta) / (gamma * 2));
          s = p / (gamma * c * 2);
        }
        a = 0;
        b = 0;
        k = 2;
        t0 = c * At[Ai] + s * At[Aj];
        t1 = -s * At[Ai] + c * At[Aj];
        At[Ai] = t0;
        At[Aj] = t1;
        a += t0 * t0;
        b += t1 * t1;
        t0 = c * At[Ai + 1] + s * At[Aj + 1];
        t1 = -s * At[Ai + 1] + c * At[Aj + 1];
        At[Ai + 1] = t0;
        At[Aj + 1] = t1;
        a += t0 * t0;
        b += t1 * t1;
        for (; k < m2; k++) {
          t0 = c * At[Ai + k] + s * At[Aj + k];
          t1 = -s * At[Ai + k] + c * At[Aj + k];
          At[Ai + k] = t0;
          At[Aj + k] = t1;
          a += t0 * t0;
          b += t1 * t1;
        }
        W[i] = a;
        W[j] = b;
        changed3 = 1;
        if (Vt) {
          Vi = i * vstep | 0;
          Vj = j * vstep | 0;
          k = 2;
          t0 = c * Vt[Vi] + s * Vt[Vj];
          t1 = -s * Vt[Vi] + c * Vt[Vj];
          Vt[Vi] = t0;
          Vt[Vj] = t1;
          t0 = c * Vt[Vi + 1] + s * Vt[Vj + 1];
          t1 = -s * Vt[Vi + 1] + c * Vt[Vj + 1];
          Vt[Vi + 1] = t0;
          Vt[Vj + 1] = t1;
          for (; k < n; k++) {
            t0 = c * Vt[Vi + k] + s * Vt[Vj + k];
            t1 = -s * Vt[Vi + k] + c * Vt[Vj + k];
            Vt[Vi + k] = t0;
            Vt[Vj + k] = t1;
          }
        }
      }
    }
    if (changed3 === 0) {
      break;
    }
  }
  for (i = 0; i < n; i++) {
    for (k = 0, sd = 0; k < m2; k++) {
      t = At[i * astep + k];
      sd += t * t;
    }
    W[i] = Math.sqrt(sd);
  }
  for (i = 0; i < n - 1; i++) {
    j = i;
    for (k = i + 1; k < n; k++) {
      if (W[j] < W[k]) {
        j = k;
      }
    }
    if (i !== j) {
      swap$1(W, i, j, sd);
      if (Vt) {
        for (k = 0; k < m2; k++) {
          swap$1(At, i * astep + k, j * astep + k, t);
        }
        for (k = 0; k < n; k++) {
          swap$1(Vt, i * vstep + k, j * vstep + k, t);
        }
      }
    }
  }
  for (i = 0; i < n; i++) {
    _W[i] = W[i];
  }
  if (!Vt) {
    return;
  }
  for (i = 0; i < n1; i++) {
    sd = i < n ? W[i] : 0;
    while (sd <= minval) {
      val0 = 1 / m2;
      for (k = 0; k < m2; k++) {
        seed = seed * 214013 + 2531011;
        val = (seed >> 16 & 32767 & 256) !== 0 ? val0 : -val0;
        At[i * astep + k] = val;
      }
      for (iter = 0; iter < 2; iter++) {
        for (j = 0; j < i; j++) {
          sd = 0;
          for (k = 0; k < m2; k++) {
            sd += At[i * astep + k] * At[j * astep + k];
          }
          asum = 0;
          for (k = 0; k < m2; k++) {
            t = At[i * astep + k] - sd * At[j * astep + k];
            At[i * astep + k] = t;
            asum += Math.abs(t);
          }
          asum = asum ? 1 / asum : 0;
          for (k = 0; k < m2; k++) {
            At[i * astep + k] *= asum;
          }
        }
      }
      sd = 0;
      for (k = 0; k < m2; k++) {
        t = At[i * astep + k];
        sd += t * t;
      }
      sd = Math.sqrt(sd);
    }
    s = 1 / sd;
    for (k = 0; k < m2; k++) {
      At[i * astep + k] *= s;
    }
  }
}
function svd(A, W, U, V) {
  var at = 0;
  var i = 0;
  var _m2 = A.rows;
  var _n = A.cols;
  var m2 = _m2;
  var n = _n;
  if (m2 < n) {
    at = 1;
    i = m2;
    m2 = n;
    n = i;
  }
  var amt = new Matrix(m2, m2);
  var wmt = new Matrix(1, n);
  var vmt = new Matrix(n, n);
  if (at === 0) {
    transpose(amt, A);
  } else {
    for (i = 0; i < _n * _m2; i++) {
      amt.data[i] = A.data[i];
    }
    for (; i < n * m2; i++) {
      amt.data[i] = 0;
    }
  }
  JacobiSVDImpl(amt.data, m2, wmt.data, vmt.data, n, m2, n, m2);
  if (W) {
    for (i = 0; i < n; i++) {
      W.data[i] = wmt.data[i];
    }
    for (; i < _n; i++) {
      W.data[i] = 0;
    }
  }
  if (at === 0) {
    if (U) {
      transpose(U, amt);
    }
    if (V) {
      transpose(V, vmt);
    }
  } else {
    if (U) {
      transpose(U, vmt);
    }
    if (V) {
      transpose(V, amt);
    }
  }
}
function m4new() {
  return new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ]);
}
function m4set(out, n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
  out[0] = n11;
  out[4] = n12;
  out[8] = n13;
  out[12] = n14;
  out[1] = n21;
  out[5] = n22;
  out[9] = n23;
  out[13] = n24;
  out[2] = n31;
  out[6] = n32;
  out[10] = n33;
  out[14] = n34;
  out[3] = n41;
  out[7] = n42;
  out[11] = n43;
  out[15] = n44;
}
function m4multiply(out, a, b) {
  var a11 = a[0];
  var a12 = a[4];
  var a13 = a[8];
  var a14 = a[12];
  var a21 = a[1];
  var a22 = a[5];
  var a23 = a[9];
  var a24 = a[13];
  var a31 = a[2];
  var a32 = a[6];
  var a33 = a[10];
  var a34 = a[14];
  var a41 = a[3];
  var a42 = a[7];
  var a43 = a[11];
  var a44 = a[15];
  var b11 = b[0];
  var b12 = b[4];
  var b13 = b[8];
  var b14 = b[12];
  var b21 = b[1];
  var b22 = b[5];
  var b23 = b[9];
  var b24 = b[13];
  var b31 = b[2];
  var b32 = b[6];
  var b33 = b[10];
  var b34 = b[14];
  var b41 = b[3];
  var b42 = b[7];
  var b43 = b[11];
  var b44 = b[15];
  out[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  out[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  out[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  out[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
  out[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  out[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  out[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  out[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
  out[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  out[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  out[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  out[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
  out[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  out[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  out[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  out[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
}
function m4makeScale(out, x, y, z) {
  m4set(out, x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
}
m4makeScale.__deps = [m4set];
function m4makeTranslation(out, x, y, z) {
  m4set(out, 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
}
m4makeTranslation.__deps = [m4set];
function m4makeRotationY(out, theta) {
  var c = Math.cos(theta);
  var s = Math.sin(theta);
  m4set(out, c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
}
m4makeRotationY.__deps = [m4set];
function m3new() {
  return new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ]);
}
function m3makeNormal(out, m4) {
  var r0 = v3new([m4[0], m4[1], m4[2]]);
  var r1 = v3new([m4[4], m4[5], m4[6]]);
  var r2 = v3new([m4[8], m4[9], m4[10]]);
  var cp = v3new();
  v3cross(cp, r1, r2);
  out[0] = cp[0];
  out[1] = cp[1];
  out[2] = cp[2];
  v3cross(cp, r2, r0);
  out[3] = cp[0];
  out[4] = cp[1];
  out[5] = cp[2];
  v3cross(cp, r0, r1);
  out[6] = cp[0];
  out[7] = cp[1];
  out[8] = cp[2];
}
m3makeNormal.__deps = [v3new, v3cross];
var negateVector = new Vector3(-1, -1, -1);
var tmpMatrix$1 = new Matrix4();
var PrincipalAxes = function PrincipalAxes2(points) {
  var n = points.rows;
  var n3 = n / 3;
  var pointsT = new Matrix(n, 3);
  var A = new Matrix(3, 3);
  var W = new Matrix(1, 3);
  var U = new Matrix(3, 3);
  var V = new Matrix(3, 3);
  var mean = meanRows(points);
  subRows(points, mean);
  transpose(pointsT, points);
  multiplyABt(A, pointsT, pointsT);
  svd(A, W, U, V);
  var vm = new Vector3(mean[0], mean[1], mean[2]);
  var van = new Vector3(U.data[0], U.data[3], U.data[6]);
  var vbn = new Vector3(U.data[1], U.data[4], U.data[7]);
  var vcn = new Vector3(U.data[2], U.data[5], U.data[8]);
  var va = van.clone().multiplyScalar(Math.sqrt(W.data[0] / n3));
  var vb = vbn.clone().multiplyScalar(Math.sqrt(W.data[1] / n3));
  var vc = vcn.clone().multiplyScalar(Math.sqrt(W.data[2] / n3));
  this.begA = vm.clone().sub(va);
  this.endA = vm.clone().add(va);
  this.begB = vm.clone().sub(vb);
  this.endB = vm.clone().add(vb);
  this.begC = vm.clone().sub(vc);
  this.endC = vm.clone().add(vc);
  this.center = vm;
  this.vecA = va;
  this.vecB = vb;
  this.vecC = vc;
  this.normVecA = van;
  this.normVecB = vbn;
  this.normVecC = vcn;
};
PrincipalAxes.prototype.getBasisMatrix = function getBasisMatrix(optionalTarget) {
  var basis = optionalTarget || new Matrix4();
  basis.makeBasis(this.normVecB, this.normVecA, this.normVecC);
  if (basis.determinant() < 0) {
    basis.scale(negateVector);
  }
  return basis;
};
PrincipalAxes.prototype.getRotationQuaternion = function getRotationQuaternion(optionalTarget) {
  var q = optionalTarget || new Quaternion();
  q.setFromRotationMatrix(this.getBasisMatrix(tmpMatrix$1));
  return q.inverse();
};
PrincipalAxes.prototype.getProjectedScaleForAtoms = function getProjectedScaleForAtoms(structure) {
  var d1a = -Infinity;
  var d1b = -Infinity;
  var d2a = -Infinity;
  var d2b = -Infinity;
  var d3a = -Infinity;
  var d3b = -Infinity;
  var p = new Vector3();
  var t = new Vector3();
  var center2 = this.center;
  var ax1 = this.normVecA;
  var ax2 = this.normVecB;
  var ax3 = this.normVecC;
  structure.eachAtom(function(ap) {
    projectPointOnVector(p.copy(ap), ax1, center2);
    var dp1 = t.subVectors(p, center2).normalize().dot(ax1);
    var dt1 = p.distanceTo(center2);
    if (dp1 > 0) {
      if (dt1 > d1a) {
        d1a = dt1;
      }
    } else {
      if (dt1 > d1b) {
        d1b = dt1;
      }
    }
    projectPointOnVector(p.copy(ap), ax2, center2);
    var dp2 = t.subVectors(p, center2).normalize().dot(ax2);
    var dt2 = p.distanceTo(center2);
    if (dp2 > 0) {
      if (dt2 > d2a) {
        d2a = dt2;
      }
    } else {
      if (dt2 > d2b) {
        d2b = dt2;
      }
    }
    projectPointOnVector(p.copy(ap), ax3, center2);
    var dp3 = t.subVectors(p, center2).normalize().dot(ax3);
    var dt3 = p.distanceTo(center2);
    if (dp3 > 0) {
      if (dt3 > d3a) {
        d3a = dt3;
      }
    } else {
      if (dt3 > d3b) {
        d3b = dt3;
      }
    }
  });
  return {
    d1a,
    d2a,
    d3a,
    d1b: -d1b,
    d2b: -d2b,
    d3b: -d3b
  };
};
function SpatialHash(atomStore, boundingBox) {
  var exp = 3;
  var bb = boundingBox;
  var minX = bb.min.x;
  var minY = bb.min.y;
  var minZ = bb.min.z;
  var boundX = (bb.max.x - minX >> exp) + 1;
  var boundY = (bb.max.y - minY >> exp) + 1;
  var boundZ = (bb.max.z - minZ >> exp) + 1;
  var n = boundX * boundY * boundZ;
  var an = atomStore.count;
  var xArray = atomStore.x;
  var yArray = atomStore.y;
  var zArray = atomStore.z;
  var i, j;
  var count2 = 0;
  var grid = new Uint32Array(n);
  var bucketIndex = new Int32Array(an);
  for (i = 0; i < an; ++i) {
    var x = xArray[i] - minX >> exp;
    var y = yArray[i] - minY >> exp;
    var z = zArray[i] - minZ >> exp;
    var idx = (x * boundY + y) * boundZ + z;
    if ((grid[idx] += 1) === 1) {
      count2 += 1;
    }
    bucketIndex[i] = idx;
  }
  var bucketCount = new Uint16Array(count2);
  for (i = 0, j = 0; i < n; ++i) {
    var c = grid[i];
    if (c > 0) {
      grid[i] = j + 1;
      bucketCount[j] = c;
      j += 1;
    }
  }
  var bucketOffset = new Uint32Array(count2);
  for (i = 1; i < count2; ++i) {
    bucketOffset[i] += bucketOffset[i - 1] + bucketCount[i - 1];
  }
  var bucketFill = new Uint16Array(count2);
  var bucketArray = new Int32Array(an);
  for (i = 0; i < an; ++i) {
    var bucketIdx = grid[bucketIndex[i]];
    if (bucketIdx > 0) {
      var k = bucketIdx - 1;
      bucketArray[bucketOffset[k] + bucketFill[k]] = i;
      bucketFill[k] += 1;
    }
  }
  function within2(x2, y2, z2, r) {
    var rSq = r * r;
    var loX = Math.max(0, x2 - r - minX >> exp);
    var loY = Math.max(0, y2 - r - minY >> exp);
    var loZ = Math.max(0, z2 - r - minZ >> exp);
    var hiX = Math.min(boundX, x2 + r - minX >> exp);
    var hiY = Math.min(boundY, y2 + r - minY >> exp);
    var hiZ = Math.min(boundZ, z2 + r - minZ >> exp);
    var result = [];
    for (var ix = loX; ix <= hiX; ++ix) {
      for (var iy = loY; iy <= hiY; ++iy) {
        for (var iz = loZ; iz <= hiZ; ++iz) {
          var idx2 = (ix * boundY + iy) * boundZ + iz;
          var bucketIdx2 = grid[idx2];
          if (bucketIdx2 > 0) {
            var k2 = bucketIdx2 - 1;
            var offset = bucketOffset[k2];
            var count3 = bucketCount[k2];
            var end = offset + count3;
            for (var i2 = offset; i2 < end; ++i2) {
              var atomIndex = bucketArray[i2];
              var dx = xArray[atomIndex] - x2;
              var dy = yArray[atomIndex] - y2;
              var dz = zArray[atomIndex] - z2;
              if (dx * dx + dy * dy + dz * dz <= rSq) {
                result.push(atomIndex);
              }
            }
          }
        }
      }
    }
    return result;
  }
  this.within = within2;
}
function Worker(name) {
  var pending = 0;
  var postCount = 0;
  var onmessageDict = {};
  var onerrorDict = {};
  var blobUrl = window.URL.createObjectURL(WorkerRegistry2.get(name));
  var worker = new window.Worker(blobUrl);
  WorkerRegistry2.activeWorkerCount += 1;
  worker.onmessage = function(event) {
    pending -= 1;
    var postId = event.data.__postId;
    if (Debug) {
      Log.timeEnd("Worker.postMessage " + name + " #" + postId);
    }
    if (onmessageDict[postId]) {
      onmessageDict[postId].call(worker, event);
    }
    delete onmessageDict[postId];
    delete onerrorDict[postId];
  };
  worker.onerror = function(event) {
    pending -= 1;
    if (event.data) {
      var postId = event.data.__postId;
      if (onerrorDict[postId]) {
        onerrorDict[postId].call(worker, event);
      } else {
        Log.error("Worker.onerror", postId, name, event);
      }
      delete onmessageDict[postId];
      delete onerrorDict[postId];
    } else {
      Log.error("Worker.onerror", name, event);
    }
  };
  this.name = name;
  this.post = function(aMessage, transferList, onmessage2, onerror2) {
    onmessageDict[postCount] = onmessage2;
    onerrorDict[postCount] = onerror2;
    aMessage = aMessage || {};
    aMessage.__name = name;
    aMessage.__postId = postCount;
    aMessage.__debug = Debug;
    if (Debug) {
      Log.time("Worker.postMessage " + name + " #" + postCount);
    }
    try {
      worker.postMessage(aMessage, transferList);
    } catch (error) {
      Log.error("worker.post:", error);
      worker.postMessage(aMessage);
    }
    pending += 1;
    postCount += 1;
    return this;
  };
  this.terminate = function() {
    if (worker) {
      worker.terminate();
      window.URL.revokeObjectURL(blobUrl);
      WorkerRegistry2.activeWorkerCount -= 1;
    } else {
      Log.log("no worker to terminate");
    }
  };
  Object.defineProperties(this, {
    postCount: {
      get: function() {
        return postCount;
      }
    },
    pending: {
      get: function() {
        return pending;
      }
    }
  });
}
Worker.prototype.constructor = Worker;
function WorkerPool(name, maxCount) {
  maxCount = Math.min(8, maxCount || 2);
  var pool = [];
  var count2 = 0;
  this.name = name;
  this.maxCount = maxCount;
  this.post = function(aMessage, transferList, onmessage2, onerror2) {
    var worker = this.getNextWorker();
    worker.post(aMessage, transferList, onmessage2, onerror2);
    return this;
  };
  this.terminate = function() {
    pool.forEach(function(worker) {
      worker.terminate();
    });
  };
  this.getNextWorker = function() {
    var nextWorker;
    var minPending = Infinity;
    for (var i = 0; i < maxCount; ++i) {
      if (i >= count2) {
        nextWorker = new Worker(name);
        pool.push(nextWorker);
        count2 += 1;
        break;
      }
      var worker = pool[i];
      if (worker.pending === 0) {
        nextWorker = worker;
        break;
      } else if (worker.pending < minPending) {
        minPending = worker.pending;
        nextWorker = worker;
      }
    }
    return nextWorker;
  };
  Object.defineProperties(this, {
    count: {
      get: function() {
        return count2;
      }
    }
  });
}
WorkerPool.prototype.constructor = WorkerPool;
function getEdgeTable() {
  return new Uint32Array([
    0,
    265,
    515,
    778,
    1030,
    1295,
    1541,
    1804,
    2060,
    2309,
    2575,
    2822,
    3082,
    3331,
    3593,
    3840,
    400,
    153,
    915,
    666,
    1430,
    1183,
    1941,
    1692,
    2460,
    2197,
    2975,
    2710,
    3482,
    3219,
    3993,
    3728,
    560,
    825,
    51,
    314,
    1590,
    1855,
    1077,
    1340,
    2620,
    2869,
    2111,
    2358,
    3642,
    3891,
    3129,
    3376,
    928,
    681,
    419,
    170,
    1958,
    1711,
    1445,
    1196,
    2988,
    2725,
    2479,
    2214,
    4010,
    3747,
    3497,
    3232,
    1120,
    1385,
    1635,
    1898,
    102,
    367,
    613,
    876,
    3180,
    3429,
    3695,
    3942,
    2154,
    2403,
    2665,
    2912,
    1520,
    1273,
    2035,
    1786,
    502,
    255,
    1013,
    764,
    3580,
    3317,
    4095,
    3830,
    2554,
    2291,
    3065,
    2800,
    1616,
    1881,
    1107,
    1370,
    598,
    863,
    85,
    348,
    3676,
    3925,
    3167,
    3414,
    2650,
    2899,
    2137,
    2384,
    1984,
    1737,
    1475,
    1226,
    966,
    719,
    453,
    204,
    4044,
    3781,
    3535,
    3270,
    3018,
    2755,
    2505,
    2240,
    2240,
    2505,
    2755,
    3018,
    3270,
    3535,
    3781,
    4044,
    204,
    453,
    719,
    966,
    1226,
    1475,
    1737,
    1984,
    2384,
    2137,
    2899,
    2650,
    3414,
    3167,
    3925,
    3676,
    348,
    85,
    863,
    598,
    1370,
    1107,
    1881,
    1616,
    2800,
    3065,
    2291,
    2554,
    3830,
    4095,
    3317,
    3580,
    764,
    1013,
    255,
    502,
    1786,
    2035,
    1273,
    1520,
    2912,
    2665,
    2403,
    2154,
    3942,
    3695,
    3429,
    3180,
    876,
    613,
    367,
    102,
    1898,
    1635,
    1385,
    1120,
    3232,
    3497,
    3747,
    4010,
    2214,
    2479,
    2725,
    2988,
    1196,
    1445,
    1711,
    1958,
    170,
    419,
    681,
    928,
    3376,
    3129,
    3891,
    3642,
    2358,
    2111,
    2869,
    2620,
    1340,
    1077,
    1855,
    1590,
    314,
    51,
    825,
    560,
    3728,
    3993,
    3219,
    3482,
    2710,
    2975,
    2197,
    2460,
    1692,
    1941,
    1183,
    1430,
    666,
    915,
    153,
    400,
    3840,
    3593,
    3331,
    3082,
    2822,
    2575,
    2309,
    2060,
    1804,
    1541,
    1295,
    1030,
    778,
    515,
    265,
    0
  ]);
}
function getTriTable() {
  return new Int32Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    9,
    8,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    0,
    2,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    8,
    3,
    2,
    10,
    8,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    8,
    11,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    2,
    1,
    9,
    11,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    11,
    10,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    10,
    1,
    0,
    8,
    10,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    9,
    0,
    3,
    11,
    9,
    11,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    7,
    3,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    1,
    9,
    4,
    7,
    1,
    7,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    7,
    3,
    0,
    4,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    9,
    0,
    2,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    9,
    2,
    9,
    7,
    2,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    4,
    7,
    11,
    2,
    4,
    2,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    8,
    4,
    7,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    9,
    4,
    11,
    9,
    11,
    2,
    9,
    2,
    1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    3,
    11,
    10,
    7,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    10,
    1,
    4,
    11,
    1,
    0,
    4,
    7,
    11,
    4,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    9,
    0,
    11,
    9,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    4,
    11,
    9,
    9,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    1,
    5,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    5,
    4,
    8,
    3,
    5,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    10,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    2,
    10,
    5,
    4,
    2,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    3,
    2,
    5,
    3,
    5,
    4,
    3,
    4,
    8,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    0,
    8,
    11,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    0,
    1,
    5,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    1,
    5,
    2,
    5,
    8,
    2,
    8,
    11,
    4,
    8,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    3,
    11,
    10,
    1,
    3,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    0,
    8,
    1,
    8,
    10,
    1,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    0,
    5,
    0,
    11,
    5,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    8,
    5,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    5,
    7,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    3,
    0,
    9,
    5,
    3,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    8,
    0,
    1,
    7,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    9,
    5,
    7,
    10,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    9,
    5,
    0,
    5,
    3,
    0,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    0,
    2,
    8,
    2,
    5,
    8,
    5,
    7,
    10,
    5,
    2,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    2,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    9,
    5,
    7,
    8,
    9,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    7,
    9,
    7,
    2,
    9,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    0,
    1,
    8,
    1,
    7,
    8,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    7,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    8,
    8,
    5,
    7,
    10,
    1,
    3,
    10,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    5,
    7,
    0,
    5,
    0,
    9,
    7,
    11,
    0,
    1,
    0,
    10,
    11,
    10,
    0,
    -1,
    11,
    10,
    0,
    11,
    0,
    3,
    10,
    5,
    0,
    8,
    0,
    7,
    5,
    7,
    0,
    -1,
    11,
    10,
    5,
    7,
    11,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    1,
    9,
    8,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    2,
    6,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    1,
    2,
    6,
    3,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    6,
    5,
    9,
    0,
    6,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    9,
    8,
    5,
    8,
    2,
    5,
    2,
    6,
    3,
    2,
    8,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    0,
    8,
    11,
    2,
    0,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    1,
    9,
    2,
    9,
    11,
    2,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    3,
    11,
    6,
    5,
    3,
    5,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    11,
    0,
    11,
    5,
    0,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    6,
    0,
    3,
    6,
    0,
    6,
    5,
    0,
    5,
    9,
    -1,
    -1,
    -1,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    11,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    4,
    7,
    3,
    6,
    5,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    5,
    10,
    6,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    1,
    9,
    7,
    1,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    6,
    1,
    2,
    6,
    5,
    1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    5,
    5,
    2,
    6,
    3,
    0,
    4,
    3,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    9,
    0,
    5,
    0,
    6,
    5,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    9,
    7,
    9,
    4,
    3,
    2,
    9,
    5,
    9,
    6,
    2,
    6,
    9,
    -1,
    3,
    11,
    2,
    7,
    8,
    4,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    2,
    4,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    4,
    7,
    8,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    1,
    9,
    11,
    2,
    9,
    4,
    11,
    7,
    11,
    4,
    5,
    10,
    6,
    -1,
    8,
    4,
    7,
    3,
    11,
    5,
    3,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    5,
    1,
    11,
    5,
    11,
    6,
    1,
    0,
    11,
    7,
    11,
    4,
    0,
    4,
    11,
    -1,
    0,
    5,
    9,
    0,
    6,
    5,
    0,
    3,
    6,
    11,
    6,
    3,
    8,
    4,
    7,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    4,
    7,
    9,
    7,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    6,
    4,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    10,
    6,
    4,
    9,
    10,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    0,
    1,
    10,
    6,
    0,
    6,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    1,
    8,
    1,
    6,
    8,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    1,
    4,
    9,
    1,
    2,
    4,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    9,
    2,
    4,
    9,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    2,
    8,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    10,
    6,
    4,
    11,
    2,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    2,
    2,
    8,
    11,
    4,
    9,
    10,
    4,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    0,
    1,
    6,
    0,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    1,
    6,
    1,
    10,
    4,
    8,
    1,
    2,
    1,
    11,
    8,
    11,
    1,
    -1,
    9,
    6,
    4,
    9,
    3,
    6,
    9,
    1,
    3,
    11,
    6,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    11,
    1,
    8,
    1,
    0,
    11,
    6,
    1,
    9,
    1,
    4,
    6,
    4,
    1,
    -1,
    3,
    11,
    6,
    3,
    6,
    0,
    0,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    8,
    11,
    6,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    10,
    6,
    7,
    8,
    10,
    8,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    3,
    0,
    10,
    7,
    0,
    9,
    10,
    6,
    7,
    10,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    1,
    10,
    7,
    1,
    7,
    8,
    1,
    8,
    0,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    10,
    7,
    1,
    1,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    6,
    1,
    6,
    8,
    1,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    6,
    9,
    2,
    9,
    1,
    6,
    7,
    9,
    0,
    9,
    3,
    7,
    3,
    9,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    6,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    2,
    6,
    7,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    8,
    10,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    0,
    7,
    2,
    7,
    11,
    0,
    9,
    7,
    6,
    7,
    10,
    9,
    10,
    7,
    -1,
    1,
    8,
    0,
    1,
    7,
    8,
    1,
    10,
    7,
    6,
    7,
    10,
    2,
    3,
    11,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    10,
    6,
    1,
    6,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    8,
    9,
    6,
    8,
    6,
    7,
    9,
    1,
    6,
    11,
    6,
    3,
    1,
    3,
    6,
    -1,
    0,
    9,
    1,
    11,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    3,
    11,
    0,
    11,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    7,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    9,
    8,
    3,
    1,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    8,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    0,
    2,
    10,
    9,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    2,
    10,
    3,
    10,
    8,
    3,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    7,
    2,
    3,
    6,
    2,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    0,
    8,
    7,
    6,
    0,
    6,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    7,
    6,
    2,
    3,
    7,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    2,
    1,
    8,
    6,
    1,
    9,
    8,
    8,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    10,
    1,
    7,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    1,
    7,
    10,
    1,
    8,
    7,
    1,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    7,
    0,
    7,
    10,
    0,
    10,
    9,
    6,
    10,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    8,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    11,
    8,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    3,
    0,
    6,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    6,
    11,
    8,
    4,
    6,
    9,
    0,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    6,
    9,
    6,
    3,
    9,
    3,
    1,
    11,
    3,
    6,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    6,
    11,
    8,
    2,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    11,
    0,
    6,
    11,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    8,
    4,
    6,
    11,
    0,
    2,
    9,
    2,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    9,
    3,
    10,
    3,
    2,
    9,
    4,
    3,
    11,
    3,
    6,
    4,
    6,
    3,
    -1,
    8,
    2,
    3,
    8,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    4,
    2,
    4,
    6,
    4,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    4,
    1,
    4,
    2,
    2,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    3,
    8,
    6,
    1,
    8,
    4,
    6,
    6,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    6,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    6,
    3,
    4,
    3,
    8,
    6,
    10,
    3,
    0,
    3,
    9,
    10,
    9,
    3,
    -1,
    10,
    9,
    4,
    6,
    10,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    5,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    1,
    5,
    4,
    0,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    6,
    8,
    3,
    4,
    3,
    5,
    4,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    10,
    1,
    2,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    1,
    2,
    10,
    0,
    8,
    3,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    5,
    4,
    10,
    4,
    2,
    10,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    8,
    3,
    5,
    4,
    3,
    2,
    5,
    10,
    5,
    2,
    11,
    7,
    6,
    -1,
    7,
    2,
    3,
    7,
    6,
    2,
    5,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    6,
    0,
    6,
    2,
    6,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    2,
    3,
    7,
    6,
    1,
    5,
    0,
    5,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    6,
    2,
    8,
    6,
    8,
    7,
    2,
    1,
    8,
    4,
    8,
    5,
    1,
    5,
    8,
    -1,
    9,
    5,
    4,
    10,
    1,
    6,
    1,
    7,
    6,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    10,
    1,
    7,
    6,
    1,
    0,
    7,
    8,
    7,
    0,
    9,
    5,
    4,
    -1,
    4,
    0,
    10,
    4,
    10,
    5,
    0,
    3,
    10,
    6,
    10,
    7,
    3,
    7,
    10,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    5,
    4,
    10,
    4,
    8,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    9,
    5,
    6,
    11,
    9,
    11,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    0,
    6,
    3,
    0,
    5,
    6,
    0,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    8,
    0,
    5,
    11,
    0,
    1,
    5,
    5,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    5,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    11,
    9,
    11,
    8,
    11,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    3,
    0,
    6,
    11,
    0,
    9,
    6,
    5,
    6,
    9,
    1,
    2,
    10,
    -1,
    11,
    8,
    5,
    11,
    5,
    6,
    8,
    0,
    5,
    10,
    5,
    2,
    0,
    2,
    5,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    2,
    10,
    3,
    10,
    5,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    9,
    5,
    2,
    8,
    5,
    6,
    2,
    3,
    8,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    6,
    9,
    6,
    0,
    0,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    8,
    1,
    8,
    0,
    5,
    6,
    8,
    3,
    8,
    2,
    6,
    2,
    8,
    -1,
    1,
    5,
    6,
    2,
    1,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    6,
    1,
    6,
    10,
    3,
    8,
    6,
    5,
    6,
    9,
    8,
    9,
    6,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    9,
    5,
    0,
    5,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    5,
    6,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    7,
    5,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    11,
    7,
    5,
    8,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    11,
    7,
    5,
    10,
    11,
    1,
    9,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    5,
    10,
    11,
    7,
    9,
    8,
    1,
    8,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    11,
    1,
    2,
    11,
    7,
    1,
    7,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    7,
    1,
    7,
    5,
    7,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    5,
    9,
    2,
    7,
    9,
    0,
    2,
    2,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    5,
    2,
    7,
    2,
    11,
    5,
    9,
    2,
    3,
    2,
    8,
    9,
    8,
    2,
    -1,
    2,
    5,
    10,
    2,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    2,
    0,
    8,
    5,
    2,
    8,
    7,
    5,
    10,
    2,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    3,
    5,
    3,
    7,
    3,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    2,
    9,
    2,
    1,
    8,
    7,
    2,
    10,
    2,
    5,
    7,
    5,
    2,
    -1,
    1,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    7,
    0,
    7,
    1,
    1,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    3,
    9,
    3,
    5,
    5,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    7,
    5,
    9,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    4,
    5,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    4,
    5,
    11,
    0,
    5,
    10,
    11,
    11,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    10,
    8,
    10,
    11,
    10,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    4,
    10,
    4,
    5,
    11,
    3,
    4,
    9,
    4,
    1,
    3,
    1,
    4,
    -1,
    2,
    5,
    1,
    2,
    8,
    5,
    2,
    11,
    8,
    4,
    5,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    11,
    0,
    11,
    3,
    4,
    5,
    11,
    2,
    11,
    1,
    5,
    1,
    11,
    -1,
    0,
    2,
    5,
    0,
    5,
    9,
    2,
    11,
    5,
    4,
    5,
    8,
    11,
    8,
    5,
    -1,
    9,
    4,
    5,
    2,
    11,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    5,
    10,
    3,
    5,
    2,
    3,
    4,
    5,
    3,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    4,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    2,
    3,
    5,
    10,
    3,
    8,
    5,
    4,
    5,
    8,
    0,
    1,
    9,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    1,
    9,
    2,
    9,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    3,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    5,
    1,
    0,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    9,
    0,
    5,
    0,
    3,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    7,
    4,
    9,
    11,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    7,
    9,
    11,
    7,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    11,
    1,
    11,
    4,
    1,
    4,
    0,
    7,
    4,
    11,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    4,
    3,
    4,
    8,
    1,
    10,
    4,
    7,
    4,
    11,
    10,
    11,
    4,
    -1,
    4,
    11,
    7,
    9,
    11,
    4,
    9,
    2,
    11,
    9,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    4,
    9,
    11,
    7,
    9,
    1,
    11,
    2,
    11,
    1,
    0,
    8,
    3,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    2,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    8,
    3,
    4,
    3,
    2,
    4,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    10,
    2,
    7,
    9,
    2,
    3,
    7,
    7,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    7,
    9,
    7,
    4,
    10,
    2,
    7,
    8,
    7,
    0,
    2,
    0,
    7,
    -1,
    3,
    7,
    10,
    3,
    10,
    2,
    7,
    4,
    10,
    1,
    10,
    0,
    4,
    0,
    10,
    -1,
    1,
    10,
    2,
    8,
    7,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    7,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    0,
    8,
    1,
    8,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    4,
    0,
    3,
    7,
    4,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    11,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    10,
    0,
    10,
    8,
    8,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    10,
    11,
    3,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    11,
    1,
    11,
    9,
    9,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    1,
    2,
    9,
    2,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    11,
    8,
    0,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    10,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    2,
    0,
    9,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    0,
    1,
    8,
    1,
    10,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    8,
    9,
    1,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    9,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ]);
}
function getAllowedContours() {
  return [
    [0, 4, 4, 4, 2, 0, 0, 0, 2, 2, 0, 0],
    [4, 0, 4, 4, 0, 8, 0, 0, 0, 8, 8, 0],
    [4, 4, 0, 4, 0, 0, 8, 0, 0, 0, 8, 8],
    [4, 4, 4, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [2, 0, 0, 0, 0, 8, 8, 8, 2, 2, 0, 0],
    [0, 8, 0, 0, 8, 0, 8, 8, 0, 8, 8, 0],
    [0, 0, 8, 0, 8, 8, 0, 8, 0, 0, 8, 8],
    [0, 0, 0, 1, 8, 8, 8, 0, 1, 0, 0, 1],
    [2, 0, 0, 1, 2, 0, 0, 1, 0, 2, 0, 1],
    [2, 8, 0, 0, 2, 8, 0, 0, 2, 0, 8, 0],
    [0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8],
    [0, 0, 8, 1, 0, 0, 8, 1, 1, 0, 8, 0]
  ];
}
function MarchingCubes(field, nx, ny, nz, atomindex) {
  var isolevel = 0;
  var noNormals = false;
  var contour = false;
  var wrap = false;
  var n = nx * ny * nz;
  var yd = nx;
  var zd = nx * ny;
  var normalCache, vertexIndex;
  var count2, icount;
  var ilist = new Int32Array(12);
  var positionArray = [];
  var normalArray = [];
  var indexArray = [];
  var atomindexArray = [];
  var edgeTable = getEdgeTable();
  var triTable = getTriTable();
  var allowedContours = getAllowedContours();
  var mx, my, mz;
  this.triangulate = function(_isolevel, _noNormals, _box, _contour, _wrap) {
    isolevel = _isolevel;
    contour = _contour;
    wrap = _wrap;
    noNormals = _noNormals || contour;
    if (!noNormals && !normalCache) {
      normalCache = new Float32Array(n * 3);
    }
    var vIndexLength = contour ? n * 3 : n;
    if (!vertexIndex || vertexIndex.length !== vIndexLength) {
      vertexIndex = new Int32Array(vIndexLength);
    }
    count2 = 0;
    icount = 0;
    if (_box !== void 0) {
      var min = _box[0].map(Math.round);
      var max2 = _box[1].map(Math.round);
      mx = nx * Math.ceil(Math.abs(min[0]) / nx);
      my = ny * Math.ceil(Math.abs(min[1]) / ny);
      mz = nz * Math.ceil(Math.abs(min[2]) / nz);
      triangulate(min[0], min[1], min[2], max2[0], max2[1], max2[2]);
    } else {
      mx = my = mz = 0;
      triangulate();
    }
    positionArray.length = count2 * 3;
    if (!noNormals) {
      normalArray.length = count2 * 3;
    }
    indexArray.length = icount;
    if (atomindex) {
      atomindexArray.length = count2;
    }
    return {
      position: new Float32Array(positionArray),
      normal: noNormals ? void 0 : new Float32Array(normalArray),
      index: getUintArray(indexArray, positionArray.length / 3),
      atomindex: atomindex ? new Int32Array(atomindexArray) : void 0,
      contour
    };
  };
  function lerp2(a, b, t) {
    return a + (b - a) * t;
  }
  function index(x, y, z) {
    x = (x + mx) % nx;
    y = (y + my) % ny;
    z = (z + mz) % nz;
    return zd * z + yd * y + x;
  }
  function VIntX(q, offset, x, y, z, valp1, valp2) {
    var _q = contour ? 3 * q : q;
    if (vertexIndex[_q] < 0) {
      var mu = (isolevel - valp1) / (valp2 - valp1);
      var nc = normalCache;
      var c = count2 * 3;
      positionArray[c + 0] = x + mu;
      positionArray[c + 1] = y;
      positionArray[c + 2] = z;
      if (!noNormals) {
        var q3 = q * 3;
        normalArray[c] = -lerp2(nc[q3], nc[q3 + 3], mu);
        normalArray[c + 1] = -lerp2(nc[q3 + 1], nc[q3 + 4], mu);
        normalArray[c + 2] = -lerp2(nc[q3 + 2], nc[q3 + 5], mu);
      }
      if (atomindex) {
        atomindexArray[count2] = atomindex[q + Math.round(mu)];
      }
      vertexIndex[_q] = count2;
      ilist[offset] = count2;
      count2 += 1;
    } else {
      ilist[offset] = vertexIndex[_q];
    }
  }
  function VIntY(q, offset, x, y, z, valp1, valp2) {
    var _q = contour ? 3 * q + 1 : q;
    if (vertexIndex[_q] < 0) {
      var mu = (isolevel - valp1) / (valp2 - valp1);
      var nc = normalCache;
      var c = count2 * 3;
      positionArray[c] = x;
      positionArray[c + 1] = y + mu;
      positionArray[c + 2] = z;
      if (!noNormals) {
        var q3 = q * 3;
        var q6 = q3 + yd * 3;
        normalArray[c] = -lerp2(nc[q3], nc[q6], mu);
        normalArray[c + 1] = -lerp2(nc[q3 + 1], nc[q6 + 1], mu);
        normalArray[c + 2] = -lerp2(nc[q3 + 2], nc[q6 + 2], mu);
      }
      if (atomindex) {
        atomindexArray[count2] = atomindex[q + Math.round(mu) * yd];
      }
      vertexIndex[_q] = count2;
      ilist[offset] = count2;
      count2 += 1;
    } else {
      ilist[offset] = vertexIndex[_q];
    }
  }
  function VIntZ(q, offset, x, y, z, valp1, valp2) {
    var _q = contour ? 3 * q + 2 : q;
    if (vertexIndex[_q] < 0) {
      var mu = (isolevel - valp1) / (valp2 - valp1);
      var nc = normalCache;
      var c = count2 * 3;
      positionArray[c] = x;
      positionArray[c + 1] = y;
      positionArray[c + 2] = z + mu;
      if (!noNormals) {
        var q3 = q * 3;
        var q6 = q3 + zd * 3;
        normalArray[c] = -lerp2(nc[q3], nc[q6], mu);
        normalArray[c + 1] = -lerp2(nc[q3 + 1], nc[q6 + 1], mu);
        normalArray[c + 2] = -lerp2(nc[q3 + 2], nc[q6 + 2], mu);
      }
      if (atomindex) {
        atomindexArray[count2] = atomindex[q + Math.round(mu) * zd];
      }
      vertexIndex[_q] = count2;
      ilist[offset] = count2;
      count2 += 1;
    } else {
      ilist[offset] = vertexIndex[_q];
    }
  }
  function compNorm(q) {
    var q3 = q * 3;
    if (normalCache[q3] === 0) {
      normalCache[q3] = field[(q - 1 + n) % n] - field[(q + 1) % n];
      normalCache[q3 + 1] = field[(q - yd + n) % n] - field[(q + yd) % n];
      normalCache[q3 + 2] = field[(q - zd + n) % n] - field[(q + zd) % n];
    }
  }
  function polygonize(fx, fy, fz, q, edgeFilter) {
    var q1;
    var qy;
    var qz;
    var q1y;
    var q1z;
    var qyz;
    var q1yz;
    if (wrap) {
      q = index(fx, fy, fz);
      q1 = index(fx + 1, fy, fz);
      qy = index(fx, fy + 1, fz);
      qz = index(fx, fy, fz + 1);
      q1y = index(fx + 1, fy + 1, fz);
      q1z = index(fx + 1, fy, fz + 1);
      qyz = index(fx, fy + 1, fz + 1);
      q1yz = index(fx + 1, fy + 1, fz + 1);
    } else {
      q1 = q + 1;
      qy = q + yd;
      qz = q + zd;
      q1y = qy + 1;
      q1z = qz + 1;
      qyz = qy + zd;
      q1yz = qyz + 1;
    }
    var cubeindex = 0;
    var field0 = field[q];
    var field1 = field[q1];
    var field2 = field[qy];
    var field3 = field[q1y];
    var field4 = field[qz];
    var field5 = field[q1z];
    var field6 = field[qyz];
    var field7 = field[q1yz];
    if (field0 < isolevel) {
      cubeindex |= 1;
    }
    if (field1 < isolevel) {
      cubeindex |= 2;
    }
    if (field2 < isolevel) {
      cubeindex |= 8;
    }
    if (field3 < isolevel) {
      cubeindex |= 4;
    }
    if (field4 < isolevel) {
      cubeindex |= 16;
    }
    if (field5 < isolevel) {
      cubeindex |= 32;
    }
    if (field6 < isolevel) {
      cubeindex |= 128;
    }
    if (field7 < isolevel) {
      cubeindex |= 64;
    }
    var bits = edgeTable[cubeindex];
    if (bits === 0) {
      return 0;
    }
    var fx2 = fx + 1;
    var fy2 = fy + 1;
    var fz2 = fz + 1;
    if (bits & 1) {
      if (!noNormals) {
        compNorm(q);
        compNorm(q1);
      }
      VIntX(q, 0, fx, fy, fz, field0, field1);
    }
    if (bits & 2) {
      if (!noNormals) {
        compNorm(q1);
        compNorm(q1y);
      }
      VIntY(q1, 1, fx2, fy, fz, field1, field3);
    }
    if (bits & 4) {
      if (!noNormals) {
        compNorm(qy);
        compNorm(q1y);
      }
      VIntX(qy, 2, fx, fy2, fz, field2, field3);
    }
    if (bits & 8) {
      if (!noNormals) {
        compNorm(q);
        compNorm(qy);
      }
      VIntY(q, 3, fx, fy, fz, field0, field2);
    }
    if (bits & 16) {
      if (!noNormals) {
        compNorm(qz);
        compNorm(q1z);
      }
      VIntX(qz, 4, fx, fy, fz2, field4, field5);
    }
    if (bits & 32) {
      if (!noNormals) {
        compNorm(q1z);
        compNorm(q1yz);
      }
      VIntY(q1z, 5, fx2, fy, fz2, field5, field7);
    }
    if (bits & 64) {
      if (!noNormals) {
        compNorm(qyz);
        compNorm(q1yz);
      }
      VIntX(qyz, 6, fx, fy2, fz2, field6, field7);
    }
    if (bits & 128) {
      if (!noNormals) {
        compNorm(qz);
        compNorm(qyz);
      }
      VIntY(qz, 7, fx, fy, fz2, field4, field6);
    }
    if (bits & 256) {
      if (!noNormals) {
        compNorm(q);
        compNorm(qz);
      }
      VIntZ(q, 8, fx, fy, fz, field0, field4);
    }
    if (bits & 512) {
      if (!noNormals) {
        compNorm(q1);
        compNorm(q1z);
      }
      VIntZ(q1, 9, fx2, fy, fz, field1, field5);
    }
    if (bits & 1024) {
      if (!noNormals) {
        compNorm(q1y);
        compNorm(q1yz);
      }
      VIntZ(q1y, 10, fx2, fy2, fz, field3, field7);
    }
    if (bits & 2048) {
      if (!noNormals) {
        compNorm(qy);
        compNorm(qyz);
      }
      VIntZ(qy, 11, fx, fy2, fz, field2, field6);
    }
    var triIndex = cubeindex << 4;
    var e1;
    var e2;
    var e3;
    var i = 0;
    while (triTable[triIndex + i] !== -1) {
      e1 = triTable[triIndex + i];
      e2 = triTable[triIndex + i + 1];
      e3 = triTable[triIndex + i + 2];
      if (contour) {
        if (allowedContours[e1][e2] & edgeFilter) {
          indexArray[icount++] = ilist[e1];
          indexArray[icount++] = ilist[e2];
        }
        if (allowedContours[e2][e3] & edgeFilter) {
          indexArray[icount++] = ilist[e2];
          indexArray[icount++] = ilist[e3];
        }
        if (allowedContours[e1][e3] & edgeFilter) {
          indexArray[icount++] = ilist[e1];
          indexArray[icount++] = ilist[e3];
        }
      } else {
        indexArray[icount++] = ilist[e2];
        indexArray[icount++] = ilist[e1];
        indexArray[icount++] = ilist[e3];
      }
      i += 3;
    }
  }
  function triangulate(xBeg, yBeg, zBeg, xEnd, yEnd, zEnd) {
    var q;
    var q3;
    var x;
    var y;
    var z;
    var yOffset;
    var zOffset;
    xBeg = xBeg !== void 0 ? xBeg : 0;
    yBeg = yBeg !== void 0 ? yBeg : 0;
    zBeg = zBeg !== void 0 ? zBeg : 0;
    xEnd = xEnd !== void 0 ? xEnd : nx - 1;
    yEnd = yEnd !== void 0 ? yEnd : ny - 1;
    zEnd = zEnd !== void 0 ? zEnd : nz - 1;
    if (!wrap) {
      if (noNormals) {
        xBeg = Math.max(0, xBeg);
        yBeg = Math.max(0, yBeg);
        zBeg = Math.max(0, zBeg);
        xEnd = Math.min(nx - 1, xEnd);
        yEnd = Math.min(ny - 1, yEnd);
        zEnd = Math.min(nz - 1, zEnd);
      } else {
        xBeg = Math.max(1, xBeg);
        yBeg = Math.max(1, yBeg);
        zBeg = Math.max(1, zBeg);
        xEnd = Math.min(nx - 2, xEnd);
        yEnd = Math.min(ny - 2, yEnd);
        zEnd = Math.min(nz - 2, zEnd);
      }
    }
    var xBeg2, yBeg2, zBeg2, xEnd2, yEnd2, zEnd2;
    if (!wrap) {
      xBeg2 = Math.max(0, xBeg - 2);
      yBeg2 = Math.max(0, yBeg - 2);
      zBeg2 = Math.max(0, zBeg - 2);
      xEnd2 = Math.min(nx, xEnd + 2);
      yEnd2 = Math.min(ny, yEnd + 2);
      zEnd2 = Math.min(nz, zEnd + 2);
      for (z = zBeg2; z < zEnd2; ++z) {
        zOffset = zd * z;
        for (y = yBeg2; y < yEnd2; ++y) {
          yOffset = zOffset + yd * y;
          for (x = xBeg2; x < xEnd2; ++x) {
            if (contour) {
              q = 3 * (yOffset + x);
              vertexIndex[q] = -1;
              vertexIndex[q + 1] = -1;
              vertexIndex[q + 2] = -1;
            } else {
              q = yOffset + x;
              vertexIndex[q] = -1;
            }
          }
        }
      }
    } else {
      xBeg2 = xBeg - 2;
      yBeg2 = yBeg - 2;
      zBeg2 = zBeg - 2;
      xEnd2 = xEnd + 2;
      yEnd2 = yEnd + 2;
      zEnd2 = zEnd + 2;
      for (z = zBeg2; z < zEnd2; ++z) {
        for (y = yBeg2; y < yEnd2; ++y) {
          for (x = xBeg2; x < xEnd2; ++x) {
            if (contour) {
              q3 = index(x, y, z) * 3;
              vertexIndex[q3] = -1;
              vertexIndex[q3 + 1] = -1;
              vertexIndex[q3 + 2] = -1;
            } else {
              q = index(x, y, z);
              vertexIndex[q] = -1;
            }
          }
        }
      }
    }
    if (!wrap) {
      var __break;
      var __xBeg = xBeg;
      var __yBeg = yBeg;
      var __zBeg = zBeg;
      var __xEnd = xEnd;
      var __yEnd = yEnd;
      var __zEnd = zEnd;
      __break = false;
      for (z = zBeg; z < zEnd; ++z) {
        for (y = yBeg; y < yEnd; ++y) {
          for (x = xBeg; x < xEnd; ++x) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __zBeg = z;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      __break = false;
      for (y = yBeg; y < yEnd; ++y) {
        for (z = __zBeg; z < zEnd; ++z) {
          for (x = xBeg; x < xEnd; ++x) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __yBeg = y;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      __break = false;
      for (x = xBeg; x < xEnd; ++x) {
        for (y = __yBeg; y < yEnd; ++y) {
          for (z = __zBeg; z < zEnd; ++z) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __xBeg = x;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      __break = false;
      for (z = zEnd; z >= zBeg; --z) {
        for (y = yEnd; y >= yBeg; --y) {
          for (x = xEnd; x >= xBeg; --x) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __zEnd = z;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      __break = false;
      for (y = yEnd; y >= yBeg; --y) {
        for (z = __zEnd; z >= zBeg; --z) {
          for (x = xEnd; x >= xBeg; --x) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __yEnd = y;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      __break = false;
      for (x = xEnd; x >= xBeg; --x) {
        for (y = __yEnd; y >= yBeg; --y) {
          for (z = __zEnd; z >= zBeg; --z) {
            q = nx * ny * z + nx * y + x;
            if (field[q] >= isolevel) {
              __xEnd = x;
              __break = true;
              break;
            }
          }
          if (__break) {
            break;
          }
        }
        if (__break) {
          break;
        }
      }
      if (noNormals) {
        xBeg = Math.max(0, __xBeg - 1);
        yBeg = Math.max(0, __yBeg - 1);
        zBeg = Math.max(0, __zBeg - 1);
        xEnd = Math.min(nx - 1, __xEnd + 1);
        yEnd = Math.min(ny - 1, __yEnd + 1);
        zEnd = Math.min(nz - 1, __zEnd + 1);
      } else {
        xBeg = Math.max(1, __xBeg - 1);
        yBeg = Math.max(1, __yBeg - 1);
        zBeg = Math.max(1, __zBeg - 1);
        xEnd = Math.min(nx - 2, __xEnd + 1);
        yEnd = Math.min(ny - 2, __yEnd + 1);
        zEnd = Math.min(nz - 2, __zEnd + 1);
      }
    }
    var edgeFilter = 15;
    for (z = zBeg; z < zEnd; ++z, edgeFilter &= ~4) {
      zOffset = zd * z;
      edgeFilter |= 2;
      for (y = yBeg; y < yEnd; ++y, edgeFilter &= ~2) {
        yOffset = zOffset + yd * y;
        edgeFilter |= 1;
        for (x = xBeg; x < xEnd; ++x, edgeFilter &= ~1) {
          q = yOffset + x;
          polygonize(x, y, z, q, edgeFilter);
        }
      }
    }
  }
}
MarchingCubes.__deps = [getEdgeTable, getTriTable, getAllowedContours, getUintArray];
function laplacianSmooth(verts, faces, numiter, inflate2) {
  numiter = numiter || 1;
  inflate2 = inflate2 || true;
  var nv = verts.length / 3;
  var nf = faces.length / 3;
  var norms;
  if (inflate2) {
    norms = new Float32Array(nv * 3);
  }
  var tps = new Float32Array(nv * 3);
  var i;
  var ndeg = 20;
  var vertdeg = new Array(ndeg);
  for (i = 0; i < ndeg; ++i) {
    vertdeg[i] = new Uint32Array(nv);
  }
  for (i = 0; i < nv; ++i) {
    vertdeg[0][i] = 0;
  }
  var j, jl;
  var flagvert;
  for (i = 0; i < nf; ++i) {
    var ao = i * 3;
    var bo = i * 3 + 1;
    var co = i * 3 + 2;
    flagvert = true;
    for (j = 0, jl = vertdeg[0][faces[ao]]; j < jl; ++j) {
      if (faces[bo] === vertdeg[j + 1][faces[ao]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[ao]]++;
      vertdeg[vertdeg[0][faces[ao]]][faces[ao]] = faces[bo];
    }
    flagvert = true;
    for (j = 0, jl = vertdeg[0][faces[ao]]; j < jl; ++j) {
      if (faces[co] === vertdeg[j + 1][faces[ao]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[ao]]++;
      vertdeg[vertdeg[0][faces[ao]]][faces[ao]] = faces[co];
    }
    flagvert = true;
    for (j = 0, jl = vertdeg[0][faces[bo]]; j < jl; ++j) {
      if (faces[ao] === vertdeg[j + 1][faces[bo]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[bo]]++;
      vertdeg[vertdeg[0][faces[bo]]][faces[bo]] = faces[ao];
    }
    flagvert = true;
    for (j = 0, jl = vertdeg[0][faces[bo]]; j < jl; ++j) {
      if (faces[co] === vertdeg[j + 1][faces[bo]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[bo]]++;
      vertdeg[vertdeg[0][faces[bo]]][faces[bo]] = faces[co];
    }
    flagvert = true;
    for (j = 0; j < vertdeg[0][faces[co]]; ++j) {
      if (faces[ao] === vertdeg[j + 1][faces[co]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[co]]++;
      vertdeg[vertdeg[0][faces[co]]][faces[co]] = faces[ao];
    }
    flagvert = true;
    for (j = 0, jl = vertdeg[0][faces[co]]; j < jl; ++j) {
      if (faces[bo] === vertdeg[j + 1][faces[co]]) {
        flagvert = false;
        break;
      }
    }
    if (flagvert) {
      vertdeg[0][faces[co]]++;
      vertdeg[vertdeg[0][faces[co]]][faces[co]] = faces[bo];
    }
  }
  var wt = 1;
  var wt2 = 0.5;
  var i3, vi3, vdi, wtvi, wt2vi;
  var ssign = -1;
  var scaleFactor = 1;
  var outwt = 0.75 / (scaleFactor + 3.5);
  for (var k = 0; k < numiter; ++k) {
    for (i = 0; i < nv; ++i) {
      i3 = i * 3;
      vdi = vertdeg[0][i];
      if (vdi < 3) {
        tps[i3] = verts[i3];
        tps[i3 + 1] = verts[i3 + 1];
        tps[i3 + 2] = verts[i3 + 2];
      } else if (vdi === 3 || vdi === 4) {
        tps[i3] = 0;
        tps[i3 + 1] = 0;
        tps[i3 + 2] = 0;
        for (j = 0; j < vdi; ++j) {
          vi3 = vertdeg[j + 1][i] * 3;
          tps[i3] += verts[vi3];
          tps[i3 + 1] += verts[vi3 + 1];
          tps[i3 + 2] += verts[vi3 + 2];
        }
        tps[i3] += wt2 * verts[i3];
        tps[i3 + 1] += wt2 * verts[i3 + 1];
        tps[i3 + 2] += wt2 * verts[i3 + 2];
        wt2vi = wt2 + vdi;
        tps[i3] /= wt2vi;
        tps[i3 + 1] /= wt2vi;
        tps[i3 + 2] /= wt2vi;
      } else {
        tps[i3] = 0;
        tps[i3 + 1] = 0;
        tps[i3 + 2] = 0;
        for (j = 0; j < vdi; ++j) {
          vi3 = vertdeg[j + 1][i] * 3;
          tps[i3] += verts[vi3];
          tps[i3 + 1] += verts[vi3 + 1];
          tps[i3 + 2] += verts[vi3 + 2];
        }
        tps[i3] += wt * verts[i3];
        tps[i3 + 1] += wt * verts[i3 + 1];
        tps[i3 + 2] += wt * verts[i3 + 2];
        wtvi = wt + vdi;
        tps[i3] /= wtvi;
        tps[i3 + 1] /= wtvi;
        tps[i3 + 2] /= wtvi;
      }
    }
    verts.set(tps);
    if (inflate2) {
      computeVertexNormals(verts, faces, norms);
      var nv3 = nv * 3;
      for (i3 = 0; i3 < nv3; i3 += 3) {
        verts[i3] += ssign * outwt * norms[i3];
        verts[i3 + 1] += ssign * outwt * norms[i3 + 1];
        verts[i3 + 2] += ssign * outwt * norms[i3 + 2];
      }
    }
  }
}
laplacianSmooth.__deps = [computeVertexNormals];
function computeVertexNormals(position, index, normal2) {
  var i, il;
  if (normal2 === void 0) {
    normal2 = new Float32Array(position.length);
  } else {
    for (i = 0, il = normal2.length; i < il; i++) {
      normal2[i] = 0;
    }
  }
  var a = new Float32Array(3);
  var b = new Float32Array(3);
  var c = new Float32Array(3);
  var cb = new Float32Array(3);
  var ab = new Float32Array(3);
  if (index) {
    for (i = 0, il = index.length; i < il; i += 3) {
      var ai = index[i] * 3;
      var bi = index[i + 1] * 3;
      var ci = index[i + 2] * 3;
      v3fromArray(a, position, ai);
      v3fromArray(b, position, bi);
      v3fromArray(c, position, ci);
      v3sub(cb, c, b);
      v3sub(ab, a, b);
      v3cross(cb, cb, ab);
      normal2[ai] += cb[0];
      normal2[ai + 1] += cb[1];
      normal2[ai + 2] += cb[2];
      normal2[bi] += cb[0];
      normal2[bi + 1] += cb[1];
      normal2[bi + 2] += cb[2];
      normal2[ci] += cb[0];
      normal2[ci + 1] += cb[1];
      normal2[ci + 2] += cb[2];
    }
  } else {
    for (i = 0, il = position.length; i < il; i += 9) {
      v3fromArray(a, position, i);
      v3fromArray(b, position, i + 3);
      v3fromArray(c, position, i + 6);
      v3sub(cb, c, b);
      v3sub(ab, a, b);
      v3cross(cb, cb, ab);
      normal2[i] = cb[0];
      normal2[i + 1] = cb[1];
      normal2[i + 2] = cb[2];
      normal2[i + 3] = cb[0];
      normal2[i + 4] = cb[1];
      normal2[i + 5] = cb[2];
      normal2[i + 6] = cb[0];
      normal2[i + 7] = cb[1];
      normal2[i + 8] = cb[2];
    }
  }
  normalizeVector3array(normal2);
  return normal2;
}
computeVertexNormals.__deps = [
  v3sub,
  v3cross,
  v3fromArray,
  normalizeVector3array
];
function getRadiusDict(radiusList) {
  var radiusDict = {};
  for (var i = 0, il = radiusList.length; i < il; ++i) {
    radiusDict[radiusList[i]] = true;
  }
  return radiusDict;
}
function getSurfaceGrid(min, max2, maxRadius2, scaleFactor, extraMargin) {
  var margin = 1 / scaleFactor * 3;
  margin += maxRadius2;
  v3subScalar(min, min, extraMargin + margin);
  v3addScalar(max2, max2, extraMargin + margin);
  v3multiplyScalar(min, min, scaleFactor);
  v3floor(min, min);
  v3divideScalar(min, min, scaleFactor);
  v3multiplyScalar(max2, max2, scaleFactor);
  v3ceil(max2, max2);
  v3divideScalar(max2, max2, scaleFactor);
  var dim = new Float32Array(3);
  v3sub(dim, max2, min);
  v3multiplyScalar(dim, dim, scaleFactor);
  v3ceil(dim, dim);
  v3addScalar(dim, dim, 1);
  var maxSize = Math.pow(10, 6) * 256;
  var tmpSize = dim[0] * dim[1] * dim[2] * 3;
  if (maxSize <= tmpSize) {
    scaleFactor *= Math.pow(maxSize / tmpSize, 1 / 3);
    v3multiplyScalar(min, min, scaleFactor);
    v3floor(min, min);
    v3divideScalar(min, min, scaleFactor);
    v3multiplyScalar(max2, max2, scaleFactor);
    v3ceil(max2, max2);
    v3divideScalar(max2, max2, scaleFactor);
    v3sub(dim, max2, min);
    v3multiplyScalar(dim, dim, scaleFactor);
    v3ceil(dim, dim);
    v3addScalar(dim, dim, 1);
  }
  var tran = new Float32Array(min);
  v3negate(tran, tran);
  var matrix2 = m4new();
  var mroty = m4new();
  m4makeRotationY(mroty, degToRad(90));
  m4multiply(matrix2, matrix2, mroty);
  var mscale = m4new();
  m4makeScale(mscale, -1 / scaleFactor, 1 / scaleFactor, 1 / scaleFactor);
  m4multiply(matrix2, matrix2, mscale);
  var mtrans = m4new();
  m4makeTranslation(mtrans, -scaleFactor * tran[2], -scaleFactor * tran[1], -scaleFactor * tran[0]);
  m4multiply(matrix2, matrix2, mtrans);
  return {
    dim,
    tran,
    matrix: matrix2,
    scaleFactor
  };
}
getSurfaceGrid.__deps = [
  degToRad,
  v3subScalar,
  v3addScalar,
  v3divideScalar,
  v3multiplyScalar,
  v3floor,
  v3ceil,
  v3sub,
  v3negate,
  m4new,
  m4multiply,
  m4makeTranslation,
  m4makeScale,
  m4makeRotationY
];
var Surface = function Surface2(name, path, data) {
  this.name = name || "";
  this.path = path || "";
  this.info = {};
  this.center = new Vector3();
  this.boundingBox = new Box3();
  if (data instanceof Geometry || data instanceof BufferGeometry || data instanceof Group) {
    this.fromGeometry(data);
  } else if (data) {
    this.set(data.position, data.index, data.normal, data.color, data.atomindex, data.contour);
    this.boundingBox.setFromArray(data.position);
    this.boundingBox.getCenter(this.center);
  }
};
var prototypeAccessors$15 = {type: {}};
prototypeAccessors$15.type.get = function() {
  return "Surface";
};
Surface.prototype.set = function set2(position, index, normal2, color, atomindex, contour) {
  this.position = position;
  this.index = index;
  this.normal = normal2;
  this.color = color;
  this.atomindex = atomindex;
  this.size = position.length / 3;
  this.contour = contour;
};
Surface.prototype.fromGeometry = function fromGeometry(geometry) {
  if (Debug) {
    Log.time("GeometrySurface.fromGeometry");
  }
  var geo;
  if (geometry instanceof Geometry) {
    geometry.computeVertexNormals(true);
    geo = new BufferGeometry().fromGeometry(geometry);
  } else if (geometry instanceof BufferGeometry) {
    geo = geometry;
  } else {
    geo = geometry[0];
  }
  if (!geo.boundingBox) {
    geo.computeBoundingBox();
  }
  this.boundingBox.copy(geo.boundingBox);
  this.boundingBox.getCenter(this.center);
  var position, color, index, normal2;
  if (geo instanceof BufferGeometry) {
    var attr = geo.attributes;
    var an = attr.normal ? attr.normal.array : false;
    if (!an || an[0] === 0 && an[1] === 0 && an[2] === 0) {
      geo.computeVertexNormals();
    }
    position = attr.position.array;
    index = attr.index ? attr.index.array : null;
    normal2 = attr.normal.array;
  }
  this.set(position, index, normal2, color, void 0);
  if (Debug) {
    Log.timeEnd("GeometrySurface.setGeometry");
  }
};
Surface.prototype.getPosition = function getPosition2() {
  return this.position;
};
Surface.prototype.getColor = function getColor(params) {
  var p = params || {};
  p.surface = this;
  var n = this.size;
  var array = new Float32Array(n * 3);
  var colormaker = ColormakerRegistry2.getScheme(p);
  if (colormaker.volumeColor || p.scheme === "random") {
    for (var i = 0; i < n; ++i) {
      colormaker.volumeColorToArray(i, array, i * 3);
    }
  } else if (colormaker.positionColor) {
    var v = new Vector3();
    var pos = this.position;
    for (var i$1 = 0; i$1 < n; ++i$1) {
      var i3 = i$1 * 3;
      v.set(pos[i3], pos[i3 + 1], pos[i3 + 2]);
      colormaker.positionColorToArray(v, array, i3);
    }
  } else if (colormaker.atomColor && this.atomindex) {
    var atomProxy = p.structure.getAtomProxy();
    var atomindex = this.atomindex;
    for (var i$2 = 0; i$2 < n; ++i$2) {
      atomProxy.index = atomindex[i$2];
      colormaker.atomColorToArray(atomProxy, array, i$2 * 3);
    }
  } else {
    var tc = new Color(p.value);
    uniformArray3(n, tc.r, tc.g, tc.b, array);
  }
  return array;
};
Surface.prototype.getPicking = function getPicking(structure) {
  if (this.atomindex && structure) {
    return new AtomPicker(this.atomindex, structure);
  } else {
    return new SurfacePicker(serialArray(this.size), this);
  }
};
Surface.prototype.getNormal = function getNormal() {
  return this.normal;
};
Surface.prototype.getSize = function getSize2(size, scale2) {
  return uniformArray(this.size, size * scale2);
};
Surface.prototype.getIndex = function getIndex2() {
  return this.index;
};
Surface.prototype.getFilteredIndex = function getFilteredIndex(sele, structure) {
  if (sele && this.atomindex) {
    var selection = new Selection(sele);
    var atomSet = structure.getAtomSet(selection);
    var filteredIndex = [];
    var atomindex = this.atomindex;
    var index = this.index;
    var n = index.length;
    var elementSize = this.contour ? 2 : 3;
    var j = 0;
    for (var i = 0; i < n; i += elementSize) {
      var include = true;
      for (var a = 0; a < elementSize; a++) {
        var idx = index[i + a];
        var ai = atomindex[idx];
        if (!atomSet.get(ai)) {
          include = false;
          break;
        }
      }
      if (!include) {
        continue;
      }
      for (var a$1 = 0; a$1 < elementSize; a$1++, j++) {
        filteredIndex[j] = index[i + a$1];
      }
    }
    return getUintArray(filteredIndex, this.position.length / 3);
  } else {
    return this.index;
  }
};
Surface.prototype.getAtomindex = function getAtomindex() {
  return this.atomindex;
};
Surface.prototype.dispose = function dispose10() {
};
Object.defineProperties(Surface.prototype, prototypeAccessors$15);
function VolumeSurface(data, nx, ny, nz, atomindex) {
  var mc = new MarchingCubes(data, nx, ny, nz, atomindex);
  function getSurface3(isolevel, smooth, box, matrix2, contour, wrap) {
    var sd = mc.triangulate(isolevel, smooth, box, contour, wrap);
    if (smooth && !contour) {
      laplacianSmooth(sd.position, sd.index, smooth, true);
      sd.normal = computeVertexNormals(sd.position, sd.index);
    }
    if (matrix2) {
      applyMatrix4toVector3array(matrix2, sd.position);
      if (sd.normal) {
        var normalMatrix2 = m3new();
        m3makeNormal(normalMatrix2, matrix2);
        applyMatrix3toVector3array(normalMatrix2, sd.normal);
      }
    }
    return sd;
  }
  this.getSurface = getSurface3;
}
VolumeSurface.__deps = [
  laplacianSmooth,
  computeVertexNormals,
  MarchingCubes,
  applyMatrix4toVector3array,
  applyMatrix3toVector3array,
  m3new,
  m3makeNormal
];
WorkerRegistry2.add("surf", function func(e, callback) {
  var a = e.data.args;
  var p = e.data.params;
  if (a) {
    self.volsurf = new VolumeSurface(a[0], a[1], a[2], a[3], a[4]);
  }
  if (p) {
    var sd = self.volsurf.getSurface(p.isolevel, p.smooth, p.box, p.matrix, p.contour, p.wrap);
    var transferList = [sd.position.buffer, sd.index.buffer];
    if (sd.normal) {
      transferList.push(sd.normal.buffer);
    }
    if (sd.atomindex) {
      transferList.push(sd.atomindex.buffer);
    }
    var data = {
      sd,
      p
    };
    callback(data, transferList);
  }
}, [VolumeSurface]);
var Volume = function Volume2(name, path, data, nx, ny, nz, atomindex) {
  this.name = name;
  this.path = path;
  this.matrix = new Matrix4();
  this.normalMatrix = new Matrix3();
  this.inverseMatrix = new Matrix4();
  this.center = new Vector3();
  this.boundingBox = new Box3();
  this.setData(data, nx, ny, nz, atomindex);
};
var prototypeAccessors$14 = {type: {}, position: {}, min: {}, max: {}, sum: {}, mean: {}, rms: {}};
prototypeAccessors$14.type.get = function() {
  return "Volume";
};
Volume.prototype.setData = function setData(data, nx, ny, nz, atomindex) {
  this.nx = nx || 1;
  this.ny = ny || 1;
  this.nz = nz || 1;
  this.data = data || new Float32Array(1);
  this.setAtomindex(atomindex);
  delete this._position;
  delete this._min;
  delete this._max;
  delete this._mean;
  delete this._rms;
  if (this.worker) {
    this.worker.terminate();
  }
};
Volume.prototype.setMatrix = function setMatrix(matrix2) {
  this.matrix.copy(matrix2);
  var bb = this.boundingBox;
  var v = this.center;
  var x = this.nx - 1;
  var y = this.ny - 1;
  var z = this.nz - 1;
  bb.makeEmpty();
  bb.expandByPoint(v.set(x, y, z));
  bb.expandByPoint(v.set(x, y, 0));
  bb.expandByPoint(v.set(x, 0, z));
  bb.expandByPoint(v.set(x, 0, 0));
  bb.expandByPoint(v.set(0, y, z));
  bb.expandByPoint(v.set(0, 0, z));
  bb.expandByPoint(v.set(0, y, 0));
  bb.expandByPoint(v.set(0, 0, 0));
  bb.applyMatrix4(this.matrix);
  bb.getCenter(this.center);
  var me = this.matrix.elements;
  var r0 = new Vector3(me[0], me[1], me[2]);
  var r1 = new Vector3(me[4], me[5], me[6]);
  var r2 = new Vector3(me[8], me[9], me[10]);
  var cp = new Vector3();
  var ne = this.normalMatrix.elements;
  cp.crossVectors(r1, r2);
  ne[0] = cp.x;
  ne[1] = cp.y;
  ne[2] = cp.z;
  cp.crossVectors(r2, r0);
  ne[3] = cp.x;
  ne[4] = cp.y;
  ne[5] = cp.z;
  cp.crossVectors(r0, r1);
  ne[6] = cp.x;
  ne[7] = cp.y;
  ne[8] = cp.z;
  this.inverseMatrix.getInverse(this.matrix);
};
Volume.prototype.setAtomindex = function setAtomindex(atomindex) {
  this.atomindex = atomindex;
};
Volume.prototype.getBox = function getBox(center2, size, target2) {
  if (!target2) {
    target2 = new Box3();
  }
  target2.set(center2, center2);
  target2.expandByScalar(size);
  target2.applyMatrix4(this.inverseMatrix);
  target2.min.round();
  target2.max.round();
  return target2;
};
Volume.prototype._getBox = function _getBox(center2, size) {
  if (!center2 || !size) {
    return;
  }
  if (!this.__box) {
    this.__box = new Box3();
  }
  var box = this.getBox(center2, size, this.__box);
  return [box.min.toArray(), box.max.toArray()];
};
Volume.prototype._makeSurface = function _makeSurface(sd, isolevel, smooth) {
  var name = this.name + "@" + isolevel.toPrecision(2);
  var surface = new Surface(name, "", sd);
  surface.info.isolevel = isolevel;
  surface.info.smooth = smooth;
  surface.info.volume = this;
  return surface;
};
Volume.prototype.getSurface = function getSurface(isolevel, smooth, center2, size, contour, wrap) {
  isolevel = isNaN(isolevel) ? this.getValueForSigma(2) : isolevel;
  smooth = defaults(smooth, 0);
  if (this.volsurf === void 0) {
    this.volsurf = new VolumeSurface(this.data, this.nx, this.ny, this.nz, this.atomindex);
  }
  var box = this._getBox(center2, size);
  var sd = this.volsurf.getSurface(isolevel, smooth, box, this.matrix.elements, contour, wrap);
  return this._makeSurface(sd, isolevel, smooth);
};
Volume.prototype.getSurfaceWorker = function getSurfaceWorker(isolevel, smooth, center2, size, contour, wrap, callback) {
  var this$1 = this;
  isolevel = isNaN(isolevel) ? this.getValueForSigma(2) : isolevel;
  smooth = smooth || 0;
  if (window.Worker) {
    if (this.workerPool === void 0) {
      this.workerPool = new WorkerPool("surf", 2);
    }
    var msg = {};
    var worker = this.workerPool.getNextWorker();
    if (worker.postCount === 0) {
      msg.args = [
        this.data,
        this.nx,
        this.ny,
        this.nz,
        this.atomindex
      ];
    }
    msg.params = {
      isolevel,
      smooth,
      box: this._getBox(center2, size),
      matrix: this.matrix.elements,
      contour,
      wrap
    };
    worker.post(msg, void 0, function(e) {
      var sd = e.data.sd;
      var p = e.data.p;
      callback(this$1._makeSurface(sd, p.isolevel, p.smooth));
    }, function(e) {
      console.warn("Volume.getSurfaceWorker error - trying without worker", e);
      var surface2 = this$1.getSurface(isolevel, smooth, center2, size, contour, wrap);
      callback(surface2);
    });
  } else {
    var surface = this.getSurface(isolevel, smooth, center2, size, contour, wrap);
    callback(surface);
  }
};
Volume.prototype.getValueForSigma = function getValueForSigma(sigma) {
  return this.mean + defaults(sigma, 2) * this.rms;
};
Volume.prototype.getSigmaForValue = function getSigmaForValue(value2) {
  return (defaults(value2, 0) - this.mean) / this.rms;
};
prototypeAccessors$14.position.get = function() {
  if (!this._position) {
    var nz = this.nz;
    var ny = this.ny;
    var nx = this.nx;
    var position = new Float32Array(nx * ny * nz * 3);
    var p = 0;
    for (var z = 0; z < nz; ++z) {
      for (var y = 0; y < ny; ++y) {
        for (var x = 0; x < nx; ++x) {
          position[p + 0] = x;
          position[p + 1] = y;
          position[p + 2] = z;
          p += 3;
        }
      }
    }
    applyMatrix4toVector3array(this.matrix.elements, position);
    this._position = position;
  }
  return this._position;
};
Volume.prototype.getDataAtomindex = function getDataAtomindex() {
  return this.atomindex;
};
Volume.prototype.getDataPosition = function getDataPosition() {
  return this.position;
};
Volume.prototype.getDataColor = function getDataColor(params) {
  var p = params || {};
  p.volume = this;
  p.scale = p.scale || "Spectral";
  p.domain = p.domain || [this.min, this.max];
  var colormaker = ColormakerRegistry2.getScheme(p);
  var n = this.position.length / 3;
  var array = new Float32Array(n * 3);
  for (var i = 0; i < n; ++i) {
    colormaker.volumeColorToArray(i, array, i * 3);
  }
  return array;
};
Volume.prototype.getDataPicking = function getDataPicking() {
  var picking = serialArray(this.position.length / 3);
  return new VolumePicker(picking, this);
};
Volume.prototype.getDataSize = function getDataSize(size, scale2) {
  var data = this.data;
  var n = this.position.length / 3;
  var array;
  switch (size) {
    case "value":
      array = new Float32Array(data);
      break;
    case "abs-value":
      array = new Float32Array(data);
      for (var i = 0; i < n; ++i) {
        array[i] = Math.abs(array[i]);
      }
      break;
    case "value-min": {
      array = new Float32Array(data);
      var min = this.min;
      for (var i$1 = 0; i$1 < n; ++i$1) {
        array[i$1] -= min;
      }
      break;
    }
    case "deviation":
      array = new Float32Array(data);
      break;
    default:
      array = uniformArray(n, size);
      break;
  }
  if (scale2 !== 1) {
    for (var i$2 = 0; i$2 < n; ++i$2) {
      array[i$2] *= scale2;
    }
  }
  return array;
};
prototypeAccessors$14.min.get = function() {
  if (this._min === void 0) {
    this._min = arrayMin(this.data);
  }
  return this._min;
};
prototypeAccessors$14.max.get = function() {
  if (this._max === void 0) {
    this._max = arrayMax$1(this.data);
  }
  return this._max;
};
prototypeAccessors$14.sum.get = function() {
  if (this._sum === void 0) {
    this._sum = arraySum(this.data);
  }
  return this._sum;
};
prototypeAccessors$14.mean.get = function() {
  if (this._mean === void 0) {
    this._mean = arrayMean(this.data);
  }
  return this._mean;
};
prototypeAccessors$14.rms.get = function() {
  if (this._rms === void 0) {
    this._rms = arrayRms(this.data);
  }
  return this._rms;
};
Volume.prototype.clone = function clone2() {
  var vol = new Volume(this.name, this.path, this.data, this.nx, this.ny, this.nz, this.atomindex);
  vol.matrix.copy(this.matrix);
  vol.header = Object.assign({}, this.header);
  return vol;
};
Volume.prototype.dispose = function dispose11() {
  if (this.workerPool) {
    this.workerPool.terminate();
  }
};
Object.defineProperties(Volume.prototype, prototypeAccessors$14);
var FilteredVolume = function FilteredVolume2(volume, minValue, maxValue, outside) {
  this.volume = volume;
  this.setFilter(minValue, maxValue, outside);
};
var prototypeAccessors$13 = {header: {}, matrix: {}, normalMatrix: {}, inverseMatrix: {}, center: {}, boundingBox: {}, min: {}, max: {}, mean: {}, rms: {}};
prototypeAccessors$13.header.get = function() {
  return this.volume.header;
};
prototypeAccessors$13.matrix.get = function() {
  return this.volume.matrix;
};
prototypeAccessors$13.normalMatrix.get = function() {
  return this.volume.normalMatrix;
};
prototypeAccessors$13.inverseMatrix.get = function() {
  return this.volume.inverseMatrix;
};
prototypeAccessors$13.center.get = function() {
  return this.volume.center;
};
prototypeAccessors$13.boundingBox.get = function() {
  return this.volume.boundingBox;
};
prototypeAccessors$13.min.get = function() {
  return this.volume.min;
};
prototypeAccessors$13.max.get = function() {
  return this.volume.max;
};
prototypeAccessors$13.mean.get = function() {
  return this.volume.mean;
};
prototypeAccessors$13.rms.get = function() {
  return this.volume.rms;
};
FilteredVolume.prototype._getFilterHash = function _getFilterHash(minValue, maxValue, outside) {
  return JSON.stringify([minValue, maxValue, outside]);
};
FilteredVolume.prototype.setFilter = function setFilter(minValue, maxValue, outside) {
  if (isNaN(minValue) && this.header) {
    minValue = this.header.DMEAN + 2 * this.header.ARMS;
  }
  minValue = minValue !== void 0 && !isNaN(minValue) ? minValue : -Infinity;
  maxValue = defaults(maxValue, Infinity);
  outside = defaults(outside, false);
  var data = this.volume.data;
  var position = this.volume.position;
  var atomindex = this.volume.atomindex;
  var filterHash = this._getFilterHash(minValue, maxValue, outside);
  if (filterHash === this._filterHash) {
    return;
  } else if (minValue === -Infinity && maxValue === Infinity) {
    this.data = data;
    this.position = position;
    this.atomindex = atomindex;
  } else {
    var n = data.length;
    if (!this._dataBuffer) {
      this._dataBuffer = new ArrayBuffer(n * 4);
      this._positionBuffer = new ArrayBuffer(n * 3 * 4);
      if (atomindex) {
        this._atomindexBuffer = new ArrayBuffer(n * 4);
      }
    }
    var filteredData = new Float32Array(this._dataBuffer);
    var filteredPosition = new Float32Array(this._positionBuffer);
    var filteredAtomindex;
    if (atomindex) {
      filteredAtomindex = new Uint32Array(this._atomindexBuffer);
    }
    var j = 0;
    for (var i = 0; i < n; ++i) {
      var i3 = i * 3;
      var v = data[i];
      if (!outside && v >= minValue && v <= maxValue || outside && (v < minValue || v > maxValue)) {
        var j3 = j * 3;
        filteredData[j] = v;
        filteredPosition[j3 + 0] = position[i3 + 0];
        filteredPosition[j3 + 1] = position[i3 + 1];
        filteredPosition[j3 + 2] = position[i3 + 2];
        if (atomindex) {
          filteredAtomindex[j] = atomindex[i];
        }
        j += 1;
      }
    }
    this.data = new Float32Array(this._dataBuffer, 0, j);
    this.position = new Float32Array(this._positionBuffer, 0, j * 3);
    if (atomindex) {
      this.atomindex = new Float32Array(this._atomindexBuffer, 0, j);
    }
  }
  this._filterHash = filterHash;
};
Object.defineProperties(FilteredVolume.prototype, prototypeAccessors$13);
FilteredVolume.prototype.getValueForSigma = Volume.prototype.getValueForSigma;
FilteredVolume.prototype.getSigmaForValue = Volume.prototype.getSigmaForValue;
FilteredVolume.prototype.getDataAtomindex = Volume.prototype.getDataAtomindex;
FilteredVolume.prototype.getDataPosition = Volume.prototype.getDataPosition;
FilteredVolume.prototype.getDataColor = Volume.prototype.getDataColor;
FilteredVolume.prototype.getDataPicking = Volume.prototype.getDataPicking;
FilteredVolume.prototype.getDataSize = Volume.prototype.getDataSize;
var BondHash = function BondHash2(bondStore, atomCount) {
  if (Debug) {
    Log.time("BondHash init");
  }
  var bondCount = bondStore.count;
  var atomIndex1Array = bondStore.atomIndex1;
  var atomIndex2Array = bondStore.atomIndex2;
  var countArray = new Uint8Array(atomCount);
  var offsetArray = new Int32Array(atomCount);
  for (var i = 0; i < bondCount; ++i) {
    countArray[atomIndex1Array[i]] += 1;
    countArray[atomIndex2Array[i]] += 1;
  }
  for (var i$1 = 1; i$1 < atomCount; ++i$1) {
    offsetArray[i$1] += offsetArray[i$1 - 1] + countArray[i$1 - 1];
  }
  var bondCount2 = bondCount * 2;
  var indexArray = new Int32Array(bondCount2);
  for (var j = 0; j < bondCount2; ++j) {
    indexArray[j] = -1;
  }
  for (var i$2 = 0; i$2 < bondCount; ++i$2) {
    var idx1 = atomIndex1Array[i$2];
    var idx2 = atomIndex2Array[i$2];
    var j1 = offsetArray[idx1];
    while (indexArray[j1] !== -1) {
      j1 += 1;
    }
    indexArray[j1] = i$2;
    var j2 = offsetArray[idx2];
    while (indexArray[j2] !== -1) {
      j2 += 1;
    }
    indexArray[j2] = i$2;
  }
  if (Debug) {
    Log.timeEnd("BondHash init");
  }
  this.countArray = countArray;
  this.offsetArray = offsetArray;
  this.indexArray = indexArray;
};
var Store = function Store2(size) {
  if (Number.isInteger(size)) {
    this._init(size);
  } else {
    this._init(0);
  }
};
Store.prototype._init = function _init2(size) {
  var this$1 = this;
  this.length = size;
  this.count = 0;
  for (var i = 0, il = this.__fields.length; i < il; ++i) {
    var name = this$1.__fields[i][0];
    var itemSize2 = this$1.__fields[i][1];
    var arrayType = this$1.__fields[i][2];
    var arraySize = this$1.length * itemSize2;
    this$1[name] = getTypedArray(arrayType, arraySize);
  }
};
Store.prototype.resize = function resize(size) {
  var this$1 = this;
  this.length = Math.round(size || 0);
  this.count = Math.min(this.count, this.length);
  for (var i = 0, il = this.__fields.length; i < il; ++i) {
    var name = this$1.__fields[i][0];
    var itemSize2 = this$1.__fields[i][1];
    var arraySize = this$1.length * itemSize2;
    var tmpArray = new this$1[name].constructor(arraySize);
    if (this$1[name].length > arraySize) {
      tmpArray.set(this$1[name].subarray(0, arraySize));
    } else {
      tmpArray.set(this$1[name]);
    }
    this$1[name] = tmpArray;
  }
};
Store.prototype.growIfFull = function growIfFull() {
  if (this.count >= this.length) {
    var size = Math.round(this.length * 1.5);
    this.resize(Math.max(256, size));
  }
};
Store.prototype.copyFrom = function copyFrom(other, thisOffset, otherOffset, length) {
  var this$1 = this;
  for (var i = 0, il = this.__fields.length; i < il; ++i) {
    var name = this$1.__fields[i][0];
    var itemSize2 = this$1.__fields[i][1];
    var thisField = this$1[name];
    var otherField = other[name];
    for (var j = 0; j < length; ++j) {
      var thisIndex = itemSize2 * (thisOffset + j);
      var otherIndex = itemSize2 * (otherOffset + j);
      for (var k = 0; k < itemSize2; ++k) {
        thisField[thisIndex + k] = otherField[otherIndex + k];
      }
    }
  }
};
Store.prototype.copyWithin = function copyWithin2(offsetTarget, offsetSource, length) {
  var this$1 = this;
  for (var i = 0, il = this.__fields.length; i < il; ++i) {
    var name = this$1.__fields[i][0];
    var itemSize2 = this$1.__fields[i][1];
    var thisField = this$1[name];
    for (var j = 0; j < length; ++j) {
      var targetIndex = itemSize2 * (offsetTarget + j);
      var sourceIndex = itemSize2 * (offsetSource + j);
      for (var k = 0; k < itemSize2; ++k) {
        thisField[targetIndex + k] = thisField[sourceIndex + k];
      }
    }
  }
};
Store.prototype.sort = function sort(compareFunction) {
  Log.time("Store.sort");
  var thisStore = this;
  var tmpStore = new this.constructor(1);
  function swap(index1, index2) {
    if (index1 === index2) {
      return;
    }
    tmpStore.copyFrom(thisStore, 0, index1, 1);
    thisStore.copyWithin(index1, index2, 1);
    thisStore.copyFrom(tmpStore, index2, 0, 1);
  }
  function quicksort(left, right) {
    if (left < right) {
      var pivot = Math.floor((left + right) / 2);
      var leftNew = left;
      var rightNew = right;
      do {
        while (compareFunction(leftNew, pivot) < 0) {
          leftNew += 1;
        }
        while (compareFunction(rightNew, pivot) > 0) {
          rightNew -= 1;
        }
        if (leftNew <= rightNew) {
          if (leftNew === pivot) {
            pivot = rightNew;
          } else if (rightNew === pivot) {
            pivot = leftNew;
          }
          swap(leftNew, rightNew);
          leftNew += 1;
          rightNew -= 1;
        }
      } while (leftNew <= rightNew);
      quicksort(left, rightNew);
      quicksort(leftNew, right);
    }
  }
  quicksort(0, this.count - 1);
  Log.timeEnd("Store.sort");
};
Store.prototype.clear = function clear5() {
  this.count = 0;
};
Store.prototype.dispose = function dispose12() {
  var this$1 = this;
  delete this.length;
  delete this.count;
  for (var i = 0, il = this.__fields.length; i < il; ++i) {
    var name = this$1.__fields[i][0];
    delete this$1[name];
  }
};
var BondStore = function(Store$$1) {
  function BondStore2() {
    Store$$1.apply(this, arguments);
  }
  if (Store$$1)
    BondStore2.__proto__ = Store$$1;
  BondStore2.prototype = Object.create(Store$$1 && Store$$1.prototype);
  BondStore2.prototype.constructor = BondStore2;
  var prototypeAccessors2 = {__fields: {}};
  prototypeAccessors2.__fields.get = function() {
    return [
      ["atomIndex1", 1, "int32"],
      ["atomIndex2", 1, "int32"],
      ["bondOrder", 1, "int8"]
    ];
  };
  BondStore2.prototype.addBond = function addBond(atom1, atom2, bondOrder) {
    this.growIfFull();
    var i = this.count;
    var ai1 = atom1.index;
    var ai2 = atom2.index;
    if (ai1 < ai2) {
      this.atomIndex1[i] = ai1;
      this.atomIndex2[i] = ai2;
    } else {
      this.atomIndex2[i] = ai1;
      this.atomIndex1[i] = ai2;
    }
    if (bondOrder) {
      this.bondOrder[i] = bondOrder;
    }
    this.count += 1;
  };
  BondStore2.prototype.addBondIfConnected = function addBondIfConnected(atom1, atom2, bondOrder) {
    if (atom1.connectedTo(atom2)) {
      this.addBond(atom1, atom2, bondOrder);
      return true;
    }
    return false;
  };
  Object.defineProperties(BondStore2.prototype, prototypeAccessors2);
  return BondStore2;
}(Store);
var AtomStore = function(Store$$1) {
  function AtomStore2() {
    Store$$1.apply(this, arguments);
  }
  if (Store$$1)
    AtomStore2.__proto__ = Store$$1;
  AtomStore2.prototype = Object.create(Store$$1 && Store$$1.prototype);
  AtomStore2.prototype.constructor = AtomStore2;
  var prototypeAccessors2 = {__fields: {}};
  prototypeAccessors2.__fields.get = function() {
    return [
      ["residueIndex", 1, "uint32"],
      ["atomTypeId", 1, "uint16"],
      ["x", 1, "float32"],
      ["y", 1, "float32"],
      ["z", 1, "float32"],
      ["serial", 1, "int32"],
      ["bfactor", 1, "float32"],
      ["altloc", 1, "uint8"],
      ["occupancy", 1, "float32"]
    ];
  };
  AtomStore2.prototype.setAltloc = function setAltloc(i, str) {
    this.altloc[i] = str.charCodeAt(0);
  };
  AtomStore2.prototype.getAltloc = function getAltloc(i) {
    var code = this.altloc[i];
    return code ? String.fromCharCode(code) : "";
  };
  Object.defineProperties(AtomStore2.prototype, prototypeAccessors2);
  return AtomStore2;
}(Store);
var ResidueStore = function(Store$$1) {
  function ResidueStore2() {
    Store$$1.apply(this, arguments);
  }
  if (Store$$1)
    ResidueStore2.__proto__ = Store$$1;
  ResidueStore2.prototype = Object.create(Store$$1 && Store$$1.prototype);
  ResidueStore2.prototype.constructor = ResidueStore2;
  var prototypeAccessors2 = {__fields: {}};
  prototypeAccessors2.__fields.get = function() {
    return [
      ["chainIndex", 1, "uint32"],
      ["atomOffset", 1, "uint32"],
      ["atomCount", 1, "uint16"],
      ["residueTypeId", 1, "uint16"],
      ["resno", 1, "int32"],
      ["sstruc", 1, "uint8"],
      ["inscode", 1, "uint8"]
    ];
  };
  ResidueStore2.prototype.setSstruc = function setSstruc(i, str) {
    this.sstruc[i] = str.charCodeAt(0);
  };
  ResidueStore2.prototype.getSstruc = function getSstruc(i) {
    var code = this.sstruc[i];
    return code ? String.fromCharCode(code) : "";
  };
  ResidueStore2.prototype.setInscode = function setInscode(i, str) {
    this.inscode[i] = str.charCodeAt(0);
  };
  ResidueStore2.prototype.getInscode = function getInscode(i) {
    var code = this.inscode[i];
    return code ? String.fromCharCode(code) : "";
  };
  Object.defineProperties(ResidueStore2.prototype, prototypeAccessors2);
  return ResidueStore2;
}(Store);
var ChainStore = function(Store$$1) {
  function ChainStore2() {
    Store$$1.apply(this, arguments);
  }
  if (Store$$1)
    ChainStore2.__proto__ = Store$$1;
  ChainStore2.prototype = Object.create(Store$$1 && Store$$1.prototype);
  ChainStore2.prototype.constructor = ChainStore2;
  var prototypeAccessors2 = {__fields: {}};
  prototypeAccessors2.__fields.get = function() {
    return [
      ["entityIndex", 1, "uint16"],
      ["modelIndex", 1, "uint16"],
      ["residueOffset", 1, "uint32"],
      ["residueCount", 1, "uint32"],
      ["chainname", 4, "uint8"],
      ["chainid", 4, "uint8"]
    ];
  };
  ChainStore2.prototype.setChainname = function setChainname(i, str) {
    var j = 4 * i;
    this.chainname[j] = str.charCodeAt(0);
    this.chainname[j + 1] = str.charCodeAt(1);
    this.chainname[j + 2] = str.charCodeAt(2);
    this.chainname[j + 3] = str.charCodeAt(3);
  };
  ChainStore2.prototype.getChainname = function getChainname(i) {
    var this$1 = this;
    var chainname = "";
    for (var k = 0; k < 4; ++k) {
      var code = this$1.chainname[4 * i + k];
      if (code) {
        chainname += String.fromCharCode(code);
      } else {
        break;
      }
    }
    return chainname;
  };
  ChainStore2.prototype.setChainid = function setChainid(i, str) {
    var j = 4 * i;
    this.chainid[j] = str.charCodeAt(0);
    this.chainid[j + 1] = str.charCodeAt(1);
    this.chainid[j + 2] = str.charCodeAt(2);
    this.chainid[j + 3] = str.charCodeAt(3);
  };
  ChainStore2.prototype.getChainid = function getChainid(i) {
    var this$1 = this;
    var chainid = "";
    for (var k = 0; k < 4; ++k) {
      var code = this$1.chainid[4 * i + k];
      if (code) {
        chainid += String.fromCharCode(code);
      } else {
        break;
      }
    }
    return chainid;
  };
  Object.defineProperties(ChainStore2.prototype, prototypeAccessors2);
  return ChainStore2;
}(Store);
var ModelStore = function(Store$$1) {
  function ModelStore2() {
    Store$$1.apply(this, arguments);
  }
  if (Store$$1)
    ModelStore2.__proto__ = Store$$1;
  ModelStore2.prototype = Object.create(Store$$1 && Store$$1.prototype);
  ModelStore2.prototype.constructor = ModelStore2;
  var prototypeAccessors2 = {__fields: {}};
  prototypeAccessors2.__fields.get = function() {
    return [
      ["chainOffset", 1, "uint32"],
      ["chainCount", 1, "uint32"]
    ];
  };
  Object.defineProperties(ModelStore2.prototype, prototypeAccessors2);
  return ModelStore2;
}(Store);
function Helixorient(polymer) {
  this.polymer = polymer;
  this.size = polymer.residueCount;
}
Helixorient.prototype = {
  constructor: Helixorient,
  getCenterIterator: function(smooth) {
    var center2 = this.getPosition().center;
    var n = center2.length / 3;
    var i = 0;
    var j = -1;
    var cache = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    function next() {
      var vector = this.get(j);
      j += 1;
      return vector;
    }
    function get7(idx) {
      idx = Math.min(n - 1, Math.max(0, idx));
      var v = cache[i % 4];
      var idx3 = 3 * idx;
      v.fromArray(center2, idx3);
      if (smooth) {
        var l, k, t;
        var w = Math.min(smooth, idx, n - idx - 1);
        for (k = 1; k <= w; ++k) {
          l = k * 3;
          t = (w + 1 - k) / (w + 1);
          v.x += t * center2[idx3 - l + 0] + t * center2[idx3 + l + 0];
          v.y += t * center2[idx3 - l + 1] + t * center2[idx3 + l + 1];
          v.z += t * center2[idx3 - l + 2] + t * center2[idx3 + l + 2];
        }
        v.x /= w + 1;
        v.y /= w + 1;
        v.z /= w + 1;
      }
      i += 1;
      return v;
    }
    function reset() {
      i = 0;
      j = -1;
    }
    return {
      size: n,
      next,
      get: get7,
      reset
    };
  },
  getColor: function(params) {
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var residueIndexStart = polymer.residueIndexStart;
    var col = new Float32Array(n * 3);
    var p = params || {};
    p.structure = structure;
    var colormaker = ColormakerRegistry2.getScheme(p);
    var rp = structure.getResidueProxy();
    var ap = structure.getAtomProxy();
    for (var i = 0; i < n; ++i) {
      rp.index = residueIndexStart + i;
      ap.index = rp.traceAtomIndex;
      colormaker.atomColorToArray(ap, col, i * 3);
    }
    return {
      color: col
    };
  },
  getPicking: function() {
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var residueIndexStart = polymer.residueIndexStart;
    var pick2 = new Float32Array(n);
    var rp = structure.getResidueProxy();
    for (var i = 0; i < n; ++i) {
      rp.index = residueIndexStart + i;
      pick2[i] = rp.traceAtomIndex;
    }
    return {
      picking: new AtomPicker(pick2, structure)
    };
  },
  getSize: function(type2, scale2) {
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var residueIndexStart = polymer.residueIndexStart;
    var size = new Float32Array(n);
    var radiusFactory = new RadiusFactory(type2, scale2);
    var rp = structure.getResidueProxy();
    var ap = structure.getAtomProxy();
    for (var i = 0; i < n; ++i) {
      rp.index = residueIndexStart + i;
      ap.index = rp.traceAtomIndex;
      size[i] = radiusFactory.atomRadius(ap);
    }
    return {
      size
    };
  },
  getPosition: function() {
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var n3 = n - 3;
    var center2 = new Float32Array(3 * n);
    var axis = new Float32Array(3 * n);
    var diff = new Float32Array(n);
    var radius = new Float32Array(n);
    var rise = new Float32Array(n);
    var twist = new Float32Array(n);
    var resdir = new Float32Array(3 * n);
    var tmp2, j, i;
    var diff13Length, diff24Length;
    var r12 = new Vector3();
    var r23 = new Vector3();
    var r34 = new Vector3();
    var diff13 = new Vector3();
    var diff24 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    var vt = new Vector3();
    var _axis = new Vector3();
    var _prevAxis = new Vector3();
    var _resdir = new Vector3();
    var _center = new Vector3(0, 0, 0);
    var type2 = "trace";
    var a1 = structure.getAtomProxy();
    var a2 = structure.getAtomProxy(polymer.getAtomIndexByType(0, type2));
    var a3 = structure.getAtomProxy(polymer.getAtomIndexByType(1, type2));
    var a4 = structure.getAtomProxy(polymer.getAtomIndexByType(2, type2));
    for (i = 0; i < n3; ++i) {
      a1.index = a2.index;
      a2.index = a3.index;
      a3.index = a4.index;
      a4.index = polymer.getAtomIndexByType(i + 3, type2);
      j = 3 * i;
      r12.subVectors(a2, a1);
      r23.subVectors(a3, a2);
      r34.subVectors(a4, a3);
      diff13.subVectors(r12, r23);
      diff24.subVectors(r23, r34);
      _axis.crossVectors(diff13, diff24).normalize();
      _axis.toArray(axis, j);
      if (i > 0) {
        diff[i] = _axis.angleTo(_prevAxis);
      }
      tmp2 = Math.cos(diff13.angleTo(diff24));
      twist[i] = 180 / Math.PI * Math.acos(tmp2);
      diff13Length = diff13.length();
      diff24Length = diff24.length();
      radius[i] = Math.sqrt(diff24Length * diff13Length) / Math.max(2, 2 * (1 - tmp2));
      rise[i] = Math.abs(r23.dot(_axis));
      v1.copy(diff13).multiplyScalar(radius[i] / diff13Length);
      v2.copy(diff24).multiplyScalar(radius[i] / diff24Length);
      v1.subVectors(a2, v1);
      v2.subVectors(a3, v2);
      v1.toArray(center2, j + 3);
      v2.toArray(center2, j + 6);
      _resdir.subVectors(a1, _center);
      _resdir.toArray(resdir, j);
      _prevAxis.copy(_axis);
      _center.copy(v1);
    }
    v1.fromArray(center2, 3);
    v2.fromArray(center2, 6);
    _axis.subVectors(v1, v2).normalize();
    a1.index = polymer.getAtomIndexByType(0, type2);
    _center.copy(a1);
    vt.copy(a1);
    projectPointOnVector(vt, _axis, v1);
    vt.toArray(center2, 0);
    _resdir.subVectors(_center, v1);
    _resdir.toArray(resdir, 0);
    v1.fromArray(center2, 3 * n - 6);
    v2.fromArray(center2, 3 * n - 9);
    _axis.subVectors(v1, v2).normalize();
    a1.index = polymer.getAtomIndexByType(n - 1, type2);
    _center.copy(a1);
    vt.copy(a1);
    projectPointOnVector(vt, _axis, v1);
    vt.toArray(center2, 3 * n - 3);
    for (i = n - 3; i < n; ++i) {
      v1.fromArray(center2, 3 * i);
      a1.index = polymer.getAtomIndexByType(i, type2);
      _center.copy(a1);
      _resdir.subVectors(_center, v1);
      _resdir.toArray(resdir, 3 * i);
    }
    var resRadius = new Float32Array(n);
    var resTwist = new Float32Array(n);
    var resRise = new Float32Array(n);
    var resBending = new Float32Array(n);
    resRadius[1] = radius[0];
    resTwist[1] = twist[0];
    resRise[1] = radius[0];
    for (i = 2; i < n - 2; ++i) {
      resRadius[i] = 0.5 * (radius[i - 2] + radius[i - 1]);
      resTwist[i] = 0.5 * (twist[i - 2] + twist[i - 1]);
      resRise[i] = 0.5 * (rise[i - 2] + rise[i - 1]);
      v1.fromArray(axis, 3 * (i - 2));
      v2.fromArray(axis, 3 * (i - 1));
      resBending[i] = 180 / Math.PI * Math.acos(Math.cos(v1.angleTo(v2)));
    }
    resRadius[n - 2] = radius[n - 4];
    resTwist[n - 2] = twist[n - 4];
    resRise[n - 2] = rise[n - 4];
    var resAxis = new Float32Array(3 * n);
    copyArray(axis, resAxis, 0, 0, 3);
    copyArray(axis, resAxis, 0, 3, 3);
    for (i = 2; i < n - 2; ++i) {
      v1.fromArray(axis, 3 * (i - 2));
      v2.fromArray(axis, 3 * (i - 1));
      _axis.addVectors(v2, v1).multiplyScalar(0.5).normalize();
      _axis.toArray(resAxis, 3 * i);
    }
    copyArray(axis, resAxis, 3 * n - 12, 3 * n - 6, 3);
    copyArray(axis, resAxis, 3 * n - 12, 3 * n - 3, 3);
    return {
      center: center2,
      axis: resAxis,
      bending: resBending,
      radius: resRadius,
      rise: resRise,
      twist: resTwist,
      resdir
    };
  }
};
function Helixbundle(polymer) {
  this.polymer = polymer;
  this.helixorient = new Helixorient(polymer);
  this.position = this.helixorient.getPosition();
}
Helixbundle.prototype = {
  constructor: Helixbundle,
  getAxis: function(localAngle, centerDist, ssBorder, colorParams, radius, scale2) {
    localAngle = localAngle || 30;
    centerDist = centerDist || 2.5;
    ssBorder = ssBorder === void 0 ? false : ssBorder;
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var residueIndexStart = polymer.residueIndexStart;
    var pos = this.position;
    var cp = colorParams || {};
    cp.structure = structure;
    var colormaker = ColormakerRegistry2.getScheme(cp);
    var radiusFactory = new RadiusFactory(radius, scale2);
    var j = 0;
    var k = 0;
    var axis = [];
    var center2 = [];
    var beg = [];
    var end = [];
    var col = [];
    var pick2 = [];
    var size = [];
    var residueOffset = [];
    var residueCount = [];
    var tmpAxis = [];
    var tmpCenter = [];
    var _axis, _center;
    var _beg = new Vector3();
    var _end = new Vector3();
    var rp1 = structure.getResidueProxy();
    var rp2 = structure.getResidueProxy();
    var ap = structure.getAtomProxy();
    var c1 = new Vector3();
    var c2 = new Vector3();
    var split = false;
    for (var i = 0; i < n; ++i) {
      rp1.index = residueIndexStart + i;
      c1.fromArray(pos.center, i * 3);
      if (i === n - 1) {
        split = true;
      } else {
        rp2.index = residueIndexStart + i + 1;
        c2.fromArray(pos.center, i * 3 + 3);
        if (ssBorder && rp1.sstruc !== rp2.sstruc) {
          split = true;
        } else if (c1.distanceTo(c2) > centerDist) {
          split = true;
        } else if (pos.bending[i] > localAngle) {
          split = true;
        }
      }
      if (split) {
        if (i - j < 4) {
          j = i;
          split = false;
          continue;
        }
        ap.index = rp1.traceAtomIndex;
        tmpAxis = pos.axis.subarray(j * 3 + 3, i * 3);
        tmpCenter = pos.center.subarray(j * 3, i * 3 + 3);
        _axis = calculateMeanVector3(tmpAxis).normalize();
        _center = calculateMeanVector3(tmpCenter);
        _beg.fromArray(tmpCenter);
        projectPointOnVector(_beg, _axis, _center);
        _end.fromArray(tmpCenter, tmpCenter.length - 3);
        projectPointOnVector(_end, _axis, _center);
        _axis.subVectors(_end, _beg);
        _axis.toArray(axis, k);
        _center.toArray(center2, k);
        _beg.toArray(beg, k);
        _end.toArray(end, k);
        colormaker.atomColorToArray(ap, col, k);
        pick2.push(ap.index);
        size.push(radiusFactory.atomRadius(ap));
        residueOffset.push(residueIndexStart + j);
        residueCount.push(residueIndexStart + i + 1 - j);
        k += 3;
        j = i;
        split = false;
      }
    }
    var picking = new Float32Array(pick2);
    return {
      axis: new Float32Array(axis),
      center: new Float32Array(center2),
      begin: new Float32Array(beg),
      end: new Float32Array(end),
      color: new Float32Array(col),
      picking: new AtomPicker(picking, structure),
      size: new Float32Array(size),
      residueOffset,
      residueCount
    };
  }
};
function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.bubbleUp(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },
  peek: function() {
    return this.content[0];
  },
  remove: function(node) {
    var this$1 = this;
    var len = this.content.length;
    for (var i = 0; i < len; i++) {
      if (this$1.content[i] === node) {
        var end = this$1.content.pop();
        if (i !== len - 1) {
          this$1.content[i] = end;
          if (this$1.scoreFunction(end) < this$1.scoreFunction(node)) {
            this$1.bubbleUp(i);
          } else {
            this$1.sinkDown(i);
          }
        }
        return;
      }
    }
    throw new Error("Node not found.");
  },
  size: function() {
    return this.content.length;
  },
  bubbleUp: function(n) {
    var this$1 = this;
    var element = this.content[n];
    while (n > 0) {
      var parentN = Math.floor((n + 1) / 2) - 1;
      var parent = this$1.content[parentN];
      if (this$1.scoreFunction(element) < this$1.scoreFunction(parent)) {
        this$1.content[parentN] = element;
        this$1.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  },
  sinkDown: function(n) {
    var this$1 = this;
    var length = this.content.length;
    var element = this.content[n];
    var elemScore = this.scoreFunction(element);
    var child1Score, child2Score;
    while (true) {
      var child2N = (n + 1) * 2;
      var child1N = child2N - 1;
      var swap = null;
      if (child1N < length) {
        var child1 = this$1.content[child1N];
        child1Score = this$1.scoreFunction(child1);
        if (child1Score < elemScore) {
          swap = child1N;
        }
      }
      if (child2N < length) {
        var child2 = this$1.content[child2N];
        child2Score = this$1.scoreFunction(child2);
        if (child2Score < (swap === null ? elemScore : child1Score)) {
          swap = child2N;
        }
      }
      if (swap !== null) {
        this$1.content[n] = this$1.content[swap];
        this$1.content[swap] = element;
        n = swap;
      } else {
        break;
      }
    }
  }
};
/**
 * Kdtree
 * @class
 * @author Alexander Rose <alexander.rose@weirdbyte.de>, 2016
 * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013
 * @author I4DS http://www.fhnw.ch/i4ds, 2013
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 * @description
 * k-d Tree for typed arrays of 3d points (e.g. for Float32Array), in-place
 * provides fast nearest neighbour search
 *
 * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs
 *
 * Further information (including mathematical properties)
 * http://en.wikipedia.org/wiki/Binary_tree
 * http://en.wikipedia.org/wiki/K-d_tree
 *
 * @example
 * points: [x, y, z, x, y, z, x, y, z, ...]
 * metric: function(a, b){
 *    return Math.pow(a[0]-b[0], 2) + Math.pow(a[1]-b[1], 2) + Math.pow(a[2]-b[2], 2);
 * }
 *
 * @param {Float32Array} points - points
 * @param {Function} metric - metric
 */
function Kdtree$2(points, metric) {
  var n = points.length / 3;
  var maxDepth = 0;
  var indices = new Uint32Array(n);
  for (var i = 0; i < n; ++i) {
    indices[i] = i;
  }
  var nodes = new Int32Array(n * 4);
  var currentNode = 0;
  var currentDim = 0;
  function buildTree(depth, parent, arrBegin, arrEnd) {
    if (depth > maxDepth) {
      maxDepth = depth;
    }
    var plength = arrEnd - arrBegin;
    if (plength === 0) {
      return -1;
    }
    var nodeIndex = currentNode * 4;
    currentNode += 1;
    if (plength === 1) {
      nodes[nodeIndex] = arrBegin;
      nodes[nodeIndex + 1] = -1;
      nodes[nodeIndex + 2] = -1;
      nodes[nodeIndex + 3] = parent;
      return nodeIndex;
    }
    var arrMedian = arrBegin + Math.floor(plength / 2);
    currentDim = depth % 3;
    var j, tmp2, pivotIndex, pivotValue, storeIndex;
    var left = arrBegin;
    var right = arrEnd - 1;
    while (right > left) {
      pivotIndex = left + right >> 1;
      pivotValue = points[indices[pivotIndex] * 3 + currentDim];
      tmp2 = indices[pivotIndex];
      indices[pivotIndex] = indices[right];
      indices[right] = tmp2;
      storeIndex = left;
      for (j = left; j < right; ++j) {
        if (points[indices[j] * 3 + currentDim] < pivotValue) {
          tmp2 = indices[storeIndex];
          indices[storeIndex] = indices[j];
          indices[j] = tmp2;
          ++storeIndex;
        }
      }
      tmp2 = indices[right];
      indices[right] = indices[storeIndex];
      indices[storeIndex] = tmp2;
      pivotIndex = storeIndex;
      if (arrMedian === pivotIndex) {
        break;
      } else if (arrMedian < pivotIndex) {
        right = pivotIndex - 1;
      } else {
        left = pivotIndex + 1;
      }
    }
    nodes[nodeIndex] = arrMedian;
    nodes[nodeIndex + 1] = buildTree(depth + 1, nodeIndex, arrBegin, arrMedian);
    nodes[nodeIndex + 2] = buildTree(depth + 1, nodeIndex, arrMedian + 1, arrEnd);
    nodes[nodeIndex + 3] = parent;
    return nodeIndex;
  }
  function getNodeDepth(nodeIndex) {
    var parentIndex = nodes[nodeIndex + 3];
    if (parentIndex === -1) {
      return 0;
    } else {
      return getNodeDepth(parentIndex) + 1;
    }
  }
  var rootIndex = buildTree(0, -1, 0, n);
  function nearest(point, maxNodes, maxDistance) {
    var bestNodes = new BinaryHeap(function(e) {
      return -e[1];
    });
    function nearestSearch(nodeIndex) {
      var bestChild, otherChild;
      var dimension = getNodeDepth(nodeIndex) % 3;
      var pointIndex = indices[nodes[nodeIndex]] * 3;
      var ownPoint = [
        points[pointIndex + 0],
        points[pointIndex + 1],
        points[pointIndex + 2]
      ];
      var ownDistance = metric(point, ownPoint);
      function saveNode(nodeIndex2, distance3) {
        bestNodes.push([nodeIndex2, distance3]);
        if (bestNodes.size() > maxNodes) {
          bestNodes.pop();
        }
      }
      var leftIndex = nodes[nodeIndex + 1];
      var rightIndex = nodes[nodeIndex + 2];
      if (rightIndex === -1 && leftIndex === -1) {
        if ((bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) && ownDistance <= maxDistance) {
          saveNode(nodeIndex, ownDistance);
        }
        return;
      }
      if (rightIndex === -1) {
        bestChild = leftIndex;
      } else if (leftIndex === -1) {
        bestChild = rightIndex;
      } else {
        if (point[dimension] <= points[pointIndex + dimension]) {
          bestChild = leftIndex;
        } else {
          bestChild = rightIndex;
        }
      }
      nearestSearch(bestChild);
      if ((bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) && ownDistance <= maxDistance) {
        saveNode(nodeIndex, ownDistance);
      }
      var linearPoint = [];
      for (var i3 = 0; i3 < 3; i3 += 1) {
        if (i3 === dimension) {
          linearPoint[i3] = point[i3];
        } else {
          linearPoint[i3] = points[pointIndex + i3];
        }
      }
      var linearDistance = metric(linearPoint, ownPoint);
      if ((bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) && Math.abs(linearDistance) <= maxDistance) {
        if (bestChild === leftIndex) {
          otherChild = rightIndex;
        } else {
          otherChild = leftIndex;
        }
        if (otherChild !== -1) {
          nearestSearch(otherChild);
        }
      }
    }
    nearestSearch(rootIndex);
    var result = [];
    for (var i2 = 0, il = Math.min(bestNodes.size(), maxNodes); i2 < il; i2 += 1) {
      result.push(bestNodes.content[i2]);
    }
    return result;
  }
  function verify(nodeIndex, depth) {
    var count2 = 1;
    if (nodeIndex === void 0) {
      nodeIndex = rootIndex;
      depth = 0;
    }
    if (nodeIndex === -1) {
      throw new Error("node is null");
    }
    var dim = depth % 3;
    var leftIndex = nodes[nodeIndex + 1];
    var rightIndex = nodes[nodeIndex + 2];
    if (leftIndex !== -1) {
      if (points[indices[nodes[leftIndex]] * 3 + dim] > points[indices[nodes[nodeIndex]] * 3 + dim]) {
        throw new Error("left child is > parent!");
      }
      count2 += verify(leftIndex, depth + 1);
    }
    if (rightIndex !== -1) {
      if (points[indices[nodes[rightIndex]] * 3 + dim] < points[indices[nodes[nodeIndex]] * 3 + dim]) {
        throw new Error("right child is < parent!");
      }
      count2 += verify(rightIndex, depth + 1);
    }
    return count2;
  }
  this.rootIndex = rootIndex;
  this.maxDepth = maxDepth;
  this.nearest = nearest;
  this.indices = indices;
  this.nodes = nodes;
  this.verify = verify;
}
function Kdtree(entity, useSquaredDist) {
  if (Debug) {
    Log.time("Kdtree build");
  }
  var metric;
  if (useSquaredDist) {
    metric = function(a, b) {
      var dx = a[0] - b[0];
      var dy = a[1] - b[1];
      var dz = a[2] - b[2];
      return dx * dx + dy * dy + dz * dz;
    };
  } else {
    metric = function(a, b) {
      var dx = a[0] - b[0];
      var dy = a[1] - b[1];
      var dz = a[2] - b[2];
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };
  }
  var points = new Float32Array(entity.atomCount * 3);
  var atomIndices = new Uint32Array(entity.atomCount);
  var i = 0;
  entity.eachAtom(function(ap) {
    points[i + 0] = ap.x;
    points[i + 1] = ap.y;
    points[i + 2] = ap.z;
    atomIndices[i / 3] = ap.index;
    i += 3;
  });
  this.atomIndices = atomIndices;
  this.points = points;
  this.kdtree = new Kdtree$2(points, metric);
  if (Debug) {
    Log.timeEnd("Kdtree build");
  }
}
Kdtree.prototype = {
  nearest: function() {
    var pointArray = new Float32Array(3);
    return function nearest(point, maxNodes, maxDistance) {
      if (point.toArray) {
        point.toArray(pointArray);
      } else if (point.positionToArray) {
        point.positionToArray(pointArray);
      }
      var nodeList = this.kdtree.nearest(pointArray, maxNodes, maxDistance);
      var indices = this.kdtree.indices;
      var nodes = this.kdtree.nodes;
      var atomIndices = this.atomIndices;
      var resultList = [];
      for (var i = 0, n = nodeList.length; i < n; ++i) {
        var d = nodeList[i];
        var nodeIndex = d[0];
        var dist = d[1];
        resultList.push({
          index: atomIndices[indices[nodes[nodeIndex]]],
          distance: dist
        });
      }
      return resultList;
    };
  }()
};
var SymOpCode = {
  " ": "X",
  "!": "Y",
  "#": "Z",
  $: "-X",
  "%": "-Y",
  "&": "-Z",
  "'": "Y+1/2",
  "(": "1/2+X",
  ")": "1/2+Y",
  "*": "1/2-X",
  "+": "1/2+Z",
  ",": "1/2-Y",
  "-": "1/2-Z",
  ".": "X+1/2",
  "/": "Z+1/2",
  "0": "-X+1/2",
  "1": "-Y+1/2",
  "2": "-Z+1/2",
  "3": "1/4+X",
  "4": "1/4-Y",
  "5": "1/4+Z",
  "6": "1/4-X",
  "7": "1/4+Y",
  "8": "3/4-Y",
  "9": "3/4+Z",
  ":": "3/4+Y",
  ";": "3/4+X",
  "<": "3/4-X",
  "=": "1/4-Z",
  ">": "3/4-Z",
  "?": "X-Y",
  "@": "Y-X",
  A: "Z+1/3",
  B: "Z+2/3",
  C: "X+2/3",
  D: "Y+1/3",
  E: "-Y+2/3",
  F: "X-Y+1/3",
  G: "Y-X+2/3",
  H: "-X+1/3",
  I: "X+1/3",
  J: "Y+2/3",
  K: "-Y+1/3",
  L: "X-Y+2/3",
  M: "Y-X+1/3",
  N: "-X+2/3",
  O: "2/3+X",
  P: "1/3+Y",
  Q: "1/3+Z",
  R: "2/3-Y",
  S: "1/3+X-Y",
  T: "2/3+Y-X",
  U: "1/3-X",
  V: "2/3-X",
  W: "1/3-Y",
  X: "1/3-Z",
  Y: "2/3+Y",
  Z: "1/3+Y-X",
  "[": "2/3+X-Y",
  "]": "1/3+X",
  "^": "2/3+Z",
  _: "2/3-Z",
  "`": "5/6+Z",
  a: "1/6+Z",
  b: "5/6-Z",
  c: "1/6-Z",
  d: "Z+5/6",
  e: "Z+1/6",
  f: "Z+1/4",
  g: "+Y"
};
var EncodedSymOp = {
  "P 1": " !#",
  "P -1": " !#$%&",
  "P 1 2 1": " !#$!&",
  "P 1 21 1": " !#$'&",
  "C 1 2 1": " !#$!&()#*)&",
  "P 1 m 1": " !# %#",
  "P 1 c 1": " !# %+",
  "C 1 m 1": " !# %#()#(,#",
  "C 1 c 1": " !# %+()#(,+",
  "P 1 2/m 1": " !# %#$!&$%&",
  "P 1 21/m 1": " !#$)&$%& ,#",
  "C 1 2/m 1": " !# %#$!&$%&()#(,#*)&*,&",
  "P 1 2/c 1": " !#$!-$%& %+",
  "P 1 21/c 1": " !#$%&$)- ,+",
  "C 1 2/c 1": " !#$!-$%& %+()#*)-*,&(,+",
  "P 2 2 2": " !#$%#$!& %&",
  "P 2 2 21": " !#$%+$!- %&",
  "P 21 21 2": " !#$%#*)&(,&",
  "P 21 21 21": " !#*%+$)-(,&",
  "C 2 2 21": " !#$%+$!- %&()#*,+*)-(,&",
  "C 2 2 2": " !#$%#$!& %&()#*,#*)&(,&",
  "F 2 2 2": " !#$%#$!& %& )+$,+$)- ,-(!+*%+*!-(%-()#*,#*)&(,&",
  "I 2 2 2": " !#$%# %&$!&.'/01/.120'2",
  "I 21 21 21": " !#*%+$)-(,&()+$,#*!& %-",
  "P m m 2": " !#$%# %#$!#",
  "P m c 21": " !#$%+ %+$!#",
  "P c c 2": " !#$%# %+$!+",
  "P m a 2": " !#$%#(%#*!#",
  "P c a 21": " !#$%+(%#*!+",
  "P n c 2": " !#$%# ,+$)+",
  "P m n 21": " !#*%+(%+$!#",
  "P b a 2": " !#$%#(,#*)#",
  "P n a 21": " !#$%+(,#*)+",
  "P n n 2": " !#$%#(,+*)+",
  "C m m 2": " !#$%# %#$!#()#*,#(,#*)#",
  "C m c 21": " !#$%+ %+$!#()#*,+(,+*)#",
  "C c c 2": " !#$%# %+$!+()#*,#(,+*)+",
  "A m m 2": " !#$%# %#$!# )+$,+ ,+$)+",
  "A b m 2": " !#$%# ,#$)# )+$,+ %+$!+",
  "A m a 2": " !#$%#(%#*!# )+$,+(,+*)+",
  "A b a 2": " !#$%#(,#*)# )+$,+(%+*!+",
  "F m m 2": " !#$%# %#$!# )+$,+ ,+$)+(!+*%+(%+*!+()#*,#(,#*)#",
  "F d d 2": " !#$%#345675 )+$,+3896:9(!+*%+;49<79()#*,#;85<:5",
  "I m m 2": " !#$%# %#$!#()+*,+(,+*)+",
  "I b a 2": " !#$%#(,#*)#()+*,+ %+$!+",
  "I m a 2": " !#$%#(%#*!#()+*,+ ,+$)+",
  "P 2/m 2/m 2/m": " !#$%#$!& %&$%& !& %#$!#",
  "P 2/n 2/n 2/n": " !#$%#$!& %&*,-()-(,+*)+",
  "P 2/c 2/c 2/m": " !#$%#$!- %-$%& !& %+$!+",
  "P 2/b 2/a 2/n": " !#$%#$!& %&*,&()&(,#*)#",
  "P 21/m 2/m 2/a": " !#*%#$!&(%&$%&(!& %#*!#",
  "P 2/n 21/n 2/a": " !#*%#*)- ,-$%&(!&(,+$)+",
  "P 2/m 2/n 21/a": " !#*%+*!- %&$%&(!-(%+$!#",
  "P 21/c 2/c 2/a": " !#*%#$!-(%-$%&(!& %+*!+",
  "P 21/b 21/a 2/m": " !#$%#*)&(,&$%& !&(,#*)#",
  "P 21/c 21/c 2/n": " !#*,#$)-(%-$%&()& ,+*!+",
  "P 2/b 21/c 21/m": " !#$%+$)- ,&$%& !- ,+$)#",
  "P 21/n 21/n 2/m": " !#$%#*)-(,-$%& !&(,+*)+",
  "P 21/m 21/m 2/n": " !#$%#*'&.,&*,&.'& %#$!#",
  "P 21/b 2/c 21/n": " !#*,+$!-(,&$%&()- %+*)#",
  "P 21/b 21/c 21/a": " !#*%+$)-(,&$%&(!- ,+*)#",
  "P 21/n 21/m 21/a": " !#0%/$'&.12$%&.!2 1#0'/",
  "C 2/m 2/c 21/m": " !#$%+$!- %&$%& !- %+$!#()#*,+*)-(,&*,&()-(,+*)#",
  "C 2/m 2/c 21/a": " !#$,+$)- %&$%& )- ,+$!#()#*%+*!-(,&*,&(!-(%+*)#",
  "C 2/m 2/m 2/m": " !#$%#$!& %&$%& !& %#$!#()#*,#*)&(,&*,&()&(,#*)#",
  "C 2/c 2/c 2/m": " !#$%#$!- %-$%& !& %+$!+()#*,#*)-(,-*,&()&(,+*)+",
  "C 2/m 2/m 2/a": " !#$,#$)& %&$%& )& ,#$!#()#*%#*!&(,&*,&(!&(%#*)#",
  "C 2/c 2/c 2/a": " !#*,#$!&(,&$,-(!- ,+*!+()#$%#*)& %&*%- )-(%+$)+",
  "F 2/m 2/m 2/m": " !#$%#$!& %&$%& !& %#$!# )+$,+$)- ,-$,- )- ,+$)+(!+*%+*!-(%-*%-(!-(%+*!+()#*,#*)&(,&*,&()&(,#*)#",
  "F 2/d 2/d 2/d": " !#$%#$!& %&64=37=345675 )+$,+$)- ,-68>3:>3896:9(!+*%+*!-(%-<4>;7>;49<79()#*,#*)&(,&<8=;:=;85<:5",
  "I 2/m 2/m 2/m": " !#$%#$!& %&$%& !& %#$!#()+*,+*)-(,-*,-()-(,+*)+",
  "I 2/b 2/a 2/m": " !#$%#*)&(,&$%& !&(,#*)#()+*,+$!- %-*,-()- %+$!+",
  "I 21/b 21/c 21/a": " !#*%+$)-(,&$%&(!- ,+*)#()+$,#*!& %-*,- )&(%#$!+",
  "I 21/m 21/m 21/a": " !#$,#$)& %&$%& )& ,#$!#()+*%+*!-(,-*,-(!-(%+*)+",
  "P 4": " !#$%#% #!$#",
  "P 41": " !#$%+% 5!$9",
  "P 42": " !#$%#% +!$+",
  "P 43": " !#$%+% 9!$5",
  "I 4": " !#$%#% #!$#()+*,+,(+)*+",
  "I 41": " !#*,+%(5)$9()+$%#, 9!*5",
  "P -4": " !#$%#!$&% &",
  "I -4": " !#$%#!$&% &()+*,+)*-,(-",
  "P 4/m": " !#$%#% #!$#$%& !&!$&% &",
  "P 42/m": " !#$%#% +!$+$%& !&!$-% -",
  "P 4/n": " !#$%#,(#)*#*,&()&!$&% &",
  "P 42/n": " !#$%#,(+)*+*,-()-!$&% &",
  "I 4/m": " !#$%#% #!$#$%& !&!$&% &()+*,+,(+)*+*,-()-)*-,(-",
  "I 41/a": " !#*,+%(5)$9$,=(!>!$&,(-()+$%#, 9!*5*%> )=)*-% &",
  "P 4 2 2": " !#$%#% #!$#$!& %&! &%$&",
  "P 4 21 2": " !#$%#,(#)*#*)&(,&! &%$&",
  "P 41 2 2": " !#$%+% 5!$9$!& %-! >%$=",
  "P 41 21 2": " !#$%+,(5)*9*)=(,>! &%$-",
  "P 42 2 2": " !#$%#% +!$+$!& %&! -%$-",
  "P 42 21 2": " !#$%#,(+)*+*)-(,-! &%$&",
  "P 43 2 2": " !#$%+% 9!$5$!& %-! =%$>",
  "P 43 21 2": " !#$%+,(9)*5*)>(,=! &%$-",
  "I 4 2 2": " !#$%#% #!$#$!& %&! &%$&()+*,+,(+)*+*)-(,-)(-,*-",
  "I 41 2 2": " !#*,+%(5)$9*!> ,=)(-%$&()+$%#, 9!*5$)=(%>! &,*-",
  "P 4 m m": " !#$%#% #!$# %#$!#%$#! #",
  "P 4 b m": " !#$%#% #!$#(,#*)#,*#)(#",
  "P 42 c m": " !#$%#% +!$+ %+$!+%$#! #",
  "P 42 n m": " !#$%#,(+)*+(,+*)+%$#! #",
  "P 4 c c": " !#$%#% #!$# %+$!+%$+! +",
  "P 4 n c": " !#$%#% #!$#(,+*)+,*+)(+",
  "P 42 m c": " !#$%#% +!$+ %#$!#%$+! +",
  "P 42 b c": " !#$%#% +!$+(,#*)#,*+)(+",
  "I 4 m m": " !#$%#% #!$# %#$!#%$#! #()+*,+,(+)*+(,+*)+,*+)(+",
  "I 4 c m": " !#$%#% #!$# %+$!+%$+! +()+*,+,(+)*+(,#*)#,*#)(#",
  "I 41 m d": " !#*,+%(5)$9 %#*)+%*5) 9()+$%#, 9!*5(,+$!#,$9!(5",
  "I 41 c d": " !#*,+%(5)$9 %+*)#%*9) 5()+$%#, 9!*5(,#$!+,$5!(9",
  "P -4 2 m": " !#$%#% &!$&$!& %&%$#! #",
  "P -4 2 c": " !#$%#% &!$&$!- %-%$+! +",
  "P -4 21 m": " !#$%#% &!$&*)&(,&,*#)(#",
  "P -4 21 c": " !#$%#% &!$&*)-(,-,*+)(+",
  "P -4 m 2": " !#$%#!$&% & %#$!#! &%$&",
  "P -4 c 2": " !#$%#% &!$& %+$!+! -%$-",
  "P -4 b 2": " !#$%#% &!$&(,#*)#)(&,*&",
  "P -4 n 2": " !#$%#% &!$&(,+*)+)(-,*-",
  "I -4 m 2": " !#$%#% &!$& %#$!#! &%$&()+*,+,(-)*-(,+*)+)(-,*-",
  "I -4 c 2": " !#$%#% &!$& %+$!+! -%$-()+*,+,(-)*-(,#*)#)(&,*&",
  "I -4 2 m": " !#$%#% &!$&$!& %&%$#! #()+*,+,(-)*-*)-(,-,*+)(+",
  "I -4 2 d": " !#$%#% &!$&*!>(%>,$9) 9()+*,+,(-)*-$)= ,=%*5!(5",
  "P 4/m 2/m 2/m": " !#$%#% #!$#$!& %&! &%$&$%& !&!$&% & %#$!#%$#! #",
  "P 4/m 2/c 2/c": " !#$%#% #!$#$!- %-! -%$-$%& !&!$&% & %+$!+%$+! +",
  "P 4/n 2/b 2/m": " !#$%#% #!$#$!& %&! &%$&*,&()&)*&,(&(,#*)#,*#)(#",
  "P 4/n 2/n 2/c": " !#$%#% #!$#$!& %&! &%$&*,-()-)*-,(-(,+*)+,*+)(+",
  "P 4/m 21/b 2/m": " !#$%#% #!$#*)&(,&)(&,*&$%& !&!$&% &(,#*)#,*#)(#",
  "P 4/m 21/n 2/c": " !#$%#% #!$#*)-(,-)(-,*-$%& !&!$&% &(,+*)+,*+)(+",
  "P 4/n 21/m 2/m": " !#$%#,(#)*#*)&(,&! &%$&*,&()&!$&% & %#$!#,*#)(#",
  "P 4/n 2/c 2/c": " !#$%#,(#)*#*)-(,-! -%$-*,&()&!$&% & %+$!+,*+)(+",
  "P 42/m 2/m 2/c": " !#$%#% +!$+$!& %&! -%$-$%& !&!$-% - %#$!#%$+! +",
  "P 42/m 2/c 2/m": " !#$%#% +!$+$!- %-! &%$&$%& !&!$-% - %+$!+%$#! #",
  "P 42/n 2/b 2/c": " !#$%#,(+)*+$!- %-)(&,*&*,-()-!$&% &(,#*)#%$+! +",
  "P 42/n 2/n 2/m": " !#$%#,(+)*+$!& %&)(-,*-*,-()-!$&% &(,+*)+%$#! #",
  "P 42/m 21/b 2/c": " !#$%#% +!$+*)&(,&)(-,*-$%& !&!$-% -(,#*)#,*+)(+",
  "P 42/m 21/n 2/m": " !#$%#,./'*/*'-.,-! &%$&$%& !&'*-,.-.,/*'/%$#! #",
  "P 42/n 21/m 2/c": " !#$%#,(+)*+*)-(,-! &%$&*,-()-!$&% & %#$!#,*+)(+",
  "P 42/n 21/c 2/m": " !#$%#,(+)*+*)&(,&! -%$-*,-()-!$&% & %+$!+,*#)(#",
  "I 4/m 2/m 2/m": " !#$%#% #!$#$!& %&! &%$&$%& !&!$&% & %#$!#%$#! #()+*,+,(+)*+*)-(,-)(-,*-*,-()-)*-,(-(,+*)+,*+)(+",
  "I 4/m 2/c 2/m": " !#$%#% #!$#$!- %-! -%$-$%& !&!$&% & %+$!+%$+! +()+*,+,(+)*+*)&(,&)(&,*&*,-()-)*-,(-(,#*)#,*#)(#",
  "I 41/a 2/m 2/d": " !#*,+%(5)$9*!> ,=)(-%$&$,=(!>!$&,(-(,+$!#,$9!(5()+$%#, 9!*5$)=(%>! &,*-*%> )=)*-% & %#*)+%*5) 9",
  "I 41/a 2/c 2/d": " !#*,+%(5)$9*!= ,>)(&%$-$,=(!>!$&,(-(,#$!+,$5!(9()+$%#, 9!*5$)>(%=! -,*&*%> )=)*-% & %+*)#%*9) 5",
  "P 3": " !#%?#@$#",
  "P 31": " !#%?A@$B",
  "P 32": " !#%?B@$A",
  "H 3": " !#%?#@$#CDAEFAGHAIJBKLBMNB",
  "R 3": " !## !!# ",
  "P -3": " !#%?#@$#$%&!@&? &",
  "H -3": " !#%?#@$#$%&!@&? &OPQRSQTUQVWXYZX[]X]Y^W[^ZV^UR_PT_SO_",
  "R -3": " !## !!# $%&&$%%&$",
  "P 3 1 2": " !#%?#@$#%$&@!& ?&",
  "P 3 2 1": " !#%?#@$#! &?%&$@&",
  "P 31 1 2": " !#%?Q@$^%$_@!X ?&",
  "P 31 2 1": " !#%?A@$B! &?%_$@X",
  "P 32 1 2": " !#%?^@$Q%$X@!_ ?&",
  "P 32 2 1": " !#%?B@$A! &?%X$@_",
  "H 3 2": " !#%?#@$#! &?%&$@&OPQRSQTUQY]X[WXVZX]Y^W[^ZV^PO_SR_UT_",
  "R 3 2": " !## !!# %$&$&%&%$",
  "P 3 m 1": " !#%?#@$#%$#@!# ?#",
  "P 3 1 m": " !#%?#@$#! #?%#$@#",
  "P 3 c 1": " !#%?#@$#%$+@!+ ?+",
  "P 3 1 c": " !#%?#@$#! +?%+$@+",
  "H 3 m": " !#%?#@$#%$#@!# ?#OPQRSQTUQRUQTPQOSQ]Y^W[^ZV^WV^ZY^][^",
  "R 3 m": " !## !!# ! # #!#! ",
  "H 3 c": " !#%?#@$#%$+@!+ ?+OPQRSQTUQRU`TP`OS`]Y^W[^ZV^WVaZYa][a",
  "R 3 c": " !## !!# '././'/'.",
  "P -3 1 2/m": " !#%?#@$#%$&@!& ?&$%&!@&? &! #?%#$@#",
  "P -3 1 2/c": " !#%?#@$#%$-@!- ?-$%&!@&? &! +?%+$@+",
  "P -3 2/m 1": " !#%?#@$#! &?%&$@&$%&!@&? &%$#@!# ?#",
  "P -3 2/c 1": " !#%?#@$#! -?%-$@-$%&!@&? &%$+@!+ ?+",
  "H -3 2/m": " !#%?#@$#! &?%&$@&$%&!@&? &%$#@!# ?#OPQRSQTUQY]X[WXVZXVWXYZX[]XRUQTPQOSQ]Y^W[^ZV^PO_SR_UT_UR_PT_SO_WV^ZY^][^",
  "R -3 2/m": " !## !!# %$&$&%&%$$%&&$%%&$! # #!#! ",
  "H -3 2/c": " !#%?#@$#! -?%-$@-$%&!@&? &%$+@!+ ?+OPQRSQTUQY]b[WbVZbVWXYZX[]XRU`TP`OS`]Y^W[^ZV^POcSRcUTcUR_PT_SO_WVaZYa][a",
  "R -3 2/c": " !## !!# 102021210$%&&$%%&$'././'/'.",
  "P 6": " !#%?#@$#$%#!@#? #",
  "P 61": " !#%?A@$B$%/!@d? e",
  "P 65": " !#%?B@$A$%/!@e? d",
  "P 62": " !#%?^@$Q$%#!@^? Q",
  "P 64": " !#%?Q@$^$%#!@Q? ^",
  "P 63": " !#%?#@$#$%+!@+? +",
  "P -6": " !#%?#@$# !&%?&@$&",
  "P 6/m": " !#%?#@$#$%#!@#? #$%&!@&? & !&%?&@$&",
  "P 63/m": " !#%?#@$#$%+!@+? +$%&!@&? & !-%?-@$-",
  "P 6 2 2": " !#%?#@$#$%#!@#? #! &?%&$@&%$&@!& ?&",
  "P 61 2 2": " !#%?Q@$^$%+!@`? a! X?%&$@_%$b@!- ?c",
  "P 65 2 2": " !#%?^@$Q$%+!@a? `! _?%&$@X%$c@!- ?b",
  "P 62 2 2": " !#%?^@$Q$%#!@^? Q! _?%&$@X%$_@!& ?X",
  "P 64 2 2": " !#%?Q@$^$%#!@Q? ^! X?%&$@_%$X@!& ?_",
  "P 63 2 2": " !#%?#@$#$%+!@+? +! &?%&$@&%$-@!- ?-",
  "P 6 m m": " !#%?#@$#$%#!@#? #%$#@!# ?#! #?%#$@#",
  "P 6 c c": " !#%?#@$#$%#!@#? #%$+@!+ ?+! +?%+$@+",
  "P 63 c m": " !#%?#@$#$%+!@+? +%$+@!+ ?+! #?%#$@#",
  "P 63 m c": " !#%?#@$#$%+!@+? +%$#@!# ?#! +?%+$@+",
  "P -6 m 2": " !#%?#@$# !&%?&@$&%$#@!# ?#%$&@!& ?&",
  "P -6 c 2": " !#%?#@$# !-%?-@$-%$+@!+ ?+%$&@!& ?&",
  "P -6 2 m": " !#%?#@$# !&%?&@$&! &?%&$@&! #?%#$@#",
  "P -6 2 c": " !#%?#@$# !-%?-@$-! &?%&$@&! +?%+$@+",
  "P 6/m 2/m 2/m": " !#%?#@$#$%#!@#? #! &?%&$@&%$&@!& ?&$%&!@&? & !&@$&%?&%$#@!# ?#! #?%#$@#",
  "P 6/m 2/c 2/c": " !#%?#@$#$%#!@#? #! -?%-$@-%$-@!- ?-$%&!@&? & !&@$&%?&%$+@!+ ?+! +?%+$@+",
  "P 63/m 2/c 2/m": " !#%?#@$#$%+!@+? +! -?%-$@-%$&@!& ?&$%&!@&? & !-@$-%?-%$+@!+ ?+! #?%#$@#",
  "P 63/m 2/m 2/c": " !#%?#@$#$%+!@+? +! &?%&$@&%$-@!- ?-$%&!@&? & !-@$-%?-%$#@!# ?#! +?%+$@+",
  "P 2 3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ",
  "F 2 3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%&  )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-((!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&(()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- ",
  "I 2 3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ()+*,+*)-(,-+()+*,-*)-(,)+(,+*)-*,-(",
  "P 21 3": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(",
  "I 21 3": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(()+$,#*!& %-+()#$,&*!- %)+(,#$!&*%- ",
  "P 2/m -3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& $%& !& %#$!#&$%& !# %#$!%&$!& %# !#$",
  "P 2/n -3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& *,-()-(,+*)+-*,-()+(,+*),-*)-(,+()+*",
  "F 2/m -3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& $%& !& %#$!#&$%& !# %#$!%&$!& %# !#$ )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-($,- )- ,+$)+&*,&()#(,#*)%-*!-(%+(!+*(!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&(*%-(!-(%+*!+-$,- )+ ,+$),&*)&(,#()#*()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- *,&()&(,#*)#-*%-(!+(%+*!,-$)- ,+ )+$",
  "F 2/d -3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& 64=37=345675=64=375345674=67=3453756 )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-(68>3:>3896:9=<8=;:5;85<:4><7>;49;79<(!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&(<4>;7>;49<79>68>3:93896:8=<:=;85;:5<()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- <8=;:=;8f<:f><4>;79;49<78>6:>3893:96",
  "I 2/m -3": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& $%& !& %#$!#&$%& !# %#$!%&$!& %# !#$()+*,+*)-(,-+()+*,-*)-(,)+(,+*)-*,-(*,-()-(,+*)+-*,-()+(,+*),-*)-(,+()+*",
  "P 21/a -3": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&($%&(!- ,+*)#&$%-(!+ ,#*)%&$!-(,+ )#*",
  "I 21/a -3": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&($%&(!- ,+*)#&$%-(!+ ,#*)%&$!-(,+ )#*()+$,#*g& %-+()#$,&*!- %)+(,#$!&*%- *,- )&(%#$!+-*,& )#(%+$!,-*)& %#(!+$",
  "P 4 3 2": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$",
  "P 42 3 2": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,*",
  "F 4 3 2": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$ )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-(!(-%*-!*+%(+ +,$+)$-, -)#)*#,(&)(&,*(!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&() -,$-)$+, +(#,*#)*&,(&)+!*+%(-!(-%*()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- )(&,*&)*#,(#(+%*+!*-%(-!+)$+, -) -,$",
  "F 41 3 2": " !#$,+*)&(%-# !+$,&*)-(%!# ,+$)&*%-(:3>46=7<98;5;58<976=43>:97<58;>:3=46 )+$%#*!-(,&#()+*%&$!- ,!+(,#*)-$%& :;=4<>765839;94<5:6>83=79:6543>7;=8<(!+*,#$)- %&+ )#$%-*!&(,)#(%+*!&$,- 73=86>:<54;935469:<=8;>7576983=:;>4<()#*%+$!& ,-+(!#*,-$)& %)+ %#$!-*,&(7;>8<=:69435398657<>4;=:5:<94;=73>86",
  "I 4 3 2": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$()+*,+*)-(,-+()+*,-*)-(,)+(,+*)-*,-()(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,*",
  "P 43 3 2": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(7;>46=:<5839398<5:6=4;>75:<983>7;=46",
  "P 41 3 2": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(:3=8<>7694;5;54697<>83=:97654;=:3>8<",
  "I 41 3 2": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(:3=8<>7694;5;54697<>83=:97654;=:3>8<()+$,#*!& %-+()#$,&*!- %)+(,#$!&*%- 7;>46=:<5839398<5:6=4;>75:<983>7;=46",
  "P -4 3 m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! #%$#!$&% & #!$#%$&! &%#! #%$&!$&% ",
  "F -4 3 m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! #%$#!$&% & #!$#%$&! &%#! #%$&!$&%  )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-(!(+%*+!*-%(- +)$+,$-) -,#)(#,*&)*&,((!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&() +,$+)$-, -(#)*#,*&)(&,+!(+%*-!*-%(()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- )(#,*#)*&,(&(+!*+%*-!(-%+) +,$-)$-, ",
  "I -4 3 m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! #%$#!$&% & #!$#%$&! &%#! #%$&!$&% ()+*,+*)-(,-+()+*,-*)-(,)+(,+*)-*,-()(+,*+)*-,(-(+)*+,*-)(-,+)(+,*-)*-,(",
  "P -4 3 n": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(+,*+)*-,(-(+)*+,*-)(-,+)(+,*-)*-,(",
  "F -4 3 c": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(+,*+)*-,(-(+)*+,*-)(-,+)(+,*-)*-,( )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-() #,$#)$&, &(#!*#%*&!(&%+! +%$-!$-% (!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&(!(#%*#!*&%(& +!$+%$-! -%#) #,$&)$&, ()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- ! +%$+!$-% - #)$#,$&) &,#!(#%*&!*&%(",
  "I -4 3 d": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(7354<9:6>8;=357<946>:;=857394<>:6=8;()+$,#*!& %-+()#$,&*!- %)+(,#$!&*%- :;98657<=43>;9:658<=73>49:;586=7<>43",
  "P 4/m -3 2/m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$$%& !& %#$!#&$%& !# %#$!%&$!& %# !#$%$#! #% &!$&$&! &% #!$#%&% &!$#%$#! ",
  "P 4/n -3 2/n": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$*,-()-(,+*)+-*,-()+(,+*),-*)-(,+()+*,*+)(+,(-)*-*-)(-,(+)*+,-,(-)*+,*+)(",
  "P 42/m -3 2/n": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,*$%& !& %#$!#&$%& !# %#$!%&$!& %# !#$,*+)(+,(-)*-*-)(-,(+)*+,-,(-)*+,*+)(",
  "P 42/n -3 2/m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,**,-()-(,+*)+-*,-()+(,+*),-*)-(,+()+*%$#! #% &!$&$&! &% #!$#%&% &!$#%$#! ",
  "F 4/m -3 2/m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$$%& !& %#$!#&$%& !# %#$!%&$!& %# !#$%$#! #% &!$&$&! &% #!$#%&% &!$#%$#!  )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-(!(-%*-!*+%(+ +,$+)$-, -)#)*#,(&)(&,*$,- )- ,+$)+&*,&()#(,#*)%-*!-(%+(!+*%*+!(+%(-!*-$-) -, +)$+,&,(&)*#,*#)((!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&() -,$-)$+, +(#,*#)*&,(&)+!*+%(-!(-%**%-(!-(%+*!+-$,- )+ ,+$),&*)&(,#()#*,$+) +, -)$-*&)(&,(#)*#,-%(-!*+%*+!(()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- )(&,*&)*#,(#(+%*+!*-%(-!+)$+, -) -,$*,&()&(,#*)#-*%-(!+(%+*!,-$)- ,+ )+$,*#)(#,(&)*&*-!(-%(+!*+%-, -)$+,$+) ",
  "F 4/m -3 2/c": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& )(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,*$%& !& %#$!#&$%& !# %#$!%&$!& %# !#$,*+)(+,(-)*-*-)(-,(+)*+,-,(-)*+,*+)( )+$,+$)- ,-#()#*,&*)&(,!+(%+*!-*%-() &,$&)$#, #(#%*#!*&%(&!+!$+% -! -%$$,- )- ,+$)+&*,&()#(,#*)%-*!-(%+(!+*,$#) #, &)$&*&!(&%(#!*#%-% -!$+%$+! (!+*%+*!-(%-+ )+$,-$)- ,)#(,#*)&*,&(!(&%*&!*#%(# +%$+!$-% -!#)$#, &) &,$*%-(!-(%+*!+-$,- )+ ,+$),&*)&(,#()#*%*#!(#%(&!*&$-! -% +!$+%&, &)$#,$#) ()#*,#*)&(,&+(!+*%-*!-(%)+ ,+$)-$,- ! -%$-!$+% + #,$#)$&, &)#!*#%(&!(&%**,&()&(,#*)#-*%-(!+(%+*!,-$)- ,+ )+$%$+! +% -!$-$&) &, #)$#,&%(&!*#%*#!(",
  "F 41/d -3 2/m": " !#$,+*)&(%-# !+$,&*)-(%!# ,+$)&*%-(:3>46=7<98;5;58<976=43>:97<58;>:3=4664=3:>;85<79=64>3:5;89<74=6:>385;79<,$+! #%(-)*&*&)(-% #!$+,-%(&)*+,$#!  )+$%#*!-(,&#()+*%&$!- ,!+(,#*)-$%& :;=4<>765839;94<5:6>83=79:6543>7;=8<68>37=;49<:5=<8>;753496:4><:=;893756,*#!(+% &)$-*-!(&, +)$#%-, &!$+%*#)((!+*,#$)- %&+ )#$%-*!&(,)#(%+*!&$,- 73=86>:<54;935469:<=8;>7576983=:;>4<<4>;:=389675>68=379;45<:8=<7>;453:96%$#) +,(&!*-$&! -,(#)*+%&% -)$#,*+!(()#*%+$!& ,-+(!#*,-$)& %)+ %#$!-*,&(7;>8<=:69435398657<>4;=:5:<94;=73>86<8=;7>3456:9><4=;:9385678>67=349;:5<%*+)(#, -!$&$-) &%(+!*#,&,(-!*#%$+) ",
  "F 41/d -3 2/c": " !#$,+*)&(%-# !+$,&*)-(%!# ,+$)&*%-(:3>46=7<98;5;58<976=43>:97<58;>:3=46<8>;7=3496:5><8=;793456:8><7=;493:56%*#)(+, &!$-$-! &,(+)*#%&, -!$#%*+)( )+$%#*!-(,&#()+*%&$!- ,!+(,#*)-$%& :;=4<>765839;94<5:6>83=79:6543>7;=8<<4=;:>385679>64=3:9;85<78=67>345;:9<%$+) #,(-!*&$&) -%(#!*+,&%(-)*#,$+! (!+*,#$)- %&+ )#$%-*!&(,)#(%+*!&$,- 73=86>:<54;935469:<=8;>7576983=:;>4<68=37>;45<:9=<4>;:5389674>6:=389;75<,*+!(#% -)$&*-)(&% +!$#,-,(&!*+%$#) ()#*%+$!& ,-+(!#*,-$)& %)+ %#$!-*,&(7;>8<=:69435398657<>4;=:5:<94;=73>8664>3:=;89<75=68>375;49<:4=<:>;853796,$#! +%(&)*-*&!(-, #)$+%-% &)$+,*#!(",
  "I 4/m -3 2/m": " !#$%#$!& %&# !#$%&$!& %!# %#$!&$%& ! &%$&!$#% # #%$#!$&% &!#!$#% &! &%$$%& !& %#$!#&$%& !# %#$!%&$!& %# !#$%$#! #% &!$&$&! &% #!$#%&% &!$#%$#! ()+*,+*)-(,-+()+*,-*)-(,)+(,+*)-*,-()(-,*-)*+,(+(+,*+)*-,(-)+)*+,(-)(-,**,-()-(,+*)+-*,-()+(,+*),-*)-(,+()+*,*+)(+,(-)*-*-)(-,(+)*+,-,(-)*+,*+)(",
  "I 41/a -3 2/d": " !#*%+$)-(,&# !+*%-$)&(,!# %+*)-$,&(:3=8<>7694;5;54697<>83=:97654;=:3>8<$%&(!- ,+*)#&$%-(!+ ,#*)%&$!-(,+ )#*4<97358;=:6>6>:;=8357<94=8;>:694<573()+$,#*!& %-+()#$,&*!- %)+(,#$!&*%- 7;>46=:<5839398<5:6=4;>75:<983>7;=46*,- )&(%#$!+-*,& )#(%+$!,-*)& %#(!+$865:;943>7<=<=73>4;9:658>43=7<5869:;",
  "P 1 1 2": " !#$%#",
  "P 1 1 21": " !#$%+",
  "B 1 1 2": " !#$%#(g+*%+",
  "A 1 2 1": " !#$!& )+$)-",
  "C 1 21 1": " !#$)&()#*!&",
  "I 1 2 1": " !#$!&.'/0'2",
  "I 1 21 1": " !#$)&.'/0!-",
  "P 1 1 m": " !# !&",
  "P 1 1 b": " !# )&",
  "B 1 1 m": " !# !&(!+(!-",
  "B 1 1 b": " !# )&(!+()-",
  "P 1 1 2/m": " !# !&$%#$%&",
  "P 1 1 21/m": " !#$%+$%& !-",
  "B 1 1 2/m": " !# !&$%#$%&(!+(!-*%+*%-",
  "P 1 1 2/b": " !#$,#$%& )&",
  "P 1 1 21/b": " !#$%&$,+ )-",
  "B 1 1 2/b": " !#$,#$%& )&(!+*,+*%-()-",
  "P 21 2 2": " !#$!&(%&*%#",
  "P 2 21 2": " !# ,&$)&$%#",
  "P 21 21 2 (a)": " !#*,#.%&$'&",
  "P 21 2 21": " !#$!&(%-*%+",
  "P 2 21 21": " !# %&$)-$,+",
  "C 2 2 21a)": " !#*%+(,&$)-()#$,+ %&*!-",
  "C 2 2 2a": " !#*,#.%&$'&()#$%# ,&*!&",
  "F 2 2 2a": " !#*,#.%&$'& '/*%/.12$!2.!/$,/ %20'2.'#$%# 1&0!&",
  "I 2 2 2a": " !#*,#.%&$'&()+$%+*!- ,-",
  "P 21/m 21/m 2/n a": " !#*,#$)&(%&$%&.'& ,#*!#",
  "P 42 21 2a": " !#*,#%.+'$+$'&.%&! -,*-",
  "I 2 3a": " !#*,#.%&$'&!# ,- '&$%/$# !-*!/$%&.%()+$%+ ,-*!-)+(%&(!-*,#*+()&$)#*,- ,"
};
function getSymmetryOperations(spacegroup) {
  var encodedSymopList = EncodedSymOp[spacegroup];
  var matrixDict = {};
  if (encodedSymopList === void 0) {
    console.warn("getSymmetryOperations: spacegroup '" + spacegroup + "' not found in symop library");
    return matrixDict;
  }
  var symopList = [];
  for (var i = 0, il = encodedSymopList.length; i < il; i += 3) {
    var symop = [];
    for (var j = 0; j < 3; ++j) {
      symop.push(SymOpCode[encodedSymopList[i + j]]);
    }
    symopList.push(symop);
  }
  var reInteger = /^[1-9]$/;
  symopList.forEach(function(symop2) {
    var row = 0;
    var matrix2 = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
    var me = matrix2.elements;
    matrixDict[symop2] = matrix2;
    symop2.forEach(function(elm) {
      var negate = false;
      var denominator = false;
      for (var i2 = 0, n = elm.length; i2 < n; ++i2) {
        var c = elm[i2];
        if (c === "-") {
          negate = true;
        } else if (c === "+") {
          negate = false;
        } else if (c === "/") {
          denominator = true;
        } else if (c === "X") {
          me[0 + row] = negate ? -1 : 1;
        } else if (c === "Y") {
          me[4 + row] = negate ? -1 : 1;
        } else if (c === "Z") {
          me[8 + row] = negate ? -1 : 1;
        } else if (reInteger.test(c)) {
          var integer = parseInt(c);
          if (denominator) {
            me[12 + row] /= integer;
          } else {
            me[12 + row] = integer;
          }
        } else {
          Log.warn('getSymmetryOperations: unknown token "' + c + '"');
        }
      }
      row += 1;
    });
  });
  return matrixDict;
}
function selectionFromChains(chainList) {
  var sele = "";
  if (chainList.length > 0) {
    sele = ":" + uniqueArray(chainList).join(" OR :");
  }
  return new Selection(sele);
}
var Assembly = function Assembly2(name) {
  this.name = name || "";
  this.partList = [];
};
var prototypeAccessors$16 = {type: {}};
prototypeAccessors$16.type.get = function() {
  return "Assembly";
};
Assembly.prototype.addPart = function addPart(matrixList, chainList) {
  var part = new AssemblyPart(matrixList, chainList);
  this.partList.push(part);
  return part;
};
Assembly.prototype._getCount = function _getCount(structure, methodName) {
  var count2 = 0;
  this.partList.forEach(function(part) {
    count2 += part[methodName](structure);
  });
  return count2;
};
Assembly.prototype.getAtomCount = function getAtomCount(structure) {
  return this._getCount(structure, "getAtomCount");
};
Assembly.prototype.getResidueCount = function getResidueCount(structure) {
  return this._getCount(structure, "getResidueCount");
};
Assembly.prototype.getInstanceCount = function getInstanceCount() {
  var instanceCount = 0;
  this.partList.forEach(function(part) {
    instanceCount += part.matrixList.length;
  });
  return instanceCount;
};
Assembly.prototype.isIdentity = function isIdentity(structure) {
  if (this.partList.length !== 1) {
    return false;
  }
  var part = this.partList[0];
  if (part.matrixList.length !== 1) {
    return false;
  }
  var identityMatrix = new Matrix4();
  if (!identityMatrix.equals(part.matrixList[0])) {
    return false;
  }
  var structureChainList = [];
  structure.eachChain(function(cp) {
    structureChainList.push(cp.chainname);
  });
  structureChainList = uniqueArray(structureChainList);
  if (part.chainList.length !== structureChainList.length) {
    return false;
  }
  return true;
};
Assembly.prototype.getBoundingBox = function getBoundingBox(structure) {
  var boundingBox = new Box3();
  this.partList.forEach(function(part) {
    var partBox = part.getBoundingBox(structure);
    boundingBox.expandByPoint(partBox.min);
    boundingBox.expandByPoint(partBox.max);
  });
  return boundingBox;
};
Assembly.prototype.getCenter = function getCenter(structure) {
  return this.getBoundingBox(structure).getCenter();
};
Assembly.prototype.getSelection = function getSelection() {
  var chainList = [];
  this.partList.forEach(function(part) {
    chainList = chainList.concat(part.chainList);
  });
  return selectionFromChains(chainList);
};
Object.defineProperties(Assembly.prototype, prototypeAccessors$16);
var AssemblyPart = function AssemblyPart2(matrixList, chainList) {
  this.matrixList = matrixList || [];
  this.chainList = chainList || [];
};
var prototypeAccessors$1$2 = {type: {}};
prototypeAccessors$1$2.type.get = function() {
  return "AssemblyPart";
};
AssemblyPart.prototype._getCount = function _getCount2(structure, propertyName) {
  var count2 = 0;
  var chainList = this.chainList;
  structure.eachChain(function(cp) {
    if (chainList.length === 0 || chainList.includes(cp.chainname)) {
      count2 += cp[propertyName];
    }
  });
  return this.matrixList.length * count2;
};
AssemblyPart.prototype.getAtomCount = function getAtomCount2(structure) {
  return this._getCount(structure, "atomCount");
};
AssemblyPart.prototype.getResidueCount = function getResidueCount2(structure) {
  return this._getCount(structure, "residueCount");
};
AssemblyPart.prototype.getBoundingBox = function getBoundingBox2(structure) {
  var partBox = new Box3();
  var instanceBox = new Box3();
  var selection = this.getSelection();
  var structureBox = structure.getBoundingBox(selection);
  this.matrixList.forEach(function(matrix2) {
    instanceBox.copy(structureBox).applyMatrix4(matrix2);
    partBox.expandByPoint(instanceBox.min);
    partBox.expandByPoint(instanceBox.max);
  });
  return partBox;
};
AssemblyPart.prototype.getSelection = function getSelection2() {
  return selectionFromChains(this.chainList);
};
AssemblyPart.prototype.getView = function getView(structure) {
  var selection = this.getSelection();
  if (selection) {
    return structure.getView(selection);
  } else {
    return structure;
  }
};
AssemblyPart.prototype.getInstanceList = function getInstanceList() {
  var this$1 = this;
  var instanceList = [];
  for (var j = 0, jl = this.matrixList.length; j < jl; ++j) {
    instanceList.push({
      id: j + 1,
      name: j,
      matrix: this$1.matrixList[j]
    });
  }
  return instanceList;
};
Object.defineProperties(AssemblyPart.prototype, prototypeAccessors$1$2);
function assignSecondaryStructure(structure, secStruct) {
  if (!secStruct) {
    return;
  }
  if (Debug) {
    Log.time("assignSecondaryStructure");
  }
  var chainnames = [];
  structure.eachModel(function(mp) {
    mp.eachChain(function(cp) {
      chainnames.push(cp.chainname);
    });
  });
  var chainnamesSorted = chainnames.slice().sort();
  var chainnamesIndex = [];
  chainnamesSorted.forEach(function(c) {
    chainnamesIndex.push(chainnames.indexOf(c));
  });
  var helices = secStruct.helices;
  helices = helices.filter(function(h) {
    return binarySearchIndexOf(chainnamesSorted, h[0]) >= 0;
  });
  helices.sort(function(h1, h2) {
    var c1 = h1[0];
    var c2 = h2[0];
    var r1 = h1[1];
    var r2 = h2[1];
    if (c1 === c2) {
      if (r1 === r2) {
        return 0;
      } else {
        return r1 < r2 ? -1 : 1;
      }
    } else {
      var idx1 = binarySearchIndexOf(chainnamesSorted, c1);
      var idx2 = binarySearchIndexOf(chainnamesSorted, c2);
      return chainnamesIndex[idx1] < chainnamesIndex[idx2] ? -1 : 1;
    }
  });
  var residueStore = structure.residueStore;
  structure.eachModel(function(mp) {
    var i = 0;
    var n = helices.length;
    if (n === 0) {
      return;
    }
    var helix = helices[i];
    var helixRun = false;
    var done = false;
    mp.eachChain(function(cp) {
      var chainChange = false;
      if (cp.chainname === helix[0]) {
        var count2 = cp.residueCount;
        var offset = cp.residueOffset;
        var end = offset + count2;
        for (var j = offset; j < end; ++j) {
          if (residueStore.resno[j] === helix[1] && residueStore.getInscode(j) === helix[2]) {
            helixRun = true;
          }
          if (helixRun) {
            residueStore.sstruc[j] = helix[6];
            if (residueStore.resno[j] === helix[4] && residueStore.getInscode(j) === helix[5]) {
              helixRun = false;
              i += 1;
              if (i < n) {
                j = offset - 1;
                helix = helices[i];
                chainChange = cp.chainname !== helix[0];
              } else {
                done = true;
              }
            }
          }
          if (chainChange || done) {
            return;
          }
        }
      }
    });
  });
  var sheets = secStruct.sheets;
  sheets = sheets.filter(function(s) {
    return binarySearchIndexOf(chainnamesSorted, s[0]) >= 0;
  });
  sheets.sort(function(s1, s2) {
    var c1 = s1[0];
    var c2 = s2[0];
    if (c1 === c2) {
      return 0;
    }
    var idx1 = binarySearchIndexOf(chainnamesSorted, c1);
    var idx2 = binarySearchIndexOf(chainnamesSorted, c2);
    return chainnamesIndex[idx1] < chainnamesIndex[idx2] ? -1 : 1;
  });
  var strandCharCode = "e".charCodeAt(0);
  structure.eachModel(function(mp) {
    var i = 0;
    var n = sheets.length;
    if (n === 0) {
      return;
    }
    var sheet = sheets[i];
    var sheetRun = false;
    var done = false;
    mp.eachChain(function(cp) {
      var chainChange = false;
      if (cp.chainname === sheet[0]) {
        var count2 = cp.residueCount;
        var offset = cp.residueOffset;
        var end = offset + count2;
        for (var j = offset; j < end; ++j) {
          if (residueStore.resno[j] === sheet[1] && residueStore.getInscode(j) === sheet[2]) {
            sheetRun = true;
          }
          if (sheetRun) {
            residueStore.sstruc[j] = strandCharCode;
            if (residueStore.resno[j] === sheet[4] && residueStore.getInscode(j) === sheet[5]) {
              sheetRun = false;
              i += 1;
              if (i < n) {
                j = offset - 1;
                sheet = sheets[i];
                chainChange = cp.chainname !== sheet[0];
              } else {
                done = true;
              }
            }
          }
          if (chainChange || done) {
            return;
          }
        }
      }
    });
  });
  if (Debug) {
    Log.timeEnd("assignSecondaryStructure");
  }
}
var calculateSecondaryStructure = function() {
  var zhangSkolnickSS = function(polymer, i, distances, delta) {
    var structure = polymer.structure;
    var offset = polymer.residueIndexStart;
    var rp1 = structure.getResidueProxy();
    var rp2 = structure.getResidueProxy();
    var ap1 = structure.getAtomProxy();
    var ap2 = structure.getAtomProxy();
    for (var j = Math.max(0, i - 2); j <= i; ++j) {
      for (var k = 2; k < 5; ++k) {
        if (j + k >= polymer.residueCount) {
          continue;
        }
        rp1.index = offset + j;
        rp2.index = offset + j + k;
        ap1.index = rp1.traceAtomIndex;
        ap2.index = rp2.traceAtomIndex;
        var d = ap1.distanceTo(ap2);
        if (Math.abs(d - distances[k - 2]) > delta) {
          return false;
        }
      }
    }
    return true;
  };
  var isHelical = function(polymer, i) {
    var helixDistances = [5.45, 5.18, 6.37];
    var helixDelta = 2.1;
    return zhangSkolnickSS(polymer, i, helixDistances, helixDelta);
  };
  var isSheet3 = function(polymer, i) {
    var sheetDistances = [6.1, 10.4, 13];
    var sheetDelta = 1.42;
    return zhangSkolnickSS(polymer, i, sheetDistances, sheetDelta);
  };
  var proteinPolymer = function(p) {
    var residueStore = p.residueStore;
    var offset = p.residueIndexStart;
    for (var i = 0, il = p.residueCount; i < il; ++i) {
      var sstruc = "c";
      if (isHelical(p, i)) {
        sstruc = "h";
      } else if (isSheet3(p, i)) {
        sstruc = "s";
      }
      residueStore.sstruc[offset + i] = sstruc.charCodeAt(0);
    }
  };
  var cgPolymer = function(p) {
    var localAngle = 20;
    var centerDist = 2;
    var residueStore = p.residueStore;
    var offset = p.residueIndexStart;
    var helixbundle = new Helixbundle(p);
    var pos = helixbundle.position;
    var c1 = new Vector3();
    var c2 = new Vector3();
    for (var i = 0, il = p.residueCount; i < il; ++i) {
      c1.fromArray(pos.center, i * 3);
      c2.fromArray(pos.center, i * 3 + 3);
      var d = c1.distanceTo(c2);
      if (d < centerDist && d > 1 && pos.bending[i] < localAngle) {
        residueStore.sstruc[offset + i] = "h".charCodeAt(0);
        residueStore.sstruc[offset + i + 1] = "h".charCodeAt(0);
      }
    }
  };
  return function calculateSecondaryStructure2(structure) {
    if (Debug) {
      Log.time("calculateSecondaryStructure");
    }
    structure.eachPolymer(function(p) {
      if (p.residueCount < 4) {
        return;
      }
      if (p.isCg()) {
        cgPolymer(p);
      } else if (p.isProtein()) {
        proteinPolymer(p);
      } else {
        return;
      }
      var prevSstruc;
      var sstrucCount = 0;
      p.eachResidue(function(r) {
        if (r.sstruc === prevSstruc) {
          sstrucCount += 1;
        } else {
          if (sstrucCount === 1) {
            r.index -= 1;
            r.sstruc = "c";
          }
          sstrucCount = 1;
          prevSstruc = r.sstruc;
        }
      });
    });
    if (Debug) {
      Log.timeEnd("calculateSecondaryStructure");
    }
  };
}();
function calculateChainnames(structure) {
  if (Debug) {
    Log.time("calculateChainnames");
  }
  var doAutoChainName = true;
  structure.eachChain(function(c) {
    if (c.chainname) {
      doAutoChainName = false;
    }
  });
  if (doAutoChainName) {
    var names = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var n = names.length;
    var modelStore = structure.modelStore;
    var chainStore = structure.chainStore;
    var residueStore = structure.residueStore;
    var addChain = function(mIndex, chainname, rOffset, rCount) {
      var ci = chainStore.count;
      for (var i2 = 0; i2 < rCount; ++i2) {
        residueStore.chainIndex[rOffset + i2] = ci;
      }
      chainStore.growIfFull();
      chainStore.modelIndex[ci] = mIndex;
      chainStore.setChainname(ci, chainname);
      chainStore.setChainid(ci, chainname);
      chainStore.residueOffset[ci] = rOffset;
      chainStore.residueCount[ci] = rCount;
      chainStore.count += 1;
      modelStore.chainCount[mIndex] += 1;
    };
    var getName = function(i2) {
      var j = i2;
      var k = 0;
      var chainname = names[j % n];
      while (j >= n) {
        j = Math.floor(j / n);
        chainname += names[j % n];
        k += 1;
      }
      if (k >= 5) {
        Log.warn("chainname overflow");
      }
      return chainname;
    };
    var ap1 = structure.getAtomProxy();
    var ap2 = structure.getAtomProxy();
    var i = 0;
    var mi = 0;
    var rStart = 0;
    var rEnd = 0;
    var chainData = [];
    if (residueStore.count === 1) {
      chainData.push({
        mIndex: 0,
        chainname: "A",
        rStart: 0,
        rCount: 1
      });
    } else {
      structure.eachResidueN(2, function(rp1, rp2) {
        var newChain = false;
        var bbType1 = rp1.backboneType;
        var bbType2 = rp2.backboneType;
        var bbTypeUnk = UnknownBackboneType;
        rEnd = rp1.index;
        if (rp1.modelIndex !== rp2.modelIndex) {
          newChain = true;
        } else if (rp1.moleculeType !== rp2.moleculeType) {
          newChain = true;
        } else if (bbType1 !== bbTypeUnk && bbType1 === bbType2) {
          ap1.index = rp1.backboneEndAtomIndex;
          ap2.index = rp2.backboneStartAtomIndex;
          if (!ap1.connectedTo(ap2)) {
            newChain = true;
          }
        }
        if (!newChain && rp2.index === residueStore.count - 1) {
          newChain = true;
          rEnd = rp2.index;
        }
        if (newChain) {
          chainData.push({
            mIndex: mi,
            chainname: getName(i),
            rStart,
            rCount: rEnd - rStart + 1
          });
          i += 1;
          if (rp1.modelIndex !== rp2.modelIndex) {
            i = 0;
            mi += 1;
          }
          if (rp2.index === residueStore.count - 1 && rEnd !== rp2.index) {
            chainData.push({
              mIndex: mi,
              chainname: getName(i),
              rStart: residueStore.count - 1,
              rCount: 1
            });
          }
          rStart = rp2.index;
          rEnd = rp2.index;
        }
      });
    }
    chainStore.count = 0;
    chainData.forEach(function(d) {
      addChain(d.mIndex, d.chainname, d.rStart, d.rCount);
    });
    var chainOffset = 0;
    structure.eachModel(function(mp) {
      modelStore.chainOffset[mp.index] = chainOffset;
      modelStore.chainCount[mp.index] -= 1;
      chainOffset += modelStore.chainCount[mp.index];
    });
  }
  if (Debug) {
    Log.timeEnd("calculateChainnames");
  }
}
function calculateBonds(structure) {
  if (Debug) {
    Log.time("calculateBonds");
  }
  calculateBondsWithin(structure);
  calculateBondsBetween(structure);
  if (Debug) {
    Log.timeEnd("calculateBonds");
  }
}
function calculateResidueBonds(r) {
  var structure = r.structure;
  var a1 = structure.getAtomProxy();
  var a2 = structure.getAtomProxy();
  var count2 = r.atomCount;
  var offset = r.atomOffset;
  var end = offset + count2;
  var end1 = end - 1;
  if (count2 > 500) {
    if (Debug) {
      Log.warn("more than 500 atoms, skip residue for auto-bonding", r.qualifiedName());
    }
    return;
  }
  var i, j;
  var atomIndices1 = [];
  var atomIndices2 = [];
  var bondOrders = [];
  if (count2 > 50) {
    var kdtree = new Kdtree(r, true);
    var radius = r.isCg() ? 1.2 : 2.3;
    for (i = offset; i < end1; ++i) {
      a1.index = i;
      var maxd = a1.covalent + radius + 0.3;
      var nearestAtoms = kdtree.nearest(a1, Infinity, maxd * maxd);
      var m2 = nearestAtoms.length;
      for (j = 0; j < m2; ++j) {
        a2.index = nearestAtoms[j].index;
        if (a1.index < a2.index) {
          if (a1.connectedTo(a2)) {
            atomIndices1.push(a1.index - offset);
            atomIndices2.push(a2.index - offset);
            bondOrders.push(1);
          }
        }
      }
    }
  } else {
    for (i = offset; i < end1; ++i) {
      a1.index = i;
      for (j = i + 1; j <= end1; ++j) {
        a2.index = j;
        if (a1.connectedTo(a2)) {
          atomIndices1.push(i - offset);
          atomIndices2.push(j - offset);
          bondOrders.push(1);
        }
      }
    }
  }
  return {
    atomIndices1,
    atomIndices2,
    bondOrders
  };
}
function calculateAtomBondMap(structure) {
  if (Debug) {
    Log.time("calculateAtomBondMap");
  }
  var atomBondMap = [];
  structure.eachBond(function(bp) {
    var ai1 = bp.atomIndex1;
    var ai2 = bp.atomIndex2;
    if (atomBondMap[ai1] === void 0) {
      atomBondMap[ai1] = [];
    }
    atomBondMap[ai1][ai2] = bp.index;
  });
  if (Debug) {
    Log.timeEnd("calculateAtomBondMap");
  }
  return atomBondMap;
}
function calculateBondsWithin(structure, onlyAddRung) {
  if (Debug) {
    Log.time("calculateBondsWithin");
  }
  var bondStore = structure.bondStore;
  var rungBondStore = structure.rungBondStore;
  var rungAtomSet = structure.getAtomSet(false);
  var a1 = structure.getAtomProxy();
  var a2 = structure.getAtomProxy();
  var bp = structure.getBondProxy();
  var atomBondMap = onlyAddRung ? null : calculateAtomBondMap(structure);
  structure.eachResidue(function(r) {
    if (!onlyAddRung) {
      var count2 = r.atomCount;
      var offset = r.atomOffset;
      if (count2 > 500) {
        Log.warn("more than 500 atoms, skip residue for auto-bonding", r.qualifiedName());
        return;
      }
      var bonds = r.getBonds();
      var atomIndices1 = bonds.atomIndices1;
      var atomIndices2 = bonds.atomIndices2;
      var bondOrders = bonds.bondOrders;
      var nn = atomIndices1.length;
      for (var i = 0; i < nn; ++i) {
        var ai1 = atomIndices1[i] + offset;
        var ai2 = atomIndices2[i] + offset;
        var tmp2 = atomBondMap[ai1];
        if (tmp2 !== void 0 && (tmp2 = tmp2[ai2]) !== void 0) {
          bp.index = tmp2;
          var residueTypeBondIndex = r.residueType.getBondIndex(ai1, ai2);
          bondOrders[residueTypeBondIndex] = bp.bondOrder;
        } else {
          a1.index = ai1;
          a2.index = ai2;
          bondStore.addBond(a1, a2, bondOrders[i]);
        }
      }
    }
    var traceAtomIndex = r.residueType.traceAtomIndex;
    var rungEndAtomIndex = r.residueType.rungEndAtomIndex;
    if (traceAtomIndex !== -1 && rungEndAtomIndex !== -1) {
      a1.index = r.traceAtomIndex;
      a2.index = r.rungEndAtomIndex;
      rungBondStore.addBond(a1, a2);
      rungAtomSet.set(a1.index);
      rungAtomSet.set(a2.index);
    }
  });
  structure.atomSetDict.rung = rungAtomSet;
  if (Debug) {
    Log.timeEnd("calculateBondsWithin");
  }
}
function calculateBondsBetween(structure, onlyAddBackbone) {
  if (Debug) {
    Log.time("calculateBondsBetween");
  }
  var bondStore = structure.bondStore;
  var backboneBondStore = structure.backboneBondStore;
  var backboneAtomSet = structure.getAtomSet(false);
  var ap1 = structure.getAtomProxy();
  var ap2 = structure.getAtomProxy();
  if (backboneBondStore.count === 0) {
    backboneBondStore.resize(structure.residueStore.count);
  }
  function addBondIfConnected(rp12, rp22) {
    var bbType1 = rp12.backboneType;
    var bbType2 = rp22.backboneType;
    if (bbType1 !== UnknownBackboneType && bbType1 === bbType2) {
      ap1.index = rp12.backboneEndAtomIndex;
      ap2.index = rp22.backboneStartAtomIndex;
      if (ap1.connectedTo(ap2)) {
        if (!onlyAddBackbone) {
          bondStore.addBond(ap1, ap2, 1);
        }
        ap1.index = rp12.traceAtomIndex;
        ap2.index = rp22.traceAtomIndex;
        backboneBondStore.addBond(ap1, ap2);
        backboneAtomSet.set(ap1.index);
        backboneAtomSet.set(ap2.index);
      }
    }
  }
  structure.eachResidueN(2, addBondIfConnected);
  var rp1 = structure.getResidueProxy();
  var rp2 = structure.getResidueProxy();
  structure.eachChain(function(cp) {
    if (cp.residueCount === 0) {
      return;
    }
    rp1.index = cp.residueOffset;
    rp2.index = cp.residueOffset + cp.residueCount - 1;
    addBondIfConnected(rp2, rp1);
  });
  structure.atomSetDict.backbone = backboneAtomSet;
  if (Debug) {
    Log.timeEnd("calculateBondsBetween");
  }
}
function buildUnitcellAssembly(structure) {
  if (!structure.unitcell) {
    return;
  }
  if (Debug) {
    Log.time("buildUnitcellAssembly");
  }
  var uc = structure.unitcell;
  var centerFrac = structure.center.clone().applyMatrix4(uc.cartToFrac);
  var symopDict = getSymmetryOperations(uc.spacegroup);
  var positionFrac = new Vector3();
  var centerFracSymop = new Vector3();
  var positionFracSymop = new Vector3();
  if (centerFrac.x > 1) {
    positionFrac.x -= 1;
  }
  if (centerFrac.x < 0) {
    positionFrac.x += 1;
  }
  if (centerFrac.y > 1) {
    positionFrac.y -= 1;
  }
  if (centerFrac.y < 0) {
    positionFrac.y += 1;
  }
  if (centerFrac.z > 1) {
    positionFrac.z -= 1;
  }
  if (centerFrac.z < 0) {
    positionFrac.z += 1;
  }
  function getMatrixList(shift) {
    var matrixList = [];
    Object.keys(symopDict).forEach(function(name) {
      var m2 = symopDict[name].clone();
      centerFracSymop.copy(centerFrac).applyMatrix4(m2);
      positionFracSymop.setFromMatrixPosition(m2);
      positionFracSymop.sub(positionFrac);
      if (centerFracSymop.x > 1) {
        positionFracSymop.x -= 1;
      }
      if (centerFracSymop.x < 0) {
        positionFracSymop.x += 1;
      }
      if (centerFracSymop.y > 1) {
        positionFracSymop.y -= 1;
      }
      if (centerFracSymop.y < 0) {
        positionFracSymop.y += 1;
      }
      if (centerFracSymop.z > 1) {
        positionFracSymop.z -= 1;
      }
      if (centerFracSymop.z < 0) {
        positionFracSymop.z += 1;
      }
      if (shift) {
        positionFracSymop.add(shift);
      }
      m2.setPosition(positionFracSymop);
      m2.multiplyMatrices(uc.fracToCart, m2);
      m2.multiply(uc.cartToFrac);
      matrixList.push(m2);
    });
    return matrixList;
  }
  var unitcellAssembly = new Assembly("UNITCELL");
  var unitcellMatrixList = getMatrixList();
  var ncsMatrixList;
  if (structure.biomolDict.NCS) {
    ncsMatrixList = [new Matrix4()].concat(structure.biomolDict.NCS.partList[0].matrixList);
    var ncsUnitcellMatrixList = [];
    unitcellMatrixList.forEach(function(sm) {
      ncsMatrixList.forEach(function(nm) {
        ncsUnitcellMatrixList.push(sm.clone().multiply(nm));
      });
    });
    unitcellAssembly.addPart(ncsUnitcellMatrixList);
  } else {
    unitcellAssembly.addPart(unitcellMatrixList);
  }
  var vec = new Vector3();
  var supercellAssembly = new Assembly("SUPERCELL");
  var supercellMatrixList = Array.prototype.concat.call(getMatrixList(vec.set(1, 0, 0)), getMatrixList(vec.set(0, 1, 0)), getMatrixList(vec.set(0, 0, 1)), getMatrixList(vec.set(-1, 0, 0)), getMatrixList(vec.set(0, -1, 0)), getMatrixList(vec.set(0, 0, -1)), getMatrixList(vec.set(1, 1, 0)), getMatrixList(vec.set(1, 0, 1)), getMatrixList(vec.set(0, 1, 1)), getMatrixList(vec.set(-1, -1, 0)), getMatrixList(vec.set(-1, 0, -1)), getMatrixList(vec.set(0, -1, -1)), getMatrixList(vec.set(1, -1, -1)), getMatrixList(vec.set(1, 1, -1)), getMatrixList(vec.set(1, -1, 1)), getMatrixList(vec.set(-1, 1, 1)), getMatrixList(vec.set(-1, -1, 1)), getMatrixList(vec.set(-1, 1, -1)), getMatrixList(vec.set(0, 1, -1)), getMatrixList(vec.set(0, -1, 1)), getMatrixList(vec.set(1, 0, -1)), getMatrixList(vec.set(-1, 0, 1)), getMatrixList(vec.set(1, -1, 0)), getMatrixList(vec.set(-1, 1, 0)), getMatrixList(), getMatrixList(vec.set(1, 1, 1)), getMatrixList(vec.set(-1, -1, -1)));
  if (structure.biomolDict.NCS) {
    var ncsSupercellMatrixList = [];
    supercellMatrixList.forEach(function(sm) {
      ncsMatrixList.forEach(function(nm) {
        ncsSupercellMatrixList.push(sm.clone().multiply(nm));
      });
    });
    supercellAssembly.addPart(ncsSupercellMatrixList);
  } else {
    supercellAssembly.addPart(supercellMatrixList);
  }
  structure.biomolDict.UNITCELL = unitcellAssembly;
  structure.biomolDict.SUPERCELL = supercellAssembly;
  if (Debug) {
    Log.timeEnd("buildUnitcellAssembly");
  }
}
var elm1 = ["H", "C", "O", "N", "S", "P"];
var elm2 = ["NA", "CL", "FE"];
function guessElement(atomName) {
  var at = atomName.trim().toUpperCase();
  if (parseInt(at.charAt(0))) {
    at = at.substr(1);
  }
  if (parseInt(at.charAt(0))) {
    at = at.substr(1);
  }
  var n = at.length;
  if (n === 0) {
    return "";
  }
  if (n === 1) {
    return at;
  }
  if (n === 2) {
    if (elm2.indexOf(at) !== -1) {
      return at;
    }
    if (elm1.indexOf(at[0]) !== -1) {
      return at[0];
    }
  }
  if (n >= 3) {
    if (elm1.indexOf(at[0]) !== -1) {
      return at[0];
    }
  }
  return "";
}
function assignResidueTypeBonds(structure) {
  var bondHash = structure.bondHash;
  var countArray = bondHash.countArray;
  var offsetArray = bondHash.offsetArray;
  var indexArray = bondHash.indexArray;
  var bp = structure.getBondProxy();
  structure.eachResidue(function(rp) {
    var residueType = rp.residueType;
    if (residueType.bonds !== void 0) {
      return;
    }
    var atomOffset = rp.atomOffset;
    var atomIndices1 = [];
    var atomIndices2 = [];
    var bondOrders = [];
    var bondDict = {};
    rp.eachAtom(function(ap) {
      var index = ap.index;
      var offset = offsetArray[index];
      var count2 = countArray[index];
      for (var i = 0, il = count2; i < il; ++i) {
        bp.index = indexArray[offset + i];
        var idx1 = bp.atomIndex1;
        var idx2 = bp.atomIndex2;
        if (idx1 > idx2) {
          var tmp2 = idx2;
          idx2 = idx1;
          idx1 = tmp2;
        }
        var hash = idx1 + "|" + idx2;
        if (bondDict[hash] === void 0) {
          bondDict[hash] = true;
          atomIndices1.push(idx1 - atomOffset);
          atomIndices2.push(idx2 - atomOffset);
          bondOrders.push(bp.bondOrder);
        }
      }
    });
    residueType.bonds = {
      atomIndices1,
      atomIndices2,
      bondOrders
    };
  });
}
var AtomType = function AtomType2(structure, atomname, element) {
  this.structure = structure;
  element = element || guessElement(atomname);
  this.atomname = atomname;
  this.element = element;
  this.vdw = VdwRadii[element];
  this.covalent = CovalentRadii[element];
};
function getHash(atomname, element) {
  return atomname + "|" + element;
}
var AtomMap = function AtomMap2(structure) {
  this.structure = structure;
  this.dict = {};
  this.list = [];
};
AtomMap.prototype.add = function add6(atomname, element) {
  atomname = atomname.toUpperCase();
  if (!element) {
    element = guessElement(atomname);
  } else {
    element = element.toUpperCase();
  }
  var hash = getHash(atomname, element);
  var id = this.dict[hash];
  if (id === void 0) {
    var atomType = new AtomType(this.structure, atomname, element);
    id = this.list.length;
    this.dict[hash] = id;
    this.list.push(atomType);
  }
  return id;
};
AtomMap.prototype.get = function get4(id) {
  return this.list[id];
};
var ResidueType = function ResidueType2(structure, resname, atomTypeIdList, hetero, chemCompType, bonds) {
  this.structure = structure;
  this.resname = resname;
  this.atomTypeIdList = atomTypeIdList;
  this.hetero = hetero ? 1 : 0;
  this.chemCompType = chemCompType;
  this.bonds = bonds;
  this.rings = void 0;
  this.atomCount = atomTypeIdList.length;
  this.moleculeType = this.getMoleculeType();
  this.backboneType = this.getBackboneType(0);
  this.backboneEndType = this.getBackboneType(-1);
  this.backboneStartType = this.getBackboneType(1);
  this.backboneIndexList = this.getBackboneIndexList();
  var atomnames = ResidueTypeAtoms[this.backboneType];
  var atomnamesStart = ResidueTypeAtoms[this.backboneStartType];
  var atomnamesEnd = ResidueTypeAtoms[this.backboneEndType];
  var traceIndex = this.getAtomIndexByName(atomnames.trace);
  this.traceAtomIndex = traceIndex !== void 0 ? traceIndex : -1;
  var dir1Index = this.getAtomIndexByName(atomnames.direction1);
  this.direction1AtomIndex = dir1Index !== void 0 ? dir1Index : -1;
  var dir2Index = this.getAtomIndexByName(atomnames.direction2);
  this.direction2AtomIndex = dir2Index !== void 0 ? dir2Index : -1;
  var bbStartIndex = this.getAtomIndexByName(atomnamesStart.backboneStart);
  this.backboneStartAtomIndex = bbStartIndex !== void 0 ? bbStartIndex : -1;
  var bbEndIndex = this.getAtomIndexByName(atomnamesEnd.backboneEnd);
  this.backboneEndAtomIndex = bbEndIndex !== void 0 ? bbEndIndex : -1;
  var rungEndIndex;
  if (PurinBases.includes(resname)) {
    rungEndIndex = this.getAtomIndexByName("N1");
  } else {
    rungEndIndex = this.getAtomIndexByName("N3");
  }
  this.rungEndAtomIndex = rungEndIndex !== void 0 ? rungEndIndex : -1;
  this.bondReferenceAtomIndices = [];
};
ResidueType.prototype.getBackboneIndexList = function getBackboneIndexList() {
  var backboneIndexList = [];
  var atomnameList;
  switch (this.moleculeType) {
    case ProteinType:
      atomnameList = ProteinBackboneAtoms;
      break;
    case RnaType:
    case DnaType:
      atomnameList = NucleicBackboneAtoms;
      break;
    default:
      return backboneIndexList;
  }
  var atomMap = this.structure.atomMap;
  var atomTypeIdList = this.atomTypeIdList;
  for (var i = 0, il = this.atomCount; i < il; ++i) {
    var atomType = atomMap.get(atomTypeIdList[i]);
    if (atomnameList.includes(atomType.atomname)) {
      backboneIndexList.push(i);
    }
  }
  return backboneIndexList;
};
ResidueType.prototype.getMoleculeType = function getMoleculeType() {
  if (this.isProtein()) {
    return ProteinType;
  } else if (this.isRna()) {
    return RnaType;
  } else if (this.isDna()) {
    return DnaType;
  } else if (this.isWater()) {
    return WaterType;
  } else if (this.isIon()) {
    return IonType;
  } else if (this.isSaccharide()) {
    return SaccharideType;
  } else {
    return UnknownType;
  }
};
ResidueType.prototype.getBackboneType = function getBackboneType(position) {
  if (this.hasProteinBackbone(position)) {
    return ProteinBackboneType;
  } else if (this.hasRnaBackbone(position)) {
    return RnaBackboneType;
  } else if (this.hasDnaBackbone(position)) {
    return DnaBackboneType;
  } else if (this.hasCgProteinBackbone(position)) {
    return CgProteinBackboneType;
  } else if (this.hasCgRnaBackbone(position)) {
    return CgRnaBackboneType;
  } else if (this.hasCgDnaBackbone(position)) {
    return CgDnaBackboneType;
  } else {
    return UnknownBackboneType;
  }
};
ResidueType.prototype.isProtein = function isProtein() {
  if (this.chemCompType) {
    return ChemCompProtein.includes(this.chemCompType);
  } else {
    return this.hasAtomWithName("CA", "C", "N") || AA3.includes(this.resname);
  }
};
ResidueType.prototype.isCg = function isCg() {
  var backboneType = this.backboneType;
  return backboneType === CgProteinBackboneType || backboneType === CgRnaBackboneType || backboneType === CgDnaBackboneType;
};
ResidueType.prototype.isNucleic = function isNucleic() {
  return this.isRna() || this.isDna();
};
ResidueType.prototype.isRna = function isRna() {
  if (this.chemCompType) {
    return ChemCompRna.includes(this.chemCompType);
  } else {
    return this.hasAtomWithName(["P", "O3'", "O3*"], ["C4'", "C4*"], ["O2'", "O2*", "F2'", "F2*"]) || RnaBases.includes(this.resname) && this.hasAtomWithName(["O2'", "O2*", "F2'", "F2*"]);
  }
};
ResidueType.prototype.isDna = function isDna() {
  if (this.chemCompType) {
    return ChemCompDna.includes(this.chemCompType);
  } else {
    return this.hasAtomWithName(["P", "O3'", "O3*"], ["C3'", "C3*"]) && !this.hasAtomWithName(["O2'", "O2*", "F2'", "F2*"]) || DnaBases.includes(this.resname);
  }
};
ResidueType.prototype.isHetero = function isHetero() {
  return this.hetero === 1;
};
ResidueType.prototype.isIon = function isIon() {
  return IonNames.includes(this.resname);
};
ResidueType.prototype.isWater = function isWater() {
  return WaterNames.includes(this.resname);
};
ResidueType.prototype.isSaccharide = function isSaccharide() {
  if (this.chemCompType) {
    return ChemCompSaccharide.includes(this.chemCompType);
  } else {
    return SaccharideNames.includes(this.resname);
  }
};
ResidueType.prototype.hasBackboneAtoms = function hasBackboneAtoms(position, type2) {
  var atomnames = ResidueTypeAtoms[type2];
  if (position === -1) {
    return this.hasAtomWithName(atomnames.trace, atomnames.backboneEnd, atomnames.direction1, atomnames.direction2);
  } else if (position === 0) {
    return this.hasAtomWithName(atomnames.trace, atomnames.direction1, atomnames.direction2);
  } else if (position === 1) {
    return this.hasAtomWithName(atomnames.trace, atomnames.backboneStart, atomnames.direction1, atomnames.direction2);
  } else {
    return this.hasAtomWithName(atomnames.trace, atomnames.backboneStart, atomnames.backboneEnd, atomnames.direction1, atomnames.direction2);
  }
};
ResidueType.prototype.hasProteinBackbone = function hasProteinBackbone(position) {
  return this.isProtein() && this.hasBackboneAtoms(position, ProteinBackboneType);
};
ResidueType.prototype.hasRnaBackbone = function hasRnaBackbone(position) {
  return this.isRna() && this.hasBackboneAtoms(position, RnaBackboneType);
};
ResidueType.prototype.hasDnaBackbone = function hasDnaBackbone(position) {
  return this.isDna() && this.hasBackboneAtoms(position, DnaBackboneType);
};
ResidueType.prototype.hasCgProteinBackbone = function hasCgProteinBackbone(position) {
  return this.isProtein() && this.hasBackboneAtoms(position, CgProteinBackboneType);
};
ResidueType.prototype.hasCgRnaBackbone = function hasCgRnaBackbone(position) {
  return this.isRna() && this.hasBackboneAtoms(position, CgRnaBackboneType);
};
ResidueType.prototype.hasCgDnaBackbone = function hasCgDnaBackbone(position) {
  return this.isDna() && this.hasBackboneAtoms(position, CgDnaBackboneType);
};
ResidueType.prototype.hasBackbone = function hasBackbone(position) {
  return this.hasProteinBackbone(position) || this.hasRnaBackbone(position) || this.hasDnaBackbone(position) || this.hasCgProteinBackbone(position) || this.hasCgRnaBackbone(position) || this.hasCgDnaBackbone(position);
};
ResidueType.prototype.getAtomIndexByName = function getAtomIndexByName(atomname) {
  var n = this.atomCount;
  var atomMap = this.structure.atomMap;
  var atomTypeIdList = this.atomTypeIdList;
  if (Array.isArray(atomname)) {
    for (var i = 0; i < n; ++i) {
      var index = atomTypeIdList[i];
      if (atomname.includes(atomMap.get(index).atomname)) {
        return i;
      }
    }
  } else {
    for (var i$1 = 0; i$1 < n; ++i$1) {
      var index$1 = atomTypeIdList[i$1];
      if (atomname === atomMap.get(index$1).atomname) {
        return i$1;
      }
    }
  }
  return void 0;
};
ResidueType.prototype.hasAtomWithName = function hasAtomWithName() {
  var arguments$1 = arguments;
  var this$1 = this;
  var n = arguments.length;
  for (var i = 0; i < n; ++i) {
    if (arguments$1[i] === void 0) {
      continue;
    }
    if (this$1.getAtomIndexByName(arguments$1[i]) === void 0) {
      return false;
    }
  }
  return true;
};
ResidueType.prototype.getBonds = function getBonds(r) {
  if (this.bonds === void 0) {
    this.bonds = calculateResidueBonds(r);
  }
  return this.bonds;
};
ResidueType.prototype.getRings = function getRings() {
  if (this.rings === void 0) {
    this.calculateRings();
  }
  return this.rings;
};
ResidueType.prototype.getBondGraph = function getBondGraph() {
  if (this.bondGraph === void 0) {
    this.calculateBondGraph();
  }
  return this.bondGraph;
};
ResidueType.prototype.calculateBondGraph = function calculateBondGraph() {
  var bondGraph = this.bondGraph = {};
  var bonds = this.getBonds();
  var nb = bonds.atomIndices1.length;
  var atomIndices1 = bonds.atomIndices1;
  var atomIndices2 = bonds.atomIndices2;
  for (var i = 0; i < nb; ++i) {
    var ai1 = atomIndices1[i];
    var ai2 = atomIndices2[i];
    var a1 = bondGraph[ai1] = bondGraph[ai1] || [];
    a1.push(ai2);
    var a2 = bondGraph[ai2] = bondGraph[ai2] || [];
    a2.push(ai1);
  }
};
ResidueType.prototype.calculateRings = function calculateRings() {
  var bondGraph = this.getBondGraph();
  var state = new Int8Array(this.atomCount);
  var flags = new Int8Array(this.atomCount);
  var rings = [];
  var visited = [];
  function DFS(i2, connected2, from) {
    if (state[i2]) {
      throw new Error("DFS revisited atom");
    }
    state[i2] = 1;
    visited.push(i2);
    var nc = connected2.length;
    for (var ci = 0; ci < nc; ++ci) {
      var j = connected2[ci];
      if (state[j] === 0) {
        if (bondGraph[j] && bondGraph[j].length >= 2) {
          DFS(j, bondGraph[j], i2);
        } else {
          state[j] = 2;
        }
      } else if (state[j] === 1) {
        if (from && from !== j) {
          var ring = [j];
          flags[j] = 1;
          rings.push(ring);
          for (var ki = visited.length - 1; ki >= 0; --ki) {
            var k = visited[ki];
            if (k === j) {
              break;
            }
            ring.push(k);
            flags[k] = 1;
          }
        }
      }
    }
    state[i2] = 2;
    visited.pop();
  }
  for (var i = 0; i < this.atomCount; ++i) {
    if (state[i]) {
      continue;
    }
    var connected = bondGraph[i];
    if (!connected || connected.length < 2) {
      state[i] = 2;
      continue;
    }
    visited.length = 0;
    DFS(i, connected);
  }
  this.rings = {flags, rings};
};
ResidueType.prototype.assignBondReferenceAtomIndices = function assignBondReferenceAtomIndices() {
  var bondGraph = this.getBondGraph();
  var rings = this.getRings();
  var ringFlags = rings.flags;
  var ringData = rings.rings;
  var atomIndices1 = this.bonds.atomIndices1;
  var atomIndices2 = this.bonds.atomIndices2;
  var bondOrders = this.bonds.bondOrders;
  var bondReferenceAtomIndices = this.bondReferenceAtomIndices;
  var nb = this.bonds.atomIndices1.length;
  bondReferenceAtomIndices.length = 0;
  for (var i = 0; i < nb; ++i) {
    if (bondOrders[i] <= 1) {
      continue;
    }
    var ai1 = atomIndices1[i];
    var ai2 = atomIndices2[i];
    if (ringFlags[ai1] && ringFlags[ai2]) {
      for (var ri = 0; ri < ringData.length; ++ri) {
        if (bondReferenceAtomIndices[i] !== void 0) {
          break;
        }
        var ring = ringData[ri];
        var refAtom = null;
        var found = false;
        for (var rai = 0; rai < ring.length; ++rai) {
          var ai3 = ring[rai];
          if (ai3 === ai1 || ai3 === ai2) {
            found = true;
          } else {
            refAtom = ai3;
          }
          if (found && refAtom !== null) {
            bondReferenceAtomIndices[i] = refAtom;
            break;
          }
        }
      }
      if (bondReferenceAtomIndices[i] !== void 0) {
        continue;
      }
    }
    if (bondGraph[ai1].length > 1) {
      for (var j = 0; j < bondGraph[ai1].length; ++j) {
        var ai3$1 = bondGraph[ai1][j];
        if (ai3$1 !== ai2) {
          bondReferenceAtomIndices[i] = ai3$1;
          break;
        }
      }
      continue;
    } else if (bondGraph[ai2].length > 1) {
      for (var j$1 = 0; j$1 < bondGraph[ai2].length; ++j$1) {
        var ai3$2 = bondGraph[ai2][j$1];
        if (ai3$2 !== ai1) {
          bondReferenceAtomIndices[i] = ai3$2;
          break;
        }
      }
      continue;
    }
  }
};
ResidueType.prototype.getBondIndex = function getBondIndex(atomIndex1, atomIndex2) {
  var bonds = this.bonds;
  var atomIndices1 = bonds.atomIndices1;
  var atomIndices2 = bonds.atomIndices2;
  var idx1 = atomIndices1.indexOf(atomIndex1);
  var idx2 = atomIndices2.indexOf(atomIndex2);
  var _idx2 = idx2;
  while (idx1 !== -1) {
    while (idx2 !== -1) {
      if (idx1 === idx2) {
        return idx1;
      }
      idx2 = atomIndices2.indexOf(atomIndex2, idx2 + 1);
    }
    idx1 = atomIndices1.indexOf(atomIndex1, idx1 + 1);
    idx2 = _idx2;
  }
};
ResidueType.prototype.getBondReferenceAtomIndex = function getBondReferenceAtomIndex(atomIndex1, atomIndex2) {
  var bondIndex = this.getBondIndex(atomIndex1, atomIndex2);
  if (bondIndex === void 0) {
    return void 0;
  }
  if (this.bondReferenceAtomIndices.length === 0) {
    this.assignBondReferenceAtomIndices();
  }
  return this.bondReferenceAtomIndices[bondIndex];
};
function getHash$1(resname, atomTypeIdList, hetero, chemCompType) {
  return resname + "|" + atomTypeIdList.join(",") + "|" + (hetero ? 1 : 0) + "|" + (chemCompType || "");
}
var ResidueMap = function ResidueMap2(structure) {
  this.structure = structure;
  this.dict = {};
  this.list = [];
};
ResidueMap.prototype.add = function add7(resname, atomTypeIdList, hetero, chemCompType, bonds) {
  resname = resname.toUpperCase();
  var hash = getHash$1(resname, atomTypeIdList, hetero, chemCompType);
  var id = this.dict[hash];
  if (id === void 0) {
    var residueType = new ResidueType(this.structure, resname, atomTypeIdList, hetero, chemCompType, bonds);
    id = this.list.length;
    this.dict[hash] = id;
    this.list.push(residueType);
  }
  return id;
};
ResidueMap.prototype.get = function get5(id) {
  return this.list[id];
};
var BondProxy = function BondProxy2(structure, index) {
  this.structure = structure;
  this.bondStore = structure.bondStore;
  this.index = index;
  this._v12 = new Vector3();
  this._v13 = new Vector3();
  this._ap1 = this.structure.getAtomProxy();
  this._ap2 = this.structure.getAtomProxy();
  this._ap3 = this.structure.getAtomProxy();
};
var prototypeAccessors$17 = {atom1: {}, atom2: {}, atomIndex1: {}, atomIndex2: {}, bondOrder: {}};
prototypeAccessors$17.atom1.get = function() {
  return this.structure.getAtomProxy(this.atomIndex1);
};
prototypeAccessors$17.atom2.get = function() {
  return this.structure.getAtomProxy(this.atomIndex2);
};
prototypeAccessors$17.atomIndex1.get = function() {
  return this.bondStore.atomIndex1[this.index];
};
prototypeAccessors$17.atomIndex1.set = function(value2) {
  this.bondStore.atomIndex1[this.index] = value2;
};
prototypeAccessors$17.atomIndex2.get = function() {
  return this.bondStore.atomIndex2[this.index];
};
prototypeAccessors$17.atomIndex2.set = function(value2) {
  this.bondStore.atomIndex2[this.index] = value2;
};
prototypeAccessors$17.bondOrder.get = function() {
  return this.bondStore.bondOrder[this.index];
};
prototypeAccessors$17.bondOrder.set = function(value2) {
  this.bondStore.bondOrder[this.index] = value2;
};
BondProxy.prototype.getReferenceAtomIndex = function getReferenceAtomIndex() {
  var ap1 = this._ap1;
  var ap2 = this._ap2;
  ap1.index = this.atomIndex1;
  ap2.index = this.atomIndex2;
  if (ap1.residueIndex !== ap2.residueIndex) {
    return void 0;
  }
  var typeAtomIndex1 = ap1.index - ap1.residueAtomOffset;
  var typeAtomIndex2 = ap2.index - ap2.residueAtomOffset;
  var residueType = ap1.residueType;
  var ix = residueType.getBondReferenceAtomIndex(typeAtomIndex1, typeAtomIndex2);
  if (ix !== void 0) {
    return ix + ap1.residueAtomOffset;
  } else {
    console.warn("No reference atom found", ap1.index, ap2.index);
  }
};
BondProxy.prototype.calculateShiftDir = function calculateShiftDir(v) {
  if (!v) {
    v = new Vector3();
  }
  var ap1 = this._ap1;
  var ap2 = this._ap2;
  var ap3 = this._ap3;
  var v12 = this._v12;
  var v13 = this._v13;
  ap1.index = this.atomIndex1;
  ap2.index = this.atomIndex2;
  var ai3 = this.getReferenceAtomIndex();
  v12.subVectors(ap1, ap2).normalize();
  if (ai3 !== void 0) {
    ap3.index = ai3;
    v13.subVectors(ap1, ap3);
  } else {
    v13.copy(ap1);
  }
  v13.normalize();
  var dp = v12.dot(v13);
  if (1 - Math.abs(dp) < 1e-5) {
    v13.set(1, 0, 0);
    dp = v12.dot(v13);
    if (1 - Math.abs(dp) < 1e-5) {
      v13.set(0, 1, 0);
      dp = v12.dot(v13);
    }
  }
  return v.copy(v13.sub(v12.multiplyScalar(dp))).normalize();
};
BondProxy.prototype.qualifiedName = function qualifiedName() {
  return this.atomIndex1 + "=" + this.atomIndex2;
};
BondProxy.prototype.clone = function clone3() {
  return new this.constructor(this.structure, this.index);
};
BondProxy.prototype.toObject = function toObject() {
  return {
    atomIndex1: this.atomIndex1,
    atomIndex2: this.atomIndex2,
    bondOrder: this.bondOrder
  };
};
Object.defineProperties(BondProxy.prototype, prototypeAccessors$17);
var AtomProxy = function AtomProxy2(structure, index) {
  this.structure = structure;
  this.chainStore = structure.chainStore;
  this.residueStore = structure.residueStore;
  this.atomStore = structure.atomStore;
  this.residueMap = structure.residueMap;
  this.atomMap = structure.atomMap;
  this.index = index;
};
var prototypeAccessors$18 = {bondHash: {}, entity: {}, entityIndex: {}, modelIndex: {}, chainIndex: {}, residue: {}, residueIndex: {}, sstruc: {}, inscode: {}, resno: {}, chainname: {}, chainid: {}, residueType: {}, atomType: {}, residueAtomOffset: {}, resname: {}, hetero: {}, atomname: {}, element: {}, vdw: {}, covalent: {}, x: {}, y: {}, z: {}, serial: {}, bfactor: {}, occupancy: {}, altloc: {}};
prototypeAccessors$18.bondHash.get = function() {
  return this.structure.bondHash;
};
prototypeAccessors$18.entity.get = function() {
  return this.structure.entityList[this.entityIndex];
};
prototypeAccessors$18.entityIndex.get = function() {
  return this.chainStore.entityIndex[this.chainIndex];
};
prototypeAccessors$18.modelIndex.get = function() {
  return this.chainStore.modelIndex[this.chainIndex];
};
prototypeAccessors$18.chainIndex.get = function() {
  return this.residueStore.chainIndex[this.residueIndex];
};
prototypeAccessors$18.residue.get = function() {
  console.warn("residue - might be expensive");
  return this.structure.getResidueProxy(this.residueIndex);
};
prototypeAccessors$18.residueIndex.get = function() {
  return this.atomStore.residueIndex[this.index];
};
prototypeAccessors$18.residueIndex.set = function(value2) {
  this.atomStore.residueIndex[this.index] = value2;
};
prototypeAccessors$18.sstruc.get = function() {
  return this.residueStore.getSstruc(this.residueIndex);
};
prototypeAccessors$18.inscode.get = function() {
  return this.residueStore.getInscode(this.residueIndex);
};
prototypeAccessors$18.resno.get = function() {
  return this.residueStore.resno[this.residueIndex];
};
prototypeAccessors$18.chainname.get = function() {
  return this.chainStore.getChainname(this.chainIndex);
};
prototypeAccessors$18.chainid.get = function() {
  return this.chainStore.getChainid(this.chainIndex);
};
prototypeAccessors$18.residueType.get = function() {
  return this.residueMap.get(this.residueStore.residueTypeId[this.residueIndex]);
};
prototypeAccessors$18.atomType.get = function() {
  return this.atomMap.get(this.atomStore.atomTypeId[this.index]);
};
prototypeAccessors$18.residueAtomOffset.get = function() {
  return this.residueStore.atomOffset[this.residueIndex];
};
prototypeAccessors$18.resname.get = function() {
  return this.residueType.resname;
};
prototypeAccessors$18.hetero.get = function() {
  return this.residueType.hetero;
};
prototypeAccessors$18.atomname.get = function() {
  return this.atomType.atomname;
};
prototypeAccessors$18.element.get = function() {
  return this.atomType.element;
};
prototypeAccessors$18.vdw.get = function() {
  return this.atomType.vdw;
};
prototypeAccessors$18.covalent.get = function() {
  return this.atomType.covalent;
};
prototypeAccessors$18.x.get = function() {
  return this.atomStore.x[this.index];
};
prototypeAccessors$18.x.set = function(value2) {
  this.atomStore.x[this.index] = value2;
};
prototypeAccessors$18.y.get = function() {
  return this.atomStore.y[this.index];
};
prototypeAccessors$18.y.set = function(value2) {
  this.atomStore.y[this.index] = value2;
};
prototypeAccessors$18.z.get = function() {
  return this.atomStore.z[this.index];
};
prototypeAccessors$18.z.set = function(value2) {
  this.atomStore.z[this.index] = value2;
};
prototypeAccessors$18.serial.get = function() {
  return this.atomStore.serial[this.index];
};
prototypeAccessors$18.serial.set = function(value2) {
  this.atomStore.serial[this.index] = value2;
};
prototypeAccessors$18.bfactor.get = function() {
  return this.atomStore.bfactor[this.index];
};
prototypeAccessors$18.bfactor.set = function(value2) {
  this.atomStore.bfactor[this.index] = value2;
};
prototypeAccessors$18.occupancy.get = function() {
  return this.atomStore.occupancy[this.index];
};
prototypeAccessors$18.occupancy.set = function(value2) {
  this.atomStore.occupancy[this.index] = value2;
};
prototypeAccessors$18.altloc.get = function() {
  return this.atomStore.getAltloc(this.index);
};
prototypeAccessors$18.altloc.set = function(value2) {
  this.atomStore.setAltloc(this.index, value2);
};
AtomProxy.prototype.eachBond = function eachBond(callback, bp) {
  bp = bp || this.structure._bp;
  var idx = this.index;
  var bondHash = this.bondHash;
  var indexArray = bondHash.indexArray;
  var n = bondHash.countArray[idx];
  var offset = bondHash.offsetArray[idx];
  for (var i = 0; i < n; ++i) {
    bp.index = indexArray[offset + i];
    callback(bp);
  }
};
AtomProxy.prototype.eachBondedAtom = function eachBondedAtom(callback, ap) {
  ap = ap || this.structure._ap;
  var idx = this.index;
  this.eachBond(function(bp) {
    if (idx !== bp.atomIndex1) {
      ap.index = bp.atomIndex1;
    } else {
      ap.index = bp.atomIndex2;
    }
    callback(ap);
  });
};
AtomProxy.prototype.isBackbone = function isBackbone() {
  var backboneIndexList = this.residueType.backboneIndexList;
  if (backboneIndexList.length > 0) {
    var atomOffset = this.residueStore.atomOffset[this.residueIndex];
    return backboneIndexList.includes(this.index - atomOffset);
  } else {
    return false;
  }
};
AtomProxy.prototype.isPolymer = function isPolymer() {
  if (this.structure.entityList.length > 0) {
    return this.entity.isPolymer();
  } else {
    var moleculeType = this.residueType.moleculeType;
    return moleculeType === ProteinType || moleculeType === RnaType || moleculeType === DnaType;
  }
};
AtomProxy.prototype.isSidechain = function isSidechain() {
  return this.isPolymer() && !this.isBackbone();
};
AtomProxy.prototype.isCg = function isCg2() {
  var backboneType = this.residueType.backboneType;
  return backboneType === CgProteinBackboneType || backboneType === CgRnaBackboneType || backboneType === CgDnaBackboneType;
};
AtomProxy.prototype.isHetero = function isHetero2() {
  return this.residueType.hetero === 1;
};
AtomProxy.prototype.isProtein = function isProtein2() {
  return this.residueType.moleculeType === ProteinType;
};
AtomProxy.prototype.isNucleic = function isNucleic2() {
  var moleculeType = this.residueType.moleculeType;
  return moleculeType === RnaType || moleculeType === DnaType;
};
AtomProxy.prototype.isRna = function isRna2() {
  return this.residueType.moleculeType === RnaType;
};
AtomProxy.prototype.isDna = function isDna2() {
  return this.residueType.moleculeType === DnaType;
};
AtomProxy.prototype.isWater = function isWater2() {
  return this.residueType.moleculeType === WaterType;
};
AtomProxy.prototype.isIon = function isIon2() {
  return this.residueType.moleculeType === IonType;
};
AtomProxy.prototype.isSaccharide = function isSaccharide2() {
  return this.residueType.moleculeType === SaccharideType;
};
AtomProxy.prototype.isHelix = function isHelix() {
  return SecStrucHelix.includes(this.sstruc);
};
AtomProxy.prototype.isSheet = function isSheet() {
  return SecStrucSheet.includes(this.sstruc);
};
AtomProxy.prototype.isTurn = function isTurn() {
  return SecStrucTurn.includes(this.sstruc) && this.isProtein();
};
AtomProxy.prototype.isBonded = function isBonded() {
  return this.bondHash.countArray[this.index] !== 0;
};
AtomProxy.prototype.isRing = function isRing() {
  var ringFlags = this.residueType.getRings().flags;
  return ringFlags[this.index - this.residueAtomOffset] === 1;
};
AtomProxy.prototype.distanceTo = function distanceTo(atom) {
  var taa = this.atomStore;
  var aaa = atom.atomStore;
  var ti = this.index;
  var ai = atom.index;
  var x = taa.x[ti] - aaa.x[ai];
  var y = taa.y[ti] - aaa.y[ai];
  var z = taa.z[ti] - aaa.z[ai];
  var distSquared = x * x + y * y + z * z;
  return Math.sqrt(distSquared);
};
AtomProxy.prototype.connectedTo = function connectedTo(atom) {
  var taa = this.atomStore;
  var aaa = atom.atomStore;
  var ti = this.index;
  var ai = atom.index;
  if (taa.altloc && aaa.altloc) {
    var ta = taa.altloc[ti];
    var aa = aaa.altloc[ai];
    if (!(ta === 0 || aa === 0 || ta === 32 || aa === 32 || ta === aa)) {
      return false;
    }
  }
  var x = taa.x[ti] - aaa.x[ai];
  var y = taa.y[ti] - aaa.y[ai];
  var z = taa.z[ti] - aaa.z[ai];
  var distSquared = x * x + y * y + z * z;
  if (distSquared < 64 && this.isCg()) {
    return true;
  }
  if (isNaN(distSquared)) {
    return false;
  }
  var d = this.covalent + atom.covalent;
  var d1 = d + 0.3;
  var d2 = d - 0.5;
  return distSquared < d1 * d1 && distSquared > d2 * d2;
};
AtomProxy.prototype.positionFromArray = function positionFromArray(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  this.x = array[offset + 0];
  this.y = array[offset + 1];
  this.z = array[offset + 2];
  return this;
};
AtomProxy.prototype.positionToArray = function positionToArray(array, offset) {
  if (array === void 0) {
    array = [];
  }
  if (offset === void 0) {
    offset = 0;
  }
  var index = this.index;
  var atomStore = this.atomStore;
  array[offset + 0] = atomStore.x[index];
  array[offset + 1] = atomStore.y[index];
  array[offset + 2] = atomStore.z[index];
  return array;
};
AtomProxy.prototype.positionToVector3 = function positionToVector3(v) {
  if (v === void 0) {
    v = new Vector3();
  }
  v.x = this.x;
  v.y = this.y;
  v.z = this.z;
  return v;
};
AtomProxy.prototype.positionFromVector3 = function positionFromVector3(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z;
  return this;
};
AtomProxy.prototype.getResidueBonds = function getResidueBonds(firstOnly) {
  var residueAtomOffset = this.residueAtomOffset;
  var relativeIndex = this.index - this.residueAtomOffset;
  var bonds = this.residueType.getBonds();
  var atomIndices1 = bonds.atomIndices1;
  var atomIndices2 = bonds.atomIndices2;
  var idx1, idx2, connectedAtomIndex, connectedAtomIndices;
  if (!firstOnly) {
    connectedAtomIndices = [];
  }
  idx1 = atomIndices1.indexOf(relativeIndex);
  while (idx1 !== -1) {
    connectedAtomIndex = atomIndices2[idx1] + residueAtomOffset;
    if (firstOnly) {
      return connectedAtomIndex;
    }
    connectedAtomIndices.push(connectedAtomIndex);
    idx1 = atomIndices1.indexOf(relativeIndex, idx1 + 1);
  }
  idx2 = atomIndices2.indexOf(relativeIndex);
  while (idx2 !== -1) {
    connectedAtomIndex = atomIndices1[idx2] + residueAtomOffset;
    if (firstOnly) {
      return connectedAtomIndex;
    }
    connectedAtomIndices.push(connectedAtomIndex);
    idx2 = atomIndices2.indexOf(relativeIndex, idx2 + 1);
  }
  return connectedAtomIndices;
};
AtomProxy.prototype.qualifiedName = function qualifiedName2(noResname) {
  var name = "";
  if (this.resname && !noResname) {
    name += "[" + this.resname + "]";
  }
  if (this.resno !== void 0) {
    name += this.resno;
  }
  if (this.inscode) {
    name += "^" + this.inscode;
  }
  if (this.chainname) {
    name += ":" + this.chainname;
  }
  if (this.atomname) {
    name += "." + this.atomname;
  }
  if (this.altloc) {
    name += "%" + this.altloc;
  }
  if (this.structure.modelStore.count > 1) {
    name += "/" + this.modelIndex;
  }
  return name;
};
AtomProxy.prototype.clone = function clone4() {
  return new this.constructor(this.structure, this.index);
};
AtomProxy.prototype.toObject = function toObject2() {
  return {
    index: this.index,
    residueIndex: this.residueIndex,
    atomno: this.atomno,
    resname: this.resname,
    x: this.x,
    y: this.y,
    z: this.z,
    element: this.element,
    chainname: this.chainname,
    resno: this.resno,
    serial: this.serial,
    vdw: this.vdw,
    covalent: this.covalent,
    hetero: this.hetero,
    bfactor: this.bfactor,
    altloc: this.altloc,
    atomname: this.atomname,
    modelindex: this.modelindex
  };
};
Object.defineProperties(AtomProxy.prototype, prototypeAccessors$18);
var ResidueProxy = function ResidueProxy2(structure, index) {
  this.structure = structure;
  this.chainStore = structure.chainStore;
  this.residueStore = structure.residueStore;
  this.atomStore = structure.atomStore;
  this.residueMap = structure.residueMap;
  this.atomMap = structure.atomMap;
  this.index = index;
};
var prototypeAccessors$19 = {entity: {}, entityIndex: {}, chain: {}, chainIndex: {}, atomOffset: {}, atomCount: {}, atomEnd: {}, modelIndex: {}, chainname: {}, chainid: {}, resno: {}, sstruc: {}, inscode: {}, residueType: {}, resname: {}, hetero: {}, moleculeType: {}, backboneType: {}, backboneStartType: {}, backboneEndType: {}, traceAtomIndex: {}, direction1AtomIndex: {}, direction2AtomIndex: {}, backboneStartAtomIndex: {}, backboneEndAtomIndex: {}, rungEndAtomIndex: {}};
prototypeAccessors$19.entity.get = function() {
  return this.structure.entityList[this.entityIndex];
};
prototypeAccessors$19.entityIndex.get = function() {
  return this.chainStore.entityIndex[this.chainIndex];
};
prototypeAccessors$19.chain.get = function() {
  return this.structure.getChainProxy(this.chainIndex);
};
prototypeAccessors$19.chainIndex.get = function() {
  return this.residueStore.chainIndex[this.index];
};
prototypeAccessors$19.chainIndex.set = function(value2) {
  this.residueStore.chainIndex[this.index] = value2;
};
prototypeAccessors$19.atomOffset.get = function() {
  return this.residueStore.atomOffset[this.index];
};
prototypeAccessors$19.atomOffset.set = function(value2) {
  this.residueStore.atomOffset[this.index] = value2;
};
prototypeAccessors$19.atomCount.get = function() {
  return this.residueStore.atomCount[this.index];
};
prototypeAccessors$19.atomCount.set = function(value2) {
  this.residueStore.atomCount[this.index] = value2;
};
prototypeAccessors$19.atomEnd.get = function() {
  return this.atomOffset + this.atomCount - 1;
};
prototypeAccessors$19.modelIndex.get = function() {
  return this.chainStore.modelIndex[this.chainIndex];
};
prototypeAccessors$19.chainname.get = function() {
  return this.chainStore.getChainname(this.chainIndex);
};
prototypeAccessors$19.chainid.get = function() {
  return this.chainStore.getChainid(this.chainIndex);
};
prototypeAccessors$19.resno.get = function() {
  return this.residueStore.resno[this.index];
};
prototypeAccessors$19.resno.set = function(value2) {
  this.residueStore.resno[this.index] = value2;
};
prototypeAccessors$19.sstruc.get = function() {
  return this.residueStore.getSstruc(this.index);
};
prototypeAccessors$19.sstruc.set = function(value2) {
  this.residueStore.setSstruc(this.index, value2);
};
prototypeAccessors$19.inscode.get = function() {
  return this.residueStore.getInscode(this.index);
};
prototypeAccessors$19.inscode.set = function(value2) {
  this.residueStore.getInscode(this.index, value2);
};
prototypeAccessors$19.residueType.get = function() {
  return this.residueMap.get(this.residueStore.residueTypeId[this.index]);
};
prototypeAccessors$19.resname.get = function() {
  return this.residueType.resname;
};
prototypeAccessors$19.hetero.get = function() {
  return this.residueType.hetero;
};
prototypeAccessors$19.moleculeType.get = function() {
  return this.residueType.moleculeType;
};
prototypeAccessors$19.backboneType.get = function() {
  return this.residueType.backboneType;
};
prototypeAccessors$19.backboneStartType.get = function() {
  return this.residueType.backboneStartType;
};
prototypeAccessors$19.backboneEndType.get = function() {
  return this.residueType.backboneEndType;
};
prototypeAccessors$19.traceAtomIndex.get = function() {
  return this.residueType.traceAtomIndex + this.atomOffset;
};
prototypeAccessors$19.direction1AtomIndex.get = function() {
  return this.residueType.direction1AtomIndex + this.atomOffset;
};
prototypeAccessors$19.direction2AtomIndex.get = function() {
  return this.residueType.direction2AtomIndex + this.atomOffset;
};
prototypeAccessors$19.backboneStartAtomIndex.get = function() {
  return this.residueType.backboneStartAtomIndex + this.atomOffset;
};
prototypeAccessors$19.backboneEndAtomIndex.get = function() {
  return this.residueType.backboneEndAtomIndex + this.atomOffset;
};
prototypeAccessors$19.rungEndAtomIndex.get = function() {
  return this.residueType.rungEndAtomIndex + this.atomOffset;
};
ResidueProxy.prototype.eachAtom = function eachAtom(callback, selection) {
  var i;
  var count2 = this.atomCount;
  var offset = this.atomOffset;
  var ap = this.structure._ap;
  var end = offset + count2;
  if (selection && selection.atomOnlyTest) {
    var atomOnlyTest = selection.atomOnlyTest;
    for (i = offset; i < end; ++i) {
      ap.index = i;
      if (atomOnlyTest(ap)) {
        callback(ap);
      }
    }
  } else {
    for (i = offset; i < end; ++i) {
      ap.index = i;
      callback(ap);
    }
  }
};
ResidueProxy.prototype.isProtein = function isProtein3() {
  return this.residueType.moleculeType === ProteinType;
};
ResidueProxy.prototype.isNucleic = function isNucleic3() {
  var moleculeType = this.residueType.moleculeType;
  return moleculeType === RnaType || moleculeType === DnaType;
};
ResidueProxy.prototype.isRna = function isRna3() {
  return this.residueType.moleculeType === RnaType;
};
ResidueProxy.prototype.isDna = function isDna3() {
  return this.residueType.moleculeType === DnaType;
};
ResidueProxy.prototype.isCg = function isCg3() {
  var backboneType = this.residueType.backboneType;
  return backboneType === CgProteinBackboneType || backboneType === CgRnaBackboneType || backboneType === CgDnaBackboneType;
};
ResidueProxy.prototype.isPolymer = function isPolymer2() {
  if (this.structure.entityList.length > 0) {
    return this.entity.isPolymer();
  } else {
    var moleculeType = this.residueType.moleculeType;
    return moleculeType === ProteinType || moleculeType === RnaType || moleculeType === DnaType;
  }
};
ResidueProxy.prototype.isHetero = function isHetero3() {
  return this.residueType.hetero === 1;
};
ResidueProxy.prototype.isWater = function isWater3() {
  return this.residueType.moleculeType === WaterType;
};
ResidueProxy.prototype.isIon = function isIon3() {
  return this.residueType.moleculeType === IonType;
};
ResidueProxy.prototype.isSaccharide = function isSaccharide3() {
  return this.residueType.moleculeType === SaccharideType;
};
ResidueProxy.prototype.isHelix = function isHelix2() {
  return SecStrucHelix.includes(this.sstruc);
};
ResidueProxy.prototype.isSheet = function isSheet2() {
  return SecStrucSheet.includes(this.sstruc);
};
ResidueProxy.prototype.isTurn = function isTurn2() {
  return SecStrucTurn.includes(this.sstruc) && this.isProtein();
};
ResidueProxy.prototype.getAtomType = function getAtomType(index) {
  return this.atomMap.get(this.atomStore.atomTypeId[index]);
};
ResidueProxy.prototype.getResname1 = function getResname1() {
  return AA1[this.resname.toUpperCase()] || "X";
};
ResidueProxy.prototype.getBackboneType = function getBackboneType2(position) {
  switch (position) {
    case -1:
      return this.residueType.backboneStartType;
    case 1:
      return this.residueType.backboneEndType;
    default:
      return this.residueType.backboneType;
  }
};
ResidueProxy.prototype.getAtomIndexByName = function getAtomIndexByName2(atomname) {
  var index = this.residueType.getAtomIndexByName(atomname);
  if (index !== void 0) {
    index += this.atomOffset;
  }
  return index;
};
ResidueProxy.prototype.getAtomByName = function getAtomByName(atomname) {
  return this.residueType.getAtomByName(atomname);
};
ResidueProxy.prototype.hasAtomWithName = function hasAtomWithName2(atomname) {
  return this.residueType.hasAtomWithName(atomname);
};
ResidueProxy.prototype.getAtomnameList = function getAtomnameList() {
  var this$1 = this;
  console.warn("getAtomnameList - might be expensive");
  var n = this.atomCount;
  var offset = this.atomOffset;
  var list = new Array(n);
  for (var i = 0; i < n; ++i) {
    list[i] = this$1.getAtomType(offset + i).atomname;
  }
  return list;
};
ResidueProxy.prototype.connectedTo = function connectedTo2(rNext) {
  var bbAtomEnd = this.structure.getAtomProxy(this.backboneEndAtomIndex);
  var bbAtomStart = this.structure.getAtomProxy(rNext.backboneStartAtomIndex);
  if (bbAtomEnd && bbAtomStart) {
    return bbAtomEnd.connectedTo(bbAtomStart);
  } else {
    return false;
  }
};
ResidueProxy.prototype.getNextConnectedResidue = function getNextConnectedResidue() {
  var rOffset = this.chainStore.residueOffset[this.chainIndex];
  var rCount = this.chainStore.residueCount[this.chainIndex];
  var nextIndex = this.index + 1;
  if (nextIndex < rOffset + rCount) {
    var rpNext = this.structure.getResidueProxy(nextIndex);
    if (this.connectedTo(rpNext)) {
      return rpNext;
    }
  } else if (nextIndex === rOffset + rCount) {
    var rpFirst = this.structure.getResidueProxy(rOffset);
    if (this.connectedTo(rpFirst)) {
      return rpFirst;
    }
  }
  return void 0;
};
ResidueProxy.prototype.getPreviousConnectedResidue = function getPreviousConnectedResidue() {
  var rOffset = this.chainStore.residueOffset[this.chainIndex];
  var prevIndex = this.index - 1;
  if (prevIndex >= rOffset) {
    var rpPrev = this.structure.getResidueProxy(prevIndex);
    if (rpPrev.connectedTo(this)) {
      return rpPrev;
    }
  } else if (prevIndex === rOffset - 1) {
    var rCount = this.chainStore.residueCount[this.chainIndex];
    var rpLast = this.structure.getResidueProxy(rOffset + rCount - 1);
    if (rpLast.connectedTo(this)) {
      return rpLast;
    }
  }
  return void 0;
};
ResidueProxy.prototype.getBonds = function getBonds2() {
  return this.residueType.getBonds(this);
};
ResidueProxy.prototype.getRings = function getRings2() {
  return this.residueType.getRings();
};
ResidueProxy.prototype.qualifiedName = function qualifiedName3(noResname) {
  var name = "";
  if (this.resname && !noResname) {
    name += "[" + this.resname + "]";
  }
  if (this.resno !== void 0) {
    name += this.resno;
  }
  if (this.inscode) {
    name += "^" + this.inscode;
  }
  if (this.chain) {
    name += ":" + this.chainname;
  }
  name += "/" + this.modelIndex;
  return name;
};
ResidueProxy.prototype.clone = function clone5() {
  return new this.constructor(this.structure, this.index);
};
ResidueProxy.prototype.toObject = function toObject3() {
  return {
    index: this.index,
    chainIndex: this.chainIndex,
    atomOffset: this.atomOffset,
    atomCount: this.atomCount,
    resno: this.resno,
    resname: this.resname,
    sstruc: this.sstruc
  };
};
Object.defineProperties(ResidueProxy.prototype, prototypeAccessors$19);
var Polymer = function Polymer2(structure, residueIndexStart, residueIndexEnd) {
  this.structure = structure;
  this.chainStore = structure.chainStore;
  this.residueStore = structure.residueStore;
  this.atomStore = structure.atomStore;
  this.residueIndexStart = residueIndexStart;
  this.residueIndexEnd = residueIndexEnd;
  this.residueCount = residueIndexEnd - residueIndexStart + 1;
  var rpStart = this.structure.getResidueProxy(this.residueIndexStart);
  var rpEnd = this.structure.getResidueProxy(this.residueIndexEnd);
  this.isPrevConnected = rpStart.getPreviousConnectedResidue() !== void 0;
  var rpNext = rpEnd.getNextConnectedResidue();
  this.isNextConnected = rpNext !== void 0;
  this.isNextNextConnected = this.isNextConnected && rpNext.getNextConnectedResidue() !== void 0;
  this.isCyclic = rpEnd.connectedTo(rpStart);
  this.__residueProxy = this.structure.getResidueProxy();
};
var prototypeAccessors$21 = {chainIndex: {}, modelIndex: {}, chainname: {}};
prototypeAccessors$21.chainIndex.get = function() {
  return this.residueStore.chainIndex[this.residueIndexStart];
};
prototypeAccessors$21.modelIndex.get = function() {
  return this.chainStore.modelIndex[this.chainIndex];
};
prototypeAccessors$21.chainname.get = function() {
  return this.chainStore.getChainname(this.chainIndex);
};
Polymer.prototype.isProtein = function isProtein4() {
  this.__residueProxy.index = this.residueIndexStart;
  return this.__residueProxy.isProtein();
};
Polymer.prototype.isCg = function isCg4() {
  this.__residueProxy.index = this.residueIndexStart;
  return this.__residueProxy.isCg();
};
Polymer.prototype.isNucleic = function isNucleic4() {
  this.__residueProxy.index = this.residueIndexStart;
  return this.__residueProxy.isNucleic();
};
Polymer.prototype.getMoleculeType = function getMoleculeType2() {
  this.__residueProxy.index = this.residueIndexStart;
  return this.__residueProxy.moleculeType;
};
Polymer.prototype.getBackboneType = function getBackboneType3(position) {
  this.__residueProxy.index = this.residueIndexStart;
  return this.__residueProxy.getBackboneType(position);
};
Polymer.prototype.getAtomIndexByType = function getAtomIndexByType(index, type2) {
  if (this.isCyclic) {
    if (index === -1) {
      index = this.residueCount - 1;
    } else if (index === this.residueCount) {
      index = 0;
    }
  } else {
    if (index === -1 && !this.isPrevConnected) {
      index += 1;
    }
    if (index === this.residueCount && !this.isNextNextConnected) {
      index -= 1;
    }
  }
  var rp = this.__residueProxy;
  rp.index = this.residueIndexStart + index;
  var aIndex;
  switch (type2) {
    case "trace":
      aIndex = rp.traceAtomIndex;
      break;
    case "direction1":
      aIndex = rp.direction1AtomIndex;
      break;
    case "direction2":
      aIndex = rp.direction2AtomIndex;
      break;
    default:
      var ap = rp.getAtomByName(type2);
      aIndex = ap ? ap.index : void 0;
  }
  return aIndex;
};
Polymer.prototype.eachAtom = function eachAtom2(callback, selection) {
  this.eachResidue(function(rp) {
    rp.eachAtom(callback, selection);
  }, selection);
};
Polymer.prototype.eachAtomN = function eachAtomN(n, callback, type2) {
  var this$1 = this;
  var i;
  var m2 = this.residueCount;
  var array = new Array(n);
  for (i = 0; i < n; ++i) {
    array[i] = this$1.structure.getAtomProxy(this$1.getAtomIndexByType(i, type2));
  }
  callback.apply(this, array);
  for (var j = n; j < m2; ++j) {
    for (i = 1; i < n; ++i) {
      array[i - 1].index = array[i].index;
    }
    array[n - 1].index = this$1.getAtomIndexByType(j, type2);
    callback.apply(this$1, array);
  }
};
Polymer.prototype.eachAtomN2 = function eachAtomN2(n, callback, type2) {
  var this$1 = this;
  var offset = this.atomOffset;
  var count2 = this.atomCount;
  var end = offset + count2;
  if (count2 < n) {
    return;
  }
  var array = new Array(n);
  for (var i = 0; i < n; ++i) {
    array[i] = this$1.structure.getAtomProxy();
  }
  var atomSet = this.structure.atomSetCache["__" + type2];
  if (atomSet === void 0) {
    Log.warn("no precomputed atomSet for: " + type2);
    atomSet = this.structure.getAtomSet(false);
    this.eachResidue(function(rp) {
      var ap = rp.getAtomByName(type2);
      atomSet.set(ap.index);
    });
  }
  var j = 0;
  atomSet.forEach(function(index) {
    if (index >= offset && index < end) {
      for (var i2 = 1; i2 < n; ++i2) {
        array[i2 - 1].index = array[i2].index;
      }
      array[n - 1].index = index;
      j += 1;
      if (j >= n) {
        callback.apply(this, array);
      }
    }
  });
};
Polymer.prototype.eachResidue = function eachResidue(callback) {
  var rp = this.structure.getResidueProxy();
  var n = this.residueCount;
  var rStartIndex = this.residueIndexStart;
  for (var i = 0; i < n; ++i) {
    rp.index = rStartIndex + i;
    callback(rp);
  }
};
Polymer.prototype.qualifiedName = function qualifiedName4() {
  var rpStart = this.structure.getResidueProxy(this.residueIndexStart);
  var rpEnd = this.structure.getResidueProxy(this.residueIndexEnd);
  return rpStart.qualifiedName() + " - " + rpEnd.qualifiedName();
};
Object.defineProperties(Polymer.prototype, prototypeAccessors$21);
var ChainProxy = function ChainProxy2(structure, index) {
  this.structure = structure;
  this.chainStore = structure.chainStore;
  this.residueStore = structure.residueStore;
  this.index = index;
};
var prototypeAccessors$20 = {entity: {}, model: {}, entityIndex: {}, modelIndex: {}, residueOffset: {}, residueCount: {}, residueEnd: {}, atomOffset: {}, atomEnd: {}, atomCount: {}, chainname: {}, chainid: {}};
prototypeAccessors$20.entity.get = function() {
  return this.structure.entityList[this.entityIndex];
};
prototypeAccessors$20.model.get = function() {
  return this.structure.getModelProxy(this.modelIndex);
};
prototypeAccessors$20.entityIndex.get = function() {
  return this.chainStore.entityIndex[this.index];
};
prototypeAccessors$20.entityIndex.set = function(value2) {
  this.chainStore.entityIndex[this.index] = value2;
};
prototypeAccessors$20.modelIndex.get = function() {
  return this.chainStore.modelIndex[this.index];
};
prototypeAccessors$20.modelIndex.set = function(value2) {
  this.chainStore.modelIndex[this.index] = value2;
};
prototypeAccessors$20.residueOffset.get = function() {
  return this.chainStore.residueOffset[this.index];
};
prototypeAccessors$20.residueOffset.set = function(value2) {
  this.chainStore.residueOffset[this.index] = value2;
};
prototypeAccessors$20.residueCount.get = function() {
  return this.chainStore.residueCount[this.index];
};
prototypeAccessors$20.residueCount.set = function(value2) {
  this.chainStore.residueCount[this.index] = value2;
};
prototypeAccessors$20.residueEnd.get = function() {
  return this.residueOffset + this.residueCount - 1;
};
prototypeAccessors$20.atomOffset.get = function() {
  return this.residueStore.atomOffset[this.residueOffset];
};
prototypeAccessors$20.atomEnd.get = function() {
  return this.residueStore.atomOffset[this.residueEnd] + this.residueStore.atomCount[this.residueEnd] - 1;
};
prototypeAccessors$20.atomCount.get = function() {
  if (this.residueCount === 0) {
    return 0;
  } else {
    return this.atomEnd - this.atomOffset + 1;
  }
};
prototypeAccessors$20.chainname.get = function() {
  return this.chainStore.getChainname(this.index);
};
prototypeAccessors$20.chainname.set = function(value2) {
  this.chainStore.setChainname(this.index, value2);
};
prototypeAccessors$20.chainid.get = function() {
  return this.chainStore.getChainid(this.index);
};
prototypeAccessors$20.chainid.set = function(value2) {
  this.chainStore.setChainid(this.index, value2);
};
ChainProxy.prototype.eachAtom = function eachAtom3(callback, selection) {
  this.eachResidue(function(rp) {
    rp.eachAtom(callback, selection);
  }, selection);
};
ChainProxy.prototype.eachResidue = function eachResidue2(callback, selection) {
  var i;
  var count2 = this.residueCount;
  var offset = this.residueOffset;
  var rp = this.structure._rp;
  var end = offset + count2;
  if (selection && selection.test) {
    var residueOnlyTest = selection.residueOnlyTest;
    if (residueOnlyTest) {
      for (i = offset; i < end; ++i) {
        rp.index = i;
        if (residueOnlyTest(rp)) {
          callback(rp, selection);
        }
      }
    } else {
      for (i = offset; i < end; ++i) {
        rp.index = i;
        callback(rp, selection);
      }
    }
  } else {
    for (i = offset; i < end; ++i) {
      rp.index = i;
      callback(rp);
    }
  }
};
ChainProxy.prototype.eachResidueN = function eachResidueN(n, callback) {
  var this$1 = this;
  var i;
  var count2 = this.residueCount;
  var offset = this.residueOffset;
  var end = offset + count2;
  if (count2 < n) {
    return;
  }
  var array = new Array(n);
  for (i = 0; i < n; ++i) {
    array[i] = this$1.structure.getResidueProxy(offset + i);
  }
  callback.apply(this, array);
  for (var j = offset + n; j < end; ++j) {
    for (i = 0; i < n; ++i) {
      array[i].index += 1;
    }
    callback.apply(this$1, array);
  }
};
ChainProxy.prototype.eachPolymer = function eachPolymer(callback, selection) {
  var rStartIndex, rNextIndex;
  var test = selection ? selection.residueOnlyTest : void 0;
  var structure = this.model.structure;
  var count2 = this.residueCount;
  var offset = this.residueOffset;
  var end = offset + count2;
  var rp1 = this.structure.getResidueProxy();
  var rp2 = this.structure.getResidueProxy(offset);
  var ap1 = this.structure.getAtomProxy();
  var ap2 = this.structure.getAtomProxy();
  var first = true;
  for (var i = offset + 1; i < end; ++i) {
    rp1.index = rp2.index;
    rp2.index = i;
    if (first) {
      rStartIndex = rp1.index;
      first = false;
    }
    rNextIndex = rp2.index;
    var bbType1 = first ? rp1.backboneEndType : rp1.backboneType;
    var bbType2 = rp2.backboneType;
    if (bbType1 !== UnknownBackboneType && bbType1 === bbType2) {
      ap1.index = rp1.backboneEndAtomIndex;
      ap2.index = rp2.backboneStartAtomIndex;
    } else {
      if (bbType1 !== UnknownBackboneType) {
        if (rp1.index - rStartIndex > 1) {
          callback(new Polymer(structure, rStartIndex, rp1.index));
        }
      }
      rStartIndex = rNextIndex;
      continue;
    }
    if (!ap1 || !ap2 || !ap1.connectedTo(ap2) || test && (!test(rp1) || !test(rp2))) {
      if (rp1.index - rStartIndex > 1) {
        callback(new Polymer(structure, rStartIndex, rp1.index));
      }
      rStartIndex = rNextIndex;
    }
  }
  if (rNextIndex - rStartIndex > 1) {
    if (this.structure.getResidueProxy(rStartIndex).backboneStartType) {
      callback(new Polymer(structure, rStartIndex, rNextIndex));
    }
  }
};
ChainProxy.prototype.qualifiedName = function qualifiedName5() {
  var name = ":" + this.chainname + "/" + this.modelIndex;
  return name;
};
ChainProxy.prototype.clone = function clone6() {
  return new this.constructor(this.structure, this.index);
};
ChainProxy.prototype.toObject = function toObject4() {
  return {
    index: this.index,
    residueOffset: this.residueOffset,
    residueCount: this.residueCount,
    chainname: this.chainname
  };
};
Object.defineProperties(ChainProxy.prototype, prototypeAccessors$20);
var ModelProxy = function ModelProxy2(structure, index) {
  this.structure = structure;
  this.modelStore = structure.modelStore;
  this.chainStore = structure.chainStore;
  this.residueStore = structure.residueStore;
  this.index = index;
};
var prototypeAccessors$22 = {chainOffset: {}, chainCount: {}, residueOffset: {}, atomOffset: {}, chainEnd: {}, residueEnd: {}, atomEnd: {}, residueCount: {}, atomCount: {}};
prototypeAccessors$22.chainOffset.get = function() {
  return this.modelStore.chainOffset[this.index];
};
prototypeAccessors$22.chainOffset.set = function(value2) {
  this.modelStore.chainOffset[this.index] = value2;
};
prototypeAccessors$22.chainCount.get = function() {
  return this.modelStore.chainCount[this.index];
};
prototypeAccessors$22.chainCount.set = function(value2) {
  this.modelStore.chainCount[this.index] = value2;
};
prototypeAccessors$22.residueOffset.get = function() {
  return this.chainStore.residueOffset[this.chainOffset];
};
prototypeAccessors$22.atomOffset.get = function() {
  return this.residueStore.atomOffset[this.residueOffset];
};
prototypeAccessors$22.chainEnd.get = function() {
  return this.chainOffset + this.chainCount - 1;
};
prototypeAccessors$22.residueEnd.get = function() {
  return this.chainStore.residueOffset[this.chainEnd] + this.chainStore.residueCount[this.chainEnd] - 1;
};
prototypeAccessors$22.atomEnd.get = function() {
  return this.residueStore.atomOffset[this.residueEnd] + this.residueStore.atomCount[this.residueEnd] - 1;
};
prototypeAccessors$22.residueCount.get = function() {
  if (this.chainCount === 0) {
    return 0;
  } else {
    return this.residueEnd - this.residueOffset + 1;
  }
};
prototypeAccessors$22.atomCount.get = function() {
  if (this.residueCount === 0) {
    return 0;
  } else {
    return this.atomEnd - this.atomOffset + 1;
  }
};
ModelProxy.prototype.eachAtom = function eachAtom4(callback, selection) {
  this.eachChain(function(cp) {
    cp.eachAtom(callback, selection);
  }, selection);
};
ModelProxy.prototype.eachResidue = function eachResidue3(callback, selection) {
  this.eachChain(function(cp) {
    cp.eachResidue(callback, selection);
  }, selection);
};
ModelProxy.prototype.eachPolymer = function eachPolymer2(callback, selection) {
  if (selection && selection.chainOnlyTest) {
    var chainOnlyTest = selection.chainOnlyTest;
    this.eachChain(function(cp) {
      if (chainOnlyTest(cp)) {
        cp.eachPolymer(callback, selection);
      }
    });
  } else {
    this.eachChain(function(cp) {
      cp.eachPolymer(callback, selection);
    });
  }
};
ModelProxy.prototype.eachChain = function eachChain(callback, selection) {
  var i;
  var count2 = this.chainCount;
  var offset = this.chainOffset;
  var cp = this.structure._cp;
  var end = offset + count2;
  if (selection && selection.test) {
    var chainOnlyTest = selection.chainOnlyTest;
    if (chainOnlyTest) {
      for (i = offset; i < end; ++i) {
        cp.index = i;
        if (chainOnlyTest(cp)) {
          callback(cp, selection);
        }
      }
    } else {
      for (i = offset; i < end; ++i) {
        cp.index = i;
        callback(cp, selection);
      }
    }
  } else {
    for (i = offset; i < end; ++i) {
      cp.index = i;
      callback(cp);
    }
  }
};
ModelProxy.prototype.qualifiedName = function qualifiedName6() {
  var name = "/" + this.index;
  return name;
};
ModelProxy.prototype.clone = function clone7() {
  return new this.constructor(this.structure, this.index);
};
ModelProxy.prototype.toObject = function toObject5() {
  return {
    index: this.index,
    chainOffset: this.chainOffset,
    chainCount: this.chainCount
  };
};
Object.defineProperties(ModelProxy.prototype, prototypeAccessors$22);
var Structure = function Structure2(name, path) {
  this.signals = {
    refreshed: new Signal()
  };
  this.init(name, path);
};
var prototypeAccessors$12 = {type: {}};
Structure.prototype.init = function init(name, path) {
  this.name = name;
  this.path = path;
  this.title = "";
  this.id = "";
  this.header = {};
  this.extraData = {};
  this.atomSetCache = void 0;
  this.atomSetDict = {};
  this.biomolDict = {};
  this.entityList = [];
  this.unitcell = void 0;
  this.frames = [];
  this.boxes = [];
  this.validation = void 0;
  this.bondStore = new BondStore(0);
  this.backboneBondStore = new BondStore(0);
  this.rungBondStore = new BondStore(0);
  this.atomStore = new AtomStore(0);
  this.residueStore = new ResidueStore(0);
  this.chainStore = new ChainStore(0);
  this.modelStore = new ModelStore(0);
  this.atomMap = new AtomMap(this);
  this.residueMap = new ResidueMap(this);
  this.bondHash = void 0;
  this.spatialHash = void 0;
  this.atomSet = void 0;
  this.bondSet = void 0;
  this.center = void 0;
  this.boundingBox = void 0;
  this._bp = this.getBondProxy();
  this._ap = this.getAtomProxy();
  this._rp = this.getResidueProxy();
  this._cp = this.getChainProxy();
};
prototypeAccessors$12.type.get = function() {
  return "Structure";
};
Structure.prototype.finalizeAtoms = function finalizeAtoms() {
  this.atomSet = this.getAtomSet();
  this.atomCount = this.atomStore.count;
  this.boundingBox = this.getBoundingBox();
  this.center = this.boundingBox.getCenter();
  this.spatialHash = new SpatialHash(this.atomStore, this.boundingBox);
};
Structure.prototype.finalizeBonds = function finalizeBonds() {
  var this$1 = this;
  this.bondSet = this.getBondSet();
  this.bondCount = this.bondStore.count;
  this.bondHash = new BondHash(this.bondStore, this.atomStore.count);
  this.atomSetCache = {};
  if (!this.atomSetDict.rung) {
    this.atomSetDict.rung = this.getAtomSet(false);
  }
  for (var name in this$1.atomSetDict) {
    this$1.atomSetCache["__" + name] = this$1.atomSetDict[name].clone();
  }
};
Structure.prototype.getBondProxy = function getBondProxy(index) {
  return new BondProxy(this, index);
};
Structure.prototype.getAtomProxy = function getAtomProxy(index) {
  return new AtomProxy(this, index);
};
Structure.prototype.getResidueProxy = function getResidueProxy(index) {
  return new ResidueProxy(this, index);
};
Structure.prototype.getChainProxy = function getChainProxy(index) {
  return new ChainProxy(this, index);
};
Structure.prototype.getModelProxy = function getModelProxy(index) {
  return new ModelProxy(this, index);
};
Structure.prototype.getBondSet = function getBondSet() {
  var n = this.bondStore.count;
  var bondSet = new BitArray(n);
  var atomSet = this.atomSet;
  if (atomSet) {
    var bp = this.getBondProxy();
    for (var i = 0; i < n; ++i) {
      bp.index = i;
      if (atomSet.isSet(bp.atomIndex1, bp.atomIndex2)) {
        bondSet.set(bp.index);
      }
    }
  } else {
    bondSet.setAll();
  }
  return bondSet;
};
Structure.prototype.getBackboneBondSet = function getBackboneBondSet() {
  var n = this.backboneBondStore.count;
  var backboneBondSet = new BitArray(n);
  var backboneAtomSet = this.atomSetCache.__backbone;
  if (backboneAtomSet) {
    var bp = this.getBondProxy();
    bp.bondStore = this.backboneBondStore;
    for (var i = 0; i < n; ++i) {
      bp.index = i;
      if (backboneAtomSet.isSet(bp.atomIndex1, bp.atomIndex2)) {
        backboneBondSet.set(bp.index);
      }
    }
  } else {
    backboneBondSet.set_all(true);
  }
  return backboneBondSet;
};
Structure.prototype.getRungBondSet = function getRungBondSet() {
  var n = this.rungBondStore.count;
  var rungBondSet = new BitArray(n);
  var rungAtomSet = this.atomSetCache.__rung;
  if (rungAtomSet) {
    var bp = this.getBondProxy();
    bp.bondStore = this.rungBondStore;
    for (var i = 0; i < n; ++i) {
      bp.index = i;
      if (rungAtomSet.isSet(bp.atomIndex1, bp.atomIndex2)) {
        rungBondSet.set(bp.index);
      }
    }
  } else {
    rungBondSet.set_all(true);
  }
  return rungBondSet;
};
Structure.prototype.getAtomSet = function getAtomSet(selection) {
  var atomSet;
  var n = this.atomStore.count;
  if (selection instanceof BitArray) {
    atomSet = selection;
  } else if (selection && selection.test) {
    var seleString = selection.string;
    if (seleString in this.atomSetCache) {
      atomSet = this.atomSetCache[seleString];
    } else {
      atomSet = new BitArray(n);
      this.eachAtom(function(ap) {
        atomSet.set(ap.index);
      }, selection);
      this.atomSetCache[seleString] = atomSet;
    }
  } else if (selection === false) {
    atomSet = new BitArray(n);
  } else {
    atomSet = new BitArray(n, true);
  }
  return atomSet;
};
Structure.prototype.getAtomSetWithinSelection = function getAtomSetWithinSelection(selection, radius) {
  var spatialHash = this.spatialHash;
  var atomSet = this.getAtomSet(false);
  var ap = this.getAtomProxy();
  this.getAtomSet(selection).forEach(function(idx) {
    ap.index = idx;
    spatialHash.within(ap.x, ap.y, ap.z, radius).forEach(function(idx2) {
      atomSet.set(idx2);
    });
  });
  return atomSet;
};
Structure.prototype.getAtomSetWithinPoint = function getAtomSetWithinPoint(point, radius) {
  var p = point;
  var atomSet = this.getAtomSet(false);
  this.spatialHash.within(p.x, p.y, p.z, radius).forEach(function(idx) {
    atomSet.set(idx);
  });
  return atomSet;
};
Structure.prototype.getAtomSetWithinVolume = function getAtomSetWithinVolume(volume, radius, minValue, maxValue, outside) {
  var this$1 = this;
  var fv = new FilteredVolume(volume, minValue, maxValue, outside);
  var dp = fv.getDataPosition();
  var n = dp.length;
  var r = fv.matrix.getMaxScaleOnAxis();
  var atomSet = this.getAtomSet(false);
  for (var i = 0; i < n; i += 3) {
    this$1.spatialHash.within(dp[i], dp[i + 1], dp[i + 2], r).forEach(function(idx) {
      atomSet.set(idx);
    });
  }
  return atomSet;
};
Structure.prototype.getAtomSetWithinGroup = function getAtomSetWithinGroup(selection) {
  var atomResidueIndex = this.atomStore.residueIndex;
  var atomSet = this.getAtomSet(false);
  var rp = this.getResidueProxy();
  this.getAtomSet(selection).forEach(function(idx) {
    rp.index = atomResidueIndex[idx];
    for (var idx2 = rp.atomOffset; idx2 <= rp.atomEnd; ++idx2) {
      atomSet.set(idx2);
    }
  });
  return atomSet;
};
Structure.prototype.getSelection = function getSelection3() {
  return false;
};
Structure.prototype.getStructure = function getStructure() {
  return this;
};
Structure.prototype.eachEntity = function eachEntity(callback, type2) {
  this.entityList.forEach(function(entity) {
    if (type2 === void 0 || entity.getEntityType() === type2) {
      callback(entity);
    }
  });
};
Structure.prototype.eachBond = function eachBond2(callback, selection) {
  var bp = this.getBondProxy();
  var bondSet;
  if (selection && selection.test) {
    bondSet = this.getBondSet(selection);
    if (this.bondSet) {
      bondSet.intersection(this.bondSet);
    }
  }
  if (bondSet) {
    bondSet.forEach(function(index) {
      bp.index = index;
      callback(bp);
    });
  } else {
    var n = this.bondStore.count;
    for (var i = 0; i < n; ++i) {
      bp.index = i;
      callback(bp);
    }
  }
};
Structure.prototype.eachAtom = function eachAtom5(callback, selection) {
  if (selection && selection.test) {
    this.eachModel(function(mp) {
      mp.eachAtom(callback, selection);
    }, selection);
  } else {
    var an = this.atomStore.count;
    var ap = this.getAtomProxy();
    for (var i = 0; i < an; ++i) {
      ap.index = i;
      callback(ap);
    }
  }
};
Structure.prototype.eachResidue = function eachResidue4(callback, selection) {
  var i;
  if (selection && selection.test) {
    var mn = this.modelStore.count;
    var mp = this.getModelProxy();
    var modelOnlyTest = selection.modelOnlyTest;
    if (modelOnlyTest) {
      for (i = 0; i < mn; ++i) {
        mp.index = i;
        if (modelOnlyTest(mp)) {
          mp.eachResidue(callback, selection);
        }
      }
    } else {
      for (i = 0; i < mn; ++i) {
        mp.index = i;
        mp.eachResidue(callback, selection);
      }
    }
  } else {
    var rn = this.residueStore.count;
    var rp = this.getResidueProxy();
    for (i = 0; i < rn; ++i) {
      rp.index = i;
      callback(rp);
    }
  }
};
Structure.prototype.eachResidueN = function eachResidueN2(n, callback) {
  var this$1 = this;
  var i, j;
  var rn = this.residueStore.count;
  if (rn < n) {
    return;
  }
  var array = new Array(n);
  for (i = 0; i < n; ++i) {
    array[i] = this$1.getResidueProxy(i);
  }
  callback.apply(this, array);
  for (j = n; j < rn; ++j) {
    for (i = 0; i < n; ++i) {
      array[i].index += 1;
    }
    callback.apply(this$1, array);
  }
};
Structure.prototype.eachPolymer = function eachPolymer3(callback, selection) {
  if (selection && selection.modelOnlyTest) {
    var modelOnlyTest = selection.modelOnlyTest;
    this.eachModel(function(mp) {
      if (modelOnlyTest(mp)) {
        mp.eachPolymer(callback, selection);
      }
    });
  } else {
    this.eachModel(function(mp) {
      mp.eachPolymer(callback, selection);
    });
  }
};
Structure.prototype.eachChain = function eachChain2(callback, selection) {
  if (selection && selection.test) {
    this.eachModel(function(mp) {
      mp.eachChain(callback, selection);
    });
  } else {
    var cn = this.chainStore.count;
    var cp = this.getChainProxy();
    for (var i = 0; i < cn; ++i) {
      cp.index = i;
      callback(cp);
    }
  }
};
Structure.prototype.eachModel = function eachModel(callback, selection) {
  var i;
  var n = this.modelStore.count;
  var mp = this.getModelProxy();
  if (selection && selection.test) {
    var modelOnlyTest = selection.modelOnlyTest;
    if (modelOnlyTest) {
      for (i = 0; i < n; ++i) {
        mp.index = i;
        if (modelOnlyTest(mp)) {
          callback(mp, selection);
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        mp.index = i;
        callback(mp, selection);
      }
    }
  } else {
    for (i = 0; i < n; ++i) {
      mp.index = i;
      callback(mp);
    }
  }
};
Structure.prototype.getAtomData = function getAtomData(params) {
  var p = Object.assign({}, params);
  if (p.colorParams) {
    p.colorParams.structure = this.getStructure();
  }
  var what = p.what;
  var atomSet = defaults(p.atomSet, this.atomSet);
  var radiusFactory, colormaker;
  var position, color, picking, radius, index;
  var atomData = {};
  var ap = this.getAtomProxy();
  var atomCount = atomSet.getSize();
  if (!what || what.position) {
    position = new Float32Array(atomCount * 3);
    atomData.position = position;
  }
  if (!what || what.color) {
    color = new Float32Array(atomCount * 3);
    atomData.color = color;
    colormaker = ColormakerRegistry2.getScheme(p.colorParams);
  }
  if (!what || what.picking) {
    picking = new Float32Array(atomCount);
    atomData.picking = new AtomPicker(picking, this.getStructure());
  }
  if (!what || what.radius) {
    radius = new Float32Array(atomCount);
    atomData.radius = radius;
    radiusFactory = new RadiusFactory(p.radiusParams.radius, p.radiusParams.scale);
  }
  if (!what || what.index) {
    index = new Float32Array(atomCount);
    atomData.index = index;
  }
  atomSet.forEach(function(idx, i) {
    var i3 = i * 3;
    ap.index = idx;
    if (position) {
      ap.positionToArray(position, i3);
    }
    if (color) {
      colormaker.atomColorToArray(ap, color, i3);
    }
    if (picking) {
      picking[i] = idx;
    }
    if (radius) {
      radius[i] = radiusFactory.atomRadius(ap);
    }
    if (index) {
      index[i] = idx;
    }
  });
  return atomData;
};
Structure.prototype.getBondData = function getBondData(params) {
  var p = Object.assign({}, params);
  if (p.colorParams) {
    p.colorParams.structure = this.getStructure();
  }
  var what = p.what;
  var bondSet = defaults(p.bondSet, this.bondSet);
  var multipleBond = defaults(p.multipleBond, "off");
  var isMulti = multipleBond !== "off";
  var isOffset = multipleBond === "offset";
  var bondScale = defaults(p.bondScale, 0.4);
  var bondSpacing = defaults(p.bondSpacing, 1);
  var radiusFactory, colormaker;
  var position1, position2, color1, color2, picking, radius1, radius2;
  var bondData = {};
  var bp = this.getBondProxy();
  if (p.bondStore) {
    bp.bondStore = p.bondStore;
  }
  var ap1 = this.getAtomProxy();
  var ap2 = this.getAtomProxy();
  var bondCount;
  if (isMulti) {
    var storeBondOrder = bp.bondStore.bondOrder;
    bondCount = 0;
    bondSet.forEach(function(index) {
      bondCount += storeBondOrder[index];
    });
  } else {
    bondCount = bondSet.getSize();
  }
  if (!what || what.position) {
    position1 = new Float32Array(bondCount * 3);
    position2 = new Float32Array(bondCount * 3);
    bondData.position1 = position1;
    bondData.position2 = position2;
  }
  if (!what || what.color) {
    color1 = new Float32Array(bondCount * 3);
    color2 = new Float32Array(bondCount * 3);
    bondData.color = color1;
    bondData.color2 = color2;
    colormaker = ColormakerRegistry2.getScheme(p.colorParams);
  }
  if (!what || what.picking) {
    picking = new Float32Array(bondCount);
    bondData.picking = new BondPicker(picking, this.getStructure(), p.bondStore);
  }
  if (!what || what.radius || isMulti && what.position) {
    radiusFactory = new RadiusFactory(p.radiusParams.radius, p.radiusParams.scale);
  }
  if (!what || what.radius) {
    radius1 = new Float32Array(bondCount);
    bondData.radius = radius1;
    if (p.radius2) {
      radius2 = new Float32Array(bondCount);
      bondData.radius2 = radius2;
    }
  }
  var i = 0;
  var j, i3, k, bondOrder, radius, multiRadius, absOffset;
  var vt = new Vector3();
  var vShortening = new Vector3();
  var vShift = new Vector3();
  bondSet.forEach(function(index) {
    i3 = i * 3;
    bp.index = index;
    ap1.index = bp.atomIndex1;
    ap2.index = bp.atomIndex2;
    bondOrder = bp.bondOrder;
    if (position1) {
      if (isMulti && bondOrder > 1) {
        radius = radiusFactory.atomRadius(ap1);
        multiRadius = radius * bondScale / (0.5 * bondOrder);
        bp.calculateShiftDir(vShift);
        if (isOffset) {
          absOffset = 2 * bondSpacing * radius;
          vShift.multiplyScalar(absOffset);
          vShift.negate();
          vShortening.subVectors(ap2, ap1).multiplyScalar(Math.max(0.1, absOffset / 1.88));
          ap1.positionToArray(position1, i3);
          ap2.positionToArray(position2, i3);
          if (bondOrder >= 2) {
            vt.addVectors(ap1, vShift).add(vShortening).toArray(position1, i3 + 3);
            vt.addVectors(ap2, vShift).sub(vShortening).toArray(position2, i3 + 3);
            if (bondOrder >= 3) {
              vt.subVectors(ap1, vShift).add(vShortening).toArray(position1, i3 + 6);
              vt.subVectors(ap2, vShift).sub(vShortening).toArray(position2, i3 + 6);
            }
          }
        } else {
          absOffset = (bondSpacing - bondScale) * radius;
          vShift.multiplyScalar(absOffset);
          if (bondOrder === 2) {
            vt.addVectors(ap1, vShift).toArray(position1, i3);
            vt.subVectors(ap1, vShift).toArray(position1, i3 + 3);
            vt.addVectors(ap2, vShift).toArray(position2, i3);
            vt.subVectors(ap2, vShift).toArray(position2, i3 + 3);
          } else if (bondOrder === 3) {
            ap1.positionToArray(position1, i3);
            vt.addVectors(ap1, vShift).toArray(position1, i3 + 3);
            vt.subVectors(ap1, vShift).toArray(position1, i3 + 6);
            ap2.positionToArray(position2, i3);
            vt.addVectors(ap2, vShift).toArray(position2, i3 + 3);
            vt.subVectors(ap2, vShift).toArray(position2, i3 + 6);
          } else {
            ap1.positionToArray(position1, i3);
            ap2.positionToArray(position2, i3);
          }
        }
      } else {
        ap1.positionToArray(position1, i3);
        ap2.positionToArray(position2, i3);
      }
    }
    if (color1) {
      colormaker.bondColorToArray(bp, 1, color1, i3);
      colormaker.bondColorToArray(bp, 0, color2, i3);
      if (isMulti && bondOrder > 1) {
        for (j = 1; j < bondOrder; ++j) {
          k = j * 3 + i3;
          copyWithin(color1, i3, k, 3);
          copyWithin(color2, i3, k, 3);
        }
      }
    }
    if (picking) {
      picking[i] = index;
      if (isMulti && bondOrder > 1) {
        for (j = 1; j < bondOrder; ++j) {
          picking[i + j] = index;
        }
      }
    }
    if (radius1) {
      radius1[i] = radiusFactory.atomRadius(ap1);
      if (isMulti && bondOrder > 1) {
        multiRadius = radius1[i] * bondScale / (isOffset ? 1 : 0.5 * bondOrder);
        for (j = isOffset ? 1 : 0; j < bondOrder; ++j) {
          radius1[i + j] = multiRadius;
        }
      }
    }
    if (radius2) {
      radius2[i] = radiusFactory.atomRadius(ap2);
      if (isMulti && bondOrder > 1) {
        multiRadius = radius2[i] * bondScale / (isOffset ? 1 : 0.5 * bondOrder);
        for (j = isOffset ? 1 : 0; j < bondOrder; ++j) {
          radius2[i + j] = multiRadius;
        }
      }
    }
    i += isMulti ? bondOrder : 1;
  });
  return bondData;
};
Structure.prototype.getBackboneAtomData = function getBackboneAtomData(params) {
  params = Object.assign({
    atomSet: this.atomSetCache.__backbone
  }, params);
  return this.getAtomData(params);
};
Structure.prototype.getBackboneBondData = function getBackboneBondData(params) {
  params = Object.assign({
    bondSet: this.getBackboneBondSet(),
    bondStore: this.backboneBondStore
  }, params);
  return this.getBondData(params);
};
Structure.prototype.getRungAtomData = function getRungAtomData(params) {
  params = Object.assign({
    atomSet: this.atomSetCache.__rung
  }, params);
  return this.getAtomData(params);
};
Structure.prototype.getRungBondData = function getRungBondData(params) {
  params = Object.assign({
    bondSet: this.getRungBondSet(),
    bondStore: this.rungBondStore
  }, params);
  return this.getBondData(params);
};
Structure.prototype.getBoundingBox = function getBoundingBox3(selection, box) {
  if (Debug) {
    Log.time("getBoundingBox");
  }
  box = box || new Box3();
  var minX = Infinity;
  var minY = Infinity;
  var minZ = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  var maxZ = -Infinity;
  this.eachAtom(function(ap) {
    var x = ap.x;
    var y = ap.y;
    var z = ap.z;
    if (x < minX) {
      minX = x;
    }
    if (y < minY) {
      minY = y;
    }
    if (z < minZ) {
      minZ = z;
    }
    if (x > maxX) {
      maxX = x;
    }
    if (y > maxY) {
      maxY = y;
    }
    if (z > maxZ) {
      maxZ = z;
    }
  }, selection);
  box.min.set(minX, minY, minZ);
  box.max.set(maxX, maxY, maxZ);
  if (Debug) {
    Log.timeEnd("getBoundingBox");
  }
  return box;
};
Structure.prototype.getPrincipalAxes = function getPrincipalAxes(selection) {
  if (Debug) {
    Log.time("getPrincipalAxes");
  }
  var i = 0;
  var coords = new Matrix(3, this.atomCount);
  var cd = coords.data;
  this.eachAtom(function(a) {
    cd[i + 0] = a.x;
    cd[i + 1] = a.y;
    cd[i + 2] = a.z;
    i += 3;
  }, selection);
  if (Debug) {
    Log.timeEnd("getPrincipalAxes");
  }
  return new PrincipalAxes(coords);
};
Structure.prototype.atomCenter = function atomCenter(selection) {
  if (selection) {
    return this.getBoundingBox(selection).getCenter();
  } else {
    return this.center.clone();
  }
};
Structure.prototype.getSequence = function getSequence(selection) {
  var seq = [];
  var rp = this.getResidueProxy();
  this.eachAtom(function(ap) {
    rp.index = ap.residueIndex;
    if (ap.index === rp.traceAtomIndex) {
      seq.push(rp.getResname1());
    }
  }, selection);
  return seq;
};
Structure.prototype.getAtomIndices = function getAtomIndices(selection) {
  var indices;
  if (selection && selection.string) {
    indices = [];
    this.eachAtom(function(ap) {
      indices.push(ap.index);
    }, selection);
  } else {
    var p = {what: {index: true}};
    indices = this.getAtomData(p).index;
  }
  return indices;
};
Structure.prototype.getChainnameCount = function getChainnameCount(selection) {
  var chainnames = new Set();
  this.eachChain(function(cp) {
    if (cp.residueCount) {
      chainnames.add(cp.chainname);
    }
  }, selection);
  return chainnames.size;
};
Structure.prototype.updatePosition = function updatePosition(position) {
  var i = 0;
  this.eachAtom(function(ap) {
    ap.positionFromArray(position, i);
    i += 3;
  });
};
Structure.prototype.refreshPosition = function refreshPosition() {
  this.getBoundingBox(void 0, this.boundingBox);
  this.boundingBox.getCenter(this.center);
  this.spatialHash = new SpatialHash(this.atomStore, this.boundingBox);
};
Structure.prototype.dispose = function dispose13() {
  if (this.frames) {
    this.frames.length = 0;
  }
  if (this.boxes) {
    this.boxes.length = 0;
  }
  this.bondStore.dispose();
  this.backboneBondStore.dispose();
  this.rungBondStore.dispose();
  this.atomStore.dispose();
  this.residueStore.dispose();
  this.chainStore.dispose();
  this.modelStore.dispose();
  delete this.bondStore;
  delete this.atomStore;
  delete this.residueStore;
  delete this.chainStore;
  delete this.modelStore;
  delete this.frames;
  delete this.boxes;
  delete this.cif;
  delete this.bondSet;
  delete this.atomSet;
};
Object.defineProperties(Structure.prototype, prototypeAccessors$12);
function Queue(fn, argList) {
  var queue = [];
  var pending = false;
  if (argList) {
    for (var i = 0, il = argList.length; i < il; ++i) {
      queue.push(argList[i]);
    }
    next();
  }
  function run3(arg) {
    fn(arg, next);
  }
  function next() {
    var arg = queue.shift();
    if (arg !== void 0) {
      pending = true;
      setTimeout(function() {
        run3(arg);
      });
    } else {
      pending = false;
    }
  }
  this.push = function(arg) {
    queue.push(arg);
    if (!pending) {
      next();
    }
  };
  this.kill = function() {
    queue.length = 0;
  };
  this.length = function() {
    return queue.length;
  };
}
var Superposition = function Superposition2(atoms1, atoms2) {
  var n;
  if (typeof atoms1.eachAtom === "function") {
    n = atoms1.atomCount;
  } else if (atoms1 instanceof Float32Array) {
    n = atoms1.length / 3;
  }
  var coords1 = new Matrix(3, n);
  var coords2 = new Matrix(3, n);
  this.coords1t = new Matrix(n, 3);
  this.coords2t = new Matrix(n, 3);
  this.A = new Matrix(3, 3);
  this.W = new Matrix(1, 3);
  this.U = new Matrix(3, 3);
  this.V = new Matrix(3, 3);
  this.VH = new Matrix(3, 3);
  this.R = new Matrix(3, 3);
  this.tmp = new Matrix(3, 3);
  this.c = new Matrix(3, 3);
  this.c.data.set([1, 0, 0, 0, 1, 0, 0, 0, -1]);
  this.prepCoords(atoms1, coords1);
  this.prepCoords(atoms2, coords2);
  this._superpose(coords1, coords2);
};
Superposition.prototype._superpose = function _superpose(coords1, coords2) {
  this.mean1 = meanRows(coords1);
  this.mean2 = meanRows(coords2);
  subRows(coords1, this.mean1);
  subRows(coords2, this.mean2);
  transpose(this.coords1t, coords1);
  transpose(this.coords2t, coords2);
  multiplyABt(this.A, this.coords2t, this.coords1t);
  svd(this.A, this.W, this.U, this.V);
  invert3x3(this.V, this.VH);
  multiply3x3(this.R, this.U, this.VH);
  if (mat3x3determinant(this.R) < 0) {
    if (Debug) {
      Log.log("R not a right handed system");
    }
    multiply3x3(this.tmp, this.c, this.VH);
    multiply3x3(this.R, this.U, this.tmp);
  }
};
Superposition.prototype.prepCoords = function prepCoords(atoms, coords) {
  var i = 0;
  var cd = coords.data;
  if (typeof atoms.eachAtom === "function") {
    atoms.eachAtom(function(a) {
      cd[i + 0] = a.x;
      cd[i + 1] = a.y;
      cd[i + 2] = a.z;
      i += 3;
    });
  } else if (atoms instanceof Float32Array) {
    cd.set(atoms);
  } else {
    Log.warn("prepCoords: input type unknown");
  }
};
Superposition.prototype.transform = function transform(atoms) {
  var n;
  if (typeof atoms.eachAtom === "function") {
    n = atoms.atomCount;
  } else if (atoms instanceof Float32Array) {
    n = atoms.length / 3;
  }
  var coords = new Matrix(3, n);
  var tmp2 = new Matrix(n, 3);
  this.prepCoords(atoms, coords);
  subRows(coords, this.mean1);
  multiplyABt(tmp2, this.R, coords);
  transpose(coords, tmp2);
  addRows(coords, this.mean2);
  var i = 0;
  var cd = coords.data;
  if (typeof atoms.eachAtom === "function") {
    atoms.eachAtom(function(a) {
      a.x = cd[i + 0];
      a.y = cd[i + 1];
      a.z = cd[i + 2];
      i += 3;
    });
  } else if (atoms instanceof Float32Array) {
    atoms.set(cd.subarray(0, n * 3));
  } else {
    Log.warn("transform: input type unknown");
  }
};
var TrajectoryPlayer = function TrajectoryPlayer2(traj, params) {
  this.signals = {
    startedRunning: new Signal(),
    haltedRunning: new Signal()
  };
  var p = Object.assign({}, params);
  traj.signals.playerChanged.add(function(player) {
    if (player !== this) {
      this.pause();
    }
  }, this);
  var n = defaults(traj.numframes, 1);
  this.traj = traj;
  this.start = defaults(p.start, 0);
  this.end = Math.min(defaults(p.end, n - 1), n - 1);
  this.step = defaults(p.step, Math.ceil((n + 1) / 100));
  this.timeout = defaults(p.timeout, 50);
  this.interpolateType = defaults(p.interpolateType, "");
  this.interpolateStep = defaults(p.interpolateStep, 5);
  this.mode = defaults(p.mode, "loop");
  this.direction = defaults(p.direction, "forward");
  this._stopFlag = false;
  this._running = false;
  traj.signals.gotNumframes.add(function(n2) {
    this.end = Math.min(defaults(p.end, n2 - 1), n2 - 1);
  }, this);
};
TrajectoryPlayer.prototype._animate = function _animate() {
  var i;
  this._running = true;
  if (!this.traj.inProgress && !this._stopFlag) {
    if (this.direction === "forward") {
      i = this.traj.currentFrame + this.step;
    } else {
      i = this.traj.currentFrame - this.step;
    }
    if (i >= this.end || i < this.start) {
      if (this.mode === "once") {
        this.pause();
        if (this.direction === "forward") {
          i = this.end;
        } else {
          i = this.start;
        }
      } else {
        if (this.direction === "forward") {
          i = this.start;
        } else {
          i = this.end;
        }
      }
    }
    if (!this.interpolateType) {
      this.traj.setFrame(i);
    }
  }
  if (!this._stopFlag) {
    if (!this.traj.inProgress && this.interpolateType) {
      var ip, ipp, ippp;
      if (this.direction === "forward") {
        ip = Math.max(this.start, i - this.step);
        ipp = Math.max(this.start, i - 2 * this.step);
        ippp = Math.max(this.start, i - 3 * this.step);
      } else {
        ip = Math.min(this.end, i + this.step);
        ipp = Math.min(this.end, i + 2 * this.step);
        ippp = Math.min(this.end, i + 3 * this.step);
      }
      this._interpolate(i, ip, ipp, ippp, 1 / this.interpolateStep, 0);
    } else {
      setTimeout(this._animate.bind(this), this.timeout);
    }
  } else {
    this._running = false;
  }
};
TrajectoryPlayer.prototype._interpolate = function _interpolate(i, ip, ipp, ippp, d, t) {
  t += d;
  if (t <= 1) {
    var deltaTime = Math.round(this.timeout * d);
    this.traj.setFrameInterpolated(i, ip, ipp, ippp, t, this.interpolateType, function() {
      setTimeout(function() {
        this._interpolate(i, ip, ipp, ippp, d, t);
      }.bind(this), deltaTime);
    }.bind(this));
  } else {
    setTimeout(this._animate.bind(this), 0);
  }
};
TrajectoryPlayer.prototype.toggle = function toggle3() {
  if (this._running) {
    this.pause();
  } else {
    this.play();
  }
};
TrajectoryPlayer.prototype.play = function play() {
  if (!this._running) {
    if (this.traj.player !== this) {
      this.traj.setPlayer(this);
    }
    var frame = this.traj.currentFrame;
    var i = Math.ceil(frame / this.step) * this.step;
    if (this.direction === "forward" && frame >= this.end) {
      i = this.start;
    } else if (this.direction === "backward" && frame <= this.start) {
      i = this.end;
    }
    this.traj.setFrame(i);
    this._stopFlag = false;
    this._animate();
    this.signals.startedRunning.dispatch();
  }
};
TrajectoryPlayer.prototype.pause = function pause3() {
  if (this._running) {
    this._stopFlag = true;
    this.signals.haltedRunning.dispatch();
  }
};
TrajectoryPlayer.prototype.stop = function stop() {
  this.traj.setFrame(this.start);
  this.pause();
};
function centerPbc(coords, mean, box) {
  if (box[0] === 0 || box[8] === 0 || box[4] === 0) {
    return;
  }
  var i;
  var n = coords.length;
  var bx = box[0];
  var by = box[1];
  var bz = box[2];
  var mx = mean[0];
  var my = mean[1];
  var mz = mean[2];
  var fx = -mx + bx + bx / 2;
  var fy = -my + by + by / 2;
  var fz = -mz + bz + bz / 2;
  for (i = 0; i < n; i += 3) {
    coords[i + 0] = (coords[i + 0] + fx) % bx;
    coords[i + 1] = (coords[i + 1] + fy) % by;
    coords[i + 2] = (coords[i + 2] + fz) % bz;
  }
}
function removePbc(x, box) {
  if (box[0] === 0 || box[8] === 0 || box[4] === 0) {
    return;
  }
  var i, j, d, dist;
  var n = x.length;
  for (i = 3; i < n; i += 3) {
    for (j = 0; j < 3; ++j) {
      dist = x[i + j] - x[i - 3 + j];
      if (Math.abs(dist) > 0.9 * box[j * 3 + j]) {
        if (dist > 0) {
          for (d = 0; d < 3; ++d) {
            x[i + d] -= box[j * 3 + d];
          }
        } else {
          for (d = 0; d < 3; ++d) {
            x[i + d] += box[j * 3 + d];
          }
        }
      }
    }
  }
  return x;
}
var Trajectory = function Trajectory2(trajPath, structure, params) {
  this.signals = {
    gotNumframes: new Signal(),
    frameChanged: new Signal(),
    selectionChanged: new Signal(),
    playerChanged: new Signal()
  };
  var p = params || {};
  p.centerPbc = defaults(p.centerPbc, true);
  p.removePbc = defaults(p.removePbc, true);
  p.superpose = defaults(p.superpose, true);
  this.setParameters(p);
  this.name = trajPath.replace(/^.*[\\/]/, "");
  this.selection = new Selection(defaults(p.sele, "backbone and not hydrogen"));
  this.selection.signals.stringChanged.add(function() {
    this.makeIndices();
    this.resetCache();
  }, this);
  this.setStructure(structure);
  this.setPlayer(new TrajectoryPlayer(this));
  this.trajPath = trajPath;
  this.numframes = void 0;
  this.getNumframes();
};
Trajectory.prototype.setStructure = function setStructure(structure) {
  this.structure = structure;
  this.atomCount = structure.atomCount;
  this.makeAtomIndices();
  this.saveInitialStructure();
  this.backboneIndices = this.getIndices(new Selection("backbone and not hydrogen"));
  this.makeIndices();
  this.frameCache = [];
  this.boxCache = [];
  this.pathCache = [];
  this.frameCacheSize = 0;
  this.currentFrame = -1;
};
Trajectory.prototype.saveInitialStructure = function saveInitialStructure() {
  var i = 0;
  var initialStructure = new Float32Array(3 * this.atomCount);
  this.structure.eachAtom(function(a) {
    initialStructure[i + 0] = a.x;
    initialStructure[i + 1] = a.y;
    initialStructure[i + 2] = a.z;
    i += 3;
  });
  this.initialStructure = initialStructure;
};
Trajectory.prototype.setSelection = function setSelection(string) {
  this.selection.setString(string);
  return this;
};
Trajectory.prototype.getIndices = function getIndices(selection) {
  var indices;
  if (selection && selection.test) {
    var i = 0;
    var test = selection.test;
    indices = [];
    this.structure.eachAtom(function(ap) {
      if (test(ap)) {
        indices.push(i);
      }
      i += 1;
    });
  } else {
    indices = this.structure.getAtomIndices(this.selection);
  }
  return indices;
};
Trajectory.prototype.makeIndices = function makeIndices() {
  var this$1 = this;
  this.indices = this.getIndices(this.selection);
  var i, j;
  var n = this.indices.length * 3;
  this.coords1 = new Float32Array(n);
  this.coords2 = new Float32Array(n);
  var y = this.initialStructure;
  var coords2 = this.coords2;
  for (i = 0; i < n; i += 3) {
    j = this$1.indices[i / 3] * 3;
    coords2[i + 0] = y[j + 0];
    coords2[i + 1] = y[j + 1];
    coords2[i + 2] = y[j + 2];
  }
};
Trajectory.prototype.makeAtomIndices = function makeAtomIndices() {
  Log.error("Trajectory.makeAtomIndices not implemented");
};
Trajectory.prototype.getNumframes = function getNumframes() {
  Log.error("Trajectory.loadFrame not implemented");
};
Trajectory.prototype.resetCache = function resetCache() {
  this.frameCache = [];
  this.boxCache = [];
  this.pathCache = [];
  this.frameCacheSize = 0;
  this.setFrame(this.currentFrame);
  return this;
};
Trajectory.prototype.setParameters = function setParameters2(params) {
  var p = params;
  var resetCache2 = false;
  if (p.centerPbc !== void 0 && p.centerPbc !== this.centerPbc) {
    this.centerPbc = p.centerPbc;
    resetCache2 = true;
  }
  if (p.removePbc !== void 0 && p.removePbc !== this.removePbc) {
    this.removePbc = p.removePbc;
    resetCache2 = true;
  }
  if (p.superpose !== void 0 && p.superpose !== this.superpose) {
    this.superpose = p.superpose;
    resetCache2 = true;
  }
  if (resetCache2) {
    this.resetCache();
  }
};
Trajectory.prototype.setFrame = function setFrame(i, callback) {
  if (i === void 0) {
    return this;
  }
  this.inProgress = true;
  i = parseInt(i);
  if (i === -1 || this.frameCache[i]) {
    this.updateStructure(i, callback);
  } else {
    this.loadFrame(i, function() {
      this.updateStructure(i, callback);
    }.bind(this));
  }
  return this;
};
Trajectory.prototype.interpolate = function interpolate2(i, ip, ipp, ippp, t, type2, callback) {
  var fc = this.frameCache;
  var c = fc[i];
  var cp = fc[ip];
  var cpp = fc[ipp];
  var cppp = fc[ippp];
  var j;
  var m2 = c.length;
  var coords = new Float32Array(m2);
  if (type2 === "spline") {
    for (j = 0; j < m2; j += 3) {
      coords[j + 0] = spline(cppp[j + 0], cpp[j + 0], cp[j + 0], c[j + 0], t, 1);
      coords[j + 1] = spline(cppp[j + 1], cpp[j + 1], cp[j + 1], c[j + 1], t, 1);
      coords[j + 2] = spline(cppp[j + 2], cpp[j + 2], cp[j + 2], c[j + 2], t, 1);
    }
  } else {
    for (j = 0; j < m2; j += 3) {
      coords[j + 0] = lerp(cp[j + 0], c[j + 0], t);
      coords[j + 1] = lerp(cp[j + 1], c[j + 1], t);
      coords[j + 2] = lerp(cp[j + 2], c[j + 2], t);
    }
  }
  this.structure.updatePosition(coords);
  this.currentFrame = i;
  this.signals.frameChanged.dispatch(i);
  if (typeof callback === "function") {
    callback();
  }
};
Trajectory.prototype.setFrameInterpolated = function setFrameInterpolated(i, ip, ipp, ippp, t, type2, callback) {
  if (i === void 0) {
    return this;
  }
  var fc = this.frameCache;
  var iList = [];
  if (!fc[ippp]) {
    iList.push(ippp);
  }
  if (!fc[ipp]) {
    iList.push(ipp);
  }
  if (!fc[ip]) {
    iList.push(ip);
  }
  if (!fc[i]) {
    iList.push(i);
  }
  if (iList.length) {
    this.loadFrame(iList, function() {
      this.interpolate(i, ip, ipp, ippp, t, type2, callback);
    }.bind(this));
  } else {
    this.interpolate(i, ip, ipp, ippp, t, type2, callback);
  }
  return this;
};
Trajectory.prototype.loadFrame = function loadFrame(i, callback) {
  if (Array.isArray(i)) {
    var queue;
    var fn = function(j, wcallback) {
      this._loadFrame(j, wcallback);
      if (queue.length() === 0 && typeof callback === "function") {
        callback();
      }
    }.bind(this);
    queue = new Queue(fn, i);
  } else {
    this._loadFrame(i, callback);
  }
};
Trajectory.prototype._loadFrame = function _loadFrame(i, callback) {
  Log.error("Trajectory._loadFrame not implemented", i, callback);
};
Trajectory.prototype.updateStructure = function updateStructure(i, callback) {
  if (this._disposed) {
    return;
  }
  if (i === -1) {
    this.structure.updatePosition(this.initialStructure);
  } else {
    this.structure.updatePosition(this.frameCache[i]);
  }
  this.structure.trajectory = {
    name: this.trajPath,
    frame: i
  };
  if (typeof callback === "function") {
    callback();
  }
  this.currentFrame = i;
  this.inProgress = false;
  this.signals.frameChanged.dispatch(i);
};
Trajectory.prototype.getCircularMean = function getCircularMean(indices, coords, box) {
  return [
    circularMean(coords, box[0], 3, 0, indices),
    circularMean(coords, box[1], 3, 1, indices),
    circularMean(coords, box[2], 3, 2, indices)
  ];
};
Trajectory.prototype.doSuperpose = function doSuperpose(x) {
  var this$1 = this;
  var i, j;
  var n = this.indices.length * 3;
  var coords1 = this.coords1;
  var coords2 = this.coords2;
  for (i = 0; i < n; i += 3) {
    j = this$1.indices[i / 3] * 3;
    coords1[i + 0] = x[j + 0];
    coords1[i + 1] = x[j + 1];
    coords1[i + 2] = x[j + 2];
  }
  var sp = new Superposition(coords1, coords2);
  sp.transform(x);
};
Trajectory.prototype.process = function process(i, box, coords, numframes) {
  this.setNumframes(numframes);
  if (box) {
    if (this.backboneIndices.length > 0 && this.centerPbc) {
      var box2 = [box[0], box[4], box[8]];
      var mean = this.getCircularMean(this.backboneIndices, coords, box2);
      centerPbc(coords, mean, box2);
    }
    if (this.removePbc) {
      removePbc(coords, box);
    }
  }
  if (this.indices.length > 0 && this.superpose) {
    this.doSuperpose(coords);
  }
  this.frameCache[i] = coords;
  this.boxCache[i] = box;
  this.frameCacheSize += 1;
};
Trajectory.prototype.setNumframes = function setNumframes(n) {
  if (n !== this.numframes) {
    this.numframes = n;
    this.signals.gotNumframes.dispatch(n);
  }
};
Trajectory.prototype.dispose = function dispose14() {
  this.frameCache = [];
  this._disposed = true;
  if (this.player) {
    this.player.stop();
  }
};
Trajectory.prototype.setPlayer = function setPlayer(player) {
  this.player = player;
  this.signals.playerChanged.dispatch(player);
};
Trajectory.prototype.getPath = function getPath(index, callback) {
  Log.error("Trajectory.getPath not implemented", index, callback);
};
ShaderRegistry.add("shader/Mesh.vert", "#define STANDARD\nuniform float nearClip;\nuniform vec3 clipCenter;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )\nvarying vec3 vViewPosition;\n#endif\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#elif defined( NOLIGHT )\nvarying vec3 vColor;\n#else\n#include color_pars_vertex\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#endif\n#include common\nvoid main(){\n#if defined( PICKING )\nvPickingColor = unpackColor( primitiveId );\n#elif defined( NOLIGHT )\nvColor = color;\n#else\n#include color_vertex\n#include beginnormal_vertex\n#include defaultnormal_vertex\n#ifndef FLAT_SHADED\nvNormal = normalize( transformedNormal );\n#endif\n#endif\n#include begin_vertex\n#include project_vertex\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )\nvViewPosition = -mvPosition.xyz;\n#endif\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n#include nearclip_vertex\n}");
ShaderRegistry.add("shader/Mesh.frag", "#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float nearClip;\nuniform float clipRadius;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )\nvarying vec3 vViewPosition;\n#endif\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\nuniform float objectId;\nvarying vec3 vPickingColor;\n#elif defined( NOLIGHT )\nvarying vec3 vColor;\n#else\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include common\n#include color_pars_fragment\n#include fog_pars_fragment\n#include bsdfs\n#include lights_pars\n#include lights_physical_pars_fragment\n#endif\nvoid main(){\n#include nearclip_fragment\n#include radiusclip_fragment\n#if defined( PICKING )\nif( opacity < 0.7 )\ndiscard;\ngl_FragColor = vec4( vPickingColor, objectId );\n#elif defined( NOLIGHT )\ngl_FragColor = vec4( vColor, opacity );\n#else\nvec4 diffuseColor = vec4( diffuse, opacity );\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveLight = emissive;\n#include color_fragment\n#include roughnessmap_fragment\n#include metalnessmap_fragment\n#include normal_flip\n#include normal_fragment\n#include dull_interior_fragment\n#include lights_physical_fragment\n#include lights_template\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#include opaque_back_fragment\n#endif\n}");
function getThreeSide(side) {
  if (side === "front") {
    return FrontSide;
  } else if (side === "back") {
    return BackSide;
  } else if (side === "double") {
    return DoubleSide;
  } else {
    return DoubleSide;
  }
}
var itemSize = {
  f: 1,
  v2: 2,
  v3: 3,
  c: 3
};
function setObjectMatrix(object, matrix2) {
  object.matrix.copy(matrix2);
  object.matrix.decompose(object.position, object.quaternion, object.scale);
  object.matrixWorldNeedsUpdate = true;
}
var Buffer = function Buffer2(data, params) {
  var d = data || {};
  var p = params || {};
  this.opaqueBack = defaults(p.opaqueBack, false);
  this.dullInterior = defaults(p.dullInterior, false);
  this.side = defaults(p.side, "double");
  this.opacity = defaults(p.opacity, 1);
  this.depthWrite = defaults(p.depthWrite, true);
  this.clipNear = defaults(p.clipNear, 0);
  this.clipRadius = defaults(p.clipRadius, 0);
  this.clipCenter = defaults(p.clipCenter, new Vector3());
  this.flatShaded = defaults(p.flatShaded, false);
  this.background = defaults(p.background, false);
  this.linewidth = defaults(p.linewidth, 1);
  this.wireframe = defaults(p.wireframe, false);
  this.wireframeLinewidth = defaults(p.wireframeLinewidth, 1);
  this.roughness = defaults(p.roughness, 0.4);
  this.metalness = defaults(p.metalness, 0);
  this.diffuse = defaults(p.diffuse, 16777215);
  this.forceTransparent = defaults(p.forceTransparent, false);
  this.disablePicking = defaults(p.disablePicking, false);
  this.geometry = new BufferGeometry();
  this.indexVersion = 0;
  this.wireframeIndexVersion = -1;
  this.uniforms = UniformsUtils.merge([
    UniformsLib.common,
    {
      fogColor: {value: null},
      fogNear: {value: 0},
      fogFar: {value: 0},
      opacity: {value: this.opacity},
      nearClip: {value: 0},
      clipRadius: {value: this.clipRadius},
      clipCenter: {value: this.clipCenter}
    },
    {
      emissive: {value: new Color(0)},
      roughness: {value: this.roughness},
      metalness: {value: this.metalness}
    },
    UniformsLib.ambient,
    UniformsLib.lights
  ]);
  this.uniforms.diffuse.value.set(this.diffuse);
  this.pickingUniforms = {
    nearClip: {value: 0},
    objectId: {value: 0},
    opacity: {value: this.opacity}
  };
  this.group = new Group();
  this.wireframeGroup = new Group();
  this.pickingGroup = new Group();
  this.matrix = defaults(p.matrix, new Matrix4());
  var position = d.position || d.position1;
  this._positionDataSize = position ? position.length / 3 : 0;
  this.addAttributes({
    position: {type: "v3", value: d.position},
    color: {type: "c", value: d.color},
    primitiveId: {type: "f", value: d.primitiveId}
  });
  if (d.index) {
    this.initIndex(d.index);
  }
  this.picking = d.picking;
  this.makeWireframeGeometry();
};
var prototypeAccessors$24 = {parameters: {}, matrix: {}, transparent: {}, size: {}, attributeSize: {}, pickable: {}, dynamic: {}, vertexShader: {}, fragmentShader: {}};
prototypeAccessors$24.parameters.get = function() {
  return {
    opaqueBack: {updateShader: true},
    dullInterior: {updateShader: true},
    side: {updateShader: true, property: true},
    opacity: {uniform: true},
    depthWrite: {property: true},
    clipNear: {updateShader: true, property: true},
    clipRadius: {updateShader: true, property: true, uniform: true},
    clipCenter: {uniform: true},
    flatShaded: {updateShader: true},
    background: {updateShader: true},
    linewidth: {property: true},
    wireframe: {updateVisibility: true},
    roughness: {uniform: true},
    metalness: {uniform: true},
    diffuse: {uniform: true},
    matrix: {}
  };
};
prototypeAccessors$24.matrix.set = function(m2) {
  this.setMatrix(m2);
};
prototypeAccessors$24.matrix.get = function() {
  return this.group.matrix.clone();
};
prototypeAccessors$24.transparent.get = function() {
  return this.opacity < 1 || this.forceTransparent;
};
prototypeAccessors$24.size.get = function() {
  return this._positionDataSize;
};
prototypeAccessors$24.attributeSize.get = function() {
  return this.size;
};
prototypeAccessors$24.pickable.get = function() {
  return !!this.picking && !this.disablePicking;
};
prototypeAccessors$24.dynamic.get = function() {
  return true;
};
prototypeAccessors$24.vertexShader.get = function() {
};
prototypeAccessors$24.fragmentShader.get = function() {
};
Buffer.prototype.setMatrix = function setMatrix2(m2) {
  setObjectMatrix(this.group, m2);
  setObjectMatrix(this.wireframeGroup, m2);
  setObjectMatrix(this.pickingGroup, m2);
};
Buffer.prototype.initIndex = function initIndex(index) {
  this.geometry.setIndex(new BufferAttribute(index, 1));
  this.geometry.getIndex().setDynamic(this.dynamic);
};
Buffer.prototype.makeMaterial = function makeMaterial() {
  var side = getThreeSide(this.side);
  var m2 = new ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: "",
    fragmentShader: "",
    depthTest: true,
    transparent: this.transparent,
    depthWrite: this.depthWrite,
    lights: true,
    fog: true,
    side,
    linewidth: this.linewidth
  });
  m2.vertexColors = VertexColors;
  m2.extensions.derivatives = this.flatShaded;
  m2.extensions.fragDepth = this.isImpostor;
  m2.clipNear = this.clipNear;
  var wm = new ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: "",
    fragmentShader: "",
    depthTest: true,
    transparent: this.transparent,
    depthWrite: this.depthWrite,
    lights: false,
    fog: true,
    side,
    linewidth: this.linewidth
  });
  wm.vertexColors = VertexColors;
  wm.clipNear = this.clipNear;
  var pm = new ShaderMaterial({
    uniforms: this.pickingUniforms,
    vertexShader: "",
    fragmentShader: "",
    depthTest: true,
    transparent: false,
    depthWrite: this.depthWrite,
    lights: false,
    fog: false,
    side,
    linewidth: this.linewidth,
    blending: NoBlending
  });
  pm.vertexColors = VertexColors;
  pm.extensions.fragDepth = this.isImpostor;
  pm.clipNear = this.clipNear;
  this.material = m2;
  this.wireframeMaterial = wm;
  this.pickingMaterial = pm;
  this.updateShader();
};
Buffer.prototype.makeWireframeGeometry = function makeWireframeGeometry() {
  this.makeWireframeIndex();
  var geometry = this.geometry;
  var wireframeIndex = this.wireframeIndex;
  var wireframeGeometry = new BufferGeometry();
  wireframeGeometry.attributes = geometry.attributes;
  if (wireframeIndex) {
    wireframeGeometry.setIndex(new BufferAttribute(wireframeIndex, 1).setDynamic(this.dynamic));
    wireframeGeometry.setDrawRange(0, this.wireframeIndexCount);
  }
  this.wireframeGeometry = wireframeGeometry;
};
Buffer.prototype.makeWireframeIndex = function makeWireframeIndex() {
  var edges = [];
  function checkEdge(a2, b2) {
    if (a2 > b2) {
      var tmp2 = a2;
      a2 = b2;
      b2 = tmp2;
    }
    var list = edges[a2];
    if (list === void 0) {
      edges[a2] = [b2];
      return true;
    } else if (!list.includes(b2)) {
      list.push(b2);
      return true;
    }
    return false;
  }
  var geometry = this.geometry;
  var index = geometry.index;
  if (!this.wireframe) {
    this.wireframeIndex = new Uint16Array(0);
    this.wireframeIndexCount = 0;
  } else if (index) {
    var array = index.array;
    var n = array.length;
    if (geometry.drawRange.count !== Infinity) {
      n = geometry.drawRange.count;
    }
    var wireframeIndex;
    if (this.wireframeIndex && this.wireframeIndex.length > n * 2) {
      wireframeIndex = this.wireframeIndex;
    } else {
      var count2 = geometry.attributes.position.count;
      wireframeIndex = getUintArray(n * 2, count2);
    }
    var j = 0;
    edges.length = 0;
    for (var i = 0; i < n; i += 3) {
      var a = array[i + 0];
      var b = array[i + 1];
      var c = array[i + 2];
      if (checkEdge(a, b)) {
        wireframeIndex[j + 0] = a;
        wireframeIndex[j + 1] = b;
        j += 2;
      }
      if (checkEdge(b, c)) {
        wireframeIndex[j + 0] = b;
        wireframeIndex[j + 1] = c;
        j += 2;
      }
      if (checkEdge(c, a)) {
        wireframeIndex[j + 0] = c;
        wireframeIndex[j + 1] = a;
        j += 2;
      }
    }
    this.wireframeIndex = wireframeIndex;
    this.wireframeIndexCount = j;
    this.wireframeIndexVersion = this.indexVersion;
  } else {
    var n$1 = geometry.attributes.position.count;
    var wireframeIndex$1;
    if (this.wireframeIndex && this.wireframeIndex.length > n$1 * 2) {
      wireframeIndex$1 = this.wireframeIndex;
    } else {
      wireframeIndex$1 = getUintArray(n$1 * 2, n$1);
    }
    for (var i$1 = 0, j$1 = 0; i$1 < n$1; i$1 += 3) {
      wireframeIndex$1[j$1 + 0] = i$1;
      wireframeIndex$1[j$1 + 1] = i$1 + 1;
      wireframeIndex$1[j$1 + 2] = i$1 + 1;
      wireframeIndex$1[j$1 + 3] = i$1 + 2;
      wireframeIndex$1[j$1 + 4] = i$1 + 2;
      wireframeIndex$1[j$1 + 5] = i$1;
      j$1 += 6;
    }
    this.wireframeIndex = wireframeIndex$1;
    this.wireframeIndexCount = n$1 * 2;
    this.wireframeIndexVersion = this.indexVersion;
  }
};
Buffer.prototype.updateWireframeIndex = function updateWireframeIndex() {
  this.wireframeGeometry.setDrawRange(0, Infinity);
  if (this.wireframeIndexVersion < this.indexVersion) {
    this.makeWireframeIndex();
  }
  if (this.wireframeIndex.length > this.wireframeGeometry.index.array.length) {
    this.wireframeGeometry.setIndex(new BufferAttribute(this.wireframeIndex, 1).setDynamic(this.dynamic));
  } else {
    var index = this.wireframeGeometry.getIndex();
    index.set(this.wireframeIndex);
    index.needsUpdate = this.wireframeIndexCount > 0;
    index.updateRange.count = this.wireframeIndexCount;
  }
  this.wireframeGeometry.setDrawRange(0, this.wireframeIndexCount);
};
Buffer.prototype.getRenderOrder = function getRenderOrder() {
  var renderOrder = 0;
  if (this.isText) {
    renderOrder = 1;
  } else if (this.transparent) {
    if (this.isSurface) {
      renderOrder = 3;
    } else {
      renderOrder = 2;
    }
  }
  return renderOrder;
};
Buffer.prototype._getMesh = function _getMesh(materialName) {
  if (!this.material) {
    this.makeMaterial();
  }
  var g = this.geometry;
  var m2 = this[materialName];
  var mesh;
  if (this.isLine) {
    mesh = new LineSegments(g, m2);
  } else if (this.isPoint) {
    mesh = new Points(g, m2);
    if (this.sortParticles) {
      mesh.sortParticles = true;
    }
  } else {
    mesh = new Mesh(g, m2);
  }
  mesh.frustumCulled = false;
  mesh.renderOrder = this.getRenderOrder();
  return mesh;
};
Buffer.prototype.getMesh = function getMesh() {
  return this._getMesh("material");
};
Buffer.prototype.getWireframeMesh = function getWireframeMesh() {
  var mesh;
  if (!this.material) {
    this.makeMaterial();
  }
  if (!this.wireframeGeometry) {
    this.makeWireframeGeometry();
  }
  mesh = new LineSegments(this.wireframeGeometry, this.wireframeMaterial);
  mesh.frustumCulled = false;
  mesh.renderOrder = this.getRenderOrder();
  return mesh;
};
Buffer.prototype.getPickingMesh = function getPickingMesh() {
  return this._getMesh("pickingMaterial");
};
Buffer.prototype.getShader = function getShader$1(name, type2) {
  return getShader(name, this.getDefines(type2));
};
Buffer.prototype.getVertexShader = function getVertexShader(type2) {
  return this.getShader(this.vertexShader, type2);
};
Buffer.prototype.getFragmentShader = function getFragmentShader(type2) {
  return this.getShader(this.fragmentShader, type2);
};
Buffer.prototype.getDefines = function getDefines2(type2) {
  var defines = {};
  if (this.clipNear) {
    defines.NEAR_CLIP = 1;
  }
  if (this.clipRadius) {
    defines.RADIUS_CLIP = 1;
  }
  if (type2 === "picking") {
    defines.PICKING = 1;
  } else {
    if (type2 === "background" || this.background) {
      defines.NOLIGHT = 1;
    }
    if (this.flatShaded) {
      defines.FLAT_SHADED = 1;
    }
    if (this.opaqueBack) {
      defines.OPAQUE_BACK = 1;
    }
    if (this.dullInterior) {
      defines.DULL_INTERIOR = 1;
    }
  }
  return defines;
};
Buffer.prototype.getParameters = function getParameters() {
  var this$1 = this;
  var params = {};
  for (var name in this$1.parameters) {
    params[name] = this$1[name];
  }
  return params;
};
Buffer.prototype.addUniforms = function addUniforms(uniforms) {
  this.uniforms = UniformsUtils.merge([this.uniforms, uniforms]);
  this.pickingUniforms = UniformsUtils.merge([this.pickingUniforms, uniforms]);
};
Buffer.prototype.addAttributes = function addAttributes(attributes) {
  var this$1 = this;
  for (var name in attributes) {
    var buf = void 0;
    var a = attributes[name];
    var arraySize = this$1.attributeSize * itemSize[a.type];
    if (a.value) {
      if (arraySize !== a.value.length) {
        Log.error("attribute value has wrong length", name);
      }
      buf = a.value;
    } else {
      buf = getTypedArray("float32", arraySize);
    }
    this$1.geometry.addAttribute(name, new BufferAttribute(buf, itemSize[a.type]).setDynamic(this$1.dynamic));
  }
};
Buffer.prototype.updateRenderOrder = function updateRenderOrder() {
  var renderOrder = this.getRenderOrder();
  function setRenderOrder(mesh) {
    mesh.renderOrder = renderOrder;
  }
  this.group.children.forEach(setRenderOrder);
  if (this.pickingGroup) {
    this.pickingGroup.children.forEach(setRenderOrder);
  }
};
Buffer.prototype.updateShader = function updateShader() {
  var m2 = this.material;
  var wm = this.wireframeMaterial;
  var pm = this.pickingMaterial;
  m2.vertexShader = this.getVertexShader();
  m2.fragmentShader = this.getFragmentShader();
  m2.needsUpdate = true;
  wm.vertexShader = this.getShader("Line.vert");
  wm.fragmentShader = this.getShader("Line.frag");
  wm.needsUpdate = true;
  pm.vertexShader = this.getVertexShader("picking");
  pm.fragmentShader = this.getFragmentShader("picking");
  pm.needsUpdate = true;
};
Buffer.prototype.setParameters = function setParameters3(params) {
  var this$1 = this;
  if (!params) {
    return;
  }
  var p = params;
  var tp = this.parameters;
  var propertyData = {};
  var uniformData = {};
  var doShaderUpdate = false;
  var doVisibilityUpdate = false;
  for (var name in p) {
    var value2 = p[name];
    if (value2 === void 0) {
      continue;
    }
    if (tp[name] === void 0) {
      continue;
    }
    this$1[name] = value2;
    if (tp[name].property) {
      if (tp[name].property !== true) {
        propertyData[tp[name].property] = value2;
      } else {
        propertyData[name] = value2;
      }
    }
    if (tp[name].uniform) {
      if (tp[name].uniform !== true) {
        uniformData[tp[name].uniform] = value2;
      } else {
        uniformData[name] = value2;
      }
    }
    if (tp[name].updateShader) {
      doShaderUpdate = true;
    }
    if (tp[name].updateVisibility) {
      doVisibilityUpdate = true;
    }
    if (this$1.dynamic && name === "wireframe" && value2 === true) {
      this$1.updateWireframeIndex();
    }
    if (name === "flatShaded") {
      this$1.material.extensions.derivatives = this$1.flatShaded;
    }
    if (name === "forceTransparent") {
      propertyData.transparent = this$1.transparent;
    }
  }
  this.setProperties(propertyData);
  this.setUniforms(uniformData);
  if (doShaderUpdate) {
    this.updateShader();
  }
  if (doVisibilityUpdate) {
    this.setVisibility(this.visible);
  }
};
Buffer.prototype.setAttributes = function setAttributes(data) {
  var this$1 = this;
  var geometry = this.geometry;
  var attributes = geometry.attributes;
  for (var name in data) {
    if (name === "picking") {
      continue;
    }
    var array = data[name];
    var length = array.length;
    if (name === "index") {
      var index = geometry.getIndex();
      geometry.setDrawRange(0, Infinity);
      if (length > index.array.length) {
        geometry.setIndex(new BufferAttribute(array, 1).setDynamic(this$1.dynamic));
      } else {
        index.set(array);
        index.needsUpdate = length > 0;
        index.updateRange.count = length;
        geometry.setDrawRange(0, length);
      }
      this$1.indexVersion++;
      if (this$1.wireframe) {
        this$1.updateWireframeIndex();
      }
    } else {
      var attribute = attributes[name];
      if (length > attribute.array.length) {
        geometry.addAttribute(name, new BufferAttribute(array, attribute.itemSize).setDynamic(this$1.dynamic));
      } else {
        attributes[name].set(array);
        attributes[name].needsUpdate = length > 0;
        attributes[name].updateRange.count = length;
      }
    }
  }
};
Buffer.prototype.setUniforms = function setUniforms(data) {
  var this$1 = this;
  if (!data) {
    return;
  }
  var u = this.material.uniforms;
  var wu = this.wireframeMaterial.uniforms;
  var pu = this.pickingMaterial.uniforms;
  for (var name in data) {
    if (name === "opacity") {
      this$1.setProperties({transparent: this$1.transparent});
    }
    if (u[name] !== void 0) {
      if (u[name].value.isVector3) {
        u[name].value.copy(data[name]);
      } else if (u[name].value.set) {
        u[name].value.set(data[name]);
      } else {
        u[name].value = data[name];
      }
    }
    if (wu[name] !== void 0) {
      if (wu[name].value.isVector3) {
        wu[name].value.copy(data[name]);
      } else if (wu[name].value.set) {
        wu[name].value.set(data[name]);
      } else {
        wu[name].value = data[name];
      }
    }
    if (pu[name] !== void 0) {
      if (pu[name].value.isVector3) {
        pu[name].value.copy(data[name]);
      } else if (pu[name].value.set) {
        pu[name].value.set(data[name]);
      } else {
        pu[name].value = data[name];
      }
    }
  }
};
Buffer.prototype.setProperties = function setProperties(data) {
  var this$1 = this;
  if (!data) {
    return;
  }
  var m2 = this.material;
  var wm = this.wireframeMaterial;
  var pm = this.pickingMaterial;
  for (var name in data) {
    var value2 = data[name];
    if (name === "transparent") {
      this$1.updateRenderOrder();
    } else if (name === "side") {
      value2 = getThreeSide(value2);
    }
    if (m2[name] !== void 0) {
      m2[name] = value2;
    }
    if (wm[name] !== void 0) {
      wm[name] = value2;
    }
    if (pm[name] !== void 0) {
      pm[name] = value2;
    }
  }
  m2.needsUpdate = true;
  wm.needsUpdate = true;
  pm.needsUpdate = true;
};
Buffer.prototype.setVisibility = function setVisibility2(value2) {
  this.visible = value2;
  if (this.wireframe) {
    this.group.visible = false;
    this.wireframeGroup.visible = value2;
    if (this.pickable) {
      this.pickingGroup.visible = false;
    }
  } else {
    this.group.visible = value2;
    this.wireframeGroup.visible = false;
    if (this.pickable) {
      this.pickingGroup.visible = value2;
    }
  }
};
Buffer.prototype.dispose = function dispose15() {
  if (this.material) {
    this.material.dispose();
  }
  if (this.wireframeMaterial) {
    this.wireframeMaterial.dispose();
  }
  if (this.pickingMaterial) {
    this.pickingMaterial.dispose();
  }
  this.geometry.dispose();
  if (this.wireframeGeometry) {
    this.wireframeGeometry.dispose();
  }
};
Object.defineProperties(Buffer.prototype, prototypeAccessors$24);
var MeshBuffer = function(Buffer$$1) {
  function MeshBuffer2(data, params) {
    var d = data || {};
    if (!d.primitiveId && d.position) {
      d.primitiveId = serialArray(d.position.length / 3);
    }
    Buffer$$1.call(this, d, params);
    this.addAttributes({
      normal: {type: "v3", value: d.normal}
    });
    if (d.normal === void 0) {
      this.geometry.computeVertexNormals();
    }
  }
  if (Buffer$$1)
    MeshBuffer2.__proto__ = Buffer$$1;
  MeshBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  MeshBuffer2.prototype.constructor = MeshBuffer2;
  var prototypeAccessors2 = {vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.vertexShader.get = function() {
    return "Mesh.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Mesh.frag";
  };
  Object.defineProperties(MeshBuffer2.prototype, prototypeAccessors2);
  return MeshBuffer2;
}(Buffer);
var matrix$1 = new Matrix4();
var normalMatrix = new Matrix3();
var GeometryBuffer = function(MeshBuffer$$1) {
  function GeometryBuffer2(data, params, geo) {
    var d = data || {};
    var p = params || {};
    var geoPosition = geo.attributes.position.array;
    var geoNormal = geo.attributes.normal.array;
    var geoIndex = geo.index ? geo.index.array : void 0;
    var n = d.position.length / 3;
    var m2 = geoPosition.length / 3;
    var size = n * m2;
    var meshPosition = new Float32Array(size * 3);
    var meshNormal = new Float32Array(size * 3);
    var meshColor = new Float32Array(size * 3);
    var meshIndex;
    if (geoIndex) {
      meshIndex = getUintArray(n * geoIndex.length, size);
    }
    MeshBuffer$$1.call(this, {
      position: meshPosition,
      color: meshColor,
      index: meshIndex,
      normal: meshNormal,
      primitiveId: d.primitiveId || serialBlockArray(n, m2),
      picking: d.picking
    }, p);
    this.setAttributes(d);
    this.geoPosition = geoPosition;
    this.geoNormal = geoNormal;
    this.geoIndex = geoIndex;
    this.positionCount = n;
    this.geoPositionCount = m2;
    this.transformedGeoPosition = new Float32Array(m2 * 3);
    this.transformedGeoNormal = new Float32Array(m2 * 3);
    this.meshPosition = meshPosition;
    this.meshColor = meshColor;
    this.meshIndex = meshIndex;
    this.meshNormal = meshNormal;
    this.meshIndex = meshIndex;
    this.makeIndex();
  }
  if (MeshBuffer$$1)
    GeometryBuffer2.__proto__ = MeshBuffer$$1;
  GeometryBuffer2.prototype = Object.create(MeshBuffer$$1 && MeshBuffer$$1.prototype);
  GeometryBuffer2.prototype.constructor = GeometryBuffer2;
  var prototypeAccessors2 = {updateNormals: {}};
  GeometryBuffer2.prototype.applyPositionTransform = function applyPositionTransform() {
  };
  GeometryBuffer2.prototype.setAttributes = function setAttributes4(data, initNormals) {
    var this$1 = this;
    var attributes = this.geometry.attributes;
    var position, color;
    var geoPosition, geoNormal;
    var transformedGeoPosition, transformedGeoNormal;
    var meshPosition, meshColor, meshNormal;
    var updateNormals = this.updateNormals;
    if (data.position) {
      position = data.position;
      geoPosition = this.geoPosition;
      meshPosition = this.meshPosition;
      transformedGeoPosition = this.transformedGeoPosition;
      attributes.position.needsUpdate = true;
      if (updateNormals || initNormals) {
        geoNormal = this.geoNormal;
        meshNormal = this.meshNormal;
        transformedGeoNormal = this.transformedGeoNormal;
        attributes.normal.needsUpdate = true;
      }
    }
    if (data.color) {
      color = data.color;
      meshColor = this.meshColor;
      attributes.color.needsUpdate = true;
    }
    var n = this.positionCount;
    var m2 = this.geoPositionCount;
    for (var i = 0; i < n; ++i) {
      var j = void 0, l = void 0;
      var k = i * m2 * 3;
      var i3 = i * 3;
      if (position) {
        transformedGeoPosition.set(geoPosition);
        matrix$1.makeTranslation(position[i3], position[i3 + 1], position[i3 + 2]);
        this$1.applyPositionTransform(matrix$1, i, i3);
        applyMatrix4toVector3array(matrix$1.elements, transformedGeoPosition);
        meshPosition.set(transformedGeoPosition, k);
        if (updateNormals) {
          transformedGeoNormal.set(geoNormal);
          normalMatrix.getNormalMatrix(matrix$1);
          applyMatrix3toVector3array(normalMatrix.elements, transformedGeoNormal);
          meshNormal.set(transformedGeoNormal, k);
        } else if (initNormals) {
          meshNormal.set(geoNormal, k);
        }
      }
      if (color) {
        for (j = 0; j < m2; ++j) {
          l = k + 3 * j;
          meshColor[l] = color[i3];
          meshColor[l + 1] = color[i3 + 1];
          meshColor[l + 2] = color[i3 + 2];
        }
      }
    }
  };
  GeometryBuffer2.prototype.makeIndex = function makeIndex() {
    var geoIndex = this.geoIndex;
    var meshIndex = this.meshIndex;
    if (!geoIndex) {
      return;
    }
    var n = this.positionCount;
    var m2 = this.geoPositionCount;
    var o = geoIndex.length / 3;
    var o3 = o * 3;
    for (var i = 0; i < n; ++i) {
      var j = i * o3;
      var q = j + o3;
      meshIndex.set(geoIndex, j);
      for (var p = j; p < q; ++p) {
        meshIndex[p] += i * m2;
      }
    }
  };
  prototypeAccessors2.updateNormals.get = function() {
    return false;
  };
  Object.defineProperties(GeometryBuffer2.prototype, prototypeAccessors2);
  return GeometryBuffer2;
}(MeshBuffer);
var scale = new Vector3();
var SphereGeometryBuffer = function(GeometryBuffer$$1) {
  function SphereGeometryBuffer2(data, params) {
    var p = params || {};
    var detail = defaults(p.sphereDetail, 1);
    var geo = new IcosahedronBufferGeometry(1, detail);
    GeometryBuffer$$1.call(this, data, p, geo);
    this.setAttributes(data, true);
  }
  if (GeometryBuffer$$1)
    SphereGeometryBuffer2.__proto__ = GeometryBuffer$$1;
  SphereGeometryBuffer2.prototype = Object.create(GeometryBuffer$$1 && GeometryBuffer$$1.prototype);
  SphereGeometryBuffer2.prototype.constructor = SphereGeometryBuffer2;
  SphereGeometryBuffer2.prototype.applyPositionTransform = function applyPositionTransform(matrix2, i) {
    var r = this._radius[i];
    scale.set(r, r, r);
    matrix2.scale(scale);
  };
  SphereGeometryBuffer2.prototype.setAttributes = function setAttributes4(data, initNormals) {
    if (data.radius) {
      this._radius = data.radius;
    }
    GeometryBuffer$$1.prototype.setAttributes.call(this, data, initNormals);
  };
  return SphereGeometryBuffer2;
}(GeometryBuffer);
ShaderRegistry.add("shader/SphereImpostor.vert", "uniform mat4 projectionMatrixInverse;\nuniform float nearClip;\nvarying float vRadius;\nvarying float vRadiusSq;\nvarying vec3 vPoint;\nvarying vec3 vPointViewPosition;\nattribute vec2 mapping;\nattribute float radius;\n#ifdef PICKING\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\n#include color_pars_vertex\n#endif\n#include matrix_scale\nconst mat4 D = mat4(\n1.0, 0.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0,\n0.0, 0.0, 1.0, 0.0,\n0.0, 0.0, 0.0, -1.0\n);\nmat4 transpose( in mat4 inMatrix ) {\nvec4 i0 = inMatrix[0];\nvec4 i1 = inMatrix[1];\nvec4 i2 = inMatrix[2];\nvec4 i3 = inMatrix[3];\nmat4 outMatrix = mat4(\nvec4(i0.x, i1.x, i2.x, i3.x),\nvec4(i0.y, i1.y, i2.y, i3.y),\nvec4(i0.z, i1.z, i2.z, i3.z),\nvec4(i0.w, i1.w, i2.w, i3.w)\n);\nreturn outMatrix;\n}\nvoid ComputePointSizeAndPositionInClipCoordSphere(){\nvec2 xbc;\nvec2 ybc;\nmat4 T = mat4(\nradius, 0.0, 0.0, 0.0,\n0.0, radius, 0.0, 0.0,\n0.0, 0.0, radius, 0.0,\nposition.x, position.y, position.z, 1.0\n);\nmat4 R = transpose( projectionMatrix * modelViewMatrix * T );\nfloat A = dot( R[ 3 ], D * R[ 3 ] );\nfloat B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );\nfloat C = dot( R[ 0 ], D * R[ 0 ] );\nxbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\nxbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\nfloat sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;\nA = dot( R[ 3 ], D * R[ 3 ] );\nB = -2.0 * dot( R[ 1 ], D * R[ 3 ] );\nC = dot( R[ 1 ], D * R[ 1 ] );\nybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\nybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\nfloat sy = abs( ybc[ 0 ] - ybc[ 1 ] ) * 0.5;\ngl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );\ngl_Position.xy -= mapping * vec2( sx, sy );\ngl_Position.xy *= gl_Position.w;\n}\nvoid main(void){\n#ifdef PICKING\nvPickingColor = unpackColor( primitiveId );\n#else\n#include color_vertex\n#endif\nvRadius = radius * matrixScale( modelViewMatrix );\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\nmvPosition.z -= vRadius;\ngl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );\nComputePointSizeAndPositionInClipCoordSphere();\nvRadiusSq = vRadius * vRadius;\nvec4 vPoint4 = projectionMatrixInverse * gl_Position;\nvPoint = vPoint4.xyz / vPoint4.w;\nvPointViewPosition = -mvPosition.xyz / mvPosition.w;\n}");
ShaderRegistry.add("shader/SphereImpostor.frag", "#define STANDARD\n#define IMPOSTOR\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float nearClip;\nuniform mat4 projectionMatrix;\nuniform float ortho;\nvarying float vRadius;\nvarying float vRadiusSq;\nvarying vec3 vPoint;\nvarying vec3 vPointViewPosition;\n#ifdef PICKING\nuniform float objectId;\nvarying vec3 vPickingColor;\n#else\n#include common\n#include color_pars_fragment\n#include fog_pars_fragment\n#include bsdfs\n#include lights_pars\n#include lights_physical_pars_fragment\n#endif\nbool flag2 = false;\nbool interior = false;\nvec3 cameraPos;\nvec3 cameraNormal;\nfloat calcDepth( in vec3 cameraPos ){\nvec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\nreturn 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\nfloat calcClip( vec3 cameraPos ){\nreturn dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\nbool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){\nvec3 cameraSpherePos = -vPointViewPosition;\ncameraSpherePos.z += vRadius;\nvec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );\nvec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );\nvec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );\nfloat B = dot( rayDirection, cameraSphereDir );\nfloat det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );\nif( det < 0.0 ){\ndiscard;\nreturn false;\n}else{\nfloat sqrtDet = sqrt( det );\nfloat posT = mix( B + sqrtDet, B + sqrtDet, ortho );\nfloat negT = mix( B - sqrtDet, sqrtDet - B, ortho );\ncameraPos = rayDirection * negT + rayOrigin;\n#ifdef NEAR_CLIP\nif( calcDepth( cameraPos ) <= 0.0 ){\ncameraPos = rayDirection * posT + rayOrigin;\ninterior = true;\nreturn false;\n}else if( calcClip( cameraPos ) > 0.0 ){\ncameraPos = rayDirection * posT + rayOrigin;\ninterior = true;\nflag2 = true;\nreturn false;\n}else{\ncameraNormal = normalize( cameraPos - cameraSpherePos );\n}\n#else\nif( calcDepth( cameraPos ) <= 0.0 ){\ncameraPos = rayDirection * posT + rayOrigin;\ninterior = true;\nreturn false;\n}else{\ncameraNormal = normalize( cameraPos - cameraSpherePos );\n}\n#endif\nreturn true;\n}\nreturn false;\n}\nvoid main(void){\nbool flag = Impostor( cameraPos, cameraNormal );\n#ifdef NEAR_CLIP\nif( calcClip( cameraPos ) > 0.0 )\ndiscard;\n#endif\ngl_FragDepthEXT = calcDepth( cameraPos );\nif( !flag ){\n#ifdef NEAR_CLIP\nif( flag2 ){\ngl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );\n}else if( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n}\n#else\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n}\n#endif\n}\nif (gl_FragDepthEXT < 0.0)\ndiscard;\nif (gl_FragDepthEXT > 1.0)\ndiscard;\n#ifdef PICKING\ngl_FragColor = vec4( vPickingColor, objectId );\n#else\nvec3 vNormal = cameraNormal;\nvec3 vViewPosition = -cameraPos;\nvec4 diffuseColor = vec4( diffuse, opacity );\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveLight = emissive;\n#include color_fragment\n#include roughnessmap_fragment\n#include metalnessmap_fragment\n#include normal_flip\n#include normal_fragment\nif( interior ){\nnormal = vec3( 0.0, 0.0, 0.4 );\n}\n#include lights_physical_fragment\n#include lights_template\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#endif\n}");
var MappedBuffer = function(Buffer$$1) {
  function MappedBuffer2(data, params) {
    Buffer$$1.call(this, data, params);
    this.index = getUintArray(this.indexSize, this.attributeSize);
    this.makeIndex();
    this.initIndex(this.index, 1);
    this.addAttributes({
      mapping: {type: this.mappingType, value: null}
    });
    this.setAttributes({primitiveId: serialArray(this.size)});
  }
  if (Buffer$$1)
    MappedBuffer2.__proto__ = Buffer$$1;
  MappedBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  MappedBuffer2.prototype.constructor = MappedBuffer2;
  var prototypeAccessors2 = {attributeSize: {}, indexSize: {}, mapping: {}, mappingIndices: {}, mappingIndicesSize: {}, mappingType: {}, mappingSize: {}, mappingItemSize: {}};
  prototypeAccessors2.attributeSize.get = function() {
    return this.size * this.mappingSize;
  };
  prototypeAccessors2.indexSize.get = function() {
    return this.size * this.mappingIndicesSize;
  };
  prototypeAccessors2.mapping.get = function() {
  };
  prototypeAccessors2.mappingIndices.get = function() {
  };
  prototypeAccessors2.mappingIndicesSize.get = function() {
  };
  prototypeAccessors2.mappingType.get = function() {
  };
  prototypeAccessors2.mappingSize.get = function() {
  };
  prototypeAccessors2.mappingItemSize.get = function() {
  };
  MappedBuffer2.prototype.addAttributes = function addAttributes2(attributes) {
    var nullValueAttributes = {};
    for (var name in attributes) {
      var a = attributes[name];
      nullValueAttributes[name] = {
        type: a.type,
        value: null
      };
    }
    Buffer$$1.prototype.addAttributes.call(this, nullValueAttributes);
  };
  MappedBuffer2.prototype.getAttributeIndex = function getAttributeIndex(dataIndex) {
    return dataIndex * 3 * this.mappingSize;
  };
  MappedBuffer2.prototype.setAttributes = function setAttributes4(data) {
    if (data && !data.position && data.position1 && data.position2) {
      data.position = calculateCenterArray(data.position1, data.position2);
    }
    var size = this.size;
    var mappingSize = this.mappingSize;
    var attributes = this.geometry.attributes;
    var a, d, itemSize2, array, n, i, j;
    for (var name in data) {
      if (name === "index" || name === "picking") {
        continue;
      }
      d = data[name];
      a = attributes[name];
      itemSize2 = a.itemSize;
      array = a.array;
      for (var k = 0; k < size; ++k) {
        n = k * itemSize2;
        i = n * mappingSize;
        for (var l = 0; l < mappingSize; ++l) {
          j = i + itemSize2 * l;
          for (var m2 = 0; m2 < itemSize2; ++m2) {
            array[j + m2] = d[n + m2];
          }
        }
      }
      a.needsUpdate = true;
    }
  };
  MappedBuffer2.prototype.makeMapping = function makeMapping() {
    var size = this.size;
    var mapping2 = this.mapping;
    var mappingSize = this.mappingSize;
    var mappingItemSize = this.mappingItemSize;
    var aMapping = this.geometry.attributes.mapping.array;
    for (var v = 0; v < size; v++) {
      aMapping.set(mapping2, v * mappingItemSize * mappingSize);
    }
  };
  MappedBuffer2.prototype.makeIndex = function makeIndex() {
    var size = this.size;
    var mappingSize = this.mappingSize;
    var mappingIndices2 = this.mappingIndices;
    var mappingIndicesSize = this.mappingIndicesSize;
    var index = this.index;
    var ix, it;
    for (var v = 0; v < size; v++) {
      ix = v * mappingIndicesSize;
      it = v * mappingSize;
      index.set(mappingIndices2, ix);
      for (var s = 0; s < mappingIndicesSize; ++s) {
        index[ix + s] += it;
      }
    }
  };
  Object.defineProperties(MappedBuffer2.prototype, prototypeAccessors2);
  return MappedBuffer2;
}(Buffer);
var mapping = new Float32Array([
  -1,
  1,
  -1,
  -1,
  1,
  1,
  1,
  -1
]);
var mappingIndices = new Uint16Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var QuadBuffer = function(MappedBuffer$$1) {
  function QuadBuffer2() {
    MappedBuffer$$1.apply(this, arguments);
  }
  if (MappedBuffer$$1)
    QuadBuffer2.__proto__ = MappedBuffer$$1;
  QuadBuffer2.prototype = Object.create(MappedBuffer$$1 && MappedBuffer$$1.prototype);
  QuadBuffer2.prototype.constructor = QuadBuffer2;
  var prototypeAccessors2 = {mapping: {}, mappingIndices: {}, mappingIndicesSize: {}, mappingType: {}, mappingSize: {}, mappingItemSize: {}};
  prototypeAccessors2.mapping.get = function() {
    return mapping;
  };
  prototypeAccessors2.mappingIndices.get = function() {
    return mappingIndices;
  };
  prototypeAccessors2.mappingIndicesSize.get = function() {
    return 6;
  };
  prototypeAccessors2.mappingType.get = function() {
    return "v2";
  };
  prototypeAccessors2.mappingSize.get = function() {
    return 4;
  };
  prototypeAccessors2.mappingItemSize.get = function() {
    return 2;
  };
  Object.defineProperties(QuadBuffer2.prototype, prototypeAccessors2);
  return QuadBuffer2;
}(MappedBuffer);
var SphereImpostorBuffer = function(QuadBuffer$$1) {
  function SphereImpostorBuffer2(data, params) {
    QuadBuffer$$1.call(this, data, params);
    this.addUniforms({
      projectionMatrixInverse: {value: new Matrix4()},
      ortho: {value: 0}
    });
    this.addAttributes({
      radius: {type: "f", value: null}
    });
    this.setAttributes(data);
    this.makeMapping();
  }
  if (QuadBuffer$$1)
    SphereImpostorBuffer2.__proto__ = QuadBuffer$$1;
  SphereImpostorBuffer2.prototype = Object.create(QuadBuffer$$1 && QuadBuffer$$1.prototype);
  SphereImpostorBuffer2.prototype.constructor = SphereImpostorBuffer2;
  var prototypeAccessors2 = {isImpostor: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.isImpostor.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "SphereImpostor.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "SphereImpostor.frag";
  };
  Object.defineProperties(SphereImpostorBuffer2.prototype, prototypeAccessors2);
  return SphereImpostorBuffer2;
}(QuadBuffer);
var SphereBuffer = function SphereBuffer2(data, params) {
  if (!ExtensionFragDepth || params && params.disableImpostor) {
    return new SphereGeometryBuffer(data, params);
  } else {
    return new SphereImpostorBuffer(data, params);
  }
};
var scale$1 = new Vector3();
var target = new Vector3();
var up = new Vector3();
var eye = new Vector3(0, 0, 0);
var EllipsoidGeometryBuffer = function(GeometryBuffer$$1) {
  function EllipsoidGeometryBuffer2(data, params) {
    var p = params || {};
    var detail = defaults(p.sphereDetail, 2);
    var geo = new IcosahedronBufferGeometry(1, detail);
    GeometryBuffer$$1.call(this, data, p, geo);
    this.setAttributes(data, true);
  }
  if (GeometryBuffer$$1)
    EllipsoidGeometryBuffer2.__proto__ = GeometryBuffer$$1;
  EllipsoidGeometryBuffer2.prototype = Object.create(GeometryBuffer$$1 && GeometryBuffer$$1.prototype);
  EllipsoidGeometryBuffer2.prototype.constructor = EllipsoidGeometryBuffer2;
  var prototypeAccessors2 = {updateNormals: {}};
  EllipsoidGeometryBuffer2.prototype.applyPositionTransform = function applyPositionTransform(matrix2, i, i3) {
    target.fromArray(this._majorAxis, i3);
    up.fromArray(this._minorAxis, i3);
    matrix2.lookAt(eye, target, up);
    scale$1.set(this._radius[i], up.length(), target.length());
    matrix2.scale(scale$1);
  };
  EllipsoidGeometryBuffer2.prototype.setAttributes = function setAttributes4(data, initNormals) {
    if (data.radius) {
      this._radius = data.radius;
    }
    if (data.majorAxis) {
      this._majorAxis = data.majorAxis;
    }
    if (data.minorAxis) {
      this._minorAxis = data.minorAxis;
    }
    GeometryBuffer$$1.prototype.setAttributes.call(this, data, initNormals);
  };
  prototypeAccessors2.updateNormals.get = function() {
    return true;
  };
  Object.defineProperties(EllipsoidGeometryBuffer2.prototype, prototypeAccessors2);
  return EllipsoidGeometryBuffer2;
}(GeometryBuffer);
var EllipsoidBuffer = function EllipsoidBuffer2(data, params) {
  return new EllipsoidGeometryBuffer(data, params);
};
var scale$2 = new Vector3();
var eye$1 = new Vector3();
var target$1 = new Vector3();
var up$1 = new Vector3(0, 1, 0);
var CylinderGeometryBuffer = function(GeometryBuffer$$1) {
  function CylinderGeometryBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    var radialSegments = defaults(p.radialSegments, 10);
    var openEnded = defaults(p.openEnded, true);
    var matrix2 = new Matrix4().makeRotationX(Math.PI / 2);
    var geo = new CylinderBufferGeometry(1, 1, 1, radialSegments, 1, openEnded);
    geo.applyMatrix(matrix2);
    var n = d.position1.length;
    var m2 = d.radius.length;
    var geoLength = geo.attributes.position.array.length / 3;
    var count2 = n / 3;
    var primitiveId = new Float32Array(count2 * 2 * geoLength);
    serialBlockArray(count2, geoLength, 0, primitiveId);
    serialBlockArray(count2, geoLength, count2 * geoLength, primitiveId);
    var position = new Float32Array(n * 2);
    var color = new Float32Array(n * 2);
    GeometryBuffer$$1.call(this, {
      position,
      color,
      primitiveId,
      picking: d.picking
    }, p, geo);
    this.__center = new Float32Array(n);
    this._position = position;
    this._color = color;
    this._from = new Float32Array(n * 2);
    this._to = new Float32Array(n * 2);
    this._radius = new Float32Array(m2 * 2);
    this.setAttributes(d, true);
  }
  if (GeometryBuffer$$1)
    CylinderGeometryBuffer2.__proto__ = GeometryBuffer$$1;
  CylinderGeometryBuffer2.prototype = Object.create(GeometryBuffer$$1 && GeometryBuffer$$1.prototype);
  CylinderGeometryBuffer2.prototype.constructor = CylinderGeometryBuffer2;
  var prototypeAccessors2 = {updateNormals: {}};
  CylinderGeometryBuffer2.prototype.applyPositionTransform = function applyPositionTransform(matrix2, i, i3) {
    eye$1.fromArray(this._from, i3);
    target$1.fromArray(this._to, i3);
    matrix2.lookAt(eye$1, target$1, up$1);
    var r = this._radius[i];
    scale$2.set(r, r, eye$1.distanceTo(target$1));
    matrix2.scale(scale$2);
  };
  CylinderGeometryBuffer2.prototype.setAttributes = function setAttributes4(data, initNormals) {
    var meshData = {};
    if (data.position1 && data.position2) {
      calculateCenterArray(data.position1, data.position2, this.__center);
      calculateCenterArray(data.position1, this.__center, this._position);
      calculateCenterArray(this.__center, data.position2, this._position, data.position1.length);
      this._from.set(data.position1);
      this._from.set(this.__center, data.position1.length);
      this._to.set(this.__center);
      this._to.set(data.position2, this.__center.length);
      meshData.position = this._position;
    }
    if (data.color && data.color2) {
      this._color.set(data.color);
      this._color.set(data.color2, data.color.length);
      meshData.color = this._color;
    }
    if (data.radius) {
      this._radius.set(data.radius);
      this._radius.set(data.radius, data.radius.length);
      meshData.radius = this._radius;
    }
    GeometryBuffer$$1.prototype.setAttributes.call(this, meshData, initNormals);
  };
  prototypeAccessors2.updateNormals.get = function() {
    return true;
  };
  Object.defineProperties(CylinderGeometryBuffer2.prototype, prototypeAccessors2);
  return CylinderGeometryBuffer2;
}(GeometryBuffer);
ShaderRegistry.add("shader/CylinderImpostor.vert", "\nattribute vec3 mapping;\nattribute vec3 position1;\nattribute vec3 position2;\nattribute float radius;\nvarying vec3 axis;\nvarying vec4 base_radius;\nvarying vec4 end_b;\nvarying vec3 U;\nvarying vec3 V;\nvarying vec4 w;\n#ifdef PICKING\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\nattribute vec3 color2;\nvarying vec3 vColor1;\nvarying vec3 vColor2;\n#endif\nuniform mat4 modelViewMatrixInverse;\nuniform float ortho;\n#include matrix_scale\nvoid main(){\n#ifdef PICKING\nvPickingColor = unpackColor( primitiveId );\n#else\nvColor1 = color;\nvColor2 = color2;\n#endif\nbase_radius.w = radius * matrixScale( modelViewMatrix );\nvec3 center = position;\nvec3 dir = normalize( position2 - position1 );\nfloat ext = length( position2 - position1 ) / 2.0;\nvec3 cam_dir;\nif( ortho == 0.0 ){\ncam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;\n}else{\ncam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;\n}\ncam_dir = normalize( cam_dir );\nvec3 ldir;\nfloat b = dot( cam_dir, dir );\nend_b.w = b;\nif( b < 0.0 )\nldir = -ext * dir;\nelse\nldir = ext * dir;\nvec3 left = normalize( cross( cam_dir, ldir ) );\nleft = radius * left;\nvec3 up = radius * normalize( cross( left, ldir ) );\naxis = normalize( normalMatrix * ldir );\nU = normalize( normalMatrix * up );\nV = normalize( normalMatrix * left );\nvec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );\nbase_radius.xyz = base4.xyz / base4.w;\nvec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );\nvec4 end4 = top_position;\nend_b.xyz = end4.xyz / end4.w;\nw = modelViewMatrix * vec4(\ncenter + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0\n);\ngl_Position = projectionMatrix * w;\ngl_Position.z = 0.99;\n}");
ShaderRegistry.add("shader/CylinderImpostor.frag", "#define STANDARD\n#define IMPOSTOR\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float nearClip;\nuniform mat4 projectionMatrix;\nuniform float ortho;\nvarying vec3 axis;\nvarying vec4 base_radius;\nvarying vec4 end_b;\nvarying vec3 U;\nvarying vec3 V;\nvarying vec4 w;\n#ifdef PICKING\nuniform float objectId;\nvarying vec3 vPickingColor;\n#else\nvarying vec3 vColor1;\nvarying vec3 vColor2;\n#include common\n#include fog_pars_fragment\n#include bsdfs\n#include lights_pars\n#include lights_physical_pars_fragment\n#endif\nbool interior = false;\nfloat distSq3( vec3 v3a, vec3 v3b ){\nreturn (\n( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +\n( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +\n( v3a.z - v3b.z ) * ( v3a.z - v3b.z )\n);\n}\nfloat calcDepth( in vec3 cameraPos ){\nvec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\nreturn 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\nfloat calcClip( vec3 cameraPos ){\nreturn dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\nvoid main(){\nvec3 point = w.xyz / w.w;\nvec3 base = base_radius.xyz;\nfloat vRadius = base_radius.w;\nvec3 end = end_b.xyz;\nfloat b = end_b.w;\nvec3 end_cyl = end;\nvec3 surface_point = point;\nvec3 ray_target = surface_point;\nvec3 ray_origin = vec3(0.0);\nvec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);\nmat3 basis = mat3( U, V, axis );\nvec3 diff = ray_target - 0.5 * (base + end_cyl);\nvec3 P = diff * basis;\nfloat dz = dot( axis, ray_direction );\nfloat radius2 = vRadius*vRadius;\nvec3 D = vec3(dot(U, ray_direction),\ndot(V, ray_direction),\ndz);\nfloat a0 = P.x*P.x + P.y*P.y - radius2;\nfloat a1 = P.x*D.x + P.y*D.y;\nfloat a2 = D.x*D.x + D.y*D.y;\nfloat d = a1*a1 - a0*a2;\nif (d < 0.0)\ndiscard;\nfloat dist = (-a1 + sqrt(d)) / a2;\nvec3 new_point = ray_target + dist * ray_direction;\nvec3 tmp_point = new_point - base;\nvec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );\nray_origin = mix( ray_origin, surface_point, ortho );\nfloat front_cap_test = dot( tmp_point, axis );\nfloat end_cap_test = dot((new_point - end_cyl), axis);\n#ifndef CAP\nvec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;\nvec3 tmp_point2 = new_point2 - base;\n#endif\nif (front_cap_test < 0.0)\n{\nfloat dNV = dot(-axis, ray_direction);\nif (dNV < 0.0)\ndiscard;\nfloat near = dot(-axis, (base)) / dNV;\nvec3 front_point = ray_direction * near + ray_origin;\nif (dot(front_point - base, front_point-base) > radius2)\ndiscard;\n#ifdef CAP\nnew_point = front_point;\n_normal = axis;\n#else\nnew_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;\ndNV = dot(-axis, ray_direction);\nnear = dot(axis, end_cyl) / dNV;\nnew_point2 = ray_direction * near + ray_origin;\nif (dot(new_point2 - end_cyl, new_point2-base) < radius2)\ndiscard;\ninterior = true;\n#endif\n}\nif( end_cap_test > 0.0 )\n{\nfloat dNV = dot(axis, ray_direction);\nif (dNV < 0.0)\ndiscard;\nfloat near = dot(axis, end_cyl) / dNV;\nvec3 end_point = ray_direction * near + ray_origin;\nif( dot(end_point - end_cyl, end_point-base) > radius2 )\ndiscard;\n#ifdef CAP\nnew_point = end_point;\n_normal = axis;\n#else\nnew_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;\ndNV = dot(-axis, ray_direction);\nnear = dot(-axis, (base)) / dNV;\nnew_point2 = ray_direction * near + ray_origin;\nif (dot(new_point2 - base, new_point2-base) < radius2)\ndiscard;\ninterior = true;\n#endif\n}\ngl_FragDepthEXT = calcDepth( new_point );\n#ifdef NEAR_CLIP\nif( calcClip( new_point ) > 0.0 ){\ndist = (-a1 - sqrt(d)) / a2;\nnew_point = ray_target + dist * ray_direction;\nif( calcClip( new_point ) > 0.0 )\ndiscard;\ninterior = true;\ngl_FragDepthEXT = calcDepth( new_point );\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );\n}\n}else if( gl_FragDepthEXT <= 0.0 ){\ndist = (-a1 - sqrt(d)) / a2;\nnew_point = ray_target + dist * ray_direction;\ninterior = true;\ngl_FragDepthEXT = calcDepth( new_point );\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n}\n}\n#else\nif( gl_FragDepthEXT <= 0.0 ){\ndist = (-a1 - sqrt(d)) / a2;\nnew_point = ray_target + dist * ray_direction;\ninterior = true;\ngl_FragDepthEXT = calcDepth( new_point );\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n}\n}\n#endif\nif (gl_FragDepthEXT < 0.0)\ndiscard;\nif (gl_FragDepthEXT > 1.0)\ndiscard;\n#ifdef PICKING\ngl_FragColor = vec4( vPickingColor, objectId );\n#else\nvec3 vViewPosition = -new_point;\nvec3 vNormal = _normal;\nvec3 vColor;\nif( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){\nif( b < 0.0 ){\nvColor = vColor1;\n}else{\nvColor = vColor2;\n}\n}else{\nif( b > 0.0 ){\nvColor = vColor1;\n}else{\nvColor = vColor2;\n}\n}\nvec4 diffuseColor = vec4( diffuse, opacity );\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveLight = emissive;\n#include color_fragment\n#include roughnessmap_fragment\n#include metalnessmap_fragment\nvec3 normal = normalize( vNormal );\nif( interior ){\nnormal = vec3( 0.0, 0.0, 0.4 );\n}\n#include lights_physical_fragment\n#include lights_template\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#endif\n}");
var mapping$1 = new Float32Array([
  -1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  1
]);
var mappingIndices$1 = new Uint16Array([
  0,
  1,
  2,
  1,
  4,
  2,
  2,
  4,
  3,
  4,
  5,
  3
]);
var AlignedBoxBuffer = function(MappedBuffer$$1) {
  function AlignedBoxBuffer2() {
    MappedBuffer$$1.apply(this, arguments);
  }
  if (MappedBuffer$$1)
    AlignedBoxBuffer2.__proto__ = MappedBuffer$$1;
  AlignedBoxBuffer2.prototype = Object.create(MappedBuffer$$1 && MappedBuffer$$1.prototype);
  AlignedBoxBuffer2.prototype.constructor = AlignedBoxBuffer2;
  var prototypeAccessors2 = {mapping: {}, mappingIndices: {}, mappingIndicesSize: {}, mappingType: {}, mappingSize: {}, mappingItemSize: {}};
  prototypeAccessors2.mapping.get = function() {
    return mapping$1;
  };
  prototypeAccessors2.mappingIndices.get = function() {
    return mappingIndices$1;
  };
  prototypeAccessors2.mappingIndicesSize.get = function() {
    return 12;
  };
  prototypeAccessors2.mappingType.get = function() {
    return "v3";
  };
  prototypeAccessors2.mappingSize.get = function() {
    return 6;
  };
  prototypeAccessors2.mappingItemSize.get = function() {
    return 3;
  };
  Object.defineProperties(AlignedBoxBuffer2.prototype, prototypeAccessors2);
  return AlignedBoxBuffer2;
}(MappedBuffer);
var CylinderImpostorBuffer = function(AlignedBoxBuffer$$1) {
  function CylinderImpostorBuffer2(data, params) {
    AlignedBoxBuffer$$1.call(this, data, params);
    var p = params || {};
    this.openEnded = defaults(p.openEnded, false);
    this.addUniforms({
      modelViewMatrixInverse: {value: new Matrix4()},
      ortho: {value: 0}
    });
    this.addAttributes({
      position1: {type: "v3", value: null},
      position2: {type: "v3", value: null},
      color2: {type: "c", value: null},
      radius: {type: "f", value: null}
    });
    this.setAttributes(data);
    this.makeMapping();
  }
  if (AlignedBoxBuffer$$1)
    CylinderImpostorBuffer2.__proto__ = AlignedBoxBuffer$$1;
  CylinderImpostorBuffer2.prototype = Object.create(AlignedBoxBuffer$$1 && AlignedBoxBuffer$$1.prototype);
  CylinderImpostorBuffer2.prototype.constructor = CylinderImpostorBuffer2;
  var prototypeAccessors2 = {parameters: {}, isImpostor: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.parameters.get = function() {
    return Object.assign.call(this, {
      openEnded: {updateShader: true}
    }, AlignedBoxBuffer$$1.prototype.parameters);
  };
  CylinderImpostorBuffer2.prototype.getDefines = function getDefines3(type2) {
    var defines = AlignedBoxBuffer$$1.prototype.getDefines.call(this, type2);
    if (!this.openEnded) {
      defines.CAP = 1;
    }
    return defines;
  };
  prototypeAccessors2.isImpostor.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "CylinderImpostor.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "CylinderImpostor.frag";
  };
  Object.defineProperties(CylinderImpostorBuffer2.prototype, prototypeAccessors2);
  return CylinderImpostorBuffer2;
}(AlignedBoxBuffer);
var CylinderBuffer = function CylinderBuffer2(data, params) {
  if (!ExtensionFragDepth || params && params.disableImpostor) {
    return new CylinderGeometryBuffer(data, params);
  } else {
    return new CylinderImpostorBuffer(data, params);
  }
};
var scale$3 = new Vector3();
var eye$2 = new Vector3();
var target$2 = new Vector3();
var up$2 = new Vector3(0, 1, 0);
var ConeGeometryBuffer = function(GeometryBuffer$$1) {
  function ConeGeometryBuffer2(data, params) {
    var p = params || {};
    var radialSegments = defaults(p.radialSegments, 60);
    var openEnded = defaults(p.openEnded, false);
    var matrix2 = new Matrix4().makeRotationX(-Math.PI / 2);
    var geo = new ConeBufferGeometry(1, 1, radialSegments, 1, openEnded);
    geo.applyMatrix(matrix2);
    var n = data.position1.length;
    var m2 = data.radius.length;
    var position = new Float32Array(n);
    GeometryBuffer$$1.call(this, {
      position,
      color: data.color,
      picking: data.picking
    }, p, geo);
    this._position = position;
    this._from = new Float32Array(n);
    this._to = new Float32Array(n);
    this._radius = new Float32Array(m2);
    this.setAttributes(data, true);
  }
  if (GeometryBuffer$$1)
    ConeGeometryBuffer2.__proto__ = GeometryBuffer$$1;
  ConeGeometryBuffer2.prototype = Object.create(GeometryBuffer$$1 && GeometryBuffer$$1.prototype);
  ConeGeometryBuffer2.prototype.constructor = ConeGeometryBuffer2;
  var prototypeAccessors2 = {updateNormals: {}};
  ConeGeometryBuffer2.prototype.applyPositionTransform = function applyPositionTransform(matrix2, i, i3) {
    eye$2.fromArray(this._from, i3);
    target$2.fromArray(this._to, i3);
    matrix2.lookAt(eye$2, target$2, up$2);
    var r = this._radius[i];
    scale$3.set(r, r, eye$2.distanceTo(target$2));
    matrix2.scale(scale$3);
  };
  ConeGeometryBuffer2.prototype.setAttributes = function setAttributes4(data, initNormals) {
    var meshData = {};
    if (data.position1 && data.position2) {
      calculateCenterArray(data.position1, data.position2, this._position);
      this._from.set(data.position1);
      this._to.set(data.position2);
      meshData.position = this._position;
    }
    if (data.color) {
      meshData.color = data.color;
    }
    if (data.radius) {
      this._radius.set(data.radius);
    }
    GeometryBuffer$$1.prototype.setAttributes.call(this, meshData, initNormals);
  };
  prototypeAccessors2.updateNormals.get = function() {
    return true;
  };
  Object.defineProperties(ConeGeometryBuffer2.prototype, prototypeAccessors2);
  return ConeGeometryBuffer2;
}(GeometryBuffer);
var ConeBuffer = function ConeBuffer2(data, params) {
  return new ConeGeometryBuffer(data, params);
};
var GeometryGroup = function GeometryGroup2(geometryList) {
  this.geometryList = geometryList;
  this.boundingBox = null;
};
GeometryGroup.prototype.computeBoundingBox = function computeBoundingBox2() {
  var this$1 = this;
  if (!this.boundingBox) {
    this.boundingBox = new Box3();
  } else {
    this.boundingBox.empty();
  }
  this.geometryList.forEach(function(geo) {
    if (!geo.boundingBox) {
      geo.computeBoundingBox();
    }
    this$1.boundingBox.union(geo.boundingBox);
  });
};
var ArrowBuffer = function ArrowBuffer2(data, params) {
  var d = data || {};
  var p = params || {};
  this.aspectRatio = defaults(p.aspectRatio, 1.5);
  this.wireframe = defaults(p.wireframe, false);
  this.splitPosition = new Float32Array(d.position1.length);
  this.cylinderRadius = new Float32Array(d.radius.length);
  var attr = this.makeAttributes(d);
  var bufferParams = {
    radialSegments: defaults(p.radialSegments, 50),
    openEnded: defaults(p.openEnded, false),
    disableImpostor: defaults(p.disableImpostor, false)
  };
  this.cylinderBuffer = new CylinderBuffer(attr.cylinder, bufferParams);
  this.coneBuffer = new ConeBuffer(attr.cone, bufferParams);
  this.geometry = new GeometryGroup([
    this.cylinderBuffer.geometry,
    this.coneBuffer.geometry
  ]);
  this.group = new Group();
  this.wireframeGroup = new Group();
  this.pickingGroup = new Group();
  this.matrix = defaults(p.matrix, new Matrix4());
  this.picking = d.picking;
};
var prototypeAccessors$25 = {matrix: {}, pickable: {}};
prototypeAccessors$25.matrix.set = function(m2) {
  Buffer.prototype.setMatrix.call(this, m2);
};
prototypeAccessors$25.matrix.get = function() {
  return this.group.matrix.clone();
};
prototypeAccessors$25.pickable.get = function() {
  return !!this.picking;
};
ArrowBuffer.prototype.makeAttributes = function makeAttributes(data) {
  var splitPosition = this.splitPosition;
  var cylinderRadius = this.cylinderRadius;
  var aspectRatio = this.aspectRatio;
  var i, il;
  var cylinder = {};
  var cone = {};
  if (data.radius) {
    for (i = 0, il = cylinderRadius.length; i < il; ++i) {
      cylinderRadius[i] = data.radius[i] / aspectRatio;
    }
    cylinder.radius = cylinderRadius;
    cone.radius = data.radius;
  }
  if (data.position1 && data.position2) {
    var vFrom = new Vector3();
    var vTo = new Vector3();
    var vDir = new Vector3();
    var vSplit = new Vector3();
    for (i = 0, il = splitPosition.length; i < il; i += 3) {
      vFrom.fromArray(data.position1, i);
      vTo.fromArray(data.position2, i);
      vDir.subVectors(vFrom, vTo);
      var fullLength = vDir.length();
      var coneLength = cylinderRadius[i / 3] * aspectRatio * 2;
      var length = Math.min(fullLength, coneLength);
      vDir.setLength(length);
      vSplit.copy(vTo).add(vDir);
      vSplit.toArray(splitPosition, i);
    }
    cylinder.position1 = data.position1;
    cylinder.position2 = splitPosition;
    cone.position1 = splitPosition;
    cone.position2 = data.position2;
  }
  if (data.color) {
    cylinder.color = data.color;
    cylinder.color2 = data.color;
    cone.color = data.color;
  }
  return {
    cylinder,
    cone
  };
};
ArrowBuffer.prototype.getMesh = function getMesh2(picking) {
  return new Group().add(this.cylinderBuffer.getMesh(picking), this.coneBuffer.getMesh(picking));
};
ArrowBuffer.prototype.getWireframeMesh = function getWireframeMesh2() {
  return new Group().add(this.cylinderBuffer.getWireframeMesh(), this.coneBuffer.getWireframeMesh());
};
ArrowBuffer.prototype.getPickingMesh = function getPickingMesh2() {
  return new Group().add(this.cylinderBuffer.getPickingMesh(), this.coneBuffer.getPickingMesh());
};
ArrowBuffer.prototype.setAttributes = function setAttributes2(data) {
  var attr = this.makeAttributes(data);
  this.cylinderBuffer.setAttributes(attr.cylinder);
  this.coneBuffer.setAttributes(attr.cone);
};
ArrowBuffer.prototype.setParameters = function setParameters4(params) {
  params = Object.assign({}, params);
  if (params && params.matrix !== void 0) {
    this.matrix = params.matrix;
  }
  delete params.matrix;
  if (params && params.wireframe !== void 0) {
    this.wireframe = params.wireframe;
    this.setVisibility(this.visible);
  }
  this.cylinderBuffer.setParameters(params);
  this.coneBuffer.setParameters(params);
};
ArrowBuffer.prototype.setVisibility = function setVisibility3() {
  Buffer.prototype.setVisibility.apply(this, arguments);
};
ArrowBuffer.prototype.dispose = function dispose16() {
  this.cylinderBuffer.dispose();
  this.coneBuffer.dispose();
};
Object.defineProperties(ArrowBuffer.prototype, prototypeAccessors$25);
ShaderRegistry.add("shader/SDFFont.vert", "uniform float nearClip;\nuniform float clipRadius;\nuniform vec3 clipCenter;\nuniform float xOffset;\nuniform float yOffset;\nuniform float zOffset;\nuniform bool ortho;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )\nvarying vec3 vViewPosition;\n#endif\nvarying vec2 texCoord;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\n#include color_pars_vertex\n#endif\nattribute vec2 mapping;\nattribute vec2 inputTexCoord;\nattribute float inputSize;\n#include matrix_scale\n#include common\nvoid main(void){\n#if defined( PICKING )\nvPickingColor = unpackColor( primitiveId );\n#else\n#include color_vertex\n#endif\ntexCoord = inputTexCoord;\nfloat scale = matrixScale( modelViewMatrix );\nfloat _zOffset = zOffset * scale;\nif( texCoord.x == 10.0 ){\n_zOffset -= 0.001;\n}\nvec3 pos = position;\nif( ortho ){\npos += normalize( cameraPosition ) * _zOffset;\n}\nvec4 cameraPos = modelViewMatrix * vec4( pos, 1.0 );\nvec4 cameraCornerPos = vec4( cameraPos.xyz, 1.0 );\ncameraCornerPos.xy += mapping * inputSize * 0.01 * scale;\ncameraCornerPos.x += xOffset * scale;\ncameraCornerPos.y += yOffset * scale;\nif( !ortho ){\ncameraCornerPos.xyz += normalize( -cameraCornerPos.xyz ) * _zOffset;\n}\ngl_Position = projectionMatrix * cameraCornerPos;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )\nvViewPosition = -cameraCornerPos.xyz;\n#endif\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n#include nearclip_vertex\n#include radiusclip_vertex\n}");
ShaderRegistry.add("shader/SDFFont.frag", "uniform sampler2D fontTexture;\nuniform float opacity;\nuniform bool showBorder;\nuniform vec3 borderColor;\nuniform float borderWidth;\nuniform vec3 backgroundColor;\nuniform float backgroundOpacity;\nuniform float nearClip;\nuniform float clipRadius;\nvarying vec3 vViewPosition;\nvarying vec2 texCoord;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\nuniform float objectId;\nvarying vec3 vPickingColor;\nconst vec3 vColor = vec3( 0.0 );\n#else\n#include common\n#include color_pars_fragment\n#include fog_pars_fragment\n#endif\n#ifdef SDF\nconst float smoothness = 16.0;\n#else\nconst float smoothness = 256.0;\n#endif\nconst float gamma = 2.2;\nvoid main(){\n#include nearclip_fragment\n#include radiusclip_fragment\nif( texCoord.x > 1.0 ){\ngl_FragColor = vec4( backgroundColor, backgroundOpacity );\n}else{\nfloat sdf = texture2D( fontTexture, texCoord ).a;\nif( showBorder ) sdf += borderWidth;\nfloat w = clamp(\nsmoothness * ( abs( dFdx( texCoord.x ) ) + abs( dFdy( texCoord.y ) ) ),\n0.0,\n0.5\n);\nfloat a = smoothstep( 0.5 - w, 0.5 + w, sdf );\na = pow( a, 1.0 / gamma );\nif( a < 0.2 ) discard;\na *= opacity;\nvec3 outgoingLight = vColor;\nif( showBorder && sdf < ( 0.5 + borderWidth ) ){\noutgoingLight = borderColor;\n}\ngl_FragColor = vec4( outgoingLight, a );\n}\n#if defined( PICKING )\ngl_FragColor = vec4( vPickingColor, objectId );\n#else\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#endif\n}");
var TextAtlasCache = {};
function getTextAtlas(params) {
  var hash = JSON.stringify(params);
  if (TextAtlasCache[hash] === void 0) {
    TextAtlasCache[hash] = new TextAtlas(params);
  }
  return TextAtlasCache[hash];
}
var TextAtlas = function TextAtlas2(params) {
  var p = Object.assign({}, params);
  this.font = defaults(p.font, ["sans-serif"]);
  this.size = defaults(p.size, 36);
  this.style = defaults(p.style, "normal");
  this.variant = defaults(p.variant, "normal");
  this.weight = defaults(p.weight, "normal");
  this.outline = defaults(p.outline, 0);
  this.width = defaults(p.width, 2048);
  this.height = defaults(p.height, 2048);
  this.gamma = 1;
  if (typeof navigator !== "undefined") {
    var ua = navigator.userAgent;
    if (ua.match(/Chrome/) && ua.match(/OS X/)) {
      this.gamma = 0.5;
    }
  }
  this.mapped = {};
  this.scratchW = 0;
  this.scratchH = 0;
  this.currentX = 0;
  this.currentY = 0;
  this.build();
  this.populate();
  this.texture = new CanvasTexture(this.canvas2);
  this.texture.flipY = false;
  this.texture.needsUpdate = true;
};
TextAtlas.prototype.build = function build() {
  var lineHeight = this.size + 2 * this.outline + Math.round(this.size / 4);
  var maxWidth = this.width / 4;
  var canvas = document.createElement("canvas");
  canvas.width = maxWidth;
  canvas.height = lineHeight;
  var ctx = canvas.getContext("2d");
  ctx.font = this.style + " " + this.variant + " " + this.weight + " " + this.size + "px " + this.font;
  ctx.fillStyle = "#FF0000";
  ctx.textAlign = "left";
  ctx.textBaseline = "bottom";
  ctx.lineJoin = "round";
  var colors = [];
  var dilate = this.outline * 3;
  for (var i = 0; i < dilate; ++i) {
    var val = Math.max(0, -i * 8 + 128 - !i * 8);
    var hex = ("00" + val.toString(16)).slice(-2);
    colors.push("#" + hex + hex + hex);
  }
  var scratch = new Uint8Array(maxWidth * lineHeight * 2);
  this.canvas = canvas;
  this.context = ctx;
  this.lineHeight = lineHeight;
  this.maxWidth = maxWidth;
  this.colors = colors;
  this.scratch = scratch;
  this.data = new Uint8Array(this.width * this.height * 4);
  this.canvas2 = document.createElement("canvas");
  this.canvas2.width = this.width;
  this.canvas2.height = this.height;
  this.context2 = this.canvas2.getContext("2d");
};
TextAtlas.prototype.map = function map(text) {
  if (this.mapped[text] === void 0) {
    this.draw(text);
    if (this.currentX + this.scratchW > this.width) {
      this.currentX = 0;
      this.currentY += this.scratchH;
    }
    if (this.currentY + this.scratchH > this.height) {
      console.warn("canvas to small");
    }
    this.mapped[text] = {
      x: this.currentX,
      y: this.currentY,
      w: this.scratchW,
      h: this.scratchH
    };
    this.context2.drawImage(this.canvas, 0, 0, this.scratchW, this.scratchH, this.currentX, this.currentY, this.scratchW, this.scratchH);
    this.currentX += this.scratchW;
  }
  return this.mapped[text];
};
TextAtlas.prototype.get = function get6(text) {
  return this.mapped[text] || this.placeholder;
};
TextAtlas.prototype.draw = function draw(text) {
  var h = this.lineHeight;
  var o = this.outline;
  var ctx = this.context;
  var dst = this.scratch;
  var max2 = this.maxWidth;
  var colors = this.colors;
  var x = o;
  var y = h - this.outline;
  var m2 = ctx.measureText(text);
  var w = Math.min(max2, Math.ceil(m2.width + 2 * x + 1));
  ctx.clearRect(0, 0, w, h);
  var i, il, j, imageData, data;
  if (this.outline === 0) {
    ctx.fillText(text, x, y);
    imageData = ctx.getImageData(0, 0, w, h);
    data = imageData.data;
    j = 3;
    for (i = 0, il = data.length / 4; i < il; ++i) {
      dst[i] = data[j];
      j += 4;
    }
  } else {
    ctx.globalCompositeOperation = "source-over";
    for (i = o + 1; i > 0; --i) {
      j = i > 1 ? i * 2 - 2 : i;
      ctx.strokeStyle = colors[j - 1];
      ctx.lineWidth = j;
      ctx.strokeText(text, x, y);
    }
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = "#FF00FF";
    ctx.fillText(text, x, y);
    imageData = ctx.getImageData(0, 0, w, h);
    data = imageData.data;
    j = 0;
    var gamma = this.gamma;
    for (i = 0, il = data.length / 4; i < il; ++i) {
      var a = data[j];
      var mask = a ? data[j + 1] / a : 1;
      if (gamma === 0.5) {
        mask = Math.sqrt(mask);
      }
      mask = Math.min(1, Math.max(0, mask));
      var b = 256 - a;
      var c = b + (a - b) * mask;
      dst[i] = Math.max(0, Math.min(255, c + 2));
      data[j + 3] = dst[i];
      j += 4;
    }
  }
  ctx.putImageData(imageData, 0, 0);
  this.scratchW = w;
  this.scratchH = h;
};
TextAtlas.prototype.populate = function populate() {
  var this$1 = this;
  this.placeholder = this.map(String.fromCharCode(65533));
  for (var i = 0; i < 127; ++i) {
    this$1.map(String.fromCharCode(i));
  }
  for (var i$1 = 128; i$1 < 255; ++i$1) {
    this$1.map(String.fromCharCode(i$1));
  }
  for (var i$2 = 880; i$2 < 1023; ++i$2) {
    this$1.map(String.fromCharCode(i$2));
  }
  for (var i$3 = 1024; i$3 < 1279; ++i$3) {
    this$1.map(String.fromCharCode(i$3));
  }
  this.map(String.fromCharCode(8491));
};
var TextBuffer = function(QuadBuffer$$1) {
  function TextBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    p.forceTransparent = true;
    var n = d.position.length / 3;
    var charCount = 0;
    for (var i = 0; i < n; ++i) {
      charCount += d.text[i].length;
    }
    var count2 = charCount;
    if (p.showBackground) {
      count2 += n;
    }
    QuadBuffer$$1.call(this, {
      position: new Float32Array(count2 * 3),
      color: new Float32Array(count2 * 3),
      picking: new IgnorePicker()
    }, p);
    this.fontFamily = defaults(p.fontFamily, "sans-serif");
    this.fontStyle = defaults(p.fontStyle, "normal");
    this.fontWeight = defaults(p.fontWeight, "bold");
    this.fontSize = defaults(p.fontSize, 48);
    this.sdf = defaults(p.sdf, Browser === "Chrome");
    this.xOffset = defaults(p.xOffset, 0);
    this.yOffset = defaults(p.yOffset, 0);
    this.zOffset = defaults(p.zOffset, 0.5);
    this.attachment = defaults(p.attachment, "bottom-left");
    this.showBorder = defaults(p.showBorder, false);
    this.borderColor = defaults(p.borderColor, "lightgrey");
    this.borderWidth = defaults(p.borderWidth, 0.15);
    this.showBackground = defaults(p.showBackground, false);
    this.backgroundColor = defaults(p.backgroundColor, "lightgrey");
    this.backgroundMargin = defaults(p.backgroundMargin, 0.5);
    this.backgroundOpacity = defaults(p.backgroundOpacity, 1);
    this.text = d.text;
    this.positionCount = n;
    this.addUniforms({
      fontTexture: {value: null},
      xOffset: {value: this.xOffset},
      yOffset: {value: this.yOffset},
      zOffset: {value: this.zOffset},
      ortho: {value: false},
      showBorder: {value: this.showBorder},
      borderColor: {value: new Color(this.borderColor)},
      borderWidth: {value: this.borderWidth},
      backgroundColor: {value: new Color(this.backgroundColor)},
      backgroundOpacity: {value: this.backgroundOpacity}
    });
    this.addAttributes({
      inputTexCoord: {type: "v2", value: null},
      inputSize: {type: "f", value: null}
    });
    this.setAttributes(data);
    this.makeTexture();
    this.makeMapping();
  }
  if (QuadBuffer$$1)
    TextBuffer2.__proto__ = QuadBuffer$$1;
  TextBuffer2.prototype = Object.create(QuadBuffer$$1 && QuadBuffer$$1.prototype);
  TextBuffer2.prototype.constructor = TextBuffer2;
  var prototypeAccessors2 = {parameters: {}, wireframe: {}, isText: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.parameters.get = function() {
    return Object.assign.call(this, {
      fontFamily: {uniform: true},
      fontStyle: {uniform: true},
      fontWeight: {uniform: true},
      fontSize: {uniform: true},
      sdf: {updateShader: true, uniform: true},
      xOffset: {uniform: true},
      yOffset: {uniform: true},
      zOffset: {uniform: true},
      showBorder: {uniform: true},
      borderColor: {uniform: true},
      borderWidth: {uniform: true},
      backgroundColor: {uniform: true},
      backgroundOpacity: {uniform: true}
    }, QuadBuffer$$1.prototype.parameters, {
      flatShaded: void 0
    });
  };
  TextBuffer2.prototype.makeMaterial = function makeMaterial2() {
    QuadBuffer$$1.prototype.makeMaterial.call(this);
    var tex = this.texture;
    var m2 = this.material;
    m2.extensions.derivatives = true;
    m2.lights = false;
    m2.uniforms.fontTexture.value = tex;
    m2.needsUpdate = true;
    var wm = this.wireframeMaterial;
    wm.extensions.derivatives = true;
    wm.lights = false;
    wm.uniforms.fontTexture.value = tex;
    wm.needsUpdate = true;
    var pm = this.pickingMaterial;
    pm.extensions.derivatives = true;
    pm.lights = false;
    pm.uniforms.fontTexture.value = tex;
    pm.needsUpdate = true;
  };
  TextBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var this$1 = this;
    var position, size, color;
    var aPosition, inputSize, aColor;
    var text = this.text;
    var attributes = this.geometry.attributes;
    if (data.position) {
      position = data.position;
      aPosition = attributes.position.array;
      attributes.position.needsUpdate = true;
    }
    if (data.size) {
      size = data.size;
      inputSize = attributes.inputSize.array;
      attributes.inputSize.needsUpdate = true;
    }
    if (data.color) {
      color = data.color;
      aColor = attributes.color.array;
      attributes.color.needsUpdate = true;
    }
    var n = this.positionCount;
    var j, o;
    var iCharAll = 0;
    var txt, iChar, nChar;
    for (var v = 0; v < n; ++v) {
      o = 3 * v;
      txt = text[v];
      nChar = txt.length;
      if (this$1.showBackground) {
        nChar += 1;
      }
      for (iChar = 0; iChar < nChar; ++iChar, ++iCharAll) {
        for (var m2 = 0; m2 < 4; m2++) {
          j = iCharAll * 4 * 3 + 3 * m2;
          if (position) {
            aPosition[j] = position[o];
            aPosition[j + 1] = position[o + 1];
            aPosition[j + 2] = position[o + 2];
          }
          if (size) {
            inputSize[iCharAll * 4 + m2] = size[v];
          }
          if (color) {
            aColor[j] = color[o];
            aColor[j + 1] = color[o + 1];
            aColor[j + 2] = color[o + 2];
          }
        }
      }
    }
  };
  TextBuffer2.prototype.makeTexture = function makeTexture() {
    this.textAtlas = getTextAtlas({
      font: [this.fontFamily],
      style: this.fontStyle,
      weight: this.fontWeight,
      size: this.fontSize,
      outline: this.sdf ? 5 : 0
    });
    this.texture = this.textAtlas.texture;
  };
  TextBuffer2.prototype.makeMapping = function makeMapping() {
    var this$1 = this;
    var ta = this.textAtlas;
    var text = this.text;
    var attachment = this.attachment;
    var margin = ta.lineHeight * this.backgroundMargin * 0.1 - 10;
    var inputTexCoord = this.geometry.attributes.inputTexCoord.array;
    var inputMapping = this.geometry.attributes.mapping.array;
    var n = this.positionCount;
    var iCharAll = 0;
    var c, i, txt, xadvance, iChar, nChar, xShift, yShift;
    for (var v = 0; v < n; ++v) {
      txt = text[v];
      xadvance = 0;
      nChar = txt.length;
      for (iChar = 0; iChar < nChar; ++iChar) {
        c = ta.get(txt[iChar]);
        xadvance += c.w - 2 * ta.outline;
      }
      if (attachment.startsWith("top")) {
        yShift = ta.lineHeight / 1.25;
      } else if (attachment.startsWith("middle")) {
        yShift = ta.lineHeight / 2.5;
      } else {
        yShift = 0;
      }
      if (attachment.endsWith("right")) {
        xShift = xadvance;
      } else if (attachment.endsWith("center")) {
        xShift = xadvance / 2;
      } else {
        xShift = 0;
      }
      xShift += ta.outline;
      yShift += ta.outline;
      if (this$1.showBackground) {
        i = iCharAll * 2 * 4;
        inputMapping[i + 0] = -ta.lineHeight / 6 - xShift - margin;
        inputMapping[i + 1] = ta.lineHeight - yShift + margin;
        inputMapping[i + 2] = -ta.lineHeight / 6 - xShift - margin;
        inputMapping[i + 3] = 0 - yShift - margin;
        inputMapping[i + 4] = xadvance + ta.lineHeight / 6 - xShift + 2 * ta.outline + margin;
        inputMapping[i + 5] = ta.lineHeight - yShift + margin;
        inputMapping[i + 6] = xadvance + ta.lineHeight / 6 - xShift + 2 * ta.outline + margin;
        inputMapping[i + 7] = 0 - yShift - margin;
        inputTexCoord[i + 0] = 10;
        inputTexCoord[i + 2] = 10;
        inputTexCoord[i + 4] = 10;
        inputTexCoord[i + 6] = 10;
        iCharAll += 1;
      }
      xadvance = 0;
      for (iChar = 0; iChar < nChar; ++iChar, ++iCharAll) {
        c = ta.get(txt[iChar]);
        i = iCharAll * 2 * 4;
        inputMapping[i + 0] = xadvance - xShift;
        inputMapping[i + 1] = c.h - yShift;
        inputMapping[i + 2] = xadvance - xShift;
        inputMapping[i + 3] = 0 - yShift;
        inputMapping[i + 4] = xadvance + c.w - xShift;
        inputMapping[i + 5] = c.h - yShift;
        inputMapping[i + 6] = xadvance + c.w - xShift;
        inputMapping[i + 7] = 0 - yShift;
        var texWidth = ta.width;
        var texHeight = ta.height;
        var texCoords = [
          c.x / texWidth,
          c.y / texHeight,
          c.x / texWidth,
          (c.y + c.h) / texHeight,
          (c.x + c.w) / texWidth,
          c.y / texHeight,
          (c.x + c.w) / texWidth,
          (c.y + c.h) / texHeight
        ];
        inputTexCoord.set(texCoords, i);
        xadvance += c.w - 2 * ta.outline;
      }
    }
    this.geometry.attributes.inputTexCoord.needsUpdate = true;
    this.geometry.attributes.mapping.needsUpdate = true;
  };
  TextBuffer2.prototype.getDefines = function getDefines3(type2) {
    var defines = QuadBuffer$$1.prototype.getDefines.call(this, type2);
    if (this.sdf) {
      defines.SDF = 1;
    }
    return defines;
  };
  TextBuffer2.prototype.setUniforms = function setUniforms2(data) {
    if (data && (data.fontFamily !== void 0 || data.fontStyle !== void 0 || data.fontWeight !== void 0 || data.fontSize !== void 0 || data.sdf !== void 0)) {
      this.makeTexture();
      this.makeMapping();
      this.texture.needsUpdate = true;
      data.fontTexture = this.texture;
    }
    QuadBuffer$$1.prototype.setUniforms.call(this, data);
  };
  prototypeAccessors2.wireframe.set = function(value2) {
  };
  prototypeAccessors2.wireframe.get = function() {
    return false;
  };
  prototypeAccessors2.isText.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "SDFFont.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "SDFFont.frag";
  };
  Object.defineProperties(TextBuffer2.prototype, prototypeAccessors2);
  return TextBuffer2;
}(QuadBuffer);
function addElement(elm, array) {
  if (elm.toArray !== void 0) {
    elm = elm.toArray();
  } else if (elm.x !== void 0) {
    elm = [elm.x, elm.y, elm.z];
  } else if (elm.r !== void 0) {
    elm = [elm.r, elm.g, elm.b];
  }
  array.push.apply(array, elm);
}
var tmpVec = new Vector3();
var tmpBox = new Box3();
var Shape$1 = function Shape$$1(name, params) {
  this.name = defaults(name, "shape");
  var p = params || {};
  this.aspectRatio = defaults(p.aspectRatio, 1.5);
  this.sphereDetail = defaults(p.sphereDetail, 2);
  this.radialSegments = defaults(p.radialSegments, 50);
  this.disableImpostor = defaults(p.disableImpostor, false);
  this.openEnded = defaults(p.openEnded, false);
  this.labelParams = defaults(p.labelParams, {});
  this.boundingBox = new Box3();
  this.bufferList = [];
  this.meshCount = 0;
  this.spherePosition = [];
  this.sphereColor = [];
  this.sphereRadius = [];
  this.sphereName = [];
  this.ellipsoidPosition = [];
  this.ellipsoidColor = [];
  this.ellipsoidRadius = [];
  this.ellipsoidMajorAxis = [];
  this.ellipsoidMinorAxis = [];
  this.ellipsoidName = [];
  this.cylinderPosition1 = [];
  this.cylinderPosition2 = [];
  this.cylinderColor = [];
  this.cylinderRadius = [];
  this.cylinderName = [];
  this.conePosition1 = [];
  this.conePosition2 = [];
  this.coneColor = [];
  this.coneRadius = [];
  this.coneName = [];
  this.arrowPosition1 = [];
  this.arrowPosition2 = [];
  this.arrowColor = [];
  this.arrowRadius = [];
  this.arrowName = [];
  this.labelPosition = [];
  this.labelColor = [];
  this.labelSize = [];
  this.labelText = [];
};
var prototypeAccessors$23 = {center: {}, type: {}};
Shape$1.prototype.addBuffer = function addBuffer(buffer) {
  this.bufferList.push(buffer);
  var geometry = buffer.geometry;
  if (!geometry.boundingBox) {
    geometry.computeBoundingBox();
  }
  this.boundingBox.union(geometry.boundingBox);
  return this;
};
Shape$1.prototype.addMesh = function addMesh(position, color, index, normal2, name) {
  position = ensureFloat32Array(position);
  color = ensureFloat32Array(color);
  if (Array.isArray(index)) {
    index = getUintArray(index, position.length);
  }
  if (normal2) {
    normal2 = ensureFloat32Array(normal2);
  }
  var data = {position, color, index, normal: normal2};
  var picking = new MeshPicker(this, Object.assign({serial: this.meshCount, name}, data));
  var meshBuffer = new MeshBuffer(Object.assign({picking}, data));
  this.bufferList.push(meshBuffer);
  tmpBox.setFromArray(position);
  this.boundingBox.union(tmpBox);
  this.meshCount += 1;
  return this;
};
Shape$1.prototype.addSphere = function addSphere(position, color, radius, name) {
  addElement(position, this.spherePosition);
  addElement(color, this.sphereColor);
  this.sphereRadius.push(radius);
  this.sphereName.push(name);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position));
  return this;
};
Shape$1.prototype.addEllipsoid = function addEllipsoid(position, color, radius, majorAxis, minorAxis, name) {
  addElement(position, this.ellipsoidPosition);
  addElement(color, this.ellipsoidColor);
  this.ellipsoidRadius.push(radius);
  addElement(majorAxis, this.ellipsoidMajorAxis);
  addElement(minorAxis, this.ellipsoidMinorAxis);
  this.ellipsoidName.push(name);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position));
  return this;
};
Shape$1.prototype.addCylinder = function addCylinder(position1, position2, color, radius, name) {
  addElement(position1, this.cylinderPosition1);
  addElement(position2, this.cylinderPosition2);
  addElement(color, this.cylinderColor);
  this.cylinderRadius.push(radius);
  this.cylinderName.push(name);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position1));
  this.boundingBox.expandByPoint(tmpVec.fromArray(position2));
  return this;
};
Shape$1.prototype.addCone = function addCone(position1, position2, color, radius, name) {
  addElement(position1, this.conePosition1);
  addElement(position2, this.conePosition2);
  addElement(color, this.coneColor);
  this.coneRadius.push(radius);
  this.coneName.push(name);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position1));
  this.boundingBox.expandByPoint(tmpVec.fromArray(position2));
  return this;
};
Shape$1.prototype.addArrow = function addArrow(position1, position2, color, radius, name) {
  addElement(position1, this.arrowPosition1);
  addElement(position2, this.arrowPosition2);
  addElement(color, this.arrowColor);
  this.arrowRadius.push(radius);
  this.arrowName.push(name);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position1));
  this.boundingBox.expandByPoint(tmpVec.fromArray(position2));
  return this;
};
Shape$1.prototype.addLabel = function addLabel(position, color, size, text) {
  addElement(position, this.labelPosition);
  addElement(color, this.labelColor);
  this.labelSize.push(size);
  this.labelText.push(text);
  this.boundingBox.expandByPoint(tmpVec.fromArray(position));
  return this;
};
Shape$1.prototype.getBufferList = function getBufferList() {
  var buffers = [];
  if (this.spherePosition.length) {
    var sphereBuffer = new SphereBuffer({
      position: new Float32Array(this.spherePosition),
      color: new Float32Array(this.sphereColor),
      radius: new Float32Array(this.sphereRadius),
      picking: new SpherePicker(this)
    }, {
      sphereDetail: this.sphereDetail,
      disableImpostor: this.disableImpostor
    });
    buffers.push(sphereBuffer);
  }
  if (this.ellipsoidPosition.length) {
    var ellipsoidBuffer = new EllipsoidBuffer({
      position: new Float32Array(this.ellipsoidPosition),
      color: new Float32Array(this.ellipsoidColor),
      radius: new Float32Array(this.ellipsoidRadius),
      majorAxis: new Float32Array(this.ellipsoidMajorAxis),
      minorAxis: new Float32Array(this.ellipsoidMinorAxis),
      picking: new EllipsoidPicker(this)
    }, {
      sphereDetail: this.sphereDetail,
      disableImpostor: this.disableImpostor
    });
    buffers.push(ellipsoidBuffer);
  }
  if (this.cylinderPosition1.length) {
    var cylinderBuffer = new CylinderBuffer({
      position1: new Float32Array(this.cylinderPosition1),
      position2: new Float32Array(this.cylinderPosition2),
      color: new Float32Array(this.cylinderColor),
      color2: new Float32Array(this.cylinderColor),
      radius: new Float32Array(this.cylinderRadius),
      picking: new CylinderPicker(this)
    }, {
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      openEnded: this.openEnded
    });
    buffers.push(cylinderBuffer);
  }
  if (this.conePosition1.length) {
    var coneBuffer = new ConeBuffer({
      position1: new Float32Array(this.conePosition1),
      position2: new Float32Array(this.conePosition2),
      color: new Float32Array(this.coneColor),
      radius: new Float32Array(this.coneRadius),
      picking: new ConePicker(this)
    }, {
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      openEnded: this.openEnded
    });
    buffers.push(coneBuffer);
  }
  if (this.arrowPosition1.length) {
    var arrowBuffer = new ArrowBuffer({
      position1: new Float32Array(this.arrowPosition1),
      position2: new Float32Array(this.arrowPosition2),
      color: new Float32Array(this.arrowColor),
      radius: new Float32Array(this.arrowRadius),
      picking: new ArrowPicker(this)
    }, {
      aspectRatio: this.aspectRatio,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      openEnded: this.openEnded
    });
    buffers.push(arrowBuffer);
  }
  if (this.labelPosition.length) {
    var labelBuffer = new TextBuffer({
      position: new Float32Array(this.labelPosition),
      color: new Float32Array(this.labelColor),
      size: new Float32Array(this.labelSize),
      text: this.labelText
    }, this.labelParams);
    buffers.push(labelBuffer);
  }
  return this.bufferList.concat(buffers);
};
Shape$1.prototype.dispose = function dispose17() {
  this.bufferList.forEach(function(buffer) {
    buffer.dispose();
  });
  this.bufferList.length = 0;
  this.spherePosition.length = 0;
  this.sphereColor.length = 0;
  this.sphereRadius.length = 0;
  this.sphereName.length = 0;
  this.ellipsoidPosition.length = 0;
  this.ellipsoidColor.length = 0;
  this.ellipsoidRadius.length = 0;
  this.ellipsoidMajorAxis.length = 0;
  this.ellipsoidMinorAxis.length = 0;
  this.ellipsoidName.length = 0;
  this.cylinderPosition1.length = 0;
  this.cylinderPosition2.length = 0;
  this.cylinderColor.length = 0;
  this.cylinderRadius.length = 0;
  this.cylinderName.length = 0;
  this.conePosition1.length = 0;
  this.conePosition2.length = 0;
  this.coneColor.length = 0;
  this.coneRadius.length = 0;
  this.coneName.length = 0;
  this.arrowPosition1.length = 0;
  this.arrowPosition2.length = 0;
  this.arrowColor.length = 0;
  this.arrowRadius.length = 0;
  this.arrowName.length = 0;
  this.labelPosition.length = 0;
  this.labelColor.length = 0;
  this.labelSize.length = 0;
  this.labelText.length = 0;
};
prototypeAccessors$23.center.get = function() {
  if (!this._center) {
    this._center = this.boundingBox.getCenter();
  }
  return this._center;
};
prototypeAccessors$23.type.get = function() {
  return "Shape";
};
Object.defineProperties(Shape$1.prototype, prototypeAccessors$23);
var Representation = function Representation2(object, viewer, params) {
  this.type = "";
  this.parameters = {
    lazy: {
      type: "boolean"
    },
    clipNear: {
      type: "range",
      step: 1,
      max: 100,
      min: 0,
      buffer: true
    },
    clipRadius: {
      type: "number",
      precision: 1,
      max: 1e3,
      min: 0,
      buffer: true
    },
    clipCenter: {
      type: "vector3",
      precision: 1,
      buffer: true
    },
    flatShaded: {
      type: "boolean",
      buffer: true
    },
    opacity: {
      type: "range",
      step: 0.01,
      max: 1,
      min: 0,
      buffer: true
    },
    depthWrite: {
      type: "boolean",
      buffer: true
    },
    side: {
      type: "select",
      buffer: true,
      options: {front: "front", back: "back", double: "double"}
    },
    wireframe: {
      type: "boolean",
      buffer: true
    },
    linewidth: {
      type: "integer",
      max: 50,
      min: 1,
      buffer: true
    },
    colorScheme: {
      type: "select",
      update: "color",
      options: {}
    },
    colorScale: {
      type: "select",
      update: "color",
      options: ColormakerRegistry2.getScales()
    },
    colorReverse: {
      type: "boolean",
      update: "color"
    },
    colorValue: {
      type: "color",
      update: "color"
    },
    colorDomain: {
      type: "hidden",
      update: "color"
    },
    colorMode: {
      type: "select",
      update: "color",
      options: ColormakerRegistry2.getModes()
    },
    roughness: {
      type: "range",
      step: 0.01,
      max: 1,
      min: 0,
      buffer: true
    },
    metalness: {
      type: "range",
      step: 0.01,
      max: 1,
      min: 0,
      buffer: true
    },
    diffuse: {
      type: "color",
      buffer: true
    },
    matrix: {
      type: "hidden",
      buffer: true
    },
    disablePicking: {
      type: "boolean",
      rebuild: true
    }
  };
  this.viewer = viewer;
  this.tasks = new Counter();
  this.queue = new Queue(this.make.bind(this));
  this.bufferList = [];
  if (this.parameters.colorScheme) {
    this.parameters.colorScheme.options = ColormakerRegistry2.getSchemes();
  }
};
Representation.prototype.init = function init2(params) {
  var p = params || {};
  this.clipNear = defaults(p.clipNear, 0);
  this.clipRadius = defaults(p.clipRadius, 0);
  this.clipCenter = defaults(p.clipCenter, new Vector3());
  this.flatShaded = defaults(p.flatShaded, false);
  this.side = defaults(p.side, "double");
  this.opacity = defaults(p.opacity, 1);
  this.depthWrite = defaults(p.depthWrite, true);
  this.wireframe = defaults(p.wireframe, false);
  this.linewidth = defaults(p.linewidth, 2);
  this.setColor(p.color, p);
  this.colorScheme = defaults(p.colorScheme, "uniform");
  this.colorScale = defaults(p.colorScale, "");
  this.colorReverse = defaults(p.colorReverse, false);
  this.colorValue = defaults(p.colorValue, 9474192);
  this.colorDomain = defaults(p.colorDomain, void 0);
  this.colorMode = defaults(p.colorMode, "hcl");
  this.visible = defaults(p.visible, true);
  this.quality = defaults(p.quality, void 0);
  this.roughness = defaults(p.roughness, 0.4);
  this.metalness = defaults(p.metalness, 0);
  this.diffuse = defaults(p.diffuse, 16777215);
  this.lazy = defaults(p.lazy, false);
  this.lazyProps = {
    build: false,
    bufferParams: {},
    what: {}
  };
  this.matrix = defaults(p.matrix, new Matrix4());
  this.disablePicking = defaults(p.disablePicking, false);
  var tp = this.parameters;
  if (tp.sphereDetail === true) {
    tp.sphereDetail = {
      type: "integer",
      max: 3,
      min: 0,
      rebuild: "impostor"
    };
  }
  if (tp.radialSegments === true) {
    tp.radialSegments = {
      type: "integer",
      max: 25,
      min: 5,
      rebuild: "impostor"
    };
  }
  if (tp.openEnded === true) {
    tp.openEnded = {
      type: "boolean",
      rebuild: "impostor",
      buffer: true
    };
  }
  if (tp.disableImpostor === true) {
    tp.disableImpostor = {
      type: "boolean",
      rebuild: true
    };
  }
  if (p.quality === "low") {
    if (tp.sphereDetail) {
      this.sphereDetail = 0;
    }
    if (tp.radialSegments) {
      this.radialSegments = 5;
    }
  } else if (p.quality === "medium") {
    if (tp.sphereDetail) {
      this.sphereDetail = 1;
    }
    if (tp.radialSegments) {
      this.radialSegments = 10;
    }
  } else if (p.quality === "high") {
    if (tp.sphereDetail) {
      this.sphereDetail = 2;
    }
    if (tp.radialSegments) {
      this.radialSegments = 20;
    }
  } else {
    if (tp.sphereDetail) {
      this.sphereDetail = defaults(p.sphereDetail, 1);
    }
    if (tp.radialSegments) {
      this.radialSegments = defaults(p.radialSegments, 10);
    }
  }
  if (tp.openEnded) {
    this.openEnded = defaults(p.openEnded, true);
  }
  if (tp.disableImpostor) {
    this.disableImpostor = defaults(p.disableImpostor, false);
  }
};
Representation.prototype.getColorParams = function getColorParams(p) {
  return Object.assign({
    scheme: this.colorScheme,
    scale: this.colorScale,
    reverse: this.colorReverse,
    value: this.colorValue,
    domain: this.colorDomain,
    mode: this.colorMode
  }, p);
};
Representation.prototype.getBufferParams = function getBufferParams(p) {
  return Object.assign({
    clipNear: this.clipNear,
    clipRadius: this.clipRadius,
    clipCenter: this.clipCenter,
    flatShaded: this.flatShaded,
    opacity: this.opacity,
    depthWrite: this.depthWrite,
    side: this.side,
    wireframe: this.wireframe,
    linewidth: this.linewidth,
    roughness: this.roughness,
    metalness: this.metalness,
    diffuse: this.diffuse,
    matrix: this.matrix,
    disablePicking: this.disablePicking
  }, p);
};
Representation.prototype.setColor = function setColor(value2, p) {
  var types = Object.keys(ColormakerRegistry2.getSchemes());
  if (types.includes(value2)) {
    if (p) {
      p.colorScheme = value2;
    } else {
      this.setParameters({colorScheme: value2});
    }
  } else if (value2 !== void 0) {
    value2 = new Color(value2).getHex();
    if (p) {
      p.colorScheme = "uniform";
      p.colorValue = value2;
    } else {
      this.setParameters({
        colorScheme: "uniform",
        colorValue: value2
      });
    }
  }
  return this;
};
Representation.prototype.create = function create() {
};
Representation.prototype.update = function update() {
  this.build();
};
Representation.prototype.build = function build2(updateWhat) {
  if (this.lazy && !this.visible) {
    this.lazyProps.build = true;
    return;
  }
  if (!this.prepare) {
    this.tasks.increment();
    this.make();
    return;
  }
  if (this.queue.length() > 0) {
    this.tasks.change(1 - this.queue.length());
    this.queue.kill();
  } else {
    this.tasks.increment();
  }
  this.queue.push(updateWhat || false);
};
Representation.prototype.make = function make(updateWhat, callback) {
  if (Debug) {
    Log.time("Representation.make " + this.type);
  }
  var _make = function() {
    if (updateWhat) {
      this.update(updateWhat);
      this.viewer.requestRender();
      this.tasks.decrement();
      if (callback) {
        callback();
      }
    } else {
      this.clear();
      this.create();
      if (!this.manualAttach && !this.disposed) {
        if (Debug) {
          Log.time("Representation.attach " + this.type);
        }
        this.attach(function() {
          if (Debug) {
            Log.timeEnd("Representation.attach " + this.type);
          }
          this.tasks.decrement();
          if (callback) {
            callback();
          }
        }.bind(this));
      }
    }
    if (Debug) {
      Log.timeEnd("Representation.make " + this.type);
    }
  }.bind(this);
  if (this.prepare) {
    this.prepare(_make);
  } else {
    _make();
  }
};
Representation.prototype.attach = function attach(callback) {
  this.setVisibility(this.visible);
  callback();
};
Representation.prototype.setVisibility = function setVisibility4(value2, noRenderRequest) {
  this.visible = value2;
  if (this.visible) {
    var lazyProps = this.lazyProps;
    var bufferParams = lazyProps.bufferParams;
    var what = lazyProps.what;
    if (lazyProps.build) {
      lazyProps.build = false;
      this.build();
      return;
    } else if (Object.keys(bufferParams).length || Object.keys(what).length) {
      lazyProps.bufferParams = {};
      lazyProps.what = {};
      this.updateParameters(bufferParams, what);
    }
  }
  this.bufferList.forEach(function(buffer) {
    buffer.setVisibility(value2);
  });
  if (!noRenderRequest) {
    this.viewer.requestRender();
  }
  return this;
};
Representation.prototype.setParameters = function setParameters5(params, what, rebuild) {
  var this$1 = this;
  var p = params || {};
  var tp = this.parameters;
  what = what || {};
  rebuild = rebuild || false;
  var bufferParams = {};
  for (var name in p) {
    if (p[name] === void 0) {
      continue;
    }
    if (tp[name] === void 0) {
      continue;
    }
    if (tp[name].int) {
      p[name] = parseInt(p[name]);
    }
    if (tp[name].float) {
      p[name] = parseFloat(p[name]);
    }
    if (p[name] === this$1[name] && (!p[name].equals || p[name].equals(this$1[name]))) {
      continue;
    }
    if (this$1[name].set) {
      this$1[name].set(p[name]);
    } else {
      this$1[name] = p[name];
    }
    if (tp[name].buffer) {
      if (tp[name].buffer === true) {
        bufferParams[name] = p[name];
      } else {
        bufferParams[tp[name].buffer] = p[name];
      }
    }
    if (tp[name].update) {
      what[tp[name].update] = true;
    }
    if (tp[name].rebuild && !(tp[name].rebuild === "impostor" && ExtensionFragDepth && !this$1.disableImpostor)) {
      rebuild = true;
    }
  }
  if (rebuild) {
    this.build();
  } else {
    this.updateParameters(bufferParams, what);
  }
  return this;
};
Representation.prototype.updateParameters = function updateParameters(bufferParams, what) {
  if (this.lazy && !this.visible) {
    Object.assign(this.lazyProps.bufferParams, bufferParams);
    Object.assign(this.lazyProps.what, what);
    return;
  }
  this.bufferList.forEach(function(buffer) {
    buffer.setParameters(bufferParams);
  });
  if (Object.keys(what).length) {
    this.update(what);
  }
  this.viewer.requestRender();
};
Representation.prototype.getParameters = function getParameters2() {
  var this$1 = this;
  var params = {
    lazy: this.lazy,
    visible: this.visible,
    quality: this.quality
  };
  Object.keys(this.parameters).forEach(function(name) {
    if (this$1.parameters[name] !== null) {
      params[name] = this$1[name];
    }
  });
  return params;
};
Representation.prototype.clear = function clear6() {
  var this$1 = this;
  this.bufferList.forEach(function(buffer) {
    this$1.viewer.remove(buffer);
    buffer.dispose();
  });
  this.bufferList.length = 0;
  this.viewer.requestRender();
};
Representation.prototype.dispose = function dispose18() {
  this.disposed = true;
  this.queue.kill();
  this.tasks.dispose();
  this.clear();
};
var BufferRepresentation = function(Representation$$1) {
  function BufferRepresentation2(buffer, viewer, params) {
    if (!Array.isArray(buffer)) {
      buffer = [buffer];
    }
    Representation$$1.call(this, buffer, viewer, params);
    this.type = "buffer";
    this.parameters = Object.assign({}, this.parameters, {
      colorScheme: null,
      colorScale: null,
      colorValue: null,
      colorDomain: null,
      colorMode: null
    });
    this.buffer = buffer;
    this.init(params);
  }
  if (Representation$$1)
    BufferRepresentation2.__proto__ = Representation$$1;
  BufferRepresentation2.prototype = Object.create(Representation$$1 && Representation$$1.prototype);
  BufferRepresentation2.prototype.constructor = BufferRepresentation2;
  BufferRepresentation2.prototype.init = function init3(params) {
    Representation$$1.prototype.init.call(this, params);
    this.build();
  };
  BufferRepresentation2.prototype.create = function create2() {
    this.bufferList.push.apply(this.bufferList, this.buffer);
  };
  BufferRepresentation2.prototype.attach = function attach2(callback) {
    var this$1 = this;
    this.bufferList.forEach(function(buffer) {
      this$1.viewer.add(buffer);
      buffer.setParameters(this$1.getBufferParams());
    });
    this.setVisibility(this.visible);
    callback();
  };
  return BufferRepresentation2;
}(Representation);
var SurfaceBuffer = function(MeshBuffer$$1) {
  function SurfaceBuffer2() {
    MeshBuffer$$1.apply(this, arguments);
  }
  if (MeshBuffer$$1)
    SurfaceBuffer2.__proto__ = MeshBuffer$$1;
  SurfaceBuffer2.prototype = Object.create(MeshBuffer$$1 && MeshBuffer$$1.prototype);
  SurfaceBuffer2.prototype.constructor = SurfaceBuffer2;
  var prototypeAccessors2 = {isSurface: {}};
  prototypeAccessors2.isSurface.get = function() {
    return true;
  };
  Object.defineProperties(SurfaceBuffer2.prototype, prototypeAccessors2);
  return SurfaceBuffer2;
}(MeshBuffer);
function setVisibilityTrue(m2) {
  m2.visible = true;
}
function setVisibilityFalse(m2) {
  m2.visible = false;
}
var DoubleSidedBuffer = function DoubleSidedBuffer2(buffer) {
  this.size = buffer.size;
  this.side = buffer.side;
  this.wireframe = buffer.wireframe;
  this.visible = buffer.visible;
  this.geometry = buffer.geometry;
  this.picking = buffer.picking;
  this.background = buffer.background;
  this.disablePicking = buffer.disablePicking;
  this.group = new Group();
  this.wireframeGroup = new Group();
  this.pickingGroup = new Group();
  this.matrix = buffer.matrix;
  this.frontMeshes = [];
  this.backMeshes = [];
  var frontBuffer = buffer;
  var backBuffer = new buffer.constructor();
  frontBuffer.makeMaterial();
  backBuffer.makeMaterial();
  backBuffer.picking = buffer.picking;
  backBuffer.geometry = buffer.geometry;
  backBuffer.wireframeGeometry = buffer.wireframeGeometry;
  backBuffer.setParameters(buffer.getParameters());
  backBuffer.updateShader();
  frontBuffer.setParameters({
    side: "front"
  });
  backBuffer.setParameters({
    side: "back",
    opacity: backBuffer.opacity
  });
  this.buffer = buffer;
  this.frontBuffer = frontBuffer;
  this.backBuffer = backBuffer;
};
var prototypeAccessors$26 = {matrix: {}, pickable: {}};
prototypeAccessors$26.matrix.set = function(m2) {
  Buffer.prototype.setMatrix.call(this, m2);
};
prototypeAccessors$26.matrix.get = function() {
  return this.group.matrix.clone();
};
prototypeAccessors$26.pickable.get = function() {
  return !!this.picking && !this.disablePicking;
};
DoubleSidedBuffer.prototype.getMesh = function getMesh3(picking) {
  var front, back;
  if (picking) {
    back = this.backBuffer.getPickingMesh();
    front = this.frontBuffer.getPickingMesh();
  } else {
    back = this.backBuffer.getMesh();
    front = this.frontBuffer.getMesh();
  }
  this.frontMeshes.push(front);
  this.backMeshes.push(back);
  this.setParameters({side: this.side});
  return new Group().add(back, front);
};
DoubleSidedBuffer.prototype.getWireframeMesh = function getWireframeMesh3() {
  return this.buffer.getWireframeMesh();
};
DoubleSidedBuffer.prototype.getPickingMesh = function getPickingMesh3() {
  return this.getMesh(true);
};
DoubleSidedBuffer.prototype.setAttributes = function setAttributes3(data) {
  this.buffer.setAttributes(data);
};
DoubleSidedBuffer.prototype.setParameters = function setParameters6(data) {
  data = Object.assign({}, data);
  if (data.side === "front") {
    this.frontMeshes.forEach(setVisibilityTrue);
    this.backMeshes.forEach(setVisibilityFalse);
  } else if (data.side === "back") {
    this.frontMeshes.forEach(setVisibilityFalse);
    this.backMeshes.forEach(setVisibilityTrue);
  } else if (data.side === "double") {
    this.frontMeshes.forEach(setVisibilityTrue);
    this.backMeshes.forEach(setVisibilityTrue);
  }
  if (data.matrix !== void 0) {
    this.matrix = data.matrix;
  }
  delete data.matrix;
  if (data.side !== void 0) {
    this.side = data.side;
  }
  delete data.side;
  this.frontBuffer.setParameters(data);
  if (data.wireframe !== void 0) {
    this.wireframe = data.wireframe;
    this.setVisibility(this.visible);
  }
  delete data.wireframe;
  this.backBuffer.setParameters(data);
};
DoubleSidedBuffer.prototype.dispose = function dispose19() {
  this.frontBuffer.dispose();
  this.backBuffer.dispose();
};
Object.defineProperties(DoubleSidedBuffer.prototype, prototypeAccessors$26);
DoubleSidedBuffer.prototype.setVisibility = Buffer.prototype.setVisibility;
ShaderRegistry.add("shader/Line.vert", "uniform float nearClip;\nuniform vec3 clipCenter;\nvarying vec3 vViewPosition;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#include color_pars_vertex\nvoid main(){\n#include color_vertex\n#include begin_vertex\n#include project_vertex\nvViewPosition = -mvPosition.xyz;\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n#include nearclip_vertex\n}");
ShaderRegistry.add("shader/Line.frag", "uniform float opacity;\nuniform float nearClip;\nuniform float clipRadius;\nvarying vec3 vViewPosition;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#include common\n#include color_pars_fragment\n#include fog_pars_fragment\nvoid main(){\n#include nearclip_fragment\n#include radiusclip_fragment\ngl_FragColor = vec4( vColor, opacity );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n}");
var ContourBuffer = function(Buffer$$1) {
  function ContourBuffer2() {
    Buffer$$1.apply(this, arguments);
  }
  if (Buffer$$1)
    ContourBuffer2.__proto__ = Buffer$$1;
  ContourBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  ContourBuffer2.prototype.constructor = ContourBuffer2;
  var prototypeAccessors2 = {isLine: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.isLine.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Line.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Line.frag";
  };
  Object.defineProperties(ContourBuffer2.prototype, prototypeAccessors2);
  return ContourBuffer2;
}(Buffer);
var SurfaceRepresentation = function(Representation$$1) {
  function SurfaceRepresentation2(surface, viewer, params) {
    Representation$$1.call(this, surface, viewer, params);
    this.type = "surface";
    this.parameters = Object.assign({
      isolevelType: {
        type: "select",
        options: {
          value: "value",
          sigma: "sigma"
        }
      },
      isolevel: {
        type: "number",
        precision: 2,
        max: 1e3,
        min: -1e3
      },
      negateIsolevel: {
        type: "boolean"
      },
      smooth: {
        type: "integer",
        precision: 1,
        max: 10,
        min: 0
      },
      background: {
        type: "boolean",
        rebuild: true
      },
      opaqueBack: {
        type: "boolean",
        buffer: true
      },
      boxSize: {
        type: "integer",
        precision: 1,
        max: 100,
        min: 0
      },
      colorVolume: {
        type: "hidden"
      },
      contour: {
        type: "boolean",
        rebuild: true
      },
      useWorker: {
        type: "boolean",
        rebuild: true
      },
      wrap: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters);
    if (surface instanceof Volume) {
      this.surface = void 0;
      this.volume = surface;
    } else {
      this.surface = surface;
      this.volume = void 0;
    }
    this.boxCenter = new Vector3();
    this.__boxCenter = new Vector3();
    this.box = new Box3();
    this.__box = new Box3();
    this._position = new Vector3();
    this.setBox = function setBox() {
      this._position.copy(viewer.translationGroup.position).negate();
      if (!this._position.equals(this.boxCenter)) {
        this.setParameters({boxCenter: this._position});
      }
    };
    this.viewer.signals.ticked.add(this.setBox, this);
    this.init(params);
  }
  if (Representation$$1)
    SurfaceRepresentation2.__proto__ = Representation$$1;
  SurfaceRepresentation2.prototype = Object.create(Representation$$1 && Representation$$1.prototype);
  SurfaceRepresentation2.prototype.constructor = SurfaceRepresentation2;
  SurfaceRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "uniform");
    p.colorValue = defaults(p.colorValue, 14540253);
    this.isolevelType = defaults(p.isolevelType, "sigma");
    this.isolevel = defaults(p.isolevel, 2);
    this.negateIsolevel = defaults(p.negateIsolevel, false);
    this.smooth = defaults(p.smooth, 0);
    this.background = defaults(p.background, false);
    this.opaqueBack = defaults(p.opaqueBack, true);
    this.boxSize = defaults(p.boxSize, 0);
    this.colorVolume = defaults(p.colorVolume, void 0);
    this.contour = defaults(p.contour, false);
    this.useWorker = defaults(p.useWorker, true);
    this.wrap = defaults(p.wrap, false);
    Representation$$1.prototype.init.call(this, p);
    this.build();
  };
  SurfaceRepresentation2.prototype.attach = function attach2(callback) {
    var this$1 = this;
    this.bufferList.forEach(function(buffer) {
      this$1.viewer.add(buffer);
    });
    this.setVisibility(this.visible);
    callback();
  };
  SurfaceRepresentation2.prototype.prepare = function prepare(callback) {
    var this$1 = this;
    if (this.volume) {
      var isolevel;
      if (this.isolevelType === "sigma") {
        isolevel = this.volume.getValueForSigma(this.isolevel);
      } else {
        isolevel = this.isolevel;
      }
      if (this.negateIsolevel) {
        isolevel *= -1;
      }
      if (!this.surface || this.__isolevel !== isolevel || this.__smooth !== this.smooth || this.__contour !== this.contour || this.__wrap !== this.wrap || this.__boxSize !== this.boxSize || this.boxSize > 0 && !this.__boxCenter.equals(this.boxCenter)) {
        this.__isolevel = isolevel;
        this.__smooth = this.smooth;
        this.__contour = this.contour;
        this.__wrap = this.wrap;
        this.__boxSize = this.boxSize;
        this.__boxCenter.copy(this.boxCenter);
        this.__box.copy(this.box);
        var onSurfaceFinish = function(surface) {
          this$1.surface = surface;
          callback();
        };
        if (this.useWorker) {
          this.volume.getSurfaceWorker(isolevel, this.smooth, this.boxCenter, this.boxSize, this.contour, this.wrap, onSurfaceFinish);
        } else {
          onSurfaceFinish(this.volume.getSurface(isolevel, this.smooth, this.boxCenter, this.boxSize, this.contour, this.wrap));
        }
      } else {
        callback();
      }
    } else {
      callback();
    }
  };
  SurfaceRepresentation2.prototype.create = function create2() {
    var sd = {
      position: this.surface.getPosition(),
      color: this.surface.getColor(this.getColorParams()),
      index: this.surface.getIndex()
    };
    var buffer;
    if (this.contour) {
      buffer = new ContourBuffer(sd, this.getBufferParams({wireframe: false}));
    } else {
      sd.normal = this.surface.getNormal();
      sd.picking = this.surface.getPicking();
      var surfaceBuffer = new SurfaceBuffer(sd, this.getBufferParams({
        background: this.background,
        opaqueBack: this.opaqueBack,
        dullInterior: false
      }));
      buffer = new DoubleSidedBuffer(surfaceBuffer);
    }
    this.bufferList.push(buffer);
  };
  SurfaceRepresentation2.prototype.update = function update2(what) {
    if (this.bufferList.length === 0) {
      return;
    }
    what = what || {};
    var surfaceData = {};
    if (what.position) {
      surfaceData.position = this.surface.getPosition();
    }
    if (what.color) {
      surfaceData.color = this.surface.getColor(this.getColorParams());
    }
    if (what.index) {
      surfaceData.index = this.surface.getIndex();
    }
    if (what.normal) {
      surfaceData.normal = this.surface.getNormal();
    }
    this.bufferList.forEach(function(buffer) {
      buffer.setAttributes(surfaceData);
    });
  };
  SurfaceRepresentation2.prototype.setParameters = function setParameters8(params, what, rebuild) {
    if (params && params.isolevelType !== void 0 && this.volume) {
      if (this.isolevelType === "value" && params.isolevelType === "sigma") {
        this.isolevel = this.volume.getSigmaForValue(this.isolevel);
      } else if (this.isolevelType === "sigma" && params.isolevelType === "value") {
        this.isolevel = this.volume.getValueForSigma(this.isolevel);
      }
      this.isolevelType = params.isolevelType;
    }
    if (params && params.boxCenter) {
      this.boxCenter.copy(params.boxCenter);
      delete params.boxCenter;
    }
    if (params && params.wireframe && (params.contour || params.contour === void 0 && this.contour)) {
      params.wireframe = false;
    }
    Representation$$1.prototype.setParameters.call(this, params, what, rebuild);
    if (this.volume) {
      this.volume.getBox(this.boxCenter, this.boxSize, this.box);
    }
    if (params && params.colorVolume !== void 0) {
      what.color = true;
    }
    if (this.surface && (params.isolevel !== void 0 || params.negateIsolevel !== void 0 || params.smooth !== void 0 || params.wrap !== void 0 || params.boxSize !== void 0 || this.boxSize > 0 && !this.__box.equals(this.box))) {
      this.build({
        position: true,
        color: true,
        index: true,
        normal: !this.contour
      });
    }
    return this;
  };
  SurfaceRepresentation2.prototype.getColorParams = function getColorParams2() {
    var p = Representation$$1.prototype.getColorParams.call(this);
    p.volume = this.colorVolume;
    return p;
  };
  SurfaceRepresentation2.prototype.dispose = function dispose24() {
    this.viewer.signals.ticked.remove(this.setBox, this);
    Representation$$1.prototype.dispose.call(this);
  };
  return SurfaceRepresentation2;
}(Representation);
ShaderRegistry.add("shader/Point.vert", "uniform float nearClip;\nuniform float clipRadius;\nuniform vec3 clipCenter;\nuniform float size;\nuniform float canvasHeight;\nuniform float pixelRatio;\nvarying vec3 vViewPosition;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\n#include color_pars_vertex\n#endif\n#include common\nvoid main(){\n#if defined( PICKING )\nvPickingColor = unpackColor( primitiveId );\n#else\n#include color_vertex\n#endif\n#include begin_vertex\n#include project_vertex\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * pixelRatio * ( ( canvasHeight / 2.0 ) / -mvPosition.z );\n#else\ngl_PointSize = size * pixelRatio;\n#endif\nvViewPosition = -mvPosition.xyz;\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n#include nearclip_vertex\n#include radiusclip_vertex\n}");
ShaderRegistry.add("shader/Point.frag", "uniform vec3 diffuse;\nuniform float opacity;\nuniform float nearClip;\nuniform float clipRadius;\nvarying vec3 vViewPosition;\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#if defined( PICKING )\nuniform float objectId;\nvarying vec3 vPickingColor;\n#else\n#include common\n#include color_pars_fragment\n#include fog_pars_fragment\n#endif\nvoid main(){\n#include nearclip_fragment\n#include radiusclip_fragment\n#if defined( PICKING )\n#ifdef USE_MAP\nif( texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) ).a < 0.5 )\ndiscard;\n#endif\ngl_FragColor = vec4( vPickingColor, objectId );\n#else\nvec3 outgoingLight = vec3( 0.0 );\nvec4 diffuseColor = vec4( diffuse, 1.0 );\n#ifdef USE_MAP\ndiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif\n#include color_fragment\n#include alphatest_fragment\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a * opacity );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#endif\n}");
function distance2(x0, y0, x1, y1) {
  var dx = x1 - x0;
  var dy = y1 - y0;
  return Math.sqrt(dx * dx + dy * dy);
}
function makePointTexture(params) {
  var p = params || {};
  var width = defaults(p.width, 256);
  var height = defaults(p.height, 256);
  var center2 = [width / 2, height / 2];
  var radius = Math.min(width / 2, height / 2);
  var delta = defaults(p.delta, 1 / (radius + 1)) * radius;
  var x = 0;
  var y = 0;
  var data = new Uint8Array(width * height * 4);
  for (var i = 0, il = data.length; i < il; i += 4) {
    var dist = distance2(x, y, center2[0], center2[1]);
    var value2 = 1 - smoothstep(radius - delta, radius, dist);
    data[i] = value2 * 255;
    data[i + 1] = value2 * 255;
    data[i + 2] = value2 * 255;
    data[i + 3] = value2 * 255;
    if (++x === width) {
      x = 0;
      y++;
    }
  }
  var tex = new DataTexture(data, width, height);
  tex.needsUpdate = true;
  return tex;
}
var PointBuffer = function(Buffer$$1) {
  function PointBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    if (!d.primitiveId) {
      d.primitiveId = serialArray(d.position.length / 3);
    }
    Buffer$$1.call(this, d, p);
    this.pointSize = defaults(p.pointSize, 1);
    this.sizeAttenuation = defaults(p.sizeAttenuation, true);
    this.sortParticles = defaults(p.sortParticles, false);
    this.alphaTest = defaults(p.alphaTest, 0.5);
    this.useTexture = defaults(p.useTexture, false);
    this.forceTransparent = defaults(p.forceTransparent, false);
    this.edgeBleach = defaults(p.edgeBleach, 0);
    this.addUniforms({
      size: {value: this.pointSize},
      canvasHeight: {value: 1},
      pixelRatio: {value: 1},
      map: {value: null}
    });
  }
  if (Buffer$$1)
    PointBuffer2.__proto__ = Buffer$$1;
  PointBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  PointBuffer2.prototype.constructor = PointBuffer2;
  var prototypeAccessors2 = {parameters: {}, isPoint: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.parameters.get = function() {
    return Object.assign.call(this, {
      pointSize: {uniform: "size"},
      sizeAttenuation: {updateShader: true},
      sortParticles: {},
      alphaTest: {updateShader: true},
      useTexture: {updateShader: true},
      forceTransparent: {},
      edgeBleach: {uniform: true}
    }, Buffer$$1.prototype.parameters);
  };
  PointBuffer2.prototype.makeMaterial = function makeMaterial2() {
    Buffer$$1.prototype.makeMaterial.call(this);
    this.makeTexture();
    var m2 = this.material;
    var wm = this.wireframeMaterial;
    var pm = this.pickingMaterial;
    m2.uniforms.map.value = this.tex;
    m2.needsUpdate = true;
    wm.uniforms.map.value = this.tex;
    wm.needsUpdate = true;
    pm.uniforms.map.value = this.tex;
    pm.needsUpdate = true;
  };
  PointBuffer2.prototype.makeTexture = function makeTexture() {
    if (this.tex) {
      this.tex.dispose();
    }
    this.tex = makePointTexture({delta: this.edgeBleach});
  };
  PointBuffer2.prototype.getDefines = function getDefines3(type2) {
    var defines = Buffer$$1.prototype.getDefines.call(this, type2);
    if (this.sizeAttenuation) {
      defines.USE_SIZEATTENUATION = 1;
    }
    if (this.useTexture) {
      defines.USE_MAP = 1;
    }
    if (this.alphaTest > 0 && this.alphaTest <= 1) {
      defines.ALPHATEST = this.alphaTest.toPrecision(2);
    }
    return defines;
  };
  PointBuffer2.prototype.setUniforms = function setUniforms2(data) {
    if (data && data.edgeBleach !== void 0) {
      this.makeTexture();
      data.map = this.tex;
    }
    Buffer$$1.prototype.setUniforms.call(this, data);
  };
  PointBuffer2.prototype.dispose = function dispose24() {
    Buffer$$1.prototype.dispose.call(this);
    if (this.tex) {
      this.tex.dispose();
    }
  };
  prototypeAccessors2.isPoint.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Point.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Point.frag";
  };
  Object.defineProperties(PointBuffer2.prototype, prototypeAccessors2);
  return PointBuffer2;
}(Buffer);
var DotRepresentation = function(Representation$$1) {
  function DotRepresentation2(surface, viewer, params) {
    Representation$$1.call(this, surface, viewer, params);
    this.type = "dot";
    this.parameters = Object.assign({
      thresholdType: {
        type: "select",
        rebuild: true,
        options: {
          value: "value",
          sigma: "sigma"
        }
      },
      thresholdMin: {
        type: "number",
        precision: 3,
        max: Infinity,
        min: -Infinity,
        rebuild: true
      },
      thresholdMax: {
        type: "number",
        precision: 3,
        max: Infinity,
        min: -Infinity,
        rebuild: true
      },
      thresholdOut: {
        type: "boolean",
        rebuild: true
      },
      dotType: {
        type: "select",
        rebuild: true,
        options: {
          "": "",
          sphere: "sphere",
          point: "point"
        }
      },
      radiusType: {
        type: "select",
        options: {
          "": "",
          value: "value",
          "abs-value": "abs-value",
          "value-min": "value-min",
          deviation: "deviation",
          size: "size"
        }
      },
      radius: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3,
        property: "size"
      },
      scale: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      sphereDetail: true,
      disableImpostor: true,
      pointSize: {
        type: "number",
        precision: 1,
        max: 100,
        min: 0,
        buffer: true
      },
      sizeAttenuation: {
        type: "boolean",
        buffer: true
      },
      sortParticles: {
        type: "boolean",
        rebuild: true
      },
      useTexture: {
        type: "boolean",
        buffer: true
      },
      alphaTest: {
        type: "range",
        step: 1e-3,
        max: 1,
        min: 0,
        buffer: true
      },
      forceTransparent: {
        type: "boolean",
        buffer: true
      },
      edgeBleach: {
        type: "range",
        step: 1e-3,
        max: 1,
        min: 0,
        buffer: true
      }
    }, this.parameters, {
      colorScheme: {
        type: "select",
        update: "color",
        options: {
          "": "",
          value: "value",
          uniform: "uniform",
          random: "random"
        }
      }
    });
    if (surface instanceof Volume) {
      this.surface = void 0;
      this.volume = new FilteredVolume(surface);
    } else {
      this.surface = surface;
      this.volume = void 0;
    }
    this.init(params);
  }
  if (Representation$$1)
    DotRepresentation2.__proto__ = Representation$$1;
  DotRepresentation2.prototype = Object.create(Representation$$1 && Representation$$1.prototype);
  DotRepresentation2.prototype.constructor = DotRepresentation2;
  DotRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "uniform");
    p.colorValue = defaults(p.colorValue, 14540253);
    this.thresholdType = defaults(p.thresholdType, "sigma");
    this.thresholdMin = defaults(p.thresholdMin, 2);
    this.thresholdMax = defaults(p.thresholdMax, Infinity);
    this.thresholdOut = defaults(p.thresholdOut, false);
    this.dotType = defaults(p.dotType, "point");
    this.radius = defaults(p.radius, 0.1);
    this.scale = defaults(p.scale, 1);
    this.pointSize = defaults(p.pointSize, 1);
    this.sizeAttenuation = defaults(p.sizeAttenuation, true);
    this.sortParticles = defaults(p.sortParticles, false);
    this.useTexture = defaults(p.useTexture, false);
    this.alphaTest = defaults(p.alphaTest, 0.5);
    this.forceTransparent = defaults(p.forceTransparent, false);
    this.edgeBleach = defaults(p.edgeBleach, 0);
    Representation$$1.prototype.init.call(this, p);
    this.build();
  };
  DotRepresentation2.prototype.attach = function attach2(callback) {
    var this$1 = this;
    this.bufferList.forEach(function(buffer) {
      this$1.viewer.add(buffer);
    });
    this.setVisibility(this.visible);
    callback();
  };
  DotRepresentation2.prototype.create = function create2() {
    var dotData = {};
    if (this.volume) {
      var volume = this.volume;
      var thresholdMin, thresholdMax;
      if (this.thresholdType === "sigma") {
        thresholdMin = volume.getValueForSigma(this.thresholdMin);
        thresholdMax = volume.getValueForSigma(this.thresholdMax);
      } else {
        thresholdMin = this.thresholdMin;
        thresholdMax = this.thresholdMax;
      }
      volume.setFilter(thresholdMin, thresholdMax, this.thresholdOut);
      dotData.position = volume.getDataPosition();
      dotData.color = volume.getDataColor(this.getColorParams());
      if (this.dotType === "sphere") {
        dotData.radius = volume.getDataSize(this.radius, this.scale);
        dotData.picking = volume.getDataPicking();
      }
    } else {
      var surface = this.surface;
      dotData.position = surface.getPosition();
      dotData.color = surface.getColor(this.getColorParams());
      if (this.dotType === "sphere") {
        dotData.radius = surface.getSize(this.radius, this.scale);
        dotData.picking = surface.getPicking();
      }
    }
    if (this.dotType === "sphere") {
      this.dotBuffer = new SphereBuffer(dotData, this.getBufferParams({
        sphereDetail: this.sphereDetail,
        disableImpostor: this.disableImpostor,
        dullInterior: false
      }));
    } else {
      this.dotBuffer = new PointBuffer(dotData, this.getBufferParams({
        pointSize: this.pointSize,
        sizeAttenuation: this.sizeAttenuation,
        sortParticles: this.sortParticles,
        useTexture: this.useTexture,
        alphaTest: this.alphaTest,
        forceTransparent: this.forceTransparent,
        edgeBleach: this.edgeBleach
      }));
    }
    this.bufferList.push(this.dotBuffer);
  };
  DotRepresentation2.prototype.update = function update2(what) {
    if (this.bufferList.length === 0) {
      return;
    }
    what = what || {};
    var dotData = {};
    if (what.color) {
      if (this.volume) {
        dotData.color = this.volume.getDataColor(this.getColorParams());
      } else {
        dotData.color = this.surface.getColor(this.getColorParams());
      }
    }
    if (this.dotType === "sphere" && (what.radius || what.scale)) {
      if (this.volume) {
        dotData.radius = this.volume.getDataSize(this.radius, this.scale);
      } else {
        dotData.radius = this.surface.getSize(this.radius, this.scale);
      }
    }
    this.dotBuffer.setAttributes(dotData);
  };
  DotRepresentation2.prototype.setParameters = function setParameters8(params, what, rebuild) {
    what = what || {};
    if (params && params.thresholdType !== void 0 && this.volume instanceof Volume) {
      if (this.thresholdType === "value" && params.thresholdType === "sigma") {
        this.thresholdMin = this.volume.getSigmaForValue(this.thresholdMin);
        this.thresholdMax = this.volume.getSigmaForValue(this.thresholdMax);
      } else if (this.thresholdType === "sigma" && params.thresholdType === "value") {
        this.thresholdMin = this.volume.getValueForSigma(this.thresholdMin);
        this.thresholdMax = this.volume.getValueForSigma(this.thresholdMax);
      }
      this.thresholdType = params.thresholdType;
    }
    if (params && params.radiusType !== void 0) {
      if (params.radiusType === "radius") {
        this.radius = 0.1;
      } else {
        this.radius = params.radiusType;
      }
      what.radius = true;
      if (this.dotType === "sphere" && (!ExtensionFragDepth || this.disableImpostor)) {
        rebuild = true;
      }
    }
    if (params && params.radius !== void 0) {
      what.radius = true;
      if (this.dotType === "sphere" && (!ExtensionFragDepth || this.disableImpostor)) {
        rebuild = true;
      }
    }
    if (params && params.scale !== void 0) {
      what.scale = true;
      if (this.dotType === "sphere" && (!ExtensionFragDepth || this.disableImpostor)) {
        rebuild = true;
      }
    }
    Representation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return DotRepresentation2;
}(Representation);
ShaderRegistry.add("shader/Image.vert", "uniform float clipRadius;\nuniform vec3 clipCenter;\nvarying vec2 vUv;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || !defined( PICKING )\nvarying vec3 vViewPosition;\n#endif\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\nvoid main() {\n#include begin_vertex\n#include project_vertex\nvUv = uv;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || !defined( PICKING )\nvViewPosition = -mvPosition.xyz;\n#endif\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n}");
ShaderRegistry.add("shader/Image.frag", "uniform sampler2D map;\nuniform float opacity;\nuniform vec2 mapSize;\nuniform float nearClip;\nuniform float clipRadius;\nvarying vec2 vUv;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || !defined( PICKING )\nvarying vec3 vViewPosition;\n#endif\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\n#if defined( PICKING )\nuniform sampler2D pickingMap;\nuniform float objectId;\n#else\n#include fog_pars_fragment\n#endif\n#if defined( CUBIC_INTERPOLATION )\n#if defined( CATMULROM_FILTER ) || defined( MITCHELL_FILTER )\n#if defined( CATMULROM_FILTER )\nconst float B = 0.0;\nconst float C = 0.5;\n#elif defined( MITCHELL_FILTER )\nconst float B = 0.333;\nconst float C = 0.333;\n#endif\nfloat filter( float x ){\nfloat f = x;\nif( f < 0.0 ){\nf = -f;\n}\nif( f < 1.0 ){\nreturn ( ( 12.0 - 9.0 * B - 6.0 * C ) * ( f * f * f ) +\n( -18.0 + 12.0 * B + 6.0 *C ) * ( f * f ) +\n( 6.0 - 2.0 * B ) ) / 6.0;\n}else if( f >= 1.0 && f < 2.0 ){\nreturn ( ( -B - 6.0 * C ) * ( f * f * f )\n+ ( 6.0 * B + 30.0 * C ) * ( f *f ) +\n( - ( 12.0 * B ) - 48.0 * C ) * f +\n8.0 * B + 24.0 * C ) / 6.0;\n}else{\nreturn 0.0;\n}\n}\n#elif defined( BSPLINE_FILTER )\nfloat filter( float x ){\nfloat f = x;\nif( f < 0.0 ){\nf = -f;\n}\nif( f >= 0.0 && f <= 1.0 ){\nreturn ( 2.0 / 3.0 ) + ( 0.5 ) * ( f * f * f ) - ( f * f );\n}else if( f > 1.0 && f <= 2.0 ){\nreturn 1.0 / 6.0 * pow( ( 2.0 - f ), 3.0 );\n}\nreturn 1.0;\n}\n#else\nfloat filter( float x ){\nreturn 1.0;\n}\n#endif\nvec4 biCubic( sampler2D tex, vec2 texCoord ){\nvec2 texelSize = 1.0 / mapSize;\ntexCoord -= texelSize / 2.0;\nvec4 nSum = vec4( 0.0 );\nfloat nDenom = 0.0;\nvec2 cell = fract( texCoord * mapSize );\nfor( float m = -1.0; m <= 2.0; ++m ){\nfor( float n = -1.0; n <= 2.0; ++n ){\nvec4 vecData = texture2D(\ntex, texCoord + texelSize * vec2( m, n )\n);\nfloat c = filter( m - cell.x ) * filter( -n + cell.y );\nnSum += vecData * c;\nnDenom += c;\n}\n}\nreturn nSum / nDenom;\n}\n#endif\nvoid main(){\n#include nearclip_fragment\n#include radiusclip_fragment\n#if defined( CUBIC_INTERPOLATION )\ngl_FragColor = biCubic( map, vUv );\n#else\ngl_FragColor = texture2D( map, vUv );\n#endif\n#if defined( PICKING )\nif( gl_FragColor.a < 0.7 )\ndiscard;\ngl_FragColor = vec4( texture2D( pickingMap, vUv ).xyz, objectId );\n#else\nif( gl_FragColor.a < 0.01 )\ndiscard;\ngl_FragColor.a *= opacity;\n#include fog_fragment\n#endif\n}");
var quadIndices = new Uint16Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var quadUvs = new Float32Array([
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  0
]);
var ImageBuffer = function(Buffer$$1) {
  function ImageBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    Buffer$$1.call(this, {
      position: d.position,
      index: quadIndices,
      picking: d.picking
    }, p);
    this.forceTransparent = true;
    this.filter = defaults(p.filter, "nearest");
    var tex = new DataTexture(d.imageData, d.width, d.height);
    tex.flipY = true;
    this.tex = tex;
    var n = d.imageData.length;
    var pickingData = new Uint8Array(n);
    for (var i = 0; i < n; i += 4) {
      var j = i / 4;
      pickingData[i] = j >> 16 & 255;
      pickingData[i + 1] = j >> 8 & 255;
      pickingData[i + 2] = j & 255;
    }
    var pickingTex = new DataTexture(pickingData, d.width, d.height);
    pickingTex.flipY = true;
    pickingTex.minFilter = NearestFilter;
    pickingTex.magFilter = NearestFilter;
    this.pickingTex = pickingTex;
    this.addUniforms({
      map: {value: tex},
      pickingMap: {value: pickingTex},
      mapSize: {value: new Vector2(d.width, d.height)}
    });
    this.geometry.addAttribute("uv", new BufferAttribute(quadUvs, 2));
  }
  if (Buffer$$1)
    ImageBuffer2.__proto__ = Buffer$$1;
  ImageBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  ImageBuffer2.prototype.constructor = ImageBuffer2;
  var prototypeAccessors2 = {parameters: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.parameters.get = function() {
    return Object.assign.call(this, {
      filter: {updateShader: true, uniform: true}
    }, Buffer$$1.prototype.parameters);
  };
  ImageBuffer2.prototype.getDefines = function getDefines3(type2) {
    var defines = Buffer$$1.prototype.getDefines.call(this, type2);
    if (this.filter.startsWith("cubic")) {
      defines.CUBIC_INTERPOLATION = 1;
      if (this.filter.endsWith("bspline")) {
        defines.BSPLINE_FILTER = 1;
      } else if (this.filter.endsWith("catmulrom")) {
        defines.CATMULROM_FILTER = 1;
      } else if (this.filter.endsWith("mitchell")) {
        defines.MITCHELL_FILTER = 1;
      }
    }
    return defines;
  };
  ImageBuffer2.prototype.updateTexture = function updateTexture() {
    var tex = this.tex;
    if (this.filter.startsWith("cubic")) {
      tex.minFilter = NearestFilter;
      tex.magFilter = NearestFilter;
    } else if (this.filter === "linear") {
      tex.minFilter = LinearFilter;
      tex.magFilter = LinearFilter;
    } else {
      tex.minFilter = NearestFilter;
      tex.magFilter = NearestFilter;
    }
    tex.needsUpdate = true;
    this.pickingTex.needsUpdate = true;
  };
  ImageBuffer2.prototype.makeMaterial = function makeMaterial2() {
    Buffer$$1.prototype.makeMaterial.call(this);
    this.updateTexture();
    var m2 = this.material;
    m2.uniforms.map.value = this.tex;
    m2.blending = NormalBlending;
    m2.needsUpdate = true;
    var wm = this.wireframeMaterial;
    wm.uniforms.map.value = this.tex;
    wm.blending = NormalBlending;
    wm.needsUpdate = true;
    var pm = this.pickingMaterial;
    pm.uniforms.map.value = this.tex;
    pm.uniforms.pickingMap.value = this.pickingTex;
    pm.blending = NormalBlending;
    pm.needsUpdate = true;
  };
  ImageBuffer2.prototype.setUniforms = function setUniforms2(data) {
    if (data && data.filter !== void 0) {
      this.updateTexture();
      data.map = this.tex;
    }
    Buffer$$1.prototype.setUniforms.call(this, data);
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Image.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Image.frag";
  };
  Object.defineProperties(ImageBuffer2.prototype, prototypeAccessors2);
  return ImageBuffer2;
}(Buffer);
var VolumeSlice = function VolumeSlice2(volume, params) {
  var p = params || {};
  this.dimension = defaults(p.dimension, "x");
  this.positionType = defaults(p.positionType, "percent");
  this.position = defaults(p.position, 30);
  this.thresholdType = defaults(p.thresholdType, "sigma");
  this.thresholdMin = defaults(p.thresholdMin, -Infinity);
  this.thresholdMax = defaults(p.thresholdMax, Infinity);
  this.normalize = defaults(p.normalize, false);
  this.volume = volume;
};
VolumeSlice.prototype.getPositionFromCoordinate = function getPositionFromCoordinate(coord) {
  var dim = this.dimension;
  var v = this.volume;
  var m2 = v.matrix;
  var mp = new Vector3().setFromMatrixPosition(m2)[dim];
  var ms = new Vector3().setFromMatrixScale(m2)[dim];
  var vn;
  if (dim === "x") {
    vn = v.nx;
  } else if (dim === "y") {
    vn = v.ny;
  } else {
    vn = v.nz;
  }
  return Math.round(((coord - mp) / (vn / 100) + 1) / ms);
};
VolumeSlice.prototype.getData = function getData(params) {
  var this$1 = this;
  params = params || {};
  var v = this.volume;
  var d = v.data;
  var m2 = v.matrix;
  var p;
  if (this.positionType === "coordinate") {
    p = this.getPositionFromCoordinate(this.position);
  } else {
    p = this.position;
  }
  function pos(dimLen) {
    return Math.round(dimLen / 100 * (p - 1));
  }
  function index(x2, y2, z2, i2) {
    return (z2 * v.ny * v.nx + y2 * v.nx + x2) * 3 + i2;
  }
  var position = new Float32Array(4 * 3);
  var vec = new Vector3();
  var width, height;
  var x;
  var y;
  var z;
  var x0 = 0;
  var y0 = 0;
  var z0 = 0;
  var nx = v.nx;
  var ny = v.ny;
  var nz = v.nz;
  function setVec(x2, y2, z2, offset) {
    vec.set(x2, y2, z2).applyMatrix4(m2).toArray(position, offset);
  }
  if (this.dimension === "x") {
    x = pos(v.nx);
    y = v.ny - 1;
    z = v.nz - 1;
    width = v.nz;
    height = v.ny;
    x0 = x;
    nx = x0 + 1;
    setVec(x, 0, 0, 0);
    setVec(x, y, 0, 3);
    setVec(x, 0, z, 6);
    setVec(x, y, z, 9);
  } else if (this.dimension === "y") {
    x = v.nx - 1;
    y = pos(v.ny);
    z = v.nz - 1;
    width = v.nz;
    height = v.nx;
    y0 = y;
    ny = y0 + 1;
    setVec(0, y, 0, 0);
    setVec(x, y, 0, 3);
    setVec(0, y, z, 6);
    setVec(x, y, z, 9);
  } else if (this.dimension === "z") {
    x = v.nx - 1;
    y = v.ny - 1;
    z = pos(v.nz);
    width = v.nx;
    height = v.ny;
    z0 = z;
    nz = z0 + 1;
    setVec(0, 0, z, 0);
    setVec(0, y, z, 3);
    setVec(x, 0, z, 6);
    setVec(x, y, z, 9);
  }
  var i = 0;
  var j = 0;
  var imageData = new Uint8Array(width * height * 4);
  var pickingArray = new Float32Array(width * height);
  var tMin, tMax;
  if (this.thresholdType === "sigma") {
    tMin = v.getValueForSigma(this.thresholdMin);
    tMax = v.getValueForSigma(this.thresholdMax);
  } else {
    tMin = this.thresholdMin;
    tMax = this.thresholdMax;
  }
  var cp = Object.assign({}, params.colorParams, {volume: v});
  if (this.normalize) {
    cp.domain = [0, 1];
  }
  var colormaker = ColormakerRegistry2.getScheme(cp);
  var tmp2 = new Float32Array(3);
  var scale2 = colormaker.getScale();
  var min, max2, diff;
  if (this.normalize) {
    min = Infinity;
    max2 = -Infinity;
    for (var iy = y0; iy < ny; ++iy) {
      for (var ix = x0; ix < nx; ++ix) {
        for (var iz = z0; iz < nz; ++iz) {
          var idx = index(ix, iy, iz, 0) / 3;
          var val = d[idx];
          if (val < min) {
            min = val;
          }
          if (val > max2) {
            max2 = val;
          }
        }
      }
    }
    diff = max2 - min;
  }
  for (var iy$1 = y0; iy$1 < ny; ++iy$1) {
    for (var ix$1 = x0; ix$1 < nx; ++ix$1) {
      for (var iz$1 = z0; iz$1 < nz; ++iz$1) {
        var idx$1 = index(ix$1, iy$1, iz$1, 0) / 3;
        var val$1 = d[idx$1];
        if (this$1.normalize) {
          val$1 = (val$1 - min) / diff;
        }
        colormaker.colorToArray(scale2(val$1), tmp2);
        imageData[i] = Math.round(tmp2[0] * 255);
        imageData[i + 1] = Math.round(tmp2[1] * 255);
        imageData[i + 2] = Math.round(tmp2[2] * 255);
        imageData[i + 3] = val$1 > tMin && val$1 < tMax ? 255 : 0;
        pickingArray[j] = idx$1;
        ++j;
        i += 4;
      }
    }
  }
  var picking = new SlicePicker(pickingArray, v);
  return {position, imageData, width, height, picking};
};
var SliceRepresentation = function(Representation$$1) {
  function SliceRepresentation2(volume, viewer, params) {
    Representation$$1.call(this, volume, viewer, params);
    this.type = "slice";
    this.parameters = Object.assign({
      filter: {
        type: "select",
        buffer: true,
        options: {
          nearest: "nearest",
          linear: "linear",
          "cubic-bspline": "cubic-bspline",
          "cubic-catmulrom": "cubic-catmulrom",
          "cubic-mitchell": "cubic-mitchell"
        }
      },
      positionType: {
        type: "select",
        rebuild: true,
        options: {
          percent: "percent",
          coordinate: "coordinate"
        }
      },
      position: {
        type: "range",
        step: 0.1,
        max: 100,
        min: 1,
        rebuild: true
      },
      dimension: {
        type: "select",
        rebuild: true,
        options: {
          x: "x",
          y: "y",
          z: "z"
        }
      },
      thresholdType: {
        type: "select",
        rebuild: true,
        options: {
          value: "value",
          sigma: "sigma"
        }
      },
      thresholdMin: {
        type: "number",
        precision: 3,
        max: Infinity,
        min: -Infinity,
        rebuild: true
      },
      thresholdMax: {
        type: "number",
        precision: 3,
        max: Infinity,
        min: -Infinity,
        rebuild: true
      },
      normalize: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters, {
      flatShaded: null,
      side: null,
      wireframe: null,
      linewidth: null,
      colorScheme: null,
      roughness: null,
      metalness: null,
      diffuse: null
    });
    this.volume = volume;
    this.init(params);
  }
  if (Representation$$1)
    SliceRepresentation2.__proto__ = Representation$$1;
  SliceRepresentation2.prototype = Object.create(Representation$$1 && Representation$$1.prototype);
  SliceRepresentation2.prototype.constructor = SliceRepresentation2;
  SliceRepresentation2.prototype.init = function init3(params) {
    var v = this.volume;
    var p = params || {};
    p.colorDomain = defaults(p.colorDomain, [v.min, v.max]);
    p.colorScheme = defaults(p.colorScheme, "value");
    p.colorScale = defaults(p.colorScale, "Spectral");
    this.colorScheme = "value";
    this.dimension = defaults(p.dimension, "x");
    this.filter = defaults(p.filter, "cubic-bspline");
    this.positionType = defaults(p.positionType, "percent");
    this.position = defaults(p.position, 30);
    this.thresholdType = defaults(p.thresholdType, "sigma");
    this.thresholdMin = defaults(p.thresholdMin, -Infinity);
    this.thresholdMax = defaults(p.thresholdMax, Infinity);
    this.normalize = defaults(p.normalize, false);
    Representation$$1.prototype.init.call(this, p);
    this.build();
  };
  SliceRepresentation2.prototype.attach = function attach2(callback) {
    var this$1 = this;
    this.bufferList.forEach(function(buffer) {
      this$1.viewer.add(buffer);
    });
    this.setVisibility(this.visible);
    callback();
  };
  SliceRepresentation2.prototype.create = function create2() {
    var volumeSlice = new VolumeSlice(this.volume, {
      positionType: this.positionType,
      position: this.position,
      dimension: this.dimension,
      thresholdType: this.thresholdType,
      thresholdMin: this.thresholdMin,
      thresholdMax: this.thresholdMax,
      normalize: this.normalize
    });
    var sliceBuffer = new ImageBuffer(volumeSlice.getData({colorParams: this.getColorParams()}), this.getBufferParams({
      filter: this.filter
    }));
    this.bufferList.push(sliceBuffer);
  };
  return SliceRepresentation2;
}(Representation);
var StructureRepresentation = function(Representation$$1) {
  function StructureRepresentation2(structure, viewer, params) {
    var p = params || {};
    Representation$$1.call(this, structure, viewer, p);
    this.type = "structure";
    this.parameters = Object.assign({
      radiusType: {
        type: "select",
        options: RadiusFactory.types
      },
      radius: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      scale: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      assembly: null,
      defaultAssembly: {
        type: "hidden"
      }
    }, this.parameters);
    this.selection = new Selection(p.sele);
    this.dataList = [];
    this.structure = structure;
    this.structureView = this.structure.getView(this.selection);
    if (structure.biomolDict) {
      var biomolOptions = {
        default: "default",
        "": structure.unitcell ? "AU" : "FULL"
      };
      Object.keys(structure.biomolDict).forEach(function(k) {
        biomolOptions[k] = k;
      });
      this.parameters.assembly = {
        type: "select",
        options: biomolOptions,
        rebuild: true
      };
    } else {
      this.parameters.assembly = null;
    }
  }
  if (Representation$$1)
    StructureRepresentation2.__proto__ = Representation$$1;
  StructureRepresentation2.prototype = Object.create(Representation$$1 && Representation$$1.prototype);
  StructureRepresentation2.prototype.constructor = StructureRepresentation2;
  var prototypeAccessors2 = {defaultScale: {}};
  prototypeAccessors2.defaultScale.get = function() {
    return {
      vdw: 1,
      covalent: 1,
      bfactor: 0.01,
      sstruc: 1
    };
  };
  StructureRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "element");
    this.radius = defaults(p.radius, "vdw");
    this.scale = defaults(p.scale, 1);
    this.assembly = defaults(p.assembly, "default");
    this.defaultAssembly = defaults(p.defaultAssembly, "");
    if (p.quality === "auto") {
      p.quality = this.getQuality();
    }
    Representation$$1.prototype.init.call(this, p);
    this.selection.signals.stringChanged.add(function() {
      this.build();
    }, this);
    this.build();
  };
  StructureRepresentation2.prototype.getAssembly = function getAssembly() {
    var name = this.assembly === "default" ? this.defaultAssembly : this.assembly;
    return this.structure.biomolDict[name];
  };
  StructureRepresentation2.prototype.getQuality = function getQuality() {
    var atomCount;
    var s = this.structureView;
    var assembly = this.getAssembly();
    if (assembly) {
      atomCount = assembly.getAtomCount(s);
    } else {
      atomCount = s.atomCount;
    }
    if (Mobile) {
      atomCount *= 4;
    }
    var backboneOnly = s.atomStore.count / s.residueStore.count < 2;
    if (backboneOnly) {
      atomCount *= 10;
    }
    if (atomCount < 15e3) {
      return "high";
    } else if (atomCount < 8e4) {
      return "medium";
    } else {
      return "low";
    }
  };
  StructureRepresentation2.prototype.create = function create2() {
    if (this.structureView.atomCount === 0) {
      return;
    }
    var assembly = this.getAssembly();
    if (assembly) {
      assembly.partList.forEach(function(part, i) {
        var sview = part.getView(this.structureView);
        if (sview.atomCount === 0) {
          return;
        }
        var data2 = this.createData(sview, i);
        if (data2) {
          data2.sview = sview;
          data2.instanceList = part.getInstanceList();
          this.dataList.push(data2);
        }
      }, this);
    } else {
      var data = this.createData(this.structureView, 0);
      if (data) {
        data.sview = this.structureView;
        this.dataList.push(data);
      }
    }
  };
  StructureRepresentation2.prototype.createData = function createData() {
    console.error("createData not implemented");
  };
  StructureRepresentation2.prototype.update = function update2(what) {
    if (this.lazy && !this.visible) {
      Object.assign(this.lazyProps.what, what);
      return;
    }
    this.dataList.forEach(function(data) {
      if (data.bufferList.length > 0) {
        this.updateData(what, data);
      }
    }, this);
  };
  StructureRepresentation2.prototype.updateData = function updateData() {
    this.build();
  };
  StructureRepresentation2.prototype.getColorParams = function getColorParams2() {
    var p = Representation$$1.prototype.getColorParams.call(this);
    p.structure = this.structure;
    return p;
  };
  StructureRepresentation2.prototype.getAtomParams = function getAtomParams(what, params) {
    return Object.assign({
      what,
      colorParams: this.getColorParams(),
      radiusParams: {radius: this.radius, scale: this.scale}
    }, params);
  };
  StructureRepresentation2.prototype.getBondParams = function getBondParams(what, params) {
    return Object.assign({
      what,
      colorParams: this.getColorParams(),
      radiusParams: {radius: this.radius, scale: this.scale}
    }, params);
  };
  StructureRepresentation2.prototype.setSelection = function setSelection3(string, silent) {
    this.selection.setString(string, silent);
    return this;
  };
  StructureRepresentation2.prototype.setParameters = function setParameters8(params, what, rebuild) {
    what = what || {};
    if (params && params.radiusType !== void 0) {
      if (params.radiusType === "size") {
        this.radius = 1;
      } else {
        this.radius = params.radiusType;
      }
      delete params.radiusType;
      what.radius = true;
      if (!ExtensionFragDepth || this.disableImpostor) {
        rebuild = true;
      }
    }
    if (params && params.radius !== void 0) {
      what.radius = true;
      if (!ExtensionFragDepth || this.disableImpostor) {
        rebuild = true;
      }
    }
    if (params && params.scale !== void 0) {
      what.radius = true;
      if (!ExtensionFragDepth || this.disableImpostor) {
        rebuild = true;
      }
    }
    if (params && params.defaultAssembly !== void 0) {
      rebuild = true;
    }
    Representation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  StructureRepresentation2.prototype.getParameters = function getParameters4() {
    var params = Object.assign(Representation$$1.prototype.getParameters.call(this), {
      sele: this.selection ? this.selection.string : void 0,
      defaultAssembly: this.defaultAssembly
    });
    return params;
  };
  StructureRepresentation2.prototype.attach = function attach2(callback) {
    var viewer = this.viewer;
    var bufferList = this.bufferList;
    this.dataList.forEach(function(data) {
      data.bufferList.forEach(function(buffer) {
        bufferList.push(buffer);
        viewer.add(buffer, data.instanceList);
      });
    });
    this.setVisibility(this.visible);
    callback();
  };
  StructureRepresentation2.prototype.clear = function clear7() {
    this.dataList.length = 0;
    Representation$$1.prototype.clear.call(this);
  };
  StructureRepresentation2.prototype.dispose = function dispose24() {
    this.structureView.dispose();
    delete this.structure;
    delete this.structureView;
    Representation$$1.prototype.dispose.call(this);
  };
  Object.defineProperties(StructureRepresentation2.prototype, prototypeAccessors2);
  return StructureRepresentation2;
}(Representation);
var LineBuffer = function(Buffer$$1) {
  function LineBuffer2(data, params) {
    var size = data.position1.length / 3;
    var attrSize = size * 4;
    Buffer$$1.call(this, {
      position: new Float32Array(attrSize * 3),
      color: new Float32Array(attrSize * 3)
    }, params);
    this.setAttributes(data);
  }
  if (Buffer$$1)
    LineBuffer2.__proto__ = Buffer$$1;
  LineBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  LineBuffer2.prototype.constructor = LineBuffer2;
  var prototypeAccessors2 = {isLine: {}, vertexShader: {}, fragmentShader: {}};
  LineBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var position1, position2, color, color2;
    var aPosition, aColor;
    var attributes = this.geometry.attributes;
    if (data.position1 && data.position2) {
      position1 = data.position1;
      position2 = data.position2;
      aPosition = attributes.position.array;
      attributes.position.needsUpdate = true;
    }
    if (data.color && data.color2) {
      color = data.color;
      color2 = data.color2;
      aColor = attributes.color.array;
      attributes.color.needsUpdate = true;
    }
    var n = this.size;
    var i, j;
    var x, y, z, x1, y1, z1, x2, y2, z2;
    for (var v = 0; v < n; v++) {
      j = v * 3;
      i = v * 4 * 3;
      if (position1 && position2) {
        x1 = position1[j];
        y1 = position1[j + 1];
        z1 = position1[j + 2];
        x2 = position2[j];
        y2 = position2[j + 1];
        z2 = position2[j + 2];
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2;
        z = (z1 + z2) / 2;
        aPosition[i] = x1;
        aPosition[i + 1] = y1;
        aPosition[i + 2] = z1;
        aPosition[i + 3] = x;
        aPosition[i + 4] = y;
        aPosition[i + 5] = z;
        aPosition[i + 6] = x;
        aPosition[i + 7] = y;
        aPosition[i + 8] = z;
        aPosition[i + 9] = x2;
        aPosition[i + 10] = y2;
        aPosition[i + 11] = z2;
      }
      if (color && color2) {
        aColor[i] = aColor[i + 3] = color[j];
        aColor[i + 1] = aColor[i + 4] = color[j + 1];
        aColor[i + 2] = aColor[i + 5] = color[j + 2];
        aColor[i + 6] = aColor[i + 9] = color2[j];
        aColor[i + 7] = aColor[i + 10] = color2[j + 1];
        aColor[i + 8] = aColor[i + 11] = color2[j + 2];
      }
    }
  };
  prototypeAccessors2.isLine.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Line.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Line.frag";
  };
  Object.defineProperties(LineBuffer2.prototype, prototypeAccessors2);
  return LineBuffer2;
}(Buffer);
var TrajectoryRepresentation = function(StructureRepresentation$$1) {
  function TrajectoryRepresentation2(trajectory, viewer, params) {
    StructureRepresentation$$1.call(this, trajectory.structure, viewer, params);
    this.type = "trajectory";
    this.parameters = Object.assign({
      drawLine: {
        type: "boolean",
        rebuild: true
      },
      drawCylinder: {
        type: "boolean",
        rebuild: true
      },
      drawPoint: {
        type: "boolean",
        rebuild: true
      },
      drawSphere: {
        type: "boolean",
        rebuild: true
      },
      linewidth: {
        type: "integer",
        max: 20,
        min: 1,
        rebuild: true
      },
      pointSize: {
        type: "integer",
        max: 20,
        min: 1,
        rebuild: true
      },
      sizeAttenuation: {
        type: "boolean",
        rebuild: true
      },
      sort: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters);
    this.manualAttach = true;
    this.trajectory = trajectory;
    this.init(params);
  }
  if (StructureRepresentation$$1)
    TrajectoryRepresentation2.__proto__ = StructureRepresentation$$1;
  TrajectoryRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  TrajectoryRepresentation2.prototype.constructor = TrajectoryRepresentation2;
  TrajectoryRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "uniform");
    p.colorValue = defaults(p.colorValue, 14540253);
    this.drawLine = defaults(p.drawLine, true);
    this.drawCylinder = defaults(p.drawCylinder, false);
    this.drawPoint = defaults(p.drawPoint, false);
    this.drawSphere = defaults(p.drawSphere, false);
    this.pointSize = defaults(p.pointSize, 1);
    this.sizeAttenuation = defaults(p.sizeAttenuation, false);
    this.sort = defaults(p.sort, true);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  TrajectoryRepresentation2.prototype.attach = function attach2(callback) {
    var this$1 = this;
    this.bufferList.forEach(function(buffer) {
      this$1.viewer.add(buffer);
    });
    this.setVisibility(this.visible);
    callback();
  };
  TrajectoryRepresentation2.prototype.prepare = function prepare(callback) {
    callback();
  };
  TrajectoryRepresentation2.prototype.create = function create2() {
    if (this.atomSet.atomCount === 0) {
      return;
    }
    var scope = this;
    var index = this.atomSet.atoms[0].index;
    this.trajectory.getPath(index, function(path) {
      var n = path.length / 3;
      var tc = new Color(scope.colorValue);
      if (scope.drawSphere) {
        var sphereBuffer = new SphereBuffer({
          position: path,
          color: uniformArray3(n, tc.r, tc.g, tc.b),
          radius: uniformArray(n, 0.2)
        }, scope.getBufferParams({
          sphereDetail: scope.sphereDetail,
          dullInterior: true,
          disableImpostor: scope.disableImpostor
        }));
        scope.bufferList.push(sphereBuffer);
      }
      if (scope.drawCylinder) {
        var cylinderBuffer = new CylinderBuffer({
          position1: path.subarray(0, -3),
          position2: path.subarray(3),
          color: uniformArray3(n - 1, tc.r, tc.g, tc.b),
          color2: uniformArray3(n - 1, tc.r, tc.g, tc.b),
          radius: uniformArray(n, 0.05)
        }, scope.getBufferParams({
          openEnded: false,
          radialSegments: scope.radialSegments,
          disableImpostor: scope.disableImpostor,
          dullInterior: true
        }));
        scope.bufferList.push(cylinderBuffer);
      }
      if (scope.drawPoint) {
        var pointBuffer = new PointBuffer({
          position: path,
          color: uniformArray3(n, tc.r, tc.g, tc.b)
        }, scope.getBufferParams({
          pointSize: scope.pointSize,
          sizeAttenuation: scope.sizeAttenuation,
          sort: scope.sort
        }));
        scope.bufferList.push(pointBuffer);
      }
      if (scope.drawLine) {
        var lineBuffer = new LineBuffer({
          position1: path.subarray(0, -3),
          position2: path.subarray(3),
          color: uniformArray3(n - 1, tc.r, tc.g, tc.b),
          color2: uniformArray3(n - 1, tc.r, tc.g, tc.b)
        }, scope.getBufferParams());
        scope.bufferList.push(lineBuffer);
      }
      scope.attach();
    });
  };
  return TrajectoryRepresentation2;
}(StructureRepresentation);
function logReprUnknown(type2) {
  Log.error("makeRepresentation: representation type " + type2 + " unknown");
}
function makeRepresentation(type2, object, viewer, params) {
  if (Debug) {
    Log.time("makeRepresentation " + type2);
  }
  var ReprClass;
  if (object instanceof Structure) {
    ReprClass = RepresentationRegistry.get(type2);
    if (!ReprClass) {
      logReprUnknown(type2);
      return;
    }
  } else if (object instanceof Surface) {
    if (type2 === "surface") {
      ReprClass = SurfaceRepresentation;
    } else if (type2 === "dot") {
      ReprClass = DotRepresentation;
    } else {
      logReprUnknown(type2);
      return;
    }
  } else if (object instanceof Volume) {
    if (type2 === "surface") {
      ReprClass = SurfaceRepresentation;
    } else if (type2 === "dot") {
      ReprClass = DotRepresentation;
    } else if (type2 === "slice") {
      ReprClass = SliceRepresentation;
    } else {
      logReprUnknown(type2);
      return;
    }
  } else if (object instanceof Trajectory) {
    ReprClass = TrajectoryRepresentation;
  } else if (object instanceof Shape$1) {
    ReprClass = BufferRepresentation;
    object = object.getBufferList();
  } else if (type2 === "buffer") {
    ReprClass = BufferRepresentation;
  } else {
    Log.error("makeRepresentation: object " + object + " unknown");
    return;
  }
  var repr = new ReprClass(object, viewer, params);
  if (Debug) {
    Log.timeEnd("makeRepresentation " + type2);
  }
  return repr;
}
var nextComponentId = 0;
var _m = new Matrix4();
var _v = new Vector3();
var Component = function Component2(stage, params) {
  Object.defineProperty(this, "id", {value: nextComponentId++});
  var p = params || {};
  this.name = p.name;
  this.uuid = generateUUID();
  this.visible = p.visible !== void 0 ? p.visible : true;
  this.signals = {
    representationAdded: new Signal(),
    representationRemoved: new Signal(),
    visibilityChanged: new Signal(),
    matrixChanged: new Signal(),
    statusChanged: new Signal(),
    nameChanged: new Signal(),
    disposed: new Signal()
  };
  this.stage = stage;
  this.viewer = stage.viewer;
  this.reprList = [];
  this.annotationList = [];
  this.matrix = new Matrix4();
  this.position = new Vector3();
  this.quaternion = new Quaternion();
  this.scale = new Vector3(1, 1, 1);
  this.transform = new Matrix4();
  this.controls = new ComponentControls(this);
};
var prototypeAccessors$10 = {type: {}};
prototypeAccessors$10.type.get = function() {
  return "component";
};
Component.prototype.setPosition = function setPosition(p) {
  if (Array.isArray(p)) {
    this.position.fromArray(p);
  } else {
    this.position.copy(p);
  }
  this.updateMatrix();
  return this;
};
Component.prototype.setRotation = function setRotation(r) {
  if (Array.isArray(r)) {
    if (r.length === 3) {
      var e = new Euler().fromArray(r);
      this.quaternion.setFromEuler(e);
    } else {
      this.quaternion.fromArray(r);
    }
  } else if (r instanceof Euler) {
    this.quaternion.setFromEuler(r);
  } else {
    this.quaternion.copy(r);
  }
  this.updateMatrix();
  return this;
};
Component.prototype.setScale = function setScale(s) {
  this.scale.set(s, s, s);
  this.updateMatrix();
  return this;
};
Component.prototype.setTransform = function setTransform(m2) {
  this.transform.copy(m2);
  this.updateMatrix();
  return this;
};
Component.prototype.updateMatrix = function updateMatrix() {
  var this$1 = this;
  var c = this.getCenterUntransformed(_v);
  this.matrix.makeTranslation(-c.x, -c.y, -c.z);
  _m.makeRotationFromQuaternion(this.quaternion);
  this.matrix.premultiply(_m);
  _m.makeScale(this.scale.x, this.scale.y, this.scale.z);
  this.matrix.premultiply(_m);
  var p = this.position;
  _m.makeTranslation(p.x + c.x, p.y + c.y, p.z + c.z);
  this.matrix.premultiply(_m);
  this.matrix.premultiply(this.transform);
  this.reprList.forEach(function(repr) {
    repr.setParameters({matrix: this$1.matrix});
  });
  this.stage.viewer.updateBoundingBox();
  this.signals.matrixChanged.dispatch(this.matrix);
};
Component.prototype.addAnnotation = function addAnnotation(position, content, params) {
  var annotation = new Annotation(this, position, content, params);
  this.annotationList.push(annotation);
  return annotation;
};
Component.prototype.removeAnnotation = function removeAnnotation(annotation) {
  var idx = this.annotationList.indexOf(annotation);
  if (idx !== -1) {
    this.annotationList.splice(idx, 1);
    annotation.dispose();
  }
};
Component.prototype.removeAllAnnotations = function removeAllAnnotations() {
  this.annotationList.forEach(function(annotation) {
    annotation.dispose();
  });
  this.annotationList.length = 0;
};
Component.prototype.addRepresentation = function addRepresentation(type2, object, params) {
  var p = params || {};
  var sp = this.stage.getParameters();
  p.matrix = this.matrix.clone();
  p.quality = p.quality || sp.quality;
  p.disableImpostor = defaults(p.disableImpostor, !sp.impostor);
  p.useWorker = defaults(p.useWorker, sp.workerDefault);
  p.visible = defaults(p.visible, true);
  var p2 = Object.assign({}, p, {visible: this.visible && p.visible});
  var repr = makeRepresentation(type2, object, this.viewer, p2);
  var reprComp = this.__getRepresentationComponent(repr, p);
  this.reprList.push(reprComp);
  this.signals.representationAdded.dispatch(reprComp);
  return reprComp;
};
Component.prototype.addBufferRepresentation = function addBufferRepresentation(buffer, params) {
  return Component.prototype.addRepresentation.call(this, "buffer", buffer, params);
};
Component.prototype.hasRepresentation = function hasRepresentation(repr) {
  return this.reprList.indexOf(repr) !== -1;
};
Component.prototype.removeRepresentation = function removeRepresentation(repr) {
  var idx = this.reprList.indexOf(repr);
  if (idx !== -1) {
    this.reprList.splice(idx, 1);
    repr.dispose();
    this.signals.representationRemoved.dispatch(repr);
  }
};
Component.prototype.updateRepresentations = function updateRepresentations(what) {
  this.reprList.forEach(function(repr) {
    repr.update(what);
  });
  this.stage.viewer.requestRender();
};
Component.prototype.removeAllRepresentations = function removeAllRepresentations() {
  this.reprList.slice(0).forEach(function(repr) {
    repr.dispose();
  });
};
Component.prototype.dispose = function dispose20() {
  this.removeAllAnnotations();
  this.removeAllRepresentations();
  delete this.annotationList;
  delete this.reprList;
  this.signals.disposed.dispatch();
};
Component.prototype.setVisibility = function setVisibility5(value2) {
  this.visible = value2;
  this.eachRepresentation(function(repr) {
    repr.updateVisibility();
  });
  this.annotationList.forEach(function(annotation) {
    annotation.updateVisibility();
  });
  this.signals.visibilityChanged.dispatch(value2);
  return this;
};
Component.prototype.setStatus = function setStatus(value2) {
  this.status = value2;
  this.signals.statusChanged.dispatch(value2);
  return this;
};
Component.prototype.setName = function setName(value2) {
  this.name = value2;
  this.signals.nameChanged.dispatch(value2);
  return this;
};
Component.prototype.getBox = function getBox2() {
  return (ref = this).getBoxUntransformed.apply(ref, arguments).clone().applyMatrix4(this.matrix);
  var ref;
};
Component.prototype.getCenter = function getCenter2() {
  return (ref = this).getCenterUntransformed.apply(ref, arguments).clone().applyMatrix4(this.matrix);
  var ref;
};
Component.prototype.getZoom = function getZoom() {
  return this.stage.getZoomForBox((ref = this).getBox.apply(ref, arguments));
  var ref;
};
Component.prototype.getBoxUntransformed = function getBoxUntransformed() {
};
Component.prototype.getCenterUntransformed = function getCenterUntransformed() {
  return this.getBoxUntransformed().getCenter();
};
Component.prototype.autoView = function autoView(duration) {
  this.stage.animationControls.zoomMove(this.getCenter(), this.getZoom(), defaults(duration, 0));
};
Component.prototype.eachRepresentation = function eachRepresentation(callback) {
  this.reprList.forEach(callback);
};
Object.defineProperties(Component.prototype, prototypeAccessors$10);
Component.prototype.__getRepresentationComponent = function(repr, p) {
  return new RepresentationComponent(this.stage, repr, p, this);
};
var RepresentationComponent = function(Component$$1) {
  function RepresentationComponent2(stage, repr, params, parent) {
    var p = params || {};
    p.name = defaults(p.name, repr.type);
    Component$$1.call(this, stage, p);
    this.signals = Object.assign(this.signals, {
      parametersChanged: new Signal()
    });
    this.parent = parent;
    this.setRepresentation(repr);
  }
  if (Component$$1)
    RepresentationComponent2.__proto__ = Component$$1;
  RepresentationComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  RepresentationComponent2.prototype.constructor = RepresentationComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "representation";
  };
  RepresentationComponent2.prototype.getType = function getType() {
    return this.repr.type;
  };
  RepresentationComponent2.prototype.setRepresentation = function setRepresentation(repr) {
    this.disposeRepresentation();
    this.repr = repr;
    this.stage.tasks.listen(this.repr.tasks);
    this.updateVisibility();
  };
  RepresentationComponent2.prototype.addRepresentation = function addRepresentation2() {
  };
  RepresentationComponent2.prototype.removeRepresentation = function removeRepresentation2() {
  };
  RepresentationComponent2.prototype.hasRepresentation = function hasRepresentation2() {
  };
  RepresentationComponent2.prototype.disposeRepresentation = function disposeRepresentation() {
    if (this.repr) {
      this.stage.tasks.unlisten(this.repr.tasks);
      this.repr.dispose();
    }
  };
  RepresentationComponent2.prototype.dispose = function dispose24() {
    if (this.parent && this.parent.hasRepresentation(this)) {
      this.parent.removeRepresentation(this);
    } else {
      this.disposeRepresentation();
      this.signals.disposed.dispatch();
    }
  };
  RepresentationComponent2.prototype.setVisibility = function setVisibility7(value2) {
    this.visible = value2;
    this.updateVisibility();
    this.signals.visibilityChanged.dispatch(this.visible);
    return this;
  };
  RepresentationComponent2.prototype.getVisibility = function getVisibility2() {
    if (this.parent) {
      return this.parent.visible && this.visible;
    } else {
      return this.visible;
    }
  };
  RepresentationComponent2.prototype.toggleVisibility = function toggleVisibility() {
    return this.setVisibility(!this.visible);
  };
  RepresentationComponent2.prototype.updateVisibility = function updateVisibility2() {
    this.repr.setVisibility(this.getVisibility());
  };
  RepresentationComponent2.prototype.update = function update2(what) {
    this.repr.update(what);
    return this;
  };
  RepresentationComponent2.prototype.build = function build3(params) {
    this.repr.build(params);
    return this;
  };
  RepresentationComponent2.prototype.setSelection = function setSelection3(string) {
    this.repr.setSelection(string);
    return this;
  };
  RepresentationComponent2.prototype.setParameters = function setParameters8(params) {
    this.repr.setParameters(params);
    this.signals.parametersChanged.dispatch(this.repr.getParameters());
    return this;
  };
  RepresentationComponent2.prototype.getParameters = function getParameters4() {
    return this.repr.getParameters();
  };
  RepresentationComponent2.prototype.setColor = function setColor2(value2) {
    this.repr.setColor(value2);
    return this;
  };
  RepresentationComponent2.prototype.getCenter = function getCenter5() {
  };
  RepresentationComponent2.prototype.getZoom = function getZoom3() {
  };
  RepresentationComponent2.prototype.getBox = function getBox4() {
  };
  Object.defineProperties(RepresentationComponent2.prototype, prototypeAccessors2);
  return RepresentationComponent2;
}(Component);
var Collection = function Collection2(list) {
  var this$1 = this;
  this.list = list || [];
  var n = this.list.length;
  for (var i = 0; i < n; ++i) {
    var elm = this$1.list[i];
    elm.signals.disposed.add(this$1._remove, this$1);
  }
};
Collection.prototype._remove = function _remove(elm) {
  var idx = this.list.indexOf(elm);
  if (idx !== -1) {
    this.list.splice(idx, 1);
  }
};
Collection.prototype._invoke = function _invoke(methodName, methodArgs) {
  var this$1 = this;
  var n = this.list.length;
  for (var i = 0; i < n; ++i) {
    var elm = this$1.list[i];
    var method = elm[methodName];
    if (typeof method === "function") {
      method.apply(elm, methodArgs);
    }
  }
  return this;
};
Collection.prototype.setVisibility = function setVisibility6(value2) {
  return this._invoke("setVisibility", [value2]);
};
Collection.prototype.setSelection = function setSelection2(string) {
  return this._invoke("setSelection", [string]);
};
Collection.prototype.dispose = function dispose21() {
  return this._invoke("dispose");
};
var ComponentCollection = function(Collection$$1) {
  function ComponentCollection2() {
    Collection$$1.apply(this, arguments);
  }
  if (Collection$$1)
    ComponentCollection2.__proto__ = Collection$$1;
  ComponentCollection2.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
  ComponentCollection2.prototype.constructor = ComponentCollection2;
  ComponentCollection2.prototype.addRepresentation = function addRepresentation2(name, params) {
    return this._invoke("addRepresentation", [name, params]);
  };
  ComponentCollection2.prototype.autoView = function autoView3(duration) {
    return this._invoke("autoView", [duration]);
  };
  return ComponentCollection2;
}(Collection);
var RepresentationCollection = function(Collection$$1) {
  function RepresentationCollection2() {
    Collection$$1.apply(this, arguments);
  }
  if (Collection$$1)
    RepresentationCollection2.__proto__ = Collection$$1;
  RepresentationCollection2.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
  RepresentationCollection2.prototype.constructor = RepresentationCollection2;
  RepresentationCollection2.prototype.setParameters = function setParameters8(params) {
    return this._invoke("setParameters", [params]);
  };
  RepresentationCollection2.prototype.setColor = function setColor2(color) {
    return this._invoke("setColor", [color]);
  };
  return RepresentationCollection2;
}(Collection);
function matchName(name, comp) {
  if (name instanceof RegExp) {
    return comp.name.match(name) !== null;
  } else {
    return comp.name === name;
  }
}
var tmpZoomVector = new Vector3();
var Stage = function Stage2(idOrElement, params) {
  this.signals = {
    parametersChanged: new Signal(),
    fullscreenChanged: new Signal(),
    componentAdded: new Signal(),
    componentRemoved: new Signal(),
    clicked: new Signal(),
    hovered: new Signal()
  };
  this.tasks = new Counter();
  this.compList = [];
  this.defaultFileParams = {};
  this.viewer = new Viewer(idOrElement);
  if (!this.viewer.renderer) {
    return;
  }
  this.tooltip = document.createElement("div");
  Object.assign(this.tooltip.style, {
    display: "none",
    position: "fixed",
    zIndex: 2 + (parseInt(this.viewer.container.style.zIndex) || 0),
    pointerEvents: "none",
    backgroundColor: "rgba( 0, 0, 0, 0.6 )",
    color: "lightgrey",
    padding: "8px",
    fontFamily: "sans-serif"
  });
  document.body.appendChild(this.tooltip);
  this.mouseObserver = new MouseObserver(this.viewer.renderer.domElement);
  this.viewerControls = new ViewerControls(this);
  this.trackballControls = new TrackballControls(this);
  this.pickingControls = new PickingControls(this);
  this.animationControls = new AnimationControls(this);
  this.mouseControls = new MouseControls(this);
  this.pickingBehavior = new PickingBehavior(this);
  this.mouseBehavior = new MouseBehavior(this);
  this.animationBehavior = new AnimationBehavior(this);
  this.keyBehavior = new KeyBehavior(this);
  this.spinAnimation = this.animationControls.spin([0, 1, 0], 5e-3);
  this.spinAnimation.pause(true);
  this.rockAnimation = this.animationControls.rock([0, 1, 0], 5e-3);
  this.rockAnimation.pause(true);
  var p = Object.assign({
    impostor: true,
    quality: "medium",
    workerDefault: true,
    sampleLevel: 0,
    backgroundColor: "black",
    rotateSpeed: 2,
    zoomSpeed: 1.2,
    panSpeed: 1,
    clipNear: 0,
    clipFar: 100,
    clipDist: 10,
    fogNear: 50,
    fogFar: 100,
    cameraFov: 40,
    cameraType: "perspective",
    lightColor: 14540253,
    lightIntensity: 1,
    ambientColor: 14540253,
    ambientIntensity: 0.2,
    hoverTimeout: 0,
    tooltip: true,
    mousePreset: "default"
  }, params);
  this.parameters = {
    backgroundColor: {
      type: "color"
    },
    quality: {
      type: "select",
      options: {auto: "auto", low: "low", medium: "medium", high: "high"}
    },
    sampleLevel: {
      type: "range",
      step: 1,
      max: 5,
      min: -1
    },
    impostor: {
      type: "boolean"
    },
    workerDefault: {
      type: "boolean"
    },
    rotateSpeed: {
      type: "number",
      precision: 1,
      max: 10,
      min: 0
    },
    zoomSpeed: {
      type: "number",
      precision: 1,
      max: 10,
      min: 0
    },
    panSpeed: {
      type: "number",
      precision: 1,
      max: 10,
      min: 0
    },
    clipNear: {
      type: "range",
      step: 1,
      max: 100,
      min: 0
    },
    clipFar: {
      type: "range",
      step: 1,
      max: 100,
      min: 0
    },
    clipDist: {
      type: "integer",
      max: 200,
      min: 0
    },
    fogNear: {
      type: "range",
      step: 1,
      max: 100,
      min: 0
    },
    fogFar: {
      type: "range",
      step: 1,
      max: 100,
      min: 0
    },
    cameraType: {
      type: "select",
      options: {perspective: "perspective", orthographic: "orthographic"}
    },
    cameraFov: {
      type: "range",
      step: 1,
      max: 120,
      min: 15
    },
    lightColor: {
      type: "color"
    },
    lightIntensity: {
      type: "number",
      precision: 2,
      max: 10,
      min: 0
    },
    ambientColor: {
      type: "color"
    },
    ambientIntensity: {
      type: "number",
      precision: 2,
      max: 10,
      min: 0
    },
    hoverTimeout: {
      type: "integer",
      max: 1e4,
      min: -1
    },
    tooltip: {
      type: "boolean"
    },
    mousePreset: {
      type: "select",
      options: {default: "default", pymol: "pymol", coot: "coot"}
    }
  };
  this.setParameters(p);
  this.viewer.animate();
};
Stage.prototype.setParameters = function setParameters7(params) {
  var p = Object.assign({}, params);
  var tp = this.parameters;
  var viewer = this.viewer;
  var controls = this.trackballControls;
  for (var name in p) {
    if (p[name] === void 0) {
      continue;
    }
    if (!tp[name]) {
      continue;
    }
    if (tp[name].int) {
      p[name] = parseInt(p[name]);
    }
    if (tp[name].float) {
      p[name] = parseFloat(p[name]);
    }
    tp[name].value = p[name];
  }
  if (p.quality !== void 0) {
    this.setQuality(p.quality);
  }
  if (p.impostor !== void 0) {
    this.setImpostor(p.impostor);
  }
  if (p.rotateSpeed !== void 0) {
    controls.rotateSpeed = p.rotateSpeed;
  }
  if (p.zoomSpeed !== void 0) {
    controls.zoomSpeed = p.zoomSpeed;
  }
  if (p.panSpeed !== void 0) {
    controls.panSpeed = p.panSpeed;
  }
  if (p.mousePreset !== void 0) {
    this.mouseControls.preset(p.mousePreset);
  }
  this.mouseObserver.setParameters({hoverTimeout: p.hoverTimeout});
  viewer.setClip(p.clipNear, p.clipFar, p.clipDist);
  viewer.setFog(void 0, p.fogNear, p.fogFar);
  viewer.setCamera(p.cameraType, p.cameraFov);
  viewer.setSampling(p.sampleLevel);
  viewer.setBackground(p.backgroundColor);
  viewer.setLight(p.lightColor, p.lightIntensity, p.ambientColor, p.ambientIntensity);
  this.signals.parametersChanged.dispatch(this.getParameters());
  return this;
};
Stage.prototype.getParameters = function getParameters3() {
  var this$1 = this;
  var params = {};
  for (var name in this$1.parameters) {
    params[name] = this$1.parameters[name].value;
  }
  return params;
};
Stage.prototype.defaultFileRepresentation = function defaultFileRepresentation(object) {
  if (object.type === "structure") {
    object.setSelection("/0");
    var atomCount, residueCount, instanceCount;
    var structure = object.structure;
    if (structure.biomolDict.BU1) {
      var assembly = structure.biomolDict.BU1;
      atomCount = assembly.getAtomCount(structure);
      residueCount = assembly.getResidueCount(structure);
      instanceCount = assembly.getInstanceCount();
      object.setDefaultAssembly("BU1");
    } else {
      atomCount = structure.getModelProxy(0).atomCount;
      residueCount = structure.getModelProxy(0).residueCount;
      instanceCount = 1;
    }
    var sizeScore = atomCount;
    if (Mobile) {
      sizeScore *= 4;
    }
    var backboneOnly = structure.atomStore.count / structure.residueStore.count < 2;
    if (backboneOnly) {
      sizeScore *= 10;
    }
    var colorScheme = "chainname";
    var colorScale = "RdYlBu";
    var colorReverse = false;
    if (structure.getChainnameCount("polymer and /0") === 1) {
      colorScheme = "residueindex";
      colorScale = "spectral";
      colorReverse = true;
    }
    if (Debug) {
      console.log(sizeScore, atomCount, instanceCount, backboneOnly);
    }
    if (residueCount / instanceCount < 4) {
      object.addRepresentation("ball+stick", {
        colorScheme: "element",
        scale: 2,
        aspectRatio: 1.5,
        bondScale: 0.3,
        bondSpacing: 0.75,
        quality: "auto"
      });
    } else if (instanceCount > 5 && sizeScore > 15e3 || sizeScore > 7e5) {
      var scaleFactor = Math.min(1.5, Math.max(0.1, 2e3 / (sizeScore / instanceCount)));
      if (backboneOnly) {
        scaleFactor = Math.min(scaleFactor, 0.15);
      }
      object.addRepresentation("surface", {
        sele: "polymer",
        surfaceType: "sas",
        probeRadius: 1.4,
        scaleFactor,
        colorScheme,
        colorScale,
        colorReverse,
        useWorker: false
      });
    } else if (sizeScore > 25e4) {
      object.addRepresentation("backbone", {
        lineOnly: true,
        colorScheme,
        colorScale,
        colorReverse
      });
    } else if (sizeScore > 1e5) {
      object.addRepresentation("backbone", {
        quality: "low",
        disableImpostor: true,
        colorScheme,
        colorScale,
        colorReverse,
        scale: 2
      });
    } else if (sizeScore > 8e4) {
      object.addRepresentation("backbone", {
        colorScheme,
        colorScale,
        colorReverse,
        scale: 2
      });
    } else {
      object.addRepresentation("cartoon", {
        colorScheme,
        colorScale,
        colorReverse,
        scale: 0.7,
        aspectRatio: 5,
        quality: "auto"
      });
      if (sizeScore < 5e4) {
        object.addRepresentation("base", {
          colorScheme,
          colorScale,
          colorReverse,
          quality: "auto"
        });
      }
      object.addRepresentation("ball+stick", {
        sele: "ligand",
        colorScheme: "element",
        scale: 2,
        aspectRatio: 1.5,
        bondScale: 0.3,
        bondSpacing: 0.75,
        quality: "auto"
      });
    }
    if (object.structure.frames.length) {
      object.addTrajectory();
    }
  } else if (object.type === "surface" || object.type === "volume") {
    object.addRepresentation("surface");
  }
  this.tasks.onZeroOnce(this.autoView, this);
};
Stage.prototype.loadFile = function loadFile(path, params) {
  var p = Object.assign({}, this.defaultFileParams, params);
  var component = new Component(this, p);
  component.name = getFileInfo(path).name;
  this.addComponent(component);
  var tasks = this.tasks;
  tasks.increment();
  var onLoadFn = function(object) {
    this.removeComponent(component);
    component = this.addComponentFromObject(object, p);
    if (component.type === "script") {
      component.run();
    } else if (p.defaultRepresentation) {
      this.defaultFileRepresentation(component);
    }
    tasks.decrement();
    return component;
  }.bind(this);
  var onErrorFn = function(e) {
    component.setStatus(e);
    tasks.decrement();
    throw e;
  };
  var ext = defaults(p.ext, getFileInfo(path).ext);
  var promise;
  if (ext === "dcd") {
    promise = Promise.reject(new Error("loadFile: ext 'dcd' must be loaded into a structure component"));
  } else {
    promise = autoLoad(path, p);
  }
  return promise.then(onLoadFn, onErrorFn);
};
Stage.prototype.addComponent = function addComponent(component) {
  if (!component) {
    Log.warn("Stage.addComponent: no component given");
    return;
  }
  this.compList.push(component);
  this.signals.componentAdded.dispatch(component);
};
Stage.prototype.addComponentFromObject = function addComponentFromObject(object, params) {
  var CompClass = ComponentRegistry.get(object.type);
  if (CompClass) {
    var component = new CompClass(this, object, params);
    this.addComponent(component);
    return component;
  }
  Log.warn("no component for object type", object.type);
};
Stage.prototype.removeComponent = function removeComponent(component) {
  var idx = this.compList.indexOf(component);
  if (idx !== -1) {
    this.compList.splice(idx, 1);
    component.dispose();
    this.signals.componentRemoved.dispatch(component);
  }
};
Stage.prototype.removeAllComponents = function removeAllComponents(type2) {
  this.compList.slice().forEach(function(o) {
    if (!type2 || o.type === type2) {
      this.removeComponent(o);
    }
  }, this);
};
Stage.prototype.handleResize = function handleResize() {
  this.viewer.handleResize();
};
Stage.prototype.setSize = function setSize(width, height) {
  var container = this.viewer.container;
  if (container !== document.body) {
    if (width !== void 0) {
      container.style.width = width;
    }
    if (height !== void 0) {
      container.style.height = height;
    }
    this.handleResize();
  }
};
Stage.prototype.toggleFullscreen = function toggleFullscreen(element) {
  if (!document.fullscreenEnabled && !document.mozFullScreenEnabled && !document.webkitFullscreenEnabled && !document.msFullscreenEnabled) {
    Log.log("fullscreen mode (currently) not possible");
    return;
  }
  var self2 = this;
  element = element || this.viewer.container;
  this.lastFullscreenElement = element;
  function getFullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
  }
  function resizeElement() {
    if (!getFullscreenElement() && self2.lastFullscreenElement) {
      var element2 = self2.lastFullscreenElement;
      element2.style.width = element2.dataset.normalWidth;
      element2.style.height = element2.dataset.normalHeight;
      document.removeEventListener("fullscreenchange", resizeElement);
      document.removeEventListener("mozfullscreenchange", resizeElement);
      document.removeEventListener("webkitfullscreenchange", resizeElement);
      document.removeEventListener("MSFullscreenChange", resizeElement);
      self2.handleResize();
      self2.signals.fullscreenChanged.dispatch(false);
    }
  }
  if (!getFullscreenElement()) {
    element.dataset.normalWidth = element.style.width;
    element.dataset.normalHeight = element.style.height;
    element.style.width = window.screen.width + "px";
    element.style.height = window.screen.height + "px";
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen();
    }
    document.addEventListener("fullscreenchange", resizeElement);
    document.addEventListener("mozfullscreenchange", resizeElement);
    document.addEventListener("webkitfullscreenchange", resizeElement);
    document.addEventListener("MSFullscreenChange", resizeElement);
    this.handleResize();
    this.signals.fullscreenChanged.dispatch(true);
    setTimeout(function() {
      self2.handleResize();
    }, 100);
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
};
Stage.prototype.setSpin = function setSpin(flag) {
  if (flag) {
    this.spinAnimation.resume(true);
    this.rockAnimation.pause(true);
  } else {
    this.spinAnimation.pause(true);
  }
};
Stage.prototype.setRock = function setRock(flag) {
  if (flag) {
    this.rockAnimation.resume(true);
    this.spinAnimation.pause(true);
  } else {
    this.rockAnimation.pause(true);
  }
};
Stage.prototype.toggleSpin = function toggleSpin() {
  this.setSpin(this.spinAnimation.paused);
};
Stage.prototype.toggleRock = function toggleRock() {
  this.setRock(this.rockAnimation.paused);
};
Stage.prototype.setFocus = function setFocus(value2) {
  var clipNear = clamp(value2 / 2, 0, 49.9);
  var clipFar = 100 - clipNear;
  var diffHalf = (clipFar - clipNear) / 2;
  this.setParameters({
    clipNear,
    clipFar,
    fogNear: pclamp(clipFar - diffHalf),
    fogFar: pclamp(clipFar + diffHalf)
  });
};
Stage.prototype.getZoomForBox = function getZoomForBox(boundingBox) {
  var bbSize = boundingBox.getSize(tmpZoomVector);
  var maxSize = Math.max(bbSize.x, bbSize.y, bbSize.z);
  var minSize = Math.min(bbSize.x, bbSize.y, bbSize.z);
  var distance3 = maxSize + Math.sqrt(minSize);
  var fov = degToRad(this.viewer.perspectiveCamera.fov);
  var width = this.viewer.width;
  var height = this.viewer.height;
  var aspect = width / height;
  var aspectFactor = height < width ? 1 : aspect;
  distance3 = Math.abs(distance3 * 0.5 / aspectFactor / Math.sin(fov / 2));
  distance3 += this.parameters.clipDist.value;
  return -distance3;
};
Stage.prototype.getBox = function getBox3() {
  return this.viewer.boundingBox;
};
Stage.prototype.getZoom = function getZoom2() {
  return this.getZoomForBox(this.getBox());
};
Stage.prototype.getCenter = function getCenter3(optionalTarget) {
  return this.getBox().getCenter(optionalTarget);
};
Stage.prototype.autoView = function autoView2(duration) {
  this.animationControls.zoomMove(this.getCenter(), this.getZoom(), defaults(duration, 0));
};
Stage.prototype.makeImage = function makeImage2(params) {
  var viewer = this.viewer;
  var tasks = this.tasks;
  return new Promise(function(resolve2, reject2) {
    function makeImage3() {
      tasks.increment();
      viewer.makeImage(params).then(function(blob) {
        tasks.decrement();
        resolve2(blob);
      }).catch(function(e) {
        tasks.decrement();
        reject2(e);
      });
    }
    tasks.onZeroOnce(makeImage3);
  });
};
Stage.prototype.setImpostor = function setImpostor(value2) {
  this.parameters.impostor.value = value2;
  var types = [
    "spacefill",
    "ball+stick",
    "licorice",
    "hyperball",
    "backbone",
    "rocket",
    "helixorient",
    "contact",
    "distance",
    "dot"
  ];
  this.eachRepresentation(function(repr) {
    if (repr.type === "script") {
      return;
    }
    if (!types.includes(repr.getType())) {
      return;
    }
    var p = repr.getParameters();
    p.disableImpostor = !value2;
    repr.build(p);
  });
};
Stage.prototype.setQuality = function setQuality(value2) {
  this.parameters.quality.value = value2;
  var types = [
    "tube",
    "cartoon",
    "ribbon",
    "trace",
    "rope"
  ];
  var impostorTypes = [
    "spacefill",
    "ball+stick",
    "licorice",
    "hyperball",
    "backbone",
    "rocket",
    "helixorient",
    "contact",
    "distance",
    "dot"
  ];
  this.eachRepresentation(function(repr) {
    if (repr.type === "script") {
      return;
    }
    var p = repr.getParameters();
    if (!types.includes(repr.getType())) {
      if (!impostorTypes.includes(repr.getType())) {
        return;
      }
      if (!p.disableImpostor) {
        repr.repr.quality = value2;
        return;
      }
    }
    p.quality = value2;
    repr.build(p);
  });
};
Stage.prototype.eachComponent = function eachComponent(callback, type2) {
  this.compList.slice().forEach(function(o, i) {
    if (!type2 || o.type === type2) {
      callback(o, i);
    }
  });
};
Stage.prototype.eachRepresentation = function eachRepresentation2(callback, type2) {
  this.eachComponent(function(comp) {
    comp.reprList.slice().forEach(function(repr) {
      callback(repr, comp);
    });
  }, type2);
};
Stage.prototype.getComponentsByName = function getComponentsByName(name, type2) {
  var compList = [];
  this.eachComponent(function(comp) {
    if (name === void 0 || matchName(name, comp)) {
      compList.push(comp);
    }
  }, type2);
  return new ComponentCollection(compList);
};
Stage.prototype.getComponentsByObject = function getComponentsByObject(object) {
  var compList = [];
  this.eachComponent(function(comp) {
    if (comp[comp.type] === object) {
      compList.push(comp);
    }
  });
  return new ComponentCollection(compList);
};
Stage.prototype.getRepresentationsByName = function getRepresentationsByName(name, type2) {
  var compName, reprName;
  if (typeof name !== "object" || name instanceof RegExp) {
    compName = void 0;
    reprName = name;
  } else {
    compName = name.comp;
    reprName = name.repr;
  }
  var reprList = [];
  this.eachRepresentation(function(repr, comp) {
    if (compName !== void 0 && !matchName(compName, comp)) {
      return;
    }
    if (reprName === void 0 || matchName(reprName, repr)) {
      reprList.push(repr);
    }
  }, type2);
  return new RepresentationCollection(reprList);
};
Stage.prototype.getAnythingByName = function getAnythingByName(name) {
  var compList = this.getComponentsByName(name).list;
  var reprList = this.getRepresentationsByName(name).list;
  return new Collection(compList.concat(reprList));
};
Stage.prototype.dispose = function dispose22() {
  this.tasks.dispose();
};
var aminoacidsX = "ACDEFGHIKLMNPQRSTVWY";
var aminoacids = "ARNDCQEGHILKMFPSTWYVBZ?";
var blosum62x = [
  [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2],
  [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2],
  [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3],
  [-1, -4, 2, 5, -3, -2, 0, -3, 1, -3, -2, 0, -1, 2, 0, 0, -1, -2, -3, -2],
  [-2, -2, -3, -3, 6, -3, -1, 0, -3, 0, 0, -3, -4, -3, -3, -2, -2, -1, 1, 3],
  [0, -3, -1, -2, -3, 6, -2, -4, -2, -4, -3, 0, -2, -2, -2, 0, -2, -3, -2, -3],
  [-2, -3, -1, 0, -1, -2, 8, -3, -1, -3, -2, 1, -2, 0, 0, -1, -2, -3, -2, 2],
  [-1, -1, -3, -3, 0, -4, -3, 4, -3, 2, 1, -3, -3, -3, -3, -2, -1, 3, -3, -1],
  [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2],
  [-1, -1, -4, -3, 0, -4, -3, 2, -2, 4, 2, -3, -3, -2, -2, -2, -1, 1, -2, -1],
  [-1, -1, -3, -2, 0, -3, -2, 1, -1, 2, 5, -2, -2, 0, -1, -1, -1, 1, -1, -1],
  [-2, -3, 1, 0, -3, 0, 1, -3, 0, -3, -2, 6, -2, 0, 0, 1, 0, -3, -4, -2],
  [-1, -3, -1, -1, -4, -2, -2, -3, -1, -3, -2, -2, 7, -1, -2, -1, -1, -2, -4, -3],
  [-1, -3, 0, 2, -3, -2, 0, -3, 1, -2, 0, 0, -1, 5, 1, 0, -1, -2, -2, -1],
  [-1, -3, -2, 0, -3, -2, 0, -3, 2, -2, -1, 0, -2, 1, 5, -1, -1, -3, -3, -2],
  [1, -1, 0, 0, -2, 0, -1, -2, 0, -2, -1, 1, -1, 0, -1, 4, 1, -2, -3, -2],
  [0, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, 0, -1, -1, -1, 1, 5, 0, -2, -2],
  [0, -1, -3, -2, -1, -3, -3, 3, -2, 1, 1, -3, -2, -2, -3, -2, 0, 4, -3, -1],
  [-3, -2, -4, -3, 1, -2, -2, -3, -3, -2, -1, -4, -4, -2, -3, -3, -2, -3, 11, 2],
  [-2, -2, -3, -2, 3, -3, 2, -1, -2, -1, -1, -2, -3, -1, -2, -2, -2, -1, 2, 7]
];
var blosum62 = [
  [4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0, -2, -1, 0],
  [-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3, -1, 0, -1],
  [-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3, 3, 0, -1],
  [-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3, 4, 1, -1],
  [0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2],
  [-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2, 0, 3, -1],
  [-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1],
  [0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3, -1, -2, -1],
  [-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3, 0, 0, -1],
  [-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3, -3, -3, -1],
  [-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1, -4, -3, -1],
  [-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2, 0, 1, -1],
  [-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1, -3, -1, -1],
  [-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1, -3, -3, -1],
  [-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2, -2, -1, -2],
  [1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2, 0, 0, 0],
  [0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0, -1, -1, 0],
  [-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3, -4, -3, -2],
  [-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1, -3, -2, -1],
  [0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4, -3, -2, -1],
  [-2, -1, 3, 4, -3, 0, 1, -1, 0, -3, -4, 0, -3, -3, -2, 0, -1, -4, -3, -3, 4, 1, -1],
  [-1, 0, 0, 1, -3, 3, 4, -2, 0, -3, -3, 1, -1, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1],
  [0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, 0, 0, -2, -1, -1, -1, -1, -1]
];
function prepareMatrix(cellNames, mat) {
  var j;
  var i = 0;
  var matDict = {};
  mat.forEach(function(row) {
    j = 0;
    var rowDict = {};
    row.forEach(function(elm) {
      rowDict[cellNames[j++]] = elm;
    });
    matDict[cellNames[i++]] = rowDict;
  });
  return matDict;
}
var SubstitutionMatrices = function() {
  return {
    blosum62: prepareMatrix(aminoacids, blosum62),
    blosum62x: prepareMatrix(aminoacidsX, blosum62x)
  };
}();
var Alignment = function Alignment2(seq1, seq2, gapPenalty, gapExtensionPenalty, substMatrix) {
  this.seq1 = seq1;
  this.seq2 = seq2;
  this.gapPenalty = gapPenalty || -10;
  this.gapExtensionPenalty = gapExtensionPenalty || -1;
  this.substMatrix = substMatrix || "blosum62";
  if (this.substMatrix) {
    this.substMatrix = SubstitutionMatrices[this.substMatrix];
  }
};
Alignment.prototype.initMatrices = function initMatrices() {
  var this$1 = this;
  this.n = this.seq1.length;
  this.m = this.seq2.length;
  this.score = void 0;
  this.ali = "";
  this.S = [];
  this.V = [];
  this.H = [];
  var i, j;
  for (i = 0; i <= this.n; ++i) {
    this$1.S[i] = [];
    this$1.V[i] = [];
    this$1.H[i] = [];
    for (j = 0; j <= this.m; ++j) {
      this$1.S[i][j] = 0;
      this$1.V[i][j] = 0;
      this$1.H[i][j] = 0;
    }
  }
  for (i = 0; i <= this.n; ++i) {
    this$1.S[i][0] = this$1.gap(0);
    this$1.H[i][0] = -Infinity;
  }
  for (j = 0; j <= this.m; ++j) {
    this$1.S[0][j] = this$1.gap(0);
    this$1.V[0][j] = -Infinity;
  }
  this.S[0][0] = 0;
};
Alignment.prototype.gap = function gap(len) {
  return this.gapPenalty + len * this.gapExtensionPenalty;
};
Alignment.prototype.makeScoreFn = function makeScoreFn() {
  var seq1 = this.seq1;
  var seq2 = this.seq2;
  var substMatrix = this.substMatrix;
  var c1, c2;
  if (substMatrix) {
    return function score(i, j) {
      c1 = seq1[i];
      c2 = seq2[j];
      try {
        return substMatrix[c1][c2];
      } catch (e) {
        return -4;
      }
    };
  } else {
    Log.warn("Alignment: no subst matrix");
    return function scoreNoSubstMat(i, j) {
      c1 = seq1[i];
      c2 = seq2[j];
      return c1 === c2 ? 5 : -3;
    };
  }
};
Alignment.prototype.calc = function calc() {
  if (Debug) {
    Log.time("Alignment.calc");
  }
  this.initMatrices();
  var gap0 = this.gap(0);
  var scoreFn = this.makeScoreFn();
  var gapExtensionPenalty = this.gapExtensionPenalty;
  var V = this.V;
  var H = this.H;
  var S = this.S;
  var n = this.n;
  var m2 = this.m;
  var Vi1, Si1, Vi, Hi, Si;
  var i, j;
  for (i = 1; i <= n; ++i) {
    Si1 = S[i - 1];
    Vi1 = V[i - 1];
    Vi = V[i];
    Hi = H[i];
    Si = S[i];
    for (j = 1; j <= m2; ++j) {
      Vi[j] = Math.max(Si1[j] + gap0, Vi1[j] + gapExtensionPenalty);
      Hi[j] = Math.max(Si[j - 1] + gap0, Hi[j - 1] + gapExtensionPenalty);
      Si[j] = Math.max(Si1[j - 1] + scoreFn(i - 1, j - 1), Vi[j], Hi[j]);
    }
  }
  if (Debug) {
    Log.timeEnd("Alignment.calc");
  }
  if (Debug) {
    Log.log(this.S, this.V, this.H);
  }
};
Alignment.prototype.trace = function trace() {
  var this$1 = this;
  if (Debug) {
    Log.time("Alignment.trace");
  }
  this.ali1 = "";
  this.ali2 = "";
  var scoreFn = this.makeScoreFn();
  var i = this.n;
  var j = this.m;
  var mat;
  if (this.S[i][j] >= this.V[i][j]) {
    mat = "S";
    this.score = this.S[i][j];
  } else if (this.V[i][j] >= this.H[i][j]) {
    mat = "V";
    this.score = this.V[i][j];
  } else {
    mat = "H";
    this.score = this.H[i][j];
  }
  if (Debug) {
    Log.log("Alignment: SCORE", this.score);
  }
  if (Debug) {
    Log.log("Alignment: S, V, H", this.S[i][j], this.V[i][j], this.H[i][j]);
  }
  while (i > 0 && j > 0) {
    if (mat === "S") {
      if (this$1.S[i][j] === this$1.S[i - 1][j - 1] + scoreFn(i - 1, j - 1)) {
        this$1.ali1 = this$1.seq1[i - 1] + this$1.ali1;
        this$1.ali2 = this$1.seq2[j - 1] + this$1.ali2;
        --i;
        --j;
        mat = "S";
      } else if (this$1.S[i][j] === this$1.V[i][j]) {
        mat = "V";
      } else if (this$1.S[i][j] === this$1.H[i][j]) {
        mat = "H";
      } else {
        --i;
        --j;
      }
    } else if (mat === "V") {
      if (this$1.V[i][j] === this$1.V[i - 1][j] + this$1.gapExtensionPenalty) {
        this$1.ali1 = this$1.seq1[i - 1] + this$1.ali1;
        this$1.ali2 = "-" + this$1.ali2;
        --i;
        mat = "V";
      } else if (this$1.V[i][j] === this$1.S[i - 1][j] + this$1.gap(0)) {
        this$1.ali1 = this$1.seq1[i - 1] + this$1.ali1;
        this$1.ali2 = "-" + this$1.ali2;
        --i;
        mat = "S";
      } else {
        --i;
      }
    } else if (mat === "H") {
      if (this$1.H[i][j] === this$1.H[i][j - 1] + this$1.gapExtensionPenalty) {
        this$1.ali1 = "-" + this$1.ali1;
        this$1.ali2 = this$1.seq2[j - 1] + this$1.ali2;
        --j;
        mat = "H";
      } else if (this$1.H[i][j] === this$1.S[i][j - 1] + this$1.gap(0)) {
        this$1.ali1 = "-" + this$1.ali1;
        this$1.ali2 = this$1.seq2[j - 1] + this$1.ali2;
        --j;
        mat = "S";
      } else {
        --j;
      }
    } else {
      Log.error("Alignment: no matrix");
    }
  }
  while (i > 0) {
    this$1.ali1 = this$1.seq1[i - 1] + this$1.ali1;
    this$1.ali2 = "-" + this$1.ali2;
    --i;
  }
  while (j > 0) {
    this$1.ali1 = "-" + this$1.ali1;
    this$1.ali2 = this$1.seq2[j - 1] + this$1.ali2;
    --j;
  }
  if (Debug) {
    Log.timeEnd("Alignment.trace");
  }
  if (Debug) {
    Log.log([this.ali1, this.ali2]);
  }
};
function superpose(s1, s2, align2, sele1, sele2) {
  align2 = defaults(align2, false);
  sele1 = defaults(sele1, "");
  sele2 = defaults(sele2, "");
  var i, j, n, atoms1, atoms2;
  if (align2) {
    var _s1 = s1;
    var _s2 = s2;
    if (sele1 && sele2) {
      _s1 = s1.getView(new Selection(sele1));
      _s2 = s2.getView(new Selection(sele2));
    }
    var seq1 = _s1.getSequence();
    var seq2 = _s2.getSequence();
    var ali = new Alignment(seq1.join(""), seq2.join(""));
    ali.calc();
    ali.trace();
    var l, _i, _j, x, y;
    i = 0;
    j = 0;
    n = ali.ali1.length;
    var aliIdx1 = [];
    var aliIdx2 = [];
    for (l = 0; l < n; ++l) {
      x = ali.ali1[l];
      y = ali.ali2[l];
      _i = 0;
      _j = 0;
      if (x === "-") {
        aliIdx2[j] = false;
      } else {
        aliIdx2[j] = true;
        _i = 1;
      }
      if (y === "-") {
        aliIdx1[i] = false;
      } else {
        aliIdx1[i] = true;
        _j = 1;
      }
      i += _i;
      j += _j;
    }
    var _atoms1 = [];
    var _atoms2 = [];
    var ap1 = _s1.getAtomProxy();
    var ap2 = _s2.getAtomProxy();
    i = 0;
    _s1.eachResidue(function(r) {
      if (r.traceAtomIndex === void 0 || r.traceAtomIndex !== r.getAtomIndexByName("CA")) {
        return;
      }
      if (aliIdx1[i]) {
        ap1.index = r.getAtomIndexByName("CA");
        _atoms1.push(ap1.x, ap1.y, ap1.z);
      }
      i += 1;
    });
    i = 0;
    _s2.eachResidue(function(r) {
      if (r.traceAtomIndex === void 0 || r.traceAtomIndex !== r.getAtomIndexByName("CA")) {
        return;
      }
      if (aliIdx2[i]) {
        ap2.index = r.getAtomIndexByName("CA");
        _atoms2.push(ap2.x, ap2.y, ap2.z);
      }
      i += 1;
    });
    atoms1 = new Float32Array(_atoms1);
    atoms2 = new Float32Array(_atoms2);
  } else {
    var sviewCa1 = s1.getView(new Selection(sele1 + " and .CA"));
    var sviewCa2 = s2.getView(new Selection(sele2 + " and .CA"));
    atoms1 = sviewCa1;
    atoms2 = sviewCa2;
  }
  var superpose2 = new Superposition(atoms1, atoms2);
  superpose2.transform(s1);
  s1.refreshPosition();
}
var AtomindexColormaker = function(Colormaker$$1) {
  function AtomindexColormaker2(params) {
    var this$1 = this;
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "rainbow";
      this.reverse = defaults(params.reverse, true);
    }
    this.scalePerModel = {};
    this.structure.eachModel(function(mp) {
      this$1.domain = [mp.atomOffset, mp.atomEnd];
      this$1.scalePerModel[mp.index] = this$1.getScale();
    });
  }
  if (Colormaker$$1)
    AtomindexColormaker2.__proto__ = Colormaker$$1;
  AtomindexColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  AtomindexColormaker2.prototype.constructor = AtomindexColormaker2;
  AtomindexColormaker2.prototype.atomColor = function atomColor(atom) {
    return this.scalePerModel[atom.modelIndex](atom.index);
  };
  return AtomindexColormaker2;
}(Colormaker);
ColormakerRegistry2.add("atomindex", AtomindexColormaker);
var BfactorColormaker = function(Colormaker$$1) {
  function BfactorColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "OrRd";
    }
    if (!params.domain) {
      var selection;
      var min = Infinity;
      var max2 = -Infinity;
      if (params.sele) {
        selection = new Selection(params.sele);
      }
      this.structure.eachAtom(function(a) {
        var bfactor = a.bfactor;
        min = Math.min(min, bfactor);
        max2 = Math.max(max2, bfactor);
      }, selection);
      this.domain = [min, max2];
    }
    this.bfactorScale = this.getScale();
  }
  if (Colormaker$$1)
    BfactorColormaker2.__proto__ = Colormaker$$1;
  BfactorColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  BfactorColormaker2.prototype.constructor = BfactorColormaker2;
  BfactorColormaker2.prototype.atomColor = function atomColor(a) {
    return this.bfactorScale(a.bfactor);
  };
  return BfactorColormaker2;
}(Colormaker);
ColormakerRegistry2.add("bfactor", BfactorColormaker);
var ChainidColormaker = function(Colormaker$$1) {
  function ChainidColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "Spectral";
    }
    var chainidDictPerModel = {};
    var scalePerModel = {};
    this.structure.eachModel(function(mp) {
      var i = 0;
      var chainidDict = {};
      mp.eachChain(function(cp) {
        if (chainidDict[cp.chainid] === void 0) {
          chainidDict[cp.chainid] = i;
          i += 1;
        }
      });
      this.domain = [0, i - 1];
      chainidDictPerModel[mp.index] = chainidDict;
      scalePerModel[mp.index] = this.getScale();
    }.bind(this));
    this.atomColor = function(a) {
      var chainidDict = chainidDictPerModel[a.modelIndex];
      return scalePerModel[a.modelIndex](chainidDict[a.chainid]);
    };
  }
  if (Colormaker$$1)
    ChainidColormaker2.__proto__ = Colormaker$$1;
  ChainidColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ChainidColormaker2.prototype.constructor = ChainidColormaker2;
  return ChainidColormaker2;
}(Colormaker);
ColormakerRegistry2.add("chainid", ChainidColormaker);
var ChainindexColormaker = function(Colormaker$$1) {
  function ChainindexColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "Spectral";
    }
    if (!params.domain) {
      var scalePerModel = {};
      this.structure.eachModel(function(mp) {
        this.domain = [mp.chainOffset, mp.chainEnd];
        scalePerModel[mp.index] = this.getScale();
      }.bind(this));
      this.atomColor = function(a) {
        return scalePerModel[a.modelIndex](a.chainIndex);
      };
    } else {
      var chainindexScale = this.getScale();
      this.atomColor = function(a) {
        return chainindexScale(a.chainIndex);
      };
    }
  }
  if (Colormaker$$1)
    ChainindexColormaker2.__proto__ = Colormaker$$1;
  ChainindexColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ChainindexColormaker2.prototype.constructor = ChainindexColormaker2;
  return ChainindexColormaker2;
}(Colormaker);
ColormakerRegistry2.add("chainindex", ChainindexColormaker);
var ChainnameColormaker = function(Colormaker$$1) {
  function ChainnameColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "Spectral";
    }
    var chainnameDictPerModel = {};
    var scalePerModel = {};
    this.structure.eachModel(function(mp) {
      var i = 0;
      var chainnameDict = {};
      mp.eachChain(function(cp) {
        if (chainnameDict[cp.chainname] === void 0) {
          chainnameDict[cp.chainname] = i;
          i += 1;
        }
      });
      this.domain = [0, i - 1];
      chainnameDictPerModel[mp.index] = chainnameDict;
      scalePerModel[mp.index] = this.getScale();
    }.bind(this));
    this.atomColor = function(a) {
      var chainnameDict = chainnameDictPerModel[a.modelIndex];
      return scalePerModel[a.modelIndex](chainnameDict[a.chainname]);
    };
  }
  if (Colormaker$$1)
    ChainnameColormaker2.__proto__ = Colormaker$$1;
  ChainnameColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ChainnameColormaker2.prototype.constructor = ChainnameColormaker2;
  return ChainnameColormaker2;
}(Colormaker);
ColormakerRegistry2.add("chainname", ChainnameColormaker);
var DensityfitColormaker = function(Colormaker$$1) {
  function DensityfitColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "RdYlBu";
    }
    this.rsrzScale = this.getScale({domain: [2, 0]});
    this.rsccScale = this.getScale({domain: [0.678, 1]});
    var val = params.structure.validation || {};
    this.rsrzDict = val.rsrzDict || {};
    this.rsccDict = val.rsccDict || {};
  }
  if (Colormaker$$1)
    DensityfitColormaker2.__proto__ = Colormaker$$1;
  DensityfitColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  DensityfitColormaker2.prototype.constructor = DensityfitColormaker2;
  DensityfitColormaker2.prototype.atomColor = function atomColor(atom) {
    var sele = atom.resno;
    if (atom.inscode) {
      sele += "^" + atom.inscode;
    }
    if (atom.chainname) {
      sele += ":" + atom.chainname;
    }
    sele += "/" + atom.modelIndex;
    var rsrz = this.rsrzDict[sele];
    if (rsrz !== void 0) {
      return this.rsrzScale(rsrz);
    }
    var rscc = this.rsccDict[sele];
    if (rscc !== void 0) {
      return this.rsccScale(rscc);
    }
    return 9474192;
  };
  return DensityfitColormaker2;
}(Colormaker);
ColormakerRegistry2.add("densityfit", DensityfitColormaker);
var partialCharges = {
  ARG: {
    CD: 0.1,
    CZ: 0.5,
    NE: -0.1
  },
  ASN: {
    CG: 0.55,
    OD1: -0.55
  },
  ASP: {
    CB: -0.16,
    CG: 0.36,
    OD1: -0.6,
    OD2: -0.6
  },
  CYS: {
    CB: 0.19,
    SG: -0.19
  },
  GLN: {
    CD: 0.55,
    OE1: -0.55
  },
  GLU: {
    CD: 0.36,
    CG: -0.16,
    OE1: -0.6,
    OE2: -0.6
  },
  HIS: {
    CB: 0.1,
    CD2: 0.2,
    CE1: 0.45,
    CG: 0.15,
    ND1: 0.05,
    NE2: 0.05
  },
  LYS: {
    CE: 0.25,
    NZ: 0.75
  },
  MET: {
    CE: 0.06,
    CG: 0.06,
    SD: -0.12
  },
  PTR: {
    C: 0.55,
    CA: 0.1,
    CZ: 0.25,
    N: -0.35,
    O: -0.55,
    O1P: -0.85,
    O2P: -0.85,
    O3P: -0.85,
    OG1: -1.1,
    P: 1.4
  },
  SEP: {
    C: 0.55,
    CA: 0.1,
    CB: 0.25,
    N: -0.35,
    O: -0.55,
    O1P: -0.85,
    O2P: -0.85,
    O3P: -0.85,
    OG1: -1.1,
    P: 1.4
  },
  SER: {
    CB: 0.25,
    OG: -0.25
  },
  THR: {
    CB: 0.25,
    OG1: -0.25
  },
  TPO: {
    C: 0.55,
    CA: 0.1,
    CB: 0.25,
    N: -0.35,
    O: -0.55,
    OG1: -1.1,
    O1P: -0.85,
    O2P: -0.85,
    O3P: -0.85,
    P: 1.4
  },
  TRP: {
    CD1: 0.06,
    CD2: 0.1,
    CE2: -0.04,
    CE3: -0.03,
    CG: -0.03,
    NE1: -0.06
  },
  TYR: {
    CZ: 0.25,
    OH: -0.25
  },
  backbone: {
    C: 0.55,
    O: -0.55,
    N: -0.35,
    CA: 0.1
  }
};
var maxRadius = 12;
var nHBondDistance = 1.04;
var nHCharge = 0.25;
function backboneNHPosition(ap, position) {
  position = position || new Vector3();
  var h = false;
  var ca = false;
  var c = false;
  position.set(2 * ap.x, 2 * ap.y, 2 * ap.z);
  ap.eachBondedAtom(function(a2) {
    if (h) {
      return;
    }
    if (a2.atomname === "H") {
      position.set(a2);
      h = true;
      return;
    }
    if (!ca && a2.atomname === "CA") {
      position.sub(a2);
      ca = true;
    } else if (!c && a2.atomname === "C") {
      c = true;
      position.sub(a2);
    }
  });
  if (h) {
    return position;
  }
  if (ca && c) {
    position.normalize();
    position.multiplyScalar(nHBondDistance);
    position.add(ap);
    return position;
  }
}
function buildStoreLike(positions) {
  var n = positions.length;
  var x = new Float32Array(n);
  var y = new Float32Array(n);
  var z = new Float32Array(n);
  for (var i = 0; i < positions.length; i++) {
    var v = positions[i];
    x[i] = v.x;
    y[i] = v.y;
    z[i] = v.z;
  }
  return {x, y, z, count: n};
}
var ElectrostaticColormaker = function(Colormaker$$1) {
  function ElectrostaticColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "rwb";
    }
    if (!params.domain) {
      this.domain = [-0.5, 0, 0.5];
    }
    var scale2 = this.getScale();
    function chargeForAtom(a) {
      if (!a.isProtein()) {
        return 0;
      }
      return partialCharges[a.resname] && partialCharges[a.resname][a.atomname] || partialCharges["backbone"][a.atomname] || 0;
    }
    var structure = this.structure;
    var charges = new Float32Array(structure.atomCount);
    var hPositions = [];
    var hCharges = [];
    structure.eachAtom(function(ap2) {
      charges[ap2.index] = chargeForAtom(ap2) * ap2.occupancy;
      if (ap2.atomname === "N") {
        var hPos = backboneNHPosition(ap2);
        if (hPos !== void 0) {
          hPositions.push(hPos);
          hCharges.push(nHCharge * ap2.occupancy);
        }
      }
    });
    var bbox = this.structure.getBoundingBox();
    bbox.expandByScalar(nHBondDistance);
    var hStore = buildStoreLike(hPositions);
    var hHash = new SpatialHash(hStore, bbox);
    var hash = new SpatialHash(this.structure.atomStore, bbox);
    var ap = this.atomProxy;
    var delta = new Vector3();
    var maxRadius2 = maxRadius * maxRadius;
    this.positionColor = function(v) {
      var p = 0;
      var neighbours = hash.within(v.x, v.y, v.z, maxRadius);
      for (var i = 0; i < neighbours.length; i++) {
        var neighbour = neighbours[i];
        var charge = charges[neighbour];
        if (charge !== 0) {
          ap.index = neighbour;
          delta.x = v.x - ap.x;
          delta.y = v.y - ap.y;
          delta.z = v.z - ap.z;
          var r2 = delta.lengthSq();
          if (r2 < maxRadius2) {
            p += charge / r2;
          }
        }
      }
      var hNeighbours = hHash.within(v.x, v.y, v.z, maxRadius);
      for (var i$1 = 0; i$1 < hNeighbours.length; i$1++) {
        var neighbour$1 = hNeighbours[i$1];
        delta.x = v.x - hStore.x[neighbour$1];
        delta.y = v.y - hStore.y[neighbour$1];
        delta.z = v.z - hStore.z[neighbour$1];
        var r2$1 = delta.lengthSq();
        if (r2$1 < maxRadius2) {
          p += hCharges[neighbour$1] / r2$1;
        }
      }
      return scale2(p);
    };
  }
  if (Colormaker$$1)
    ElectrostaticColormaker2.__proto__ = Colormaker$$1;
  ElectrostaticColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ElectrostaticColormaker2.prototype.constructor = ElectrostaticColormaker2;
  return ElectrostaticColormaker2;
}(Colormaker);
ColormakerRegistry2.add("electrostatic", ElectrostaticColormaker);
var ElementColors = {
  H: 16777215,
  HE: 14286847,
  LI: 13402367,
  BE: 12779264,
  B: 16758197,
  C: 9474192,
  N: 3166456,
  O: 16715021,
  F: 9494608,
  NE: 11789301,
  NA: 11230450,
  MG: 9109248,
  AL: 12560038,
  SI: 1578e4,
  P: 16744448,
  S: 16777008,
  CL: 2093087,
  AR: 8442339,
  K: 9388244,
  CA: 4062976,
  SC: 15132390,
  TI: 12567239,
  V: 10921643,
  CR: 9083335,
  MN: 10255047,
  FE: 14706227,
  CO: 15765664,
  NI: 5296208,
  CU: 13140019,
  ZN: 8224944,
  GA: 12750735,
  GE: 6721423,
  AS: 12419299,
  SE: 16752896,
  BR: 10889513,
  KR: 6076625,
  RB: 7351984,
  SR: 65280,
  Y: 9764863,
  ZR: 9756896,
  NB: 7586505,
  MO: 5551541,
  TC: 3907230,
  RU: 2396047,
  RH: 687500,
  PD: 27013,
  AG: 12632256,
  CD: 16767375,
  IN: 10909043,
  SN: 6717568,
  SB: 10380213,
  TE: 13924864,
  I: 9699476,
  XE: 9699476,
  CS: 5707663,
  BA: 51456,
  LA: 7394559,
  CE: 16777159,
  PR: 14286791,
  ND: 13107143,
  PM: 10747847,
  SM: 9437127,
  EU: 6422471,
  GD: 4587463,
  TB: 3211207,
  DY: 2097095,
  HO: 65436,
  ER: 58997,
  TM: 54354,
  YB: 48952,
  LU: 43812,
  HF: 5096191,
  TA: 5089023,
  W: 2200790,
  RE: 2522539,
  OS: 2516630,
  IR: 1528967,
  PT: 13684960,
  AU: 16765219,
  HG: 12105936,
  TL: 10900557,
  PB: 5724513,
  BI: 10375093,
  PO: 11230208,
  AT: 7688005,
  RN: 4358806,
  FR: 4325478,
  RA: 32e3,
  AC: 7384058,
  TH: 47871,
  PA: 41471,
  U: 36863,
  NP: 33023,
  PU: 27647,
  AM: 5528818,
  CM: 7888099,
  BK: 9064419,
  CF: 10565332,
  ES: 11739092,
  FM: 11739066,
  MD: 11734438,
  NO: 12389767,
  LR: 13041766,
  RF: 13369433,
  DB: 13697103,
  SG: 14221381,
  BH: 14680120,
  HS: 15073326,
  MT: 15400998,
  DS: 16777215,
  RG: 16777215,
  CN: 16777215,
  UUT: 16777215,
  FL: 16777215,
  UUP: 16777215,
  LV: 16777215,
  UUH: 16777215,
  D: 16777152,
  T: 16777120
};
var DefaultElementColor = 16777215;
var ElementColormaker = function(Colormaker$$1) {
  function ElementColormaker2(params) {
    var p = params || {};
    p.value = defaults(p.value, ElementColors.C);
    Colormaker$$1.call(this, p);
  }
  if (Colormaker$$1)
    ElementColormaker2.__proto__ = Colormaker$$1;
  ElementColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ElementColormaker2.prototype.constructor = ElementColormaker2;
  ElementColormaker2.prototype.atomColor = function atomColor(a) {
    var element = a.element;
    if (element === "C") {
      return this.value;
    } else {
      return ElementColors[element] || DefaultElementColor;
    }
  };
  return ElementColormaker2;
}(Colormaker);
ColormakerRegistry2.add("element", ElementColormaker);
var EntityindexColormaker = function(Colormaker$$1) {
  function EntityindexColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "Spectral";
    }
    if (!params.domain) {
      this.domain = [0, this.structure.entityList.length - 1];
    }
    var entityindexScale = this.getScale();
    this.atomColor = function(a) {
      return entityindexScale(a.entityIndex);
    };
  }
  if (Colormaker$$1)
    EntityindexColormaker2.__proto__ = Colormaker$$1;
  EntityindexColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  EntityindexColormaker2.prototype.constructor = EntityindexColormaker2;
  return EntityindexColormaker2;
}(Colormaker);
ColormakerRegistry2.add("entityindex", EntityindexColormaker);
var EntitytypeColormaker = function(Colormaker$$1) {
  function EntitytypeColormaker2() {
    Colormaker$$1.apply(this, arguments);
  }
  if (Colormaker$$1)
    EntitytypeColormaker2.__proto__ = Colormaker$$1;
  EntitytypeColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  EntitytypeColormaker2.prototype.constructor = EntitytypeColormaker2;
  EntitytypeColormaker2.prototype.atomColor = function atomColor(a) {
    var e = a.entity;
    var et = e ? e.entityType : void 0;
    switch (et) {
      case PolymerEntity:
        return 8374655;
      case NonPolymerEntity:
        return 16629894;
      case MacrolideEntity:
        return 12496596;
      case WaterEntity:
        return 3697840;
      default:
        return 16777113;
    }
  };
  return EntitytypeColormaker2;
}(Colormaker);
ColormakerRegistry2.add("entitytype", EntitytypeColormaker);
var GeoqualityColormaker = function(Colormaker$$1) {
  function GeoqualityColormaker2(params) {
    Colormaker$$1.call(this, params);
    var val = params.structure.validation || {};
    this.geoAtomDict = val.geoAtomDict || {};
    this.geoDict = val.geoDict || {};
  }
  if (Colormaker$$1)
    GeoqualityColormaker2.__proto__ = Colormaker$$1;
  GeoqualityColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  GeoqualityColormaker2.prototype.constructor = GeoqualityColormaker2;
  GeoqualityColormaker2.prototype.atomColor = function atomColor(atom) {
    var sele = atom.resno;
    if (atom.inscode) {
      sele += "^" + atom.inscode;
    }
    if (atom.chainname) {
      sele += ":" + atom.chainname;
    }
    sele += "/" + atom.modelIndex;
    var geoProblemCount;
    var geoAtom = this.geoAtomDict[sele];
    if (geoAtom !== void 0) {
      var atomProblems = geoAtom[atom.atomname] || 0;
      geoProblemCount = countSetBits(atomProblems);
    } else {
      geoProblemCount = this.geoDict[sele] || 0;
    }
    if (geoProblemCount === 0) {
      return 2188972;
    } else if (geoProblemCount === 1) {
      return 16703627;
    } else if (geoProblemCount === 2) {
      return 16018755;
    } else if (geoProblemCount >= 3) {
      return 10813478;
    }
    return 9474192;
  };
  return GeoqualityColormaker2;
}(Colormaker);
ColormakerRegistry2.add("geoquality", GeoqualityColormaker);
var HydrophobicityColormaker = function(Colormaker$$1) {
  function HydrophobicityColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "RdYlGn";
    }
    var name;
    var idx = 0;
    var resHF = {};
    for (name in ResidueHydrophobicity) {
      resHF[name] = ResidueHydrophobicity[name][idx];
    }
    if (!params.domain) {
      var val;
      var min = Infinity;
      var max2 = -Infinity;
      for (name in resHF) {
        val = resHF[name];
        min = Math.min(min, val);
        max2 = Math.max(max2, val);
      }
      this.domain = [min, 0, max2];
    }
    var hfScale = this.getScale();
    this.atomColor = function(a) {
      return hfScale(resHF[a.resname] || DefaultResidueHydrophobicity);
    };
  }
  if (Colormaker$$1)
    HydrophobicityColormaker2.__proto__ = Colormaker$$1;
  HydrophobicityColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  HydrophobicityColormaker2.prototype.constructor = HydrophobicityColormaker2;
  return HydrophobicityColormaker2;
}(Colormaker);
ColormakerRegistry2.add("hydrophobicity", HydrophobicityColormaker);
var ModelindexColormaker = function(Colormaker$$1) {
  function ModelindexColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "rainbow";
    }
    if (!params.domain) {
      this.domain = [0, this.structure.modelStore.count];
    }
    var modelindexScale = this.getScale();
    this.atomColor = function(a) {
      return modelindexScale(a.modelIndex);
    };
  }
  if (Colormaker$$1)
    ModelindexColormaker2.__proto__ = Colormaker$$1;
  ModelindexColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ModelindexColormaker2.prototype.constructor = ModelindexColormaker2;
  return ModelindexColormaker2;
}(Colormaker);
ColormakerRegistry2.add("modelindex", ModelindexColormaker);
var MoleculetypeColormaker = function(Colormaker$$1) {
  function MoleculetypeColormaker2() {
    Colormaker$$1.apply(this, arguments);
  }
  if (Colormaker$$1)
    MoleculetypeColormaker2.__proto__ = Colormaker$$1;
  MoleculetypeColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  MoleculetypeColormaker2.prototype.constructor = MoleculetypeColormaker2;
  MoleculetypeColormaker2.prototype.atomColor = function atomColor(a) {
    switch (a.residueType.moleculeType) {
      case WaterType:
        return 3697840;
      case IonType:
        return 15729279;
      case ProteinType:
        return 12496596;
      case RnaType:
        return 16629894;
      case DnaType:
        return 12540695;
      case SaccharideType:
        return 8374655;
      default:
        return 16777113;
    }
  };
  return MoleculetypeColormaker2;
}(Colormaker);
ColormakerRegistry2.add("moleculetype", MoleculetypeColormaker);
var OccupancyColormaker = function(Colormaker$$1) {
  function OccupancyColormaker2(params) {
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "PuBu";
    }
    if (!params.domain) {
      this.domain = [0, 1];
    }
    var occupancyScale = this.getScale();
    this.atomColor = function(a) {
      return occupancyScale(a.occupancy);
    };
  }
  if (Colormaker$$1)
    OccupancyColormaker2.__proto__ = Colormaker$$1;
  OccupancyColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  OccupancyColormaker2.prototype.constructor = OccupancyColormaker2;
  return OccupancyColormaker2;
}(Colormaker);
ColormakerRegistry2.add("occupancy", OccupancyColormaker);
function randomColor() {
  return Math.random() * 16777215;
}
var RandomColormaker = function(Colormaker$$1) {
  function RandomColormaker2() {
    Colormaker$$1.apply(this, arguments);
  }
  if (Colormaker$$1)
    RandomColormaker2.__proto__ = Colormaker$$1;
  RandomColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  RandomColormaker2.prototype.constructor = RandomColormaker2;
  RandomColormaker2.prototype.atomColor = function atomColor() {
    return randomColor();
  };
  RandomColormaker2.prototype.volumeColor = function volumeColor() {
    return randomColor();
  };
  RandomColormaker2.prototype.positionColor = function positionColor() {
    return randomColor();
  };
  return RandomColormaker2;
}(Colormaker);
ColormakerRegistry2.add("random", RandomColormaker);
var ResidueindexColormaker = function(Colormaker$$1) {
  function ResidueindexColormaker2(params) {
    var this$1 = this;
    Colormaker$$1.call(this, params);
    if (!params.scale) {
      this.scale = "rainbow";
      this.reverse = defaults(params.reverse, true);
    }
    if (!params.domain) {
      var scalePerChain = {};
      this.structure.eachChain(function(cp) {
        this$1.domain = [cp.residueOffset, cp.residueEnd];
        scalePerChain[cp.index] = this$1.getScale();
      });
      this.atomColor = function(a) {
        return scalePerChain[a.chainIndex](a.residueIndex);
      };
    } else {
      var residueindexScale = this.getScale();
      this.atomColor = function(a) {
        return residueindexScale(a.residueIndex);
      };
    }
  }
  if (Colormaker$$1)
    ResidueindexColormaker2.__proto__ = Colormaker$$1;
  ResidueindexColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ResidueindexColormaker2.prototype.constructor = ResidueindexColormaker2;
  return ResidueindexColormaker2;
}(Colormaker);
ColormakerRegistry2.add("residueindex", ResidueindexColormaker);
var ResidueColors = {
  ALA: 9240460,
  ARG: 124,
  ASN: 16743536,
  ASP: 10485826,
  CYS: 16777072,
  GLN: 16731212,
  GLU: 6684672,
  GLY: 16777215,
  HIS: 7368959,
  ILE: 19456,
  LEU: 4546117,
  LYS: 4671416,
  MET: 12099650,
  PHE: 5459026,
  PRO: 5395026,
  SER: 16740418,
  THR: 12078080,
  TRP: 5195264,
  TYR: 9203788,
  VAL: 16747775,
  ASX: 16711935,
  GLX: 16711935,
  ASH: 16711935,
  GLH: 16711935,
  A: 10526975,
  G: 16740464,
  I: 8454143,
  C: 16747595,
  T: 10551200,
  U: 16744576,
  DA: 10526975,
  DG: 16740464,
  DI: 8454143,
  DC: 16747595,
  DT: 10551200,
  DU: 16744576
};
var DefaultResidueColor = 16711935;
var ResnameColormaker = function(Colormaker$$1) {
  function ResnameColormaker2() {
    Colormaker$$1.apply(this, arguments);
  }
  if (Colormaker$$1)
    ResnameColormaker2.__proto__ = Colormaker$$1;
  ResnameColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ResnameColormaker2.prototype.constructor = ResnameColormaker2;
  ResnameColormaker2.prototype.atomColor = function atomColor(a) {
    return ResidueColors[a.resname] || DefaultResidueColor;
  };
  return ResnameColormaker2;
}(Colormaker);
ColormakerRegistry2.add("resname", ResnameColormaker);
var StructureColors = {
  alphaHelix: 16711808,
  threeTenHelix: 10485888,
  piHelix: 6291584,
  betaStrand: 16762880,
  betaTurn: 6324479,
  coil: 16777215,
  dna: 11403518,
  rna: 16580962,
  carbohydrate: 10921722
};
var DefaultStructureColor = 8421504;
var SstrucColormaker = function(Colormaker$$1) {
  function SstrucColormaker2(params) {
    Colormaker$$1.call(this, params);
    this.rp = this.structure.getResidueProxy();
  }
  if (Colormaker$$1)
    SstrucColormaker2.__proto__ = Colormaker$$1;
  SstrucColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  SstrucColormaker2.prototype.constructor = SstrucColormaker2;
  SstrucColormaker2.prototype.atomColor = function atomColor(ap) {
    var sstruc = ap.sstruc;
    var rp = this.rp;
    if (sstruc === "h") {
      return StructureColors.alphaHelix;
    } else if (sstruc === "g") {
      return StructureColors.threeTenHelix;
    } else if (sstruc === "i") {
      return StructureColors.piHelix;
    } else if (sstruc === "e" || sstruc === "b") {
      return StructureColors.betaStrand;
    } else if (sstruc === "t") {
      return StructureColors.betaTurn;
    } else {
      rp.index = ap.residueIndex;
      if (rp.isDna()) {
        return StructureColors.dna;
      } else if (rp.isRna()) {
        return StructureColors.rna;
      } else if (rp.isSaccharide()) {
        return StructureColors.carbohydrate;
      } else if (rp.isProtein() || sstruc === "s" || sstruc === "l") {
        return StructureColors.coil;
      } else {
        return DefaultStructureColor;
      }
    }
  };
  return SstrucColormaker2;
}(Colormaker);
ColormakerRegistry2.add("sstruc", SstrucColormaker);
var UniformColormaker = function(Colormaker$$1) {
  function UniformColormaker2() {
    Colormaker$$1.apply(this, arguments);
  }
  if (Colormaker$$1)
    UniformColormaker2.__proto__ = Colormaker$$1;
  UniformColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  UniformColormaker2.prototype.constructor = UniformColormaker2;
  UniformColormaker2.prototype.atomColor = function atomColor() {
    return this.value;
  };
  UniformColormaker2.prototype.bondColor = function bondColor2() {
    return this.value;
  };
  UniformColormaker2.prototype.valueColor = function valueColor() {
    return this.value;
  };
  UniformColormaker2.prototype.volumeColor = function volumeColor() {
    return this.value;
  };
  return UniformColormaker2;
}(Colormaker);
ColormakerRegistry2.add("uniform", UniformColormaker);
var ValueColormaker = function(Colormaker$$1) {
  function ValueColormaker2(params) {
    Colormaker$$1.call(this, params);
    this.valueScale = this.getScale();
  }
  if (Colormaker$$1)
    ValueColormaker2.__proto__ = Colormaker$$1;
  ValueColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  ValueColormaker2.prototype.constructor = ValueColormaker2;
  ValueColormaker2.prototype.volumeColor = function volumeColor(index) {
    return this.valueScale(this.volume.data[index]);
  };
  return ValueColormaker2;
}(Colormaker);
ColormakerRegistry2.add("value", ValueColormaker);
var VolumeColormaker = function(Colormaker$$1) {
  function VolumeColormaker2(params) {
    Colormaker$$1.call(this, params);
    var volume = this.volume;
    if (volume && volume.inverseMatrix) {
      var valueScale = this.getScale();
      var inverseMatrix = volume.inverseMatrix;
      var data = volume.data;
      var nx = volume.nx;
      var ny = volume.ny;
      var nxy = nx * ny;
      var vec = new Vector3();
      this.positionColor = function(coords) {
        vec.copy(coords);
        vec.applyMatrix4(inverseMatrix);
        var x0 = Math.floor(vec.x);
        var y0 = Math.floor(vec.y);
        var z0 = Math.floor(vec.z);
        var i = (z0 * ny + y0) * nx + x0;
        var i1 = i + 1;
        var iy = i + nx;
        var iz = i + nxy;
        var i1y = iy + 1;
        var i1z = iz + 1;
        var iyz = iy + nxy;
        var i1yz = iyz + 1;
        var v = data[i];
        var v1 = data[i1];
        var vy = data[iy];
        var vz = data[iz];
        var v1y = data[i1y];
        var v1z = data[i1z];
        var vyz = data[iyz];
        var v1yz = data[i1yz];
        var xd = vec.x - x0;
        var yd = vec.y - y0;
        var zd = vec.z - z0;
        var c00 = lerp(v, v1, xd);
        var c01 = lerp(vz, v1z, xd);
        var c10 = lerp(vy, v1y, xd);
        var c11 = lerp(vyz, v1yz, xd);
        var c0 = lerp(c00, c10, yd);
        var c1 = lerp(c01, c11, yd);
        var c = lerp(c0, c1, zd);
        return valueScale(c);
      };
    } else {
      var colorValue = this.value;
      this.positionColor = function() {
        return colorValue;
      };
    }
  }
  if (Colormaker$$1)
    VolumeColormaker2.__proto__ = Colormaker$$1;
  VolumeColormaker2.prototype = Object.create(Colormaker$$1 && Colormaker$$1.prototype);
  VolumeColormaker2.prototype.constructor = VolumeColormaker2;
  VolumeColormaker2.prototype.positionColor = function positionColor() {
  };
  return VolumeColormaker2;
}(Colormaker);
ColormakerRegistry2.add("volume", VolumeColormaker);
var ScriptComponent = function(Component$$1) {
  function ScriptComponent2(stage, script, params) {
    var this$1 = this;
    var p = params || {};
    p.name = defaults(p.name, script.name);
    Component$$1.call(this, stage, p);
    this.script = script;
    this.status = "loaded";
    this.script.signals.nameChanged.add(function(value2) {
      this$1.setName(value2);
    });
  }
  if (Component$$1)
    ScriptComponent2.__proto__ = Component$$1;
  ScriptComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  ScriptComponent2.prototype.constructor = ScriptComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "script";
  };
  ScriptComponent2.prototype.addRepresentation = function addRepresentation2() {
  };
  ScriptComponent2.prototype.removeRepresentation = function removeRepresentation2() {
  };
  ScriptComponent2.prototype.run = function run3() {
    var this$1 = this;
    this.setStatus("running");
    this.script.call(this.stage).then(function() {
      this$1.setStatus("finished");
    });
    this.setStatus("called");
  };
  ScriptComponent2.prototype.dispose = function dispose24() {
    this.signals.disposed.dispatch();
  };
  ScriptComponent2.prototype.setVisibility = function setVisibility7() {
  };
  ScriptComponent2.prototype.getCenter = function getCenter5() {
  };
  ScriptComponent2.prototype.getZoom = function getZoom3() {
  };
  ScriptComponent2.prototype.getBox = function getBox4() {
  };
  Object.defineProperties(ScriptComponent2.prototype, prototypeAccessors2);
  return ScriptComponent2;
}(Component);
ComponentRegistry.add("script", ScriptComponent);
var ShapeComponent = function(Component$$1) {
  function ShapeComponent2(stage, shape, params) {
    var p = params || {};
    p.name = defaults(p.name, shape.name);
    Component$$1.call(this, stage, p);
    this.shape = shape;
  }
  if (Component$$1)
    ShapeComponent2.__proto__ = Component$$1;
  ShapeComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  ShapeComponent2.prototype.constructor = ShapeComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "shape";
  };
  ShapeComponent2.prototype.addRepresentation = function addRepresentation2(type2, params) {
    return Component$$1.prototype.addRepresentation.call(this, type2, this.shape, params);
  };
  ShapeComponent2.prototype.getBoxUntransformed = function getBoxUntransformed2() {
    return this.shape.boundingBox;
  };
  ShapeComponent2.prototype.getCenterUntransformed = function getCenterUntransformed2() {
    return this.shape.center;
  };
  ShapeComponent2.prototype.dispose = function dispose24() {
    this.shape.dispose();
    Component$$1.prototype.dispose.call(this);
  };
  Object.defineProperties(ShapeComponent2.prototype, prototypeAccessors2);
  return ShapeComponent2;
}(Component);
ComponentRegistry.add("shape", ShapeComponent);
var TrajectoryComponent = function(Component$$1) {
  function TrajectoryComponent2(stage, trajectory, params, parent) {
    var this$1 = this;
    var p = params || {};
    p.name = defaults(p.name, trajectory.name);
    Component$$1.call(this, stage, p);
    this.signals = Object.assign(this.signals, {
      frameChanged: new Signal(),
      playerChanged: new Signal(),
      gotNumframes: new Signal(),
      parametersChanged: new Signal()
    });
    this.trajectory = trajectory;
    this.parent = parent;
    this.status = "loaded";
    this.defaultStep = defaults(p.defaultStep, void 0);
    this.defaultTimeout = defaults(p.defaultTimeout, 50);
    this.defaultInterpolateType = defaults(p.defaultInterpolateType, "");
    this.defaultInterpolateStep = defaults(p.defaultInterpolateStep, 5);
    this.defaultMode = defaults(p.defaultMode, "loop");
    this.defaultDirection = defaults(p.defaultDirection, "forward");
    trajectory.signals.frameChanged.add(function(i) {
      this$1.signals.frameChanged.dispatch(i);
    });
    trajectory.signals.playerChanged.add(function(player) {
      this$1.signals.playerChanged.dispatch(player);
    });
    trajectory.signals.gotNumframes.add(function(n) {
      this$1.signals.gotNumframes.dispatch(n);
    });
    if (p.initialFrame !== void 0) {
      this.setFrame(p.initialFrame);
    }
  }
  if (Component$$1)
    TrajectoryComponent2.__proto__ = Component$$1;
  TrajectoryComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  TrajectoryComponent2.prototype.constructor = TrajectoryComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "trajectory";
  };
  TrajectoryComponent2.prototype.addRepresentation = function addRepresentation2(type2, params) {
    return Component$$1.prototype.addRepresentation.call(this, type2, this.trajectory, params);
  };
  TrajectoryComponent2.prototype.setFrame = function setFrame2(i) {
    this.trajectory.setFrame(i);
  };
  TrajectoryComponent2.prototype.setParameters = function setParameters8(params) {
    this.trajectory.setParameters(params);
    this.signals.parametersChanged.dispatch(params);
  };
  TrajectoryComponent2.prototype.dispose = function dispose24() {
    this.trajectory.dispose();
    Component$$1.prototype.dispose.call(this);
  };
  TrajectoryComponent2.prototype.getCenter = function getCenter5() {
  };
  Object.defineProperties(TrajectoryComponent2.prototype, prototypeAccessors2);
  return TrajectoryComponent2;
}(Component);
var FramesTrajectory = function(Trajectory$$1) {
  function FramesTrajectory2(frames, structure, params) {
    Trajectory$$1.call(this, "", structure, params);
    this.name = frames.name;
    this.path = frames.path;
    this.frames = frames.coordinates;
    this.boxes = frames.boxes;
    this.getNumframes();
  }
  if (Trajectory$$1)
    FramesTrajectory2.__proto__ = Trajectory$$1;
  FramesTrajectory2.prototype = Object.create(Trajectory$$1 && Trajectory$$1.prototype);
  FramesTrajectory2.prototype.constructor = FramesTrajectory2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "frames";
  };
  FramesTrajectory2.prototype.makeAtomIndices = function makeAtomIndices2() {
    if (this.structure.type === "StructureView") {
      this.atomIndices = this.structure.getAtomIndices();
    } else {
      this.atomIndices = null;
    }
  };
  FramesTrajectory2.prototype._loadFrame = function _loadFrame2(i, callback) {
    var coords;
    var frame = this.frames[i];
    if (this.atomIndices) {
      var indices = this.atomIndices;
      var m2 = indices.length;
      coords = new Float32Array(m2 * 3);
      for (var j = 0; j < m2; ++j) {
        var j3 = j * 3;
        var idx3 = indices[j] * 3;
        coords[j3 + 0] = frame[idx3 + 0];
        coords[j3 + 1] = frame[idx3 + 1];
        coords[j3 + 2] = frame[idx3 + 2];
      }
    } else {
      coords = new Float32Array(frame);
    }
    var box = this.boxes[i];
    var numframes = this.frames.length;
    this.process(i, box, coords, numframes);
    if (typeof callback === "function") {
      callback();
    }
  };
  FramesTrajectory2.prototype.getNumframes = function getNumframes2() {
    if (this.frames) {
      this.setNumframes(this.frames.length);
    }
  };
  FramesTrajectory2.prototype.getPath = function getPath2(index, callback) {
    var this$1 = this;
    var i, j, f;
    var n = this.numframes;
    var k = index * 3;
    var path = new Float32Array(n * 3);
    for (i = 0; i < n; ++i) {
      j = 3 * i;
      f = this$1.frames[i];
      path[j + 0] = f[k + 0];
      path[j + 1] = f[k + 1];
      path[j + 2] = f[k + 2];
    }
    callback(path);
  };
  Object.defineProperties(FramesTrajectory2.prototype, prototypeAccessors2);
  return FramesTrajectory2;
}(Trajectory);
var StructureTrajectory = function(Trajectory$$1) {
  function StructureTrajectory2(trajPath, structure, params) {
    Trajectory$$1.call(this, "", structure, params);
  }
  if (Trajectory$$1)
    StructureTrajectory2.__proto__ = Trajectory$$1;
  StructureTrajectory2.prototype = Object.create(Trajectory$$1 && Trajectory$$1.prototype);
  StructureTrajectory2.prototype.constructor = StructureTrajectory2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "structure";
  };
  StructureTrajectory2.prototype.makeAtomIndices = function makeAtomIndices2() {
    if (this.structure.atomSet.getSize() < this.structure.atomStore.count) {
      this.atomIndices = this.structure.getAtomIndices();
    } else {
      this.atomIndices = null;
    }
  };
  StructureTrajectory2.prototype._loadFrame = function _loadFrame2(i, callback) {
    var coords;
    var structure = this.structure;
    var frame = structure.frames[i];
    if (this.atomIndices) {
      var indices = this.atomIndices;
      var m2 = indices.length;
      coords = new Float32Array(m2 * 3);
      for (var j = 0; j < m2; ++j) {
        var j3 = j * 3;
        var idx3 = indices[j] * 3;
        coords[j3 + 0] = frame[idx3 + 0];
        coords[j3 + 1] = frame[idx3 + 1];
        coords[j3 + 2] = frame[idx3 + 2];
      }
    } else {
      coords = new Float32Array(frame);
    }
    var box = structure.boxes[i];
    var numframes = structure.frames.length;
    this.process(i, box, coords, numframes);
    if (typeof callback === "function") {
      callback();
    }
  };
  StructureTrajectory2.prototype.getNumframes = function getNumframes2() {
    this.setNumframes(this.structure.frames.length);
  };
  StructureTrajectory2.prototype.getPath = function getPath2(index, callback) {
    var this$1 = this;
    var i, j, f;
    var n = this.numframes;
    var k = index * 3;
    var path = new Float32Array(n * 3);
    for (i = 0; i < n; ++i) {
      j = 3 * i;
      f = this$1.structure.frames[i];
      path[j + 0] = f[k + 0];
      path[j + 1] = f[k + 1];
      path[j + 2] = f[k + 2];
    }
    callback(path);
  };
  Object.defineProperties(StructureTrajectory2.prototype, prototypeAccessors2);
  return StructureTrajectory2;
}(Trajectory);
var RemoteTrajectory = function(Trajectory$$1) {
  function RemoteTrajectory2() {
    Trajectory$$1.apply(this, arguments);
  }
  if (Trajectory$$1)
    RemoteTrajectory2.__proto__ = Trajectory$$1;
  RemoteTrajectory2.prototype = Object.create(Trajectory$$1 && Trajectory$$1.prototype);
  RemoteTrajectory2.prototype.constructor = RemoteTrajectory2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "remote";
  };
  RemoteTrajectory2.prototype.makeAtomIndices = function makeAtomIndices2() {
    var atomIndices = [];
    if (this.structure.type === "StructureView") {
      var indices = this.structure.getAtomIndices();
      var i, r;
      var p = indices[0];
      var q = indices[0];
      var n = indices.length;
      for (i = 1; i < n; ++i) {
        r = indices[i];
        if (q + 1 < r) {
          atomIndices.push([p, q + 1]);
          p = r;
        }
        q = r;
      }
      atomIndices.push([p, q + 1]);
    } else {
      atomIndices.push([0, this.atomCount]);
    }
    this.atomIndices = atomIndices;
  };
  RemoteTrajectory2.prototype._loadFrame = function _loadFrame2(i, callback) {
    var request = new window.XMLHttpRequest();
    var ds = DatasourceRegistry.trajectory;
    var url = ds.getFrameUrl(this.trajPath, i);
    var params = ds.getFrameParams(this.trajPath, this.atomIndices);
    request.open("POST", url, true);
    request.responseType = "arraybuffer";
    request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    request.addEventListener("load", function() {
      var arrayBuffer = request.response;
      if (!arrayBuffer) {
        Log.error("empty arrayBuffer for '" + url + "'");
        return;
      }
      var numframes = new Int32Array(arrayBuffer, 0, 1)[0];
      var box = new Float32Array(arrayBuffer, 2 * 4, 9);
      var coords = new Float32Array(arrayBuffer, 11 * 4);
      this.process(i, box, coords, numframes);
      if (typeof callback === "function") {
        callback();
      }
    }.bind(this), false);
    request.send(params);
  };
  RemoteTrajectory2.prototype.getNumframes = function getNumframes2() {
    var request = new window.XMLHttpRequest();
    var ds = DatasourceRegistry.trajectory;
    var url = ds.getNumframesUrl(this.trajPath);
    request.open("GET", url, true);
    request.addEventListener("load", function() {
      this.setNumframes(parseInt(request.response));
    }.bind(this), false);
    request.send(null);
  };
  RemoteTrajectory2.prototype.getPath = function getPath2(index, callback) {
    if (this.pathCache[index]) {
      callback(this.pathCache[index]);
      return;
    }
    Log.time("loadPath");
    var request = new window.XMLHttpRequest();
    var ds = DatasourceRegistry.trajectory;
    var url = ds.getPathUrl(this.trajPath, index);
    var params = "";
    request.open("POST", url, true);
    request.responseType = "arraybuffer";
    request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    request.addEventListener("load", function() {
      Log.timeEnd("loadPath");
      var arrayBuffer = request.response;
      if (!arrayBuffer) {
        Log.error("empty arrayBuffer for '" + url + "'");
        return;
      }
      var path = new Float32Array(arrayBuffer);
      this.pathCache[index] = path;
      callback(path);
    }.bind(this), false);
    request.send(params);
  };
  Object.defineProperties(RemoteTrajectory2.prototype, prototypeAccessors2);
  return RemoteTrajectory2;
}(Trajectory);
function makeTrajectory(trajSrc, structure, params) {
  var traj;
  if (trajSrc && trajSrc.type === "Frames") {
    traj = new FramesTrajectory(trajSrc, structure, params);
  } else if (!trajSrc && structure.frames) {
    traj = new StructureTrajectory(trajSrc, structure, params);
  } else {
    traj = new RemoteTrajectory(trajSrc, structure, params);
  }
  return traj;
}
Structure.prototype.getView = function(selection) {
  return new StructureView(this, selection);
};
var StructureView = function(Structure$$1) {
  function StructureView2(structure, selection) {
    Structure$$1.call(this);
    this.structure = structure;
    this.selection = selection;
    this.center = new Vector3();
    this.boundingBox = new Box3();
    this._bp = this.getBondProxy();
    this._ap = this.getAtomProxy();
    this._rp = this.getResidueProxy();
    this._cp = this.getChainProxy();
    if (this.selection) {
      this.selection.signals.stringChanged.add(this.refresh, this);
    }
    this.structure.signals.refreshed.add(this.refresh, this);
    this.refresh();
  }
  if (Structure$$1)
    StructureView2.__proto__ = Structure$$1;
  StructureView2.prototype = Object.create(Structure$$1 && Structure$$1.prototype);
  StructureView2.prototype.constructor = StructureView2;
  var prototypeAccessors2 = {type: {}, name: {}, path: {}, title: {}, id: {}, atomSetDict: {}, biomolDict: {}, entityList: {}, unitcell: {}, frames: {}, boxes: {}, validation: {}, bondStore: {}, backboneBondStore: {}, rungBondStore: {}, atomStore: {}, residueStore: {}, chainStore: {}, modelStore: {}, atomMap: {}, residueMap: {}, bondHash: {}, spatialHash: {}};
  StructureView2.prototype.init = function init3() {
  };
  prototypeAccessors2.type.get = function() {
    return "StructureView";
  };
  prototypeAccessors2.name.get = function() {
    return this.structure.name;
  };
  prototypeAccessors2.path.get = function() {
    return this.structure.path;
  };
  prototypeAccessors2.title.get = function() {
    return this.structure.title;
  };
  prototypeAccessors2.id.get = function() {
    return this.structure.id;
  };
  prototypeAccessors2.atomSetDict.get = function() {
    return this.structure.atomSetDict;
  };
  prototypeAccessors2.biomolDict.get = function() {
    return this.structure.biomolDict;
  };
  prototypeAccessors2.entityList.get = function() {
    return this.structure.entityList;
  };
  prototypeAccessors2.unitcell.get = function() {
    return this.structure.unitcell;
  };
  prototypeAccessors2.frames.get = function() {
    return this.structure.frames;
  };
  prototypeAccessors2.boxes.get = function() {
    return this.structure.boxes;
  };
  prototypeAccessors2.validation.get = function() {
    return this.structure.validation;
  };
  prototypeAccessors2.bondStore.get = function() {
    return this.structure.bondStore;
  };
  prototypeAccessors2.backboneBondStore.get = function() {
    return this.structure.backboneBondStore;
  };
  prototypeAccessors2.rungBondStore.get = function() {
    return this.structure.rungBondStore;
  };
  prototypeAccessors2.atomStore.get = function() {
    return this.structure.atomStore;
  };
  prototypeAccessors2.residueStore.get = function() {
    return this.structure.residueStore;
  };
  prototypeAccessors2.chainStore.get = function() {
    return this.structure.chainStore;
  };
  prototypeAccessors2.modelStore.get = function() {
    return this.structure.modelStore;
  };
  prototypeAccessors2.atomMap.get = function() {
    return this.structure.atomMap;
  };
  prototypeAccessors2.residueMap.get = function() {
    return this.structure.residueMap;
  };
  prototypeAccessors2.bondHash.get = function() {
    return this.structure.bondHash;
  };
  prototypeAccessors2.spatialHash.get = function() {
    return this.structure.spatialHash;
  };
  StructureView2.prototype.refresh = function refresh() {
    var this$1 = this;
    if (Debug) {
      Log.time("StructureView.refresh");
    }
    this.atomSetCache = {};
    this.atomSet = this.getAtomSet(this.selection, true);
    if (this.structure.atomSet) {
      this.atomSet = this.atomSet.intersection(this.structure.atomSet);
    }
    this.bondSet = this.getBondSet();
    for (var name in this$1.atomSetDict) {
      var atomSet = this$1.atomSetDict[name];
      this$1.atomSetCache["__" + name] = atomSet.makeIntersection(this$1.atomSet);
    }
    this.atomCount = this.atomSet.getSize();
    this.bondCount = this.bondSet.getSize();
    this.boundingBox = this.getBoundingBox();
    this.center = this.boundingBox.getCenter();
    if (Debug) {
      Log.timeEnd("StructureView.refresh");
    }
    this.signals.refreshed.dispatch();
  };
  StructureView2.prototype.setSelection = function setSelection3(selection) {
    this.selection = selection;
    this.refresh();
  };
  StructureView2.prototype.getSelection = function getSelection4(selection) {
    var seleList = [];
    if (selection && selection.string) {
      seleList.push(selection.string);
    }
    var parentSelection = this.structure.getSelection();
    if (parentSelection && parentSelection.string) {
      seleList.push(parentSelection.string);
    }
    if (this.selection && this.selection.string) {
      seleList.push(this.selection.string);
    }
    var sele = "";
    if (seleList.length > 0) {
      sele = "( " + seleList.join(" ) AND ( ") + " )";
    }
    return new Selection(sele);
  };
  StructureView2.prototype.getStructure = function getStructure2() {
    return this.structure.getStructure();
  };
  StructureView2.prototype.eachBond = function eachBond3(callback, selection) {
    this.structure.eachBond(callback, this.getSelection(selection));
  };
  StructureView2.prototype.eachAtom = function eachAtom6(callback, selection) {
    var ap = this.getAtomProxy();
    var atomSet = this.getAtomSet(selection);
    var n = this.atomStore.count;
    if (atomSet.getSize() < n) {
      atomSet.forEach(function(index) {
        ap.index = index;
        callback(ap);
      });
    } else {
      for (var i = 0; i < n; ++i) {
        ap.index = i;
        callback(ap);
      }
    }
  };
  StructureView2.prototype.eachResidue = function eachResidue5(callback, selection) {
    this.structure.eachResidue(callback, this.getSelection(selection));
  };
  StructureView2.prototype.eachResidueN = function eachResidueN3() {
    console.error("StructureView.eachResidueN() not implemented");
  };
  StructureView2.prototype.eachChain = function eachChain4(callback, selection) {
    this.structure.eachChain(callback, this.getSelection(selection));
  };
  StructureView2.prototype.eachModel = function eachModel2(callback, selection) {
    this.structure.eachModel(callback, this.getSelection(selection));
  };
  StructureView2.prototype.getAtomSet = function getAtomSet2(selection, ignoreView) {
    var atomSet = this.structure.getAtomSet(selection);
    if (!ignoreView && this.atomSet) {
      atomSet = atomSet.makeIntersection(this.atomSet);
    }
    return atomSet;
  };
  StructureView2.prototype.getAtomIndices = function getAtomIndices2(selection) {
    return this.structure.getAtomIndices(this.getSelection(selection));
  };
  StructureView2.prototype.refreshPosition = function refreshPosition2() {
    return this.structure.refreshPosition();
  };
  StructureView2.prototype.dispose = function dispose24() {
    if (this.selection) {
      this.selection.signals.stringChanged.remove(this.refresh, this);
    }
    this.structure.signals.refreshed.remove(this.refresh, this);
    delete this.structure;
    delete this.atomSet;
    delete this.bondSet;
    delete this.atomCount;
    delete this.bondCount;
  };
  Object.defineProperties(StructureView2.prototype, prototypeAccessors2);
  return StructureView2;
}(Structure);
var StructureComponent = function(Component$$1) {
  function StructureComponent2(stage, structure, params) {
    var p = params || {};
    p.name = defaults(p.name, structure.name);
    Component$$1.call(this, stage, p);
    this.signals = Object.assign(this.signals, {
      trajectoryAdded: new Signal(),
      trajectoryRemoved: new Signal(),
      defaultAssemblyChanged: new Signal()
    });
    this.structure = structure;
    this.trajList = [];
    this.initSelection(p.sele);
    this.setDefaultAssembly(p.assembly || "");
  }
  if (Component$$1)
    StructureComponent2.__proto__ = Component$$1;
  StructureComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  StructureComponent2.prototype.constructor = StructureComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "structure";
  };
  StructureComponent2.prototype.initSelection = function initSelection(sele) {
    var this$1 = this;
    this.selection = new Selection(sele);
    this.structureView = new StructureView(this.structure, this.selection);
    this.selection.signals.stringChanged.add(function() {
      this$1.structureView.setSelection(this$1.selection);
      this$1.rebuildRepresentations();
      this$1.rebuildTrajectories();
    });
  };
  StructureComponent2.prototype.setSelection = function setSelection3(string) {
    this.selection.setString(string);
    return this;
  };
  StructureComponent2.prototype.setDefaultAssembly = function setDefaultAssembly(value2) {
    var this$1 = this;
    this.defaultAssembly = value2;
    this.reprList.forEach(function(repr) {
      repr.setParameters({defaultAssembly: this$1.defaultAssembly});
    });
    this.signals.defaultAssemblyChanged.dispatch(value2);
  };
  StructureComponent2.prototype.rebuildRepresentations = function rebuildRepresentations() {
    this.reprList.forEach(function(repr) {
      repr.build();
    });
  };
  StructureComponent2.prototype.rebuildTrajectories = function rebuildTrajectories() {
    var this$1 = this;
    this.trajList.slice().forEach(function(trajComp) {
      trajComp.trajectory.setStructure(this$1.structureView);
    });
  };
  StructureComponent2.prototype.addRepresentation = function addRepresentation2(type2, params) {
    var p = params || {};
    p.defaultAssembly = this.defaultAssembly;
    return Component$$1.prototype.addRepresentation.call(this, type2, this.structureView, p);
  };
  StructureComponent2.prototype.addTrajectory = function addTrajectory(trajPath, params) {
    var this$1 = this;
    var traj = makeTrajectory(trajPath, this.structureView, params);
    traj.signals.frameChanged.add(function() {
      this$1.updateRepresentations({position: true});
    });
    var trajComp = new TrajectoryComponent(this.stage, traj, params, this);
    this.trajList.push(trajComp);
    this.signals.trajectoryAdded.dispatch(trajComp);
    return trajComp;
  };
  StructureComponent2.prototype.removeTrajectory = function removeTrajectory(traj) {
    var idx = this.trajList.indexOf(traj);
    if (idx !== -1) {
      this.trajList.splice(idx, 1);
    }
    traj.dispose();
    this.signals.trajectoryRemoved.dispatch(traj);
  };
  StructureComponent2.prototype.dispose = function dispose24() {
    this.trajList.slice().forEach(function(traj) {
      traj.dispose();
    });
    this.trajList.length = 0;
    this.structure.dispose();
    Component$$1.prototype.dispose.call(this);
  };
  StructureComponent2.prototype.autoView = function autoView3(sele, duration) {
    if (Number.isInteger(sele)) {
      duration = sele;
      sele = void 0;
    }
    this.stage.animationControls.zoomMove(this.getCenter(sele), this.getZoom(sele), defaults(duration, 0));
  };
  StructureComponent2.prototype.getBoxUntransformed = function getBoxUntransformed2(sele) {
    var bb;
    if (sele) {
      bb = this.structureView.getBoundingBox(new Selection(sele));
    } else {
      bb = this.structureView.boundingBox;
    }
    return bb;
  };
  StructureComponent2.prototype.getCenterUntransformed = function getCenterUntransformed2(sele) {
    if (sele && typeof sele === "string") {
      return this.structure.atomCenter(new Selection(sele));
    } else {
      return this.structure.center;
    }
  };
  StructureComponent2.prototype.superpose = function superpose$1(component, align2, sele1, sele2) {
    superpose(this.structureView, component.structureView, align2, sele1, sele2);
    this.updateRepresentations({position: true});
    return this;
  };
  StructureComponent2.prototype.setVisibility = function setVisibility7(value2) {
    Component$$1.prototype.setVisibility.call(this, value2);
    this.trajList.forEach(function(traj) {
      traj.setVisibility(value2);
    });
    return this;
  };
  Object.defineProperties(StructureComponent2.prototype, prototypeAccessors2);
  return StructureComponent2;
}(Component);
ComponentRegistry.add("structure", StructureComponent);
ComponentRegistry.add("structureview", StructureComponent);
var SurfaceComponent = function(Component$$1) {
  function SurfaceComponent2(stage, surface, params) {
    var p = params || {};
    p.name = defaults(p.name, surface.name);
    Component$$1.call(this, stage, p);
    this.surface = surface;
  }
  if (Component$$1)
    SurfaceComponent2.__proto__ = Component$$1;
  SurfaceComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  SurfaceComponent2.prototype.constructor = SurfaceComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "surface";
  };
  SurfaceComponent2.prototype.addRepresentation = function addRepresentation2(type2, params) {
    return Component$$1.prototype.addRepresentation.call(this, type2, this.surface, params);
  };
  SurfaceComponent2.prototype.getBoxUntransformed = function getBoxUntransformed2() {
    return this.surface.boundingBox;
  };
  SurfaceComponent2.prototype.getCenterUntransformed = function getCenterUntransformed2() {
    return this.surface.center;
  };
  SurfaceComponent2.prototype.dispose = function dispose24() {
    this.surface.dispose();
    Component$$1.prototype.dispose.call(this);
  };
  Object.defineProperties(SurfaceComponent2.prototype, prototypeAccessors2);
  return SurfaceComponent2;
}(Component);
ComponentRegistry.add("surface", SurfaceComponent);
var VolumeComponent = function(Component$$1) {
  function VolumeComponent2(stage, volume, params) {
    var p = params || {};
    p.name = defaults(p.name, volume.name);
    Component$$1.call(this, stage, p);
    this.volume = volume;
  }
  if (Component$$1)
    VolumeComponent2.__proto__ = Component$$1;
  VolumeComponent2.prototype = Object.create(Component$$1 && Component$$1.prototype);
  VolumeComponent2.prototype.constructor = VolumeComponent2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "volume";
  };
  VolumeComponent2.prototype.addRepresentation = function addRepresentation2(type2, params) {
    return Component$$1.prototype.addRepresentation.call(this, type2, this.volume, params);
  };
  VolumeComponent2.prototype.getBoxUntransformed = function getBoxUntransformed2() {
    return this.volume.boundingBox;
  };
  VolumeComponent2.prototype.getCenterUntransformed = function getCenterUntransformed2() {
    return this.volume.center;
  };
  VolumeComponent2.prototype.dispose = function dispose24() {
    this.volume.dispose();
    Component$$1.prototype.dispose.call(this);
  };
  Object.defineProperties(VolumeComponent2.prototype, prototypeAccessors2);
  return VolumeComponent2;
}(Component);
ComponentRegistry.add("volume", VolumeComponent);
var AxesRepresentation = function(StructureRepresentation$$1) {
  function AxesRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "axes";
    this.parameters = Object.assign({
      radius: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      sphereDetail: true,
      radialSegments: true,
      disableImpostor: true,
      showAxes: {
        type: "boolean",
        rebuild: true
      },
      showBox: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters, {
      assembly: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    AxesRepresentation2.__proto__ = StructureRepresentation$$1;
  AxesRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  AxesRepresentation2.prototype.constructor = AxesRepresentation2;
  AxesRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.radius = defaults(p.radius, 0.5);
    p.colorValue = defaults(p.colorValue, "lightgreen");
    this.showAxes = defaults(p.showAxes, true);
    this.showBox = defaults(p.showBox, false);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  AxesRepresentation2.prototype.getPrincipalAxes = function getPrincipalAxes2() {
    var selection;
    var assembly = this.getAssembly();
    if (assembly) {
      selection = assembly.partList[0].getSelection();
    }
    return this.structureView.getPrincipalAxes(selection);
  };
  AxesRepresentation2.prototype.getAxesData = function getAxesData(sview) {
    var pa = this.getPrincipalAxes(sview);
    var c = new Color(this.colorValue);
    var vn = 0;
    var en = 0;
    if (this.showAxes) {
      vn += 6;
      en += 3;
    }
    if (this.showBox) {
      vn += 8;
      en += 12;
    }
    var vertexPosition = new Float32Array(3 * vn);
    var vertexColor = uniformArray3(vn, c.r, c.g, c.b);
    var vertexRadius = uniformArray(vn, this.radius);
    var edgePosition1 = new Float32Array(3 * en);
    var edgePosition2 = new Float32Array(3 * en);
    var edgeColor = uniformArray3(en, c.r, c.g, c.b);
    var edgeRadius = uniformArray(en, this.radius);
    var offset = 0;
    if (this.showAxes) {
      var addAxis = function(v1, v2) {
        v1.toArray(vertexPosition, offset * 2);
        v2.toArray(vertexPosition, offset * 2 + 3);
        v1.toArray(edgePosition1, offset);
        v2.toArray(edgePosition2, offset);
        offset += 3;
      };
      addAxis(pa.begA, pa.endA);
      addAxis(pa.begB, pa.endB);
      addAxis(pa.begC, pa.endC);
    }
    if (this.showBox) {
      var v = new Vector3();
      var ref = pa.getProjectedScaleForAtoms(sview);
      var d1a = ref.d1a;
      var d2a = ref.d2a;
      var d3a = ref.d3a;
      var d1b = ref.d1b;
      var d2b = ref.d2b;
      var d3b = ref.d3b;
      console.log(d1a, d2a, d3a, d1b, d2b, d3b);
      var offset2 = offset * 2;
      var addCorner = function(d1, d2, d3) {
        v.copy(pa.center).addScaledVector(pa.normVecA, d1).addScaledVector(pa.normVecB, d2).addScaledVector(pa.normVecC, d3);
        v.toArray(vertexPosition, offset2);
        offset2 += 3;
      };
      addCorner(d1a, d2a, d3a);
      addCorner(d1a, d2a, d3b);
      addCorner(d1a, d2b, d3b);
      addCorner(d1a, d2b, d3a);
      addCorner(d1b, d2b, d3b);
      addCorner(d1b, d2b, d3a);
      addCorner(d1b, d2a, d3a);
      addCorner(d1b, d2a, d3b);
      var edgeOffset = offset;
      var addEdge = function(a, b) {
        v.fromArray(vertexPosition, offset * 2 + a * 3).toArray(edgePosition1, edgeOffset);
        v.fromArray(vertexPosition, offset * 2 + b * 3).toArray(edgePosition2, edgeOffset);
        edgeOffset += 3;
      };
      addEdge(0, 1);
      addEdge(0, 3);
      addEdge(0, 6);
      addEdge(1, 2);
      addEdge(1, 7);
      addEdge(2, 3);
      addEdge(2, 4);
      addEdge(3, 5);
      addEdge(4, 5);
      addEdge(4, 7);
      addEdge(5, 6);
      addEdge(6, 7);
    }
    var picker = new AxesPicker(pa);
    return {
      vertex: {
        position: vertexPosition,
        color: vertexColor,
        radius: vertexRadius,
        picking: picker
      },
      edge: {
        position1: edgePosition1,
        position2: edgePosition2,
        color: edgeColor,
        color2: edgeColor,
        radius: edgeRadius,
        picking: picker
      }
    };
  };
  AxesRepresentation2.prototype.create = function create2() {
    var axesData = this.getAxesData(this.structureView);
    this.sphereBuffer = new SphereBuffer(axesData.vertex, this.getBufferParams({
      sphereDetail: this.sphereDetail,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.cylinderBuffer = new CylinderBuffer(axesData.edge, this.getBufferParams({
      openEnded: true,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.dataList.push({
      sview: this.structureView,
      bufferList: [this.sphereBuffer, this.cylinderBuffer]
    });
  };
  AxesRepresentation2.prototype.updateData = function updateData(what, data) {
    var axesData = this.getAxesData(data.sview);
    var sphereData = {};
    var cylinderData = {};
    if (!what || what.position) {
      sphereData.position = axesData.vertex.position;
      cylinderData.position1 = axesData.edge.position1;
      cylinderData.position2 = axesData.edge.position2;
    }
    if (!what || what.color) {
      sphereData.color = axesData.vertex.color;
      cylinderData.color = axesData.edge.color;
      cylinderData.color2 = axesData.edge.color;
    }
    if (!what || what.radius) {
      sphereData.radius = axesData.vertex.radius;
      cylinderData.radius = axesData.edge.radius;
    }
    this.sphereBuffer.setAttributes(sphereData);
    this.cylinderBuffer.setAttributes(cylinderData);
  };
  return AxesRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("axes", AxesRepresentation);
var BallAndStickRepresentation = function(StructureRepresentation$$1) {
  function BallAndStickRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "ball+stick";
    this.parameters = Object.assign({
      sphereDetail: true,
      radialSegments: true,
      openEnded: true,
      disableImpostor: true,
      aspectRatio: {
        type: "number",
        precision: 1,
        max: 10,
        min: 1
      },
      lineOnly: {
        type: "boolean",
        rebuild: true
      },
      cylinderOnly: {
        type: "boolean",
        rebuild: true
      },
      multipleBond: {
        type: "select",
        rebuild: true,
        options: {
          off: "off",
          symmetric: "symmetric",
          offset: "offset"
        }
      },
      bondScale: {
        type: "number",
        precision: 2,
        max: 1,
        min: 0.01
      },
      bondSpacing: {
        type: "number",
        precision: 2,
        max: 2,
        min: 0.5
      }
    }, this.parameters);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    BallAndStickRepresentation2.__proto__ = StructureRepresentation$$1;
  BallAndStickRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  BallAndStickRepresentation2.prototype.constructor = BallAndStickRepresentation2;
  BallAndStickRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.radius = defaults(p.radius, 0.15);
    this.aspectRatio = defaults(p.aspectRatio, 2);
    this.lineOnly = defaults(p.lineOnly, false);
    this.cylinderOnly = defaults(p.cylinderOnly, false);
    this.multipleBond = defaults(p.multipleBond, "off");
    this.bondSpacing = defaults(p.bondSpacing, 1);
    this.bondScale = defaults(p.bondScale, 0.4);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  BallAndStickRepresentation2.prototype.getAtomParams = function getAtomParams(what, params) {
    params = Object.assign({
      radiusParams: {radius: this.radius, scale: this.scale * this.aspectRatio}
    }, params);
    return StructureRepresentation$$1.prototype.getAtomParams.call(this, what, params);
  };
  BallAndStickRepresentation2.prototype.getAtomData = function getAtomData2(sview, what, params) {
    return sview.getAtomData(this.getAtomParams(what, params));
  };
  BallAndStickRepresentation2.prototype.getBondParams = function getBondParams(what, params) {
    params = Object.assign({
      multipleBond: this.multipleBond,
      bondSpacing: this.bondSpacing,
      bondScale: this.bondScale
    }, params);
    return StructureRepresentation$$1.prototype.getBondParams.call(this, what, params);
  };
  BallAndStickRepresentation2.prototype.getBondData = function getBondData2(sview, what, params) {
    return sview.getBondData(this.getBondParams(what, params));
  };
  BallAndStickRepresentation2.prototype.createData = function createData(sview) {
    var bondData = this.getBondData(sview);
    var bufferList = [];
    if (this.lineOnly) {
      this.lineBuffer = new LineBuffer(bondData, this.getBufferParams());
      bufferList.push(this.lineBuffer);
    } else {
      var cylinderBuffer = new CylinderBuffer(bondData, this.getBufferParams({
        openEnded: this.openEnded,
        radialSegments: this.radialSegments,
        disableImpostor: this.disableImpostor,
        dullInterior: true
      }));
      bufferList.push(cylinderBuffer);
      if (!this.cylinderOnly) {
        var sphereBuffer = new SphereBuffer(this.getAtomData(sview), this.getBufferParams({
          sphereDetail: this.sphereDetail,
          disableImpostor: this.disableImpostor,
          dullInterior: true
        }));
        bufferList.push(sphereBuffer);
      }
    }
    return {
      bufferList
    };
  };
  BallAndStickRepresentation2.prototype.updateData = function updateData(what, data) {
    if (this.multipleBond !== "off" && what && what.radius) {
      what.position = true;
    }
    var bondData = this.getBondData(data.sview, what);
    if (this.lineOnly) {
      var lineData = {};
      if (!what || what.position) {
        lineData.position1 = bondData.position1;
        lineData.position2 = bondData.position2;
      }
      if (!what || what.color) {
        lineData.color = bondData.color;
        lineData.color2 = bondData.color2;
      }
      data.bufferList[0].setAttributes(lineData);
    } else {
      var cylinderData = {};
      if (!what || what.position) {
        cylinderData.position1 = bondData.position1;
        cylinderData.position2 = bondData.position2;
      }
      if (!what || what.color) {
        cylinderData.color = bondData.color;
        cylinderData.color2 = bondData.color2;
      }
      if (!what || what.radius) {
        cylinderData.radius = bondData.radius;
      }
      data.bufferList[0].setAttributes(cylinderData);
      if (!this.cylinderOnly) {
        var atomData = this.getAtomData(data.sview, what);
        var sphereData = {};
        if (!what || what.position) {
          sphereData.position = atomData.position;
        }
        if (!what || what.color) {
          sphereData.color = atomData.color;
        }
        if (!what || what.radius) {
          sphereData.radius = atomData.radius;
        }
        data.bufferList[1].setAttributes(sphereData);
      }
    }
  };
  BallAndStickRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && (params.aspectRatio || params.bondSpacing || params.bondScale)) {
      what.radius = true;
      if (!ExtensionFragDepth || this.disableImpostor) {
        rebuild = true;
      }
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return BallAndStickRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("ball+stick", BallAndStickRepresentation);
var BackboneRepresentation = function(BallAndStickRepresentation$$1) {
  function BackboneRepresentation2(structure, viewer, params) {
    BallAndStickRepresentation$$1.call(this, structure, viewer, params);
    this.type = "backbone";
    this.parameters = Object.assign({}, this.parameters, {
      multipleBond: null,
      bondSpacing: null
    });
    this.init(params);
  }
  if (BallAndStickRepresentation$$1)
    BackboneRepresentation2.__proto__ = BallAndStickRepresentation$$1;
  BackboneRepresentation2.prototype = Object.create(BallAndStickRepresentation$$1 && BallAndStickRepresentation$$1.prototype);
  BackboneRepresentation2.prototype.constructor = BackboneRepresentation2;
  BackboneRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.aspectRatio = defaults(p.aspectRatio, 1);
    p.radius = defaults(p.radius, 0.25);
    BallAndStickRepresentation$$1.prototype.init.call(this, p);
  };
  BackboneRepresentation2.prototype.getAtomData = function getAtomData2(sview, what, params) {
    return sview.getBackboneAtomData(this.getAtomParams(what, params));
  };
  BackboneRepresentation2.prototype.getBondData = function getBondData2(sview, what, params) {
    return sview.getBackboneBondData(this.getBondParams(what, params));
  };
  return BackboneRepresentation2;
}(BallAndStickRepresentation);
RepresentationRegistry.add("backbone", BackboneRepresentation);
var BaseRepresentation = function(BallAndStickRepresentation$$1) {
  function BaseRepresentation2(structure, viewer, params) {
    BallAndStickRepresentation$$1.call(this, structure, viewer, params);
    this.type = "base";
    this.parameters = Object.assign({}, this.parameters, {
      multipleBond: null,
      bondSpacing: null
    });
  }
  if (BallAndStickRepresentation$$1)
    BaseRepresentation2.__proto__ = BallAndStickRepresentation$$1;
  BaseRepresentation2.prototype = Object.create(BallAndStickRepresentation$$1 && BallAndStickRepresentation$$1.prototype);
  BaseRepresentation2.prototype.constructor = BaseRepresentation2;
  BaseRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.aspectRatio = defaults(p.aspectRatio, 1);
    p.radius = defaults(p.radius, 0.3);
    BallAndStickRepresentation$$1.prototype.init.call(this, p);
  };
  BaseRepresentation2.prototype.getAtomData = function getAtomData2(sview, what, params) {
    return sview.getRungAtomData(this.getAtomParams(what, params));
  };
  BaseRepresentation2.prototype.getBondData = function getBondData2(sview, what, params) {
    var p = this.getBondParams(what, params);
    p.colorParams.rung = true;
    return sview.getRungBondData(p);
  };
  return BaseRepresentation2;
}(BallAndStickRepresentation);
RepresentationRegistry.add("base", BaseRepresentation);
function Interpolator(m2, tension) {
  var dt = 1 / m2;
  var delta = 1e-4;
  var vec1 = new Vector3();
  var vec2 = new Vector3();
  function interpolateToArr(v0, v1, v2, v3, t, arr, offset) {
    arr[offset + 0] = spline(v0.x, v1.x, v2.x, v3.x, t, tension);
    arr[offset + 1] = spline(v0.y, v1.y, v2.y, v3.y, t, tension);
    arr[offset + 2] = spline(v0.z, v1.z, v2.z, v3.z, t, tension);
  }
  function interpolateToVec(v0, v1, v2, v3, t, vec) {
    vec.x = spline(v0.x, v1.x, v2.x, v3.x, t, tension);
    vec.y = spline(v0.y, v1.y, v2.y, v3.y, t, tension);
    vec.z = spline(v0.z, v1.z, v2.z, v3.z, t, tension);
  }
  function interpolatePosition(v0, v1, v2, v3, pos, offset) {
    for (var j = 0; j < m2; ++j) {
      var l = offset + j * 3;
      var d = dt * j;
      interpolateToArr(v0, v1, v2, v3, d, pos, l);
    }
  }
  function interpolateTangent(v0, v1, v2, v3, tan, offset) {
    for (var j = 0; j < m2; ++j) {
      var d = dt * j;
      var d1 = d - delta;
      var d2 = d + delta;
      var l = offset + j * 3;
      if (d1 < 0) {
        d1 = 0;
      }
      if (d2 > 1) {
        d2 = 1;
      }
      interpolateToVec(v0, v1, v2, v3, d1, vec1);
      interpolateToVec(v0, v1, v2, v3, d2, vec2);
      vec2.sub(vec1).normalize();
      vec2.toArray(tan, l);
    }
  }
  function vectorSubdivide(interpolationFn, iterator, array, offset, isCyclic) {
    var v0;
    var v1 = iterator.next();
    var v2 = iterator.next();
    var v3 = iterator.next();
    var n = iterator.size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      v0 = v1;
      v1 = v2;
      v2 = v3;
      v3 = iterator.next();
      interpolationFn(v0, v1, v2, v3, array, k);
      k += 3 * m2;
    }
    if (isCyclic) {
      v0 = iterator.get(n - 2);
      v1 = iterator.get(n - 1);
      v2 = iterator.get(0);
      v3 = iterator.get(1);
      interpolationFn(v0, v1, v2, v3, array, k);
      k += 3 * m2;
    }
  }
  this.getPosition = function(iterator, array, offset, isCyclic) {
    iterator.reset();
    vectorSubdivide(interpolatePosition, iterator, array, offset, isCyclic);
    var n1 = iterator.size - 1;
    var k = n1 * m2 * 3;
    if (isCyclic) {
      k += m2 * 3;
    }
    var v = iterator.get(isCyclic ? 0 : n1);
    array[k] = v.x;
    array[k + 1] = v.y;
    array[k + 2] = v.z;
  };
  this.getTangent = function(iterator, array, offset, isCyclic) {
    iterator.reset();
    vectorSubdivide(interpolateTangent, iterator, array, offset, isCyclic);
    var n1 = iterator.size - 1;
    var k = n1 * m2 * 3;
    if (isCyclic) {
      k += m2 * 3;
    }
    copyArray(array, array, k - 3, k, 3);
  };
  var vDir = new Vector3();
  var vTan = new Vector3();
  var vNorm = new Vector3();
  var vBin = new Vector3();
  var m22 = Math.ceil(m2 / 2);
  function interpolateNormalDir(u0, u1, u2, u3, v0, v1, v2, v3, tan, norm, bin, offset, shift) {
    for (var j = 0; j < m2; ++j) {
      var l = offset + j * 3;
      if (shift) {
        l += m22 * 3;
      }
      var d = dt * j;
      interpolateToVec(u0, u1, u2, u3, d, vec1);
      interpolateToVec(v0, v1, v2, v3, d, vec2);
      vDir.subVectors(vec2, vec1).normalize();
      vTan.fromArray(tan, l);
      vBin.crossVectors(vDir, vTan).normalize();
      vBin.toArray(bin, l);
      vNorm.crossVectors(vTan, vBin).normalize();
      vNorm.toArray(norm, l);
    }
  }
  function interpolateNormal(vDir2, tan, norm, bin, offset) {
    for (var j = 0; j < m2; ++j) {
      var l = offset + j * 3;
      vDir2.copy(vNorm);
      vTan.fromArray(tan, l);
      vBin.crossVectors(vDir2, vTan).normalize();
      vBin.toArray(bin, l);
      vNorm.crossVectors(vTan, vBin).normalize();
      vNorm.toArray(norm, l);
    }
  }
  this.getNormal = function(size, tan, norm, bin, offset, isCyclic) {
    vNorm.set(0, 0, 1);
    var n = size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      interpolateNormal(vDir, tan, norm, bin, k);
      k += 3 * m2;
    }
    if (isCyclic) {
      interpolateNormal(vDir, tan, norm, bin, k);
      k += 3 * m2;
    }
    vBin.toArray(bin, k);
    vNorm.toArray(norm, k);
  };
  this.getNormalDir = function(iterDir1, iterDir2, tan, norm, bin, offset, isCyclic, shift) {
    iterDir1.reset();
    iterDir2.reset();
    var vSub1 = new Vector3();
    var vSub2 = new Vector3();
    var vSub3 = new Vector3();
    var vSub4 = new Vector3();
    var d1v1 = new Vector3();
    var d1v2 = new Vector3().copy(iterDir1.next());
    var d1v3 = new Vector3().copy(iterDir1.next());
    var d1v4 = new Vector3().copy(iterDir1.next());
    var d2v1 = new Vector3();
    var d2v2 = new Vector3().copy(iterDir2.next());
    var d2v3 = new Vector3().copy(iterDir2.next());
    var d2v4 = new Vector3().copy(iterDir2.next());
    vNorm.set(0, 0, 1);
    var n = iterDir1.size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      d1v1.copy(d1v2);
      d1v2.copy(d1v3);
      d1v3.copy(d1v4);
      d1v4.copy(iterDir1.next());
      d2v1.copy(d2v2);
      d2v2.copy(d2v3);
      d2v3.copy(d2v4);
      d2v4.copy(iterDir2.next());
      if (i === 0) {
        vSub1.subVectors(d2v1, d1v1);
        vSub2.subVectors(d2v2, d1v2);
        if (vSub1.dot(vSub2) < 0) {
          vSub2.multiplyScalar(-1);
          d2v2.addVectors(d1v2, vSub2);
        }
        vSub3.subVectors(d2v3, d1v3);
        if (vSub2.dot(vSub3) < 0) {
          vSub3.multiplyScalar(-1);
          d2v3.addVectors(d1v3, vSub3);
        }
      } else {
        vSub3.copy(vSub4);
      }
      vSub4.subVectors(d2v4, d1v4);
      if (vSub3.dot(vSub4) < 0) {
        vSub4.multiplyScalar(-1);
        d2v4.addVectors(d1v4, vSub4);
      }
      interpolateNormalDir(d1v1, d1v2, d1v3, d1v4, d2v1, d2v2, d2v3, d2v4, tan, norm, bin, k, shift);
      k += 3 * m2;
    }
    if (isCyclic) {
      d1v1.copy(iterDir1.get(n - 2));
      d1v2.copy(iterDir1.get(n - 1));
      d1v3.copy(iterDir1.get(0));
      d1v4.copy(iterDir1.get(1));
      d2v1.copy(iterDir2.get(n - 2));
      d2v2.copy(iterDir2.get(n - 1));
      d2v3.copy(iterDir2.get(0));
      d2v4.copy(iterDir2.get(1));
      vSub3.copy(vSub4);
      vSub4.subVectors(d2v4, d1v4);
      if (vSub3.dot(vSub4) < 0) {
        vSub4.multiplyScalar(-1);
        d2v4.addVectors(d1v4, vSub4);
      }
      interpolateNormalDir(d1v1, d1v2, d1v3, d1v4, d2v1, d2v2, d2v3, d2v4, tan, norm, bin, k, shift);
      k += 3 * m2;
    }
    if (shift) {
      vBin.fromArray(bin, m22 * 3);
      vNorm.fromArray(norm, m22 * 3);
      for (var j = 0; j < m22; ++j) {
        vBin.toArray(bin, j * 3);
        vNorm.toArray(norm, j * 3);
      }
    } else {
      vBin.toArray(bin, k);
      vNorm.toArray(norm, k);
    }
  };
  function interpolateColor(item1, item2, colFn, col, offset) {
    var j, l;
    for (j = 0; j < m22; ++j) {
      l = offset + j * 3;
      colFn(item1, col, l);
    }
    for (j = m22; j < m2; ++j) {
      l = offset + j * 3;
      colFn(item2, col, l);
    }
  }
  this.getColor = function(iterator, colFn, col, offset, isCyclic) {
    iterator.reset();
    iterator.next();
    var i0;
    var i1 = iterator.next();
    var n = iterator.size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      i0 = i1;
      i1 = iterator.next();
      interpolateColor(i0, i1, colFn, col, k);
      k += 3 * m2;
    }
    if (isCyclic) {
      i0 = iterator.get(n - 1);
      i1 = iterator.get(0);
      interpolateColor(i0, i1, colFn, col, k);
      k += 3 * m2;
    }
    col[k] = col[k - 3];
    col[k + 1] = col[k - 2];
    col[k + 2] = col[k - 1];
  };
  function interpolatePicking(item1, item2, pickFn, pick2, offset) {
    var j;
    for (j = 0; j < m22; ++j) {
      pick2[offset + j] = pickFn(item1);
    }
    for (j = m22; j < m2; ++j) {
      pick2[offset + j] = pickFn(item2);
    }
  }
  this.getPicking = function(iterator, pickFn, pick2, offset, isCyclic) {
    iterator.reset();
    iterator.next();
    var i0;
    var i1 = iterator.next();
    var n = iterator.size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      i0 = i1;
      i1 = iterator.next();
      interpolatePicking(i0, i1, pickFn, pick2, k);
      k += m2;
    }
    if (isCyclic) {
      i0 = iterator.get(n - 1);
      i1 = iterator.get(0);
      interpolatePicking(i0, i1, pickFn, pick2, k);
      k += m2;
    }
    pick2[k] = pick2[k - 1];
  };
  function interpolateSize(item1, item2, sizeFn, size, offset) {
    var s1 = sizeFn(item1);
    var s2 = sizeFn(item2);
    for (var j = 0; j < m2; ++j) {
      var t = j / m2;
      size[offset + j] = (1 - t) * s1 + t * s2;
    }
  }
  this.getSize = function(iterator, sizeFn, size, offset, isCyclic) {
    iterator.reset();
    iterator.next();
    var i0;
    var i1 = iterator.next();
    var n = iterator.size;
    var n1 = n - 1;
    var k = offset || 0;
    for (var i = 0; i < n1; ++i) {
      i0 = i1;
      i1 = iterator.next();
      interpolateSize(i0, i1, sizeFn, size, k);
      k += m2;
    }
    if (isCyclic) {
      i0 = iterator.get(n - 1);
      i1 = iterator.get(0);
      interpolateSize(i0, i1, sizeFn, size, k);
      k += m2;
    }
    size[k] = size[k - 1];
  };
}
function Spline$1(polymer, params) {
  this.polymer = polymer;
  this.size = polymer.residueCount;
  var p = params || {};
  this.directional = p.directional || false;
  this.positionIterator = p.positionIterator || false;
  this.subdiv = p.subdiv || 1;
  this.smoothSheet = p.smoothSheet || false;
  if (isNaN(p.tension)) {
    this.tension = this.polymer.isNucleic() ? 0.5 : 0.9;
  } else {
    this.tension = p.tension || 0.5;
  }
  this.interpolator = new Interpolator(this.subdiv, this.tension);
}
Spline$1.prototype = {
  constructor: Spline$1,
  getAtomIterator: function(type2, smooth) {
    var polymer = this.polymer;
    var structure = polymer.structure;
    var n = polymer.residueCount;
    var i = 0;
    var j = -1;
    var cache = [
      structure.getAtomProxy(),
      structure.getAtomProxy(),
      structure.getAtomProxy(),
      structure.getAtomProxy()
    ];
    var cache2 = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    function next() {
      var atomProxy = this.get(j);
      j += 1;
      return atomProxy;
    }
    var apPrev = structure.getAtomProxy();
    var apNext = structure.getAtomProxy();
    function get7(idx) {
      var atomProxy = cache[i % 4];
      atomProxy.index = polymer.getAtomIndexByType(idx, type2);
      if (smooth && idx > 0 && idx < n && atomProxy.sstruc === "e") {
        var vec = cache2[i % 4];
        apPrev.index = polymer.getAtomIndexByType(idx + 1, type2);
        apNext.index = polymer.getAtomIndexByType(idx - 1, type2);
        vec.addVectors(apPrev, apNext).add(atomProxy).add(atomProxy).multiplyScalar(0.25);
        i += 1;
        return vec;
      }
      i += 1;
      return atomProxy;
    }
    function reset() {
      i = 0;
      j = -1;
    }
    return {
      size: n,
      next,
      get: get7,
      reset
    };
  },
  getSubdividedColor: function(params) {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var n = polymer.residueCount;
    var n1 = n - 1;
    var nCol = n1 * m2 * 3 + 3;
    if (polymer.isCyclic) {
      nCol += m2 * 3;
    }
    var col = new Float32Array(nCol);
    var iterator = this.getAtomIterator("trace");
    var p = params || {};
    p.structure = polymer.structure;
    var colormaker = ColormakerRegistry2.getScheme(p);
    function colFn(item, array, offset) {
      colormaker.atomColorToArray(item, array, offset);
    }
    this.interpolator.getColor(iterator, colFn, col, 0, polymer.isCyclic);
    return {
      color: col
    };
  },
  getSubdividedPicking: function() {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var n = polymer.residueCount;
    var n1 = n - 1;
    var nCol = n1 * m2 + 1;
    if (polymer.isCyclic) {
      nCol += m2;
    }
    var structure = polymer.structure;
    var iterator = this.getAtomIterator("trace");
    var pick2 = new Float32Array(nCol);
    function pickFn(item) {
      return item.index;
    }
    this.interpolator.getPicking(iterator, pickFn, pick2, 0, polymer.isCyclic);
    return {
      picking: new AtomPicker(pick2, structure)
    };
  },
  getSubdividedPosition: function() {
    var pos = this.getPosition();
    return {
      position: pos
    };
  },
  getSubdividedOrientation: function() {
    var tan = this.getTangent();
    var normals = this.getNormals(tan);
    return {
      tangent: tan,
      normal: normals.normal,
      binormal: normals.binormal
    };
  },
  getSubdividedSize: function(type2, scale2) {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var n = polymer.residueCount;
    var n1 = n - 1;
    var nSize = n1 * m2 + 1;
    if (polymer.isCyclic) {
      nSize += m2;
    }
    var size = new Float32Array(nSize);
    var iterator = this.getAtomIterator("trace");
    var radiusFactory = new RadiusFactory(type2, scale2);
    function sizeFn(item) {
      return radiusFactory.atomRadius(item);
    }
    this.interpolator.getSize(iterator, sizeFn, size, 0, polymer.isCyclic);
    return {
      size
    };
  },
  getPosition: function() {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var n = polymer.residueCount;
    var n1 = n - 1;
    var nPos = n1 * m2 * 3 + 3;
    if (polymer.isCyclic) {
      nPos += m2 * 3;
    }
    var pos = new Float32Array(nPos);
    var iterator = this.positionIterator || this.getAtomIterator("trace", this.smoothSheet);
    this.interpolator.getPosition(iterator, pos, 0, polymer.isCyclic);
    return pos;
  },
  getTangent: function() {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var n = this.size;
    var n1 = n - 1;
    var nTan = n1 * m2 * 3 + 3;
    if (polymer.isCyclic) {
      nTan += m2 * 3;
    }
    var tan = new Float32Array(nTan);
    var iterator = this.positionIterator || this.getAtomIterator("trace", this.smoothSheet);
    this.interpolator.getTangent(iterator, tan, 0, polymer.isCyclic);
    return tan;
  },
  getNormals: function(tan) {
    var m2 = this.subdiv;
    var polymer = this.polymer;
    var isProtein5 = polymer.isProtein();
    var n = this.size;
    var n1 = n - 1;
    var nNorm = n1 * m2 * 3 + 3;
    if (polymer.isCyclic) {
      nNorm += m2 * 3;
    }
    var norm = new Float32Array(nNorm);
    var bin = new Float32Array(nNorm);
    if (this.directional && !this.polymer.isCg()) {
      var iterDir1 = this.getAtomIterator("direction1");
      var iterDir2 = this.getAtomIterator("direction2");
      this.interpolator.getNormalDir(iterDir1, iterDir2, tan, norm, bin, 0, polymer.isCyclic, isProtein5);
    } else {
      this.interpolator.getNormal(n, tan, norm, bin, 0, polymer.isCyclic, isProtein5);
    }
    return {
      normal: norm,
      binormal: bin
    };
  }
};
var vTangent = new Vector3();
var vMeshNormal = new Vector3();
var TubeMeshBuffer = function(MeshBuffer$$1) {
  function TubeMeshBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    var radialSegments = defaults(p.radialSegments, 4);
    var capped = defaults(p.capped, false);
    var capVertices = capped ? radialSegments : 0;
    var capTriangles = capped ? radialSegments - 2 : 0;
    var n = d.position.length / 3;
    var n1 = n - 1;
    var x = n * radialSegments * 3 + 2 * capVertices * 3;
    var xi = n1 * 2 * radialSegments * 3 + 2 * capTriangles * 3;
    var meshPosition = new Float32Array(x);
    var meshColor = new Float32Array(x);
    var meshNormal = new Float32Array(x);
    var meshIndex = getUintArray(xi, x / 3);
    MeshBuffer$$1.call(this, {
      position: meshPosition,
      color: meshColor,
      index: meshIndex,
      normal: meshNormal,
      picking: d.picking
    }, p);
    this.aspectRatio = defaults(p.aspectRatio, 1);
    this.radialSegments = radialSegments;
    this.capped = capped;
    this.capVertices = capVertices;
    this.capTriangles = capTriangles;
    this.size2 = n;
    d.primitiveId = serialArray(n);
    this.setAttributes(d);
    this.meshIndex = meshIndex;
    this.makeIndex();
  }
  if (MeshBuffer$$1)
    TubeMeshBuffer2.__proto__ = MeshBuffer$$1;
  TubeMeshBuffer2.prototype = Object.create(MeshBuffer$$1 && MeshBuffer$$1.prototype);
  TubeMeshBuffer2.prototype.constructor = TubeMeshBuffer2;
  TubeMeshBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var aspectRatio = this.aspectRatio;
    var n = this.size2;
    var n1 = n - 1;
    var radialSegments = this.radialSegments;
    var attributes = this.geometry.attributes;
    var position, normal2, binormal, tangent, color, size, primitiveId;
    var meshPosition, meshColor, meshNormal, meshPrimitiveId;
    if (data.position) {
      position = data.position;
      normal2 = data.normal;
      binormal = data.binormal;
      tangent = data.tangent;
      size = data.size;
      meshPosition = attributes.position.array;
      meshNormal = attributes.normal.array;
      attributes.position.needsUpdate = true;
      attributes.normal.needsUpdate = true;
    }
    if (data.color) {
      color = data.color;
      meshColor = attributes.color.array;
      attributes.color.needsUpdate = true;
    }
    if (data.primitiveId) {
      primitiveId = data.primitiveId;
      meshPrimitiveId = attributes.primitiveId.array;
      attributes.primitiveId.needsUpdate = true;
    }
    var i, j, k, l, s, t;
    var v, cx, cy;
    var cx1, cy1, cx2, cy2;
    var radius;
    var normX, normY, normZ;
    var biX, biY, biZ;
    var posX, posY, posZ;
    var cxArr = [];
    var cyArr = [];
    var cx1Arr = [];
    var cy1Arr = [];
    var cx2Arr = [];
    var cy2Arr = [];
    if (position) {
      for (j = 0; j < radialSegments; ++j) {
        v = j / radialSegments * 2 * Math.PI;
        cxArr[j] = aspectRatio * Math.cos(v);
        cyArr[j] = Math.sin(v);
        cx1Arr[j] = aspectRatio * Math.cos(v - 0.01);
        cy1Arr[j] = Math.sin(v - 0.01);
        cx2Arr[j] = aspectRatio * Math.cos(v + 0.01);
        cy2Arr[j] = Math.sin(v + 0.01);
      }
    }
    for (i = 0; i < n; ++i) {
      k = i * 3;
      l = k * radialSegments;
      if (position) {
        vTangent.set(tangent[k], tangent[k + 1], tangent[k + 2]);
        normX = normal2[k];
        normY = normal2[k + 1];
        normZ = normal2[k + 2];
        biX = binormal[k];
        biY = binormal[k + 1];
        biZ = binormal[k + 2];
        posX = position[k];
        posY = position[k + 1];
        posZ = position[k + 2];
        radius = size[i];
      }
      for (j = 0; j < radialSegments; ++j) {
        s = l + j * 3;
        if (position) {
          cx = -radius * cxArr[j];
          cy = radius * cyArr[j];
          cx1 = -radius * cx1Arr[j];
          cy1 = radius * cy1Arr[j];
          cx2 = -radius * cx2Arr[j];
          cy2 = radius * cy2Arr[j];
          meshPosition[s] = posX + cx * normX + cy * biX;
          meshPosition[s + 1] = posY + cx * normY + cy * biY;
          meshPosition[s + 2] = posZ + cx * normZ + cy * biZ;
          vMeshNormal.set(cx2 * normX + cy2 * biX - (cx1 * normX + cy1 * biX), cx2 * normY + cy2 * biY - (cx1 * normY + cy1 * biY), cx2 * normZ + cy2 * biZ - (cx1 * normZ + cy1 * biZ)).cross(vTangent);
          meshNormal[s] = vMeshNormal.x;
          meshNormal[s + 1] = vMeshNormal.y;
          meshNormal[s + 2] = vMeshNormal.z;
        }
        if (color) {
          meshColor[s] = color[k];
          meshColor[s + 1] = color[k + 1];
          meshColor[s + 2] = color[k + 2];
        }
        if (primitiveId) {
          meshPrimitiveId[i * radialSegments + j] = primitiveId[i];
        }
      }
    }
    k = 0;
    l = n * 3 * radialSegments;
    for (j = 0; j < radialSegments; ++j) {
      s = k + j * 3;
      t = l + j * 3;
      if (position) {
        meshPosition[t] = meshPosition[s];
        meshPosition[t + 1] = meshPosition[s + 1];
        meshPosition[t + 2] = meshPosition[s + 2];
        meshNormal[t] = tangent[k];
        meshNormal[t + 1] = tangent[k + 1];
        meshNormal[t + 2] = tangent[k + 2];
      }
      if (color) {
        meshColor[t] = meshColor[s];
        meshColor[t + 1] = meshColor[s + 1];
        meshColor[t + 2] = meshColor[s + 2];
      }
      if (primitiveId) {
        meshPrimitiveId[n * radialSegments + j] = meshPrimitiveId[0 + j];
      }
    }
    k = (n - 1) * 3 * radialSegments;
    l = (n + 1) * 3 * radialSegments;
    for (j = 0; j < radialSegments; ++j) {
      s = k + j * 3;
      t = l + j * 3;
      if (position) {
        meshPosition[t] = meshPosition[s];
        meshPosition[t + 1] = meshPosition[s + 1];
        meshPosition[t + 2] = meshPosition[s + 2];
        meshNormal[t] = tangent[n1 * 3];
        meshNormal[t + 1] = tangent[n1 * 3 + 1];
        meshNormal[t + 2] = tangent[n1 * 3 + 2];
      }
      if (color) {
        meshColor[t] = meshColor[s];
        meshColor[t + 1] = meshColor[s + 1];
        meshColor[t + 2] = meshColor[s + 2];
      }
      if (primitiveId) {
        meshPrimitiveId[(n + 1) * radialSegments + j] = meshPrimitiveId[(n - 1) * radialSegments + j];
      }
    }
  };
  TubeMeshBuffer2.prototype.makeIndex = function makeIndex() {
    var meshIndex = this.meshIndex;
    var n = this.size2;
    var n1 = n - 1;
    var capTriangles = this.capTriangles;
    var radialSegments = this.radialSegments;
    var radialSegments1 = this.radialSegments + 1;
    var i, k, irs, irs1, l, j;
    for (i = 0; i < n1; ++i) {
      k = i * radialSegments * 3 * 2;
      irs = i * radialSegments;
      irs1 = (i + 1) * radialSegments;
      for (j = 0; j < radialSegments; ++j) {
        l = k + j * 3 * 2;
        meshIndex[l] = irs + j;
        meshIndex[l + 1] = irs + (j + 1) % radialSegments;
        meshIndex[l + 2] = irs1 + j;
        meshIndex[l + 3] = irs1 + j;
        meshIndex[l + 4] = irs + (j + 1) % radialSegments;
        meshIndex[l + 5] = irs1 + (j + 1) % radialSegments;
      }
    }
    var strip2 = [0];
    for (j = 1; j < radialSegments1 / 2; ++j) {
      strip2.push(j);
      if (radialSegments - j !== j) {
        strip2.push(radialSegments - j);
      }
    }
    l = n1 * radialSegments * 3 * 2;
    k = n * radialSegments;
    for (j = 0; j < strip2.length - 2; ++j) {
      if (j % 2 === 0) {
        meshIndex[l + j * 3 + 0] = k + strip2[j + 0];
        meshIndex[l + j * 3 + 1] = k + strip2[j + 1];
        meshIndex[l + j * 3 + 2] = k + strip2[j + 2];
      } else {
        meshIndex[l + j * 3 + 0] = k + strip2[j + 2];
        meshIndex[l + j * 3 + 1] = k + strip2[j + 1];
        meshIndex[l + j * 3 + 2] = k + strip2[j + 0];
      }
    }
    l = n1 * radialSegments * 3 * 2 + 3 * capTriangles;
    k = n * radialSegments + radialSegments;
    for (j = 0; j < strip2.length - 2; ++j) {
      if (j % 2 === 0) {
        meshIndex[l + j * 3 + 0] = k + strip2[j + 0];
        meshIndex[l + j * 3 + 1] = k + strip2[j + 1];
        meshIndex[l + j * 3 + 2] = k + strip2[j + 2];
      } else {
        meshIndex[l + j * 3 + 0] = k + strip2[j + 2];
        meshIndex[l + j * 3 + 1] = k + strip2[j + 1];
        meshIndex[l + j * 3 + 2] = k + strip2[j + 0];
      }
    }
  };
  return TubeMeshBuffer2;
}(MeshBuffer);
var CartoonRepresentation = function(StructureRepresentation$$1) {
  function CartoonRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "cartoon";
    this.parameters = Object.assign({
      aspectRatio: {
        type: "number",
        precision: 1,
        max: 10,
        min: 1
      },
      subdiv: {
        type: "integer",
        max: 50,
        min: 1,
        rebuild: true
      },
      radialSegments: {
        type: "integer",
        max: 50,
        min: 1,
        rebuild: true
      },
      tension: {
        type: "number",
        precision: 1,
        max: 1,
        min: 0.1
      },
      capped: {
        type: "boolean",
        rebuild: true
      },
      smoothSheet: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    CartoonRepresentation2.__proto__ = StructureRepresentation$$1;
  CartoonRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  CartoonRepresentation2.prototype.constructor = CartoonRepresentation2;
  CartoonRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "chainname");
    p.colorScale = defaults(p.colorScale, "RdYlBu");
    p.radius = defaults(p.radius, "sstruc");
    p.scale = defaults(p.scale, 0.7);
    this.aspectRatio = defaults(p.aspectRatio, 5);
    this.tension = defaults(p.tension, NaN);
    this.capped = defaults(p.capped, true);
    this.smoothSheet = defaults(p.smoothSheet, false);
    if (p.quality === "low") {
      this.subdiv = 3;
      this.radialSegments = 6;
    } else if (p.quality === "medium") {
      this.subdiv = 6;
    } else if (p.quality === "high") {
      this.subdiv = 12;
    } else {
      this.subdiv = defaults(p.subdiv, 6);
    }
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  CartoonRepresentation2.prototype.getSplineParams = function getSplineParams(params) {
    return Object.assign({
      subdiv: this.subdiv,
      tension: this.tension,
      directional: this.aspectRatio !== 1,
      smoothSheet: this.smoothSheet
    }, params);
  };
  CartoonRepresentation2.prototype.getSpline = function getSpline(polymer) {
    return new Spline$1(polymer, this.getSplineParams());
  };
  CartoonRepresentation2.prototype.getScale = function getScale2(polymer) {
    return polymer.isCg() ? this.scale * this.aspectRatio : this.scale;
  };
  CartoonRepresentation2.prototype.getAspectRatio = function getAspectRatio(polymer) {
    return polymer.isCg() ? 1 : this.aspectRatio;
  };
  CartoonRepresentation2.prototype.createData = function createData(sview) {
    var this$1 = this;
    var bufferList = [];
    var polymerList = [];
    this.structure.eachPolymer(function(polymer) {
      if (polymer.residueCount < 4) {
        return;
      }
      polymerList.push(polymer);
      var spline2 = this$1.getSpline(polymer);
      var subPos = spline2.getSubdividedPosition();
      var subOri = spline2.getSubdividedOrientation();
      var subCol = spline2.getSubdividedColor(this$1.getColorParams());
      var subPick = spline2.getSubdividedPicking();
      var subSize = spline2.getSubdividedSize(this$1.radius, this$1.getScale(polymer));
      bufferList.push(new TubeMeshBuffer(Object.assign({}, subPos, subOri, subCol, subPick, subSize), this$1.getBufferParams({
        radialSegments: this$1.radialSegments,
        aspectRatio: this$1.getAspectRatio(polymer),
        capped: this$1.capped,
        dullInterior: true
      })));
    }, sview.getSelection());
    return {
      bufferList,
      polymerList
    };
  };
  CartoonRepresentation2.prototype.updateData = function updateData(what, data) {
    var this$1 = this;
    if (Debug) {
      Log.time(this.type + " repr update");
    }
    what = what || {};
    for (var i = 0, il = data.polymerList.length; i < il; ++i) {
      var bufferData = {};
      var polymer = data.polymerList[i];
      var spline2 = this$1.getSpline(polymer);
      data.bufferList[i].aspectRatio = this$1.getAspectRatio(polymer);
      if (what.position || what.radius) {
        var subPos = spline2.getSubdividedPosition();
        var subOri = spline2.getSubdividedOrientation();
        var subSize = spline2.getSubdividedSize(this$1.radius, this$1.getScale(polymer));
        bufferData.position = subPos.position;
        bufferData.normal = subOri.normal;
        bufferData.binormal = subOri.binormal;
        bufferData.tangent = subOri.tangent;
        bufferData.size = subSize.size;
      }
      if (what.color) {
        var subCol = spline2.getSubdividedColor(this$1.getColorParams());
        bufferData.color = subCol.color;
      }
      if (what.picking) {
        var subPick = spline2.getSubdividedPicking();
        bufferData.picking = subPick.picking;
      }
      data.bufferList[i].setAttributes(bufferData);
    }
    if (Debug) {
      Log.timeEnd(this.type + " repr update");
    }
  };
  CartoonRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && params.aspectRatio) {
      what.radius = true;
    }
    if (params && params.tension) {
      what.position = true;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return CartoonRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("cartoon", CartoonRepresentation);
var Contact = function Contact2(sview1, sview2) {
  this.sview1 = sview1;
  this.sview2 = sview2;
  this.kdtree2 = new Kdtree(sview2);
};
Contact.prototype.within = function within(maxDistance, minDistance) {
  Log.time("Contact within");
  var kdtree2 = this.kdtree2;
  var ap2 = this.sview1.getAtomProxy();
  var atomSet = this.sview1.getAtomSet(false);
  var bondStore = new BondStore();
  this.sview1.eachAtom(function(ap1) {
    var found = false;
    var contacts = kdtree2.nearest(ap1, Infinity, maxDistance);
    for (var j = 0, m2 = contacts.length; j < m2; ++j) {
      var d = contacts[j];
      ap2.index = d.index;
      if (ap1.residueIndex !== ap2.residueIndex && (!minDistance || d.distance > minDistance)) {
        found = true;
        atomSet.set(ap2.index);
        bondStore.addBond(ap1, ap2, 1);
      }
    }
    if (found) {
      atomSet.set(ap1.index);
    }
  });
  var bondSet = new BitArray(bondStore.count, true);
  Log.timeEnd("Contact within");
  return {
    atomSet,
    bondSet,
    bondStore
  };
};
function polarContacts(structure, maxDistance, maxAngle) {
  maxDistance = maxDistance || 3.5;
  maxAngle = maxAngle || 40;
  var donorSelection = new Selection("( ARG and ( .NE or .NH1 or .NH2 ) ) or ( ASP and .ND2 ) or ( GLN and .NE2 ) or ( HIS and ( .ND1 or .NE2 ) ) or ( LYS and .NZ ) or ( SER and .OG ) or ( THR and .OG1 ) or ( TRP and .NE1 ) or ( TYR and .OH ) or ( PROTEIN and .N )");
  var acceptorSelection = new Selection("( ASN and .OD1 ) or ( ASP and ( OD1 or .OD2 ) ) or ( GLN and .OE1 ) or ( GLU and ( .OE1 or .OE2 ) ) or ( HIS and ( .ND1 or .NE2 ) ) or ( SER and .OG ) or ( THR and .OG1 ) or ( TYR and .OH ) or ( PROTEIN and .O )");
  var donorView = structure.getView(donorSelection);
  var acceptorView = structure.getView(acceptorSelection);
  var contact = new Contact(donorView, acceptorView);
  var data = contact.within(maxDistance);
  var bondStore = data.bondStore;
  var ap1 = structure.getAtomProxy();
  var ap2 = structure.getAtomProxy();
  var atomCA = structure.getAtomProxy();
  var atomC = structure.getAtomProxy();
  var rp = structure.getResidueProxy();
  var rpPrev = structure.getResidueProxy();
  var v1 = new Vector3();
  var v2 = new Vector3();
  var checkAngle = function(atom1, atom2, oName, cName) {
    var atomO, atomN2;
    if (atom1.atomname === oName) {
      atomO = atom1;
      atomN2 = atom2;
    } else {
      atomO = atom2;
      atomN2 = atom1;
    }
    rp.index = atomO.residueIndex;
    var atomC2 = rp.getAtomIndexByName(cName);
    v1.subVectors(atomC2, atomO);
    v2.subVectors(atomC2, atomN2);
    return radToDeg(v1.angleTo(v2)) < maxAngle;
  };
  for (var i = 0, il = bondStore.count; i < il; ++i) {
    ap1.index = bondStore.atomIndex1[i];
    ap2.index = bondStore.atomIndex2[i];
    if (ap1.atomname === "O" && ap2.atomname === "N" || ap1.atomname === "N" && ap2.atomname === "O") {
      data.bondSet.clear(i);
      continue;
    } else if (ap1.atomname === "N" || ap2.atomname === "N") {
      var atomN, atomX;
      if (ap1.atomname === "N") {
        atomN = ap1;
        atomX = ap2;
      } else {
        atomN = ap2;
        atomX = ap1;
      }
      rp.index = atomN.residueIndex;
      atomCA.index = rp.getAtomIndexByName("CA");
      if (atomCA.index === void 0) {
        continue;
      }
      var prevRes = rp.getPreviousConnectedResidue(rpPrev);
      if (prevRes === void 0) {
        continue;
      }
      atomC.index = prevRes.getAtomIndexByName("C");
      if (atomC.index === void 0) {
        continue;
      }
      v1.subVectors(atomN, atomC);
      v2.subVectors(atomN, atomCA);
      v1.add(v2).multiplyScalar(0.5);
      v2.subVectors(atomX, atomN);
      if (radToDeg(v1.angleTo(v2)) > maxAngle) {
        data.bondSet.clear(i);
      }
    } else if (ap1.atomname === "OH" && ap1.resname === "TYR" || ap2.atomname === "OH" && ap2.resname === "TYR") {
      if (!checkAngle(ap1, ap2, "OH", "CZ")) {
        data.bondSet.clear(i);
      }
    }
  }
  return {
    atomSet: data.atomSet,
    bondSet: data.bondSet,
    bondStore: data.bondStore
  };
}
function polarBackboneContacts(structure, maxDistance, maxAngle) {
  maxDistance = maxDistance || 3.5;
  maxAngle = maxAngle || 40;
  var donorSelection = new Selection("( PROTEIN and .N )");
  var acceptorSelection = new Selection("( PROTEIN and .O )");
  var donorView = structure.getView(donorSelection);
  var acceptorView = structure.getView(acceptorSelection);
  var contact = new Contact(donorView, acceptorView);
  var data = contact.within(maxDistance);
  var bondStore = data.bondStore;
  var ap1 = structure.getAtomProxy();
  var ap2 = structure.getAtomProxy();
  var atomCA = structure.getAtomProxy();
  var atomC = structure.getAtomProxy();
  var rp = structure.getResidueProxy();
  var rpPrev = structure.getResidueProxy();
  var v1 = new Vector3();
  var v2 = new Vector3();
  for (var i = 0, il = bondStore.count; i < il; ++i) {
    ap1.index = bondStore.atomIndex1[i];
    ap2.index = bondStore.atomIndex2[i];
    var atomN, atomO;
    if (ap1.atomname === "N") {
      atomN = ap1;
      atomO = ap2;
    } else {
      atomN = ap2;
      atomO = ap1;
    }
    rp.index = atomN.residueIndex;
    atomCA.index = rp.getAtomIndexByName("CA");
    if (atomCA.index === void 0) {
      continue;
    }
    var prevRes = rp.getPreviousConnectedResidue(rpPrev);
    if (prevRes === void 0) {
      continue;
    }
    atomC.index = prevRes.getAtomIndexByName("C");
    if (atomC.index === void 0) {
      continue;
    }
    v1.subVectors(atomN, atomC);
    v2.subVectors(atomN, atomCA);
    v1.add(v2).multiplyScalar(0.5);
    v2.subVectors(atomO, atomN);
    if (radToDeg(v1.angleTo(v2)) > maxAngle) {
      data.bondSet.clear(i);
    }
  }
  return {
    atomSet: data.atomSet,
    bondSet: data.bondSet,
    bondStore: data.bondStore
  };
}
var ContactRepresentation = function(StructureRepresentation$$1) {
  function ContactRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "contact";
    this.parameters = Object.assign({
      contactType: {
        type: "select",
        rebuild: true,
        options: {
          polar: "polar",
          polarBackbone: "polar backbone"
        }
      },
      maxDistance: {
        type: "number",
        precision: 1,
        max: 10,
        min: 0.1,
        rebuild: true
      },
      maxAngle: {
        type: "integer",
        max: 180,
        min: 0,
        rebuild: true
      },
      radialSegments: true,
      disableImpostor: true
    }, this.parameters);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    ContactRepresentation2.__proto__ = StructureRepresentation$$1;
  ContactRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  ContactRepresentation2.prototype.constructor = ContactRepresentation2;
  ContactRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.radius = defaults(p.radius, 0.25);
    this.contactType = defaults(p.contactType, "polarBackbone");
    this.maxDistance = defaults(p.maxDistance, 3.5);
    this.maxAngle = defaults(p.maxAngle, 40);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  ContactRepresentation2.prototype.getContactData = function getContactData(sview) {
    var contactsFnDict = {
      polar: polarContacts,
      polarBackbone: polarBackboneContacts
    };
    var contactData = contactsFnDict[this.contactType](sview, this.maxDistance, this.maxAngle);
    return contactData;
  };
  ContactRepresentation2.prototype.getBondData = function getBondData2(sview, what, params) {
    var bondData = sview.getBondData(this.getBondParams(what, params));
    if (bondData.picking) {
      bondData.picking = new ContactPicker(bondData.picking.array, bondData.picking.structure, params.bondStore);
    }
    return bondData;
  };
  ContactRepresentation2.prototype.createData = function createData(sview) {
    var contactData = this.getContactData(sview);
    var cylinderBuffer = new CylinderBuffer(this.getBondData(sview, void 0, {
      bondSet: contactData.bondSet,
      bondStore: contactData.bondStore
    }), this.getBufferParams({
      openEnded: false,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    return {
      bufferList: [cylinderBuffer],
      bondSet: contactData.bondSet,
      bondStore: contactData.bondStore
    };
  };
  ContactRepresentation2.prototype.updateData = function updateData(what, data) {
    if (!what || what.position) {
      var contactData = this.getContactData(data.sview);
      data.bondSet = contactData.bondSet;
      data.bondStore = contactData.bondStore;
    }
    var bondParams = {
      bondSet: data.bondSet,
      bondStore: data.bondStore
    };
    var bondData = this.getBondData(data.sview, what, bondParams);
    var cylinderData = {};
    if (!what || what.position) {
      cylinderData.position = calculateCenterArray(bondData.position1, bondData.position2);
      cylinderData.position1 = bondData.position1;
      cylinderData.position2 = bondData.position2;
    }
    if (!what || what.color) {
      cylinderData.color = bondData.color;
      cylinderData.color2 = bondData.color2;
    }
    if (!what || what.radius) {
      cylinderData.radius = bondData.radius;
    }
    data.bufferList[0].setAttributes(cylinderData);
  };
  return ContactRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("contact", ContactRepresentation);
var DistanceRepresentation = function(StructureRepresentation$$1) {
  function DistanceRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "distance";
    this.parameters = Object.assign({
      labelSize: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      labelColor: {
        type: "color"
      },
      labelVisible: {
        type: "boolean"
      },
      labelZOffset: {
        type: "number",
        precision: 1,
        max: 20,
        min: -20,
        buffer: "zOffset"
      },
      labelUnit: {
        type: "select",
        rebuild: true,
        options: {"": "", angstrom: "angstrom", nm: "nm"}
      },
      atomPair: {
        type: "hidden",
        rebuild: true
      },
      radialSegments: true,
      disableImpostor: true
    }, this.parameters, {
      flatShaded: null,
      assembly: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    DistanceRepresentation2.__proto__ = StructureRepresentation$$1;
  DistanceRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  DistanceRepresentation2.prototype.constructor = DistanceRepresentation2;
  DistanceRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.radius = defaults(p.radius, 0.15);
    this.fontFamily = defaults(p.fontFamily, "sans-serif");
    this.fontStyle = defaults(p.fontStyle, "normal");
    this.fontWeight = defaults(p.fontWeight, "bold");
    this.sdf = defaults(p.sdf, Browser !== "Firefox");
    this.labelSize = defaults(p.labelSize, 2);
    this.labelColor = defaults(p.labelColor, 16777215);
    this.labelVisible = defaults(p.labelVisible, true);
    this.labelZOffset = defaults(p.labelZOffset, 0.5);
    this.labelUnit = defaults(p.labelUnit, "");
    this.atomPair = defaults(p.atomPair, []);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  DistanceRepresentation2.prototype.getDistanceData = function getDistanceData(sview, atomPair) {
    var n = atomPair.length;
    var text = new Array(n);
    var position = new Float32Array(n * 3);
    var sele1 = new Selection();
    var sele2 = new Selection();
    var bondStore = new BondStore();
    var ap1 = sview.getAtomProxy();
    var ap2 = sview.getAtomProxy();
    var j = 0;
    atomPair.forEach(function(pair, i) {
      var v1 = pair[0];
      var v2 = pair[1];
      if (Number.isInteger(v1) && Number.isInteger(v2)) {
        ap1.index = v1;
        ap2.index = v2;
      } else {
        sele1.setString(v1);
        sele2.setString(v2);
        var atomIndices1 = sview.getAtomIndices(sele1);
        var atomIndices2 = sview.getAtomIndices(sele2);
        if (atomIndices1.length && atomIndices2.length) {
          ap1.index = atomIndices1[0];
          ap2.index = atomIndices2[0];
        } else {
          j += 1;
          return;
        }
      }
      bondStore.addBond(ap1, ap2, 1);
      i -= j;
      var d = ap1.distanceTo(ap2);
      switch (this.labelUnit) {
        case "angstrom":
          text[i] = d.toFixed(2) + " " + String.fromCharCode(8491);
          break;
        case "nm":
          text[i] = (d / 10).toFixed(2) + " nm";
          break;
        default:
          text[i] = d.toFixed(2);
          break;
      }
      var i3 = i * 3;
      position[i3 + 0] = (ap1.x + ap2.x) / 2;
      position[i3 + 1] = (ap1.y + ap2.y) / 2;
      position[i3 + 2] = (ap1.z + ap2.z) / 2;
    }, this);
    if (j > 0) {
      n -= j;
      position = position.subarray(0, n * 3);
    }
    var bondSet = new BitArray(bondStore.count, true);
    return {
      text,
      position,
      bondSet,
      bondStore
    };
  };
  DistanceRepresentation2.prototype.getBondData = function getBondData2(sview, what, params) {
    var bondData = sview.getBondData(this.getBondParams(what, params));
    if (bondData.picking) {
      bondData.picking = new DistancePicker(bondData.picking.array, bondData.picking.structure, params.bondStore);
    }
    return bondData;
  };
  DistanceRepresentation2.prototype.create = function create2() {
    if (this.structureView.atomCount === 0) {
      return;
    }
    var n = this.atomPair.length;
    if (n === 0) {
      return;
    }
    var distanceData = this.getDistanceData(this.structureView, this.atomPair);
    var c = new Color(this.labelColor);
    this.textBuffer = new TextBuffer({
      position: distanceData.position,
      size: uniformArray(n, this.labelSize),
      color: uniformArray3(n, c.r, c.g, c.b),
      text: distanceData.text
    }, this.getBufferParams({
      fontFamily: this.fontFamily,
      fontStyle: this.fontStyle,
      fontWeight: this.fontWeight,
      sdf: this.sdf,
      zOffset: this.labelZOffset,
      opacity: 1,
      visible: this.labelVisible
    }));
    var bondParams = {
      bondSet: distanceData.bondSet,
      bondStore: distanceData.bondStore
    };
    var bondData = this.getBondData(this.structureView, void 0, bondParams);
    this.cylinderBuffer = new CylinderBuffer(bondData, this.getBufferParams({
      openEnded: false,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.dataList.push({
      sview: this.structureView,
      bondSet: distanceData.bondSet,
      bondStore: distanceData.bondStore,
      position: distanceData.position,
      bufferList: [this.textBuffer, this.cylinderBuffer]
    });
  };
  DistanceRepresentation2.prototype.update = function update2(what) {
    if (what.position) {
      this.build();
    } else {
      StructureRepresentation$$1.prototype.update.call(this, what);
    }
  };
  DistanceRepresentation2.prototype.updateData = function updateData(what, data) {
    var bondParams = {
      bondSet: data.bondSet,
      bondStore: data.bondStore
    };
    var bondData = this.getBondData(data.sview, what, bondParams);
    var cylinderData = {};
    var textData = {};
    var n = this.atomPair.length;
    if (what.labelSize) {
      textData.size = uniformArray(n, this.labelSize);
    }
    if (what.labelColor) {
      var c = new Color(this.labelColor);
      textData.color = uniformArray3(n, c.r, c.g, c.b);
    }
    if (what.color) {
      cylinderData.color = bondData.color;
      cylinderData.color2 = bondData.color2;
    }
    if (what.radius || what.scale) {
      cylinderData.radius = bondData.radius;
    }
    this.textBuffer.setAttributes(textData);
    this.cylinderBuffer.setAttributes(cylinderData);
  };
  DistanceRepresentation2.prototype.setVisibility = function setVisibility7(value2, noRenderRequest) {
    StructureRepresentation$$1.prototype.setVisibility.call(this, value2, true);
    if (this.textBuffer) {
      this.textBuffer.setVisibility(this.labelVisible && this.visible);
    }
    if (!noRenderRequest) {
      this.viewer.requestRender();
    }
    return this;
  };
  DistanceRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && params.labelSize) {
      what.labelSize = true;
    }
    if (params && (params.labelColor || params.labelColor === 0)) {
      what.labelColor = true;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    if (params && params.labelVisible !== void 0) {
      this.setVisibility(this.visible);
    }
    return this;
  };
  return DistanceRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("distance", DistanceRepresentation);
var VectorBuffer = function(Buffer$$1) {
  function VectorBuffer2(data, params) {
    var p = params || {};
    var n = data.position.length / 3;
    var n2 = n * 2;
    var color = new Color(defaults(p.color, "grey"));
    var linePosition = new Float32Array(n2 * 3);
    var lineColor = uniformArray3(n2, color.r, color.g, color.b);
    Buffer$$1.call(this, {
      position: linePosition,
      color: lineColor
    }, p);
    this.scale = defaults(p.scale, 1);
    this.setAttributes(data);
  }
  if (Buffer$$1)
    VectorBuffer2.__proto__ = Buffer$$1;
  VectorBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  VectorBuffer2.prototype.constructor = VectorBuffer2;
  var prototypeAccessors2 = {isLine: {}, vertexShader: {}, fragmentShader: {}};
  VectorBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var attributes = this.geometry.attributes;
    var position, vector;
    var aPosition;
    if (data.position && data.vector) {
      position = data.position;
      vector = data.vector;
      aPosition = attributes.position.array;
      attributes.position.needsUpdate = true;
    }
    var n = this.size / 2;
    var scale2 = this.scale;
    var i, j;
    if (data.position && data.vector) {
      for (var v = 0; v < n; v++) {
        i = v * 2 * 3;
        j = v * 3;
        aPosition[i + 0] = position[j + 0];
        aPosition[i + 1] = position[j + 1];
        aPosition[i + 2] = position[j + 2];
        aPosition[i + 3] = position[j + 0] + vector[j + 0] * scale2;
        aPosition[i + 4] = position[j + 1] + vector[j + 1] * scale2;
        aPosition[i + 5] = position[j + 2] + vector[j + 2] * scale2;
      }
    }
  };
  prototypeAccessors2.isLine.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Line.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Line.frag";
  };
  Object.defineProperties(VectorBuffer2.prototype, prototypeAccessors2);
  return VectorBuffer2;
}(Buffer);
var HelixorientRepresentation = function(StructureRepresentation$$1) {
  function HelixorientRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "helixorient";
    this.parameters = Object.assign({
      sphereDetail: true,
      disableImpostor: true
    }, this.parameters);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    HelixorientRepresentation2.__proto__ = StructureRepresentation$$1;
  HelixorientRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  HelixorientRepresentation2.prototype.constructor = HelixorientRepresentation2;
  HelixorientRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "sstruc");
    p.radius = defaults(p.radius, 0.15);
    p.scale = defaults(p.scale, 1);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  HelixorientRepresentation2.prototype.createData = function createData(sview) {
    var this$1 = this;
    var bufferList = [];
    var polymerList = [];
    this.structure.eachPolymer(function(polymer) {
      if (polymer.residueCount < 4) {
        return;
      }
      polymerList.push(polymer);
      var helixorient = new Helixorient(polymer);
      var position = helixorient.getPosition();
      var color = helixorient.getColor(this$1.getColorParams());
      var size = helixorient.getSize(this$1.radius, this$1.scale);
      var picking = helixorient.getPicking();
      bufferList.push(new SphereBuffer({
        position: position.center,
        color: color.color,
        radius: size.size,
        picking: picking.picking
      }, this$1.getBufferParams({
        sphereDetail: this$1.sphereDetail,
        disableImpostor: this$1.disableImpostor,
        dullInterior: true
      })), new VectorBuffer({
        position: position.center,
        vector: position.axis
      }, this$1.getBufferParams({
        color: "skyblue",
        scale: 1
      })), new VectorBuffer({
        position: position.center,
        vector: position.resdir
      }, this$1.getBufferParams({
        color: "lightgreen",
        scale: 1
      })));
    }, sview.getSelection());
    return {
      bufferList,
      polymerList
    };
  };
  HelixorientRepresentation2.prototype.updateData = function updateData(what, data) {
    if (Debug) {
      Log.time(this.type + " repr update");
    }
    what = what || {};
    for (var i = 0, il = data.polymerList.length; i < il; ++i) {
      var j = i * 3;
      var bufferData = {};
      var polymer = data.polymerList[i];
      var helixorient = new Helixorient(polymer);
      if (what.position) {
        var position = helixorient.getPosition();
        bufferData.position = position.center;
        data.bufferList[j + 1].setAttributes({
          position: position.center,
          vector: position.axis
        });
        data.bufferList[j + 2].setAttributes({
          position: position.center,
          vector: position.resdir
        });
      }
      data.bufferList[j].setAttributes(bufferData);
    }
    if (Debug) {
      Log.timeEnd(this.type + " repr update");
    }
  };
  return HelixorientRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("helixorient", HelixorientRepresentation);
var LicoriceRepresentation = function(BallAndStickRepresentation$$1) {
  function LicoriceRepresentation2(structure, viewer, params) {
    BallAndStickRepresentation$$1.call(this, structure, viewer, params);
    this.type = "licorice";
    this.parameters = Object.assign({}, this.parameters, {aspectRatio: null});
  }
  if (BallAndStickRepresentation$$1)
    LicoriceRepresentation2.__proto__ = BallAndStickRepresentation$$1;
  LicoriceRepresentation2.prototype = Object.create(BallAndStickRepresentation$$1 && BallAndStickRepresentation$$1.prototype);
  LicoriceRepresentation2.prototype.constructor = LicoriceRepresentation2;
  LicoriceRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.aspectRatio = 1;
    BallAndStickRepresentation$$1.prototype.init.call(this, p);
  };
  return LicoriceRepresentation2;
}(BallAndStickRepresentation);
RepresentationRegistry.add("licorice", LicoriceRepresentation);
ShaderRegistry.add("shader/HyperballStickImpostor.vert", "\nattribute vec3 mapping;\nattribute float radius;\nattribute float radius2;\nattribute vec3 position1;\nattribute vec3 position2;\nvarying mat4 matrix_near;\nvarying vec4 prime1;\nvarying vec4 prime2;\nvarying float vRadius;\nvarying float vRadius2;\n#ifdef PICKING\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\nattribute vec3 color2;\nvarying vec3 vColor1;\nvarying vec3 vColor2;\n#endif\nuniform float shrink;\nuniform mat4 modelViewProjectionMatrix;\nuniform mat4 modelViewProjectionMatrixInverse;\nvoid main(){\nvRadius = radius;\nvRadius2 = radius2;\nvec4 spaceposition;\nvec3 position_atom1;\nvec3 position_atom2;\nvec4 vertex_position;\n#ifdef PICKING\nvPickingColor = unpackColor( primitiveId );\n#else\nvColor1 = color;\nvColor2 = color2;\n#endif\nfloat radius1 = radius;\nposition_atom1 = position1;\nposition_atom2 = position2;\nfloat distance = distance( position_atom1, position_atom2 );\nspaceposition.z = mapping.z * distance;\nif (radius1 > radius2) {\nspaceposition.y = mapping.y * 1.5 * radius1;\nspaceposition.x = mapping.x * 1.5 * radius1;\n} else {\nspaceposition.y = mapping.y * 1.5 * radius2;\nspaceposition.x = mapping.x * 1.5 * radius2;\n}\nspaceposition.w = 1.0;\nvec4 e3 = vec4( 1.0 );\nvec3 e1, e1_temp, e2, e2_temp;\ne3.xyz = normalize(position_atom1-position_atom2);\nif (e3.z == 0.0) { e3.z = 0.0000000000001;}\nif ( (position_atom1.x - position_atom2.x) == 0.0) { position_atom1.x += 0.001;}\nif ( (position_atom1.y - position_atom2.y) == 0.0) { position_atom1.y += 0.001;}\nif ( (position_atom1.z - position_atom2.z) == 0.0) { position_atom1.z += 0.001;}\nvec4 focus = vec4( 1.0 );\nfocus.x = ( position_atom1.x*position_atom1.x - position_atom2.x*position_atom2.x +\n( radius2*radius2 - radius1*radius1 )*e3.x*e3.x/shrink )/(2.0*(position_atom1.x - position_atom2.x));\nfocus.y = ( position_atom1.y*position_atom1.y - position_atom2.y*position_atom2.y +\n( radius2*radius2 - radius1*radius1 )*e3.y*e3.y/shrink )/(2.0*(position_atom1.y - position_atom2.y));\nfocus.z = ( position_atom1.z*position_atom1.z - position_atom2.z*position_atom2.z +\n( radius2*radius2 - radius1*radius1 )*e3.z*e3.z/shrink )/(2.0*(position_atom1.z - position_atom2.z));\ne1.x = 1.0;\ne1.y = 1.0;\ne1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;\ne1_temp = e1 - focus.xyz;\ne1 = normalize(e1_temp);\ne2_temp = e1.yzx * e3.zxy - e1.zxy * e3.yzx;\ne2 = normalize(e2_temp);\nmat3 R= mat3( e1.xyz, e2.xyz, e3.xyz );\nvertex_position.xyz = R * spaceposition.xyz;\nvertex_position.w = 1.0;\nvertex_position.x += (position_atom1.x+position_atom2.x) / 2.0;\nvertex_position.y += (position_atom1.y+position_atom2.y) / 2.0;\nvertex_position.z += (position_atom1.z+position_atom2.z) / 2.0;\ngl_Position = modelViewProjectionMatrix * vertex_position;\nvec4 i_near, i_far;\nvec4 near = gl_Position;\nnear.z = 0.0 ;\nnear = modelViewProjectionMatrixInverse * near;\ni_near = near;\nvec4 far = gl_Position;\nfar.z = far.w ;\ni_far = modelViewProjectionMatrixInverse * far;\nprime1 = vec4( position_atom1 - (position_atom1 - focus.xyz)*shrink, 1.0 );\nprime2 = vec4( position_atom2 - (position_atom2 - focus.xyz)*shrink, 1.0 );\nfloat Rsquare = (radius1*radius1/shrink) - (\n(position_atom1.x - focus.x)*(position_atom1.x - focus.x) +\n(position_atom1.y - focus.y)*(position_atom1.y - focus.y) +\n(position_atom1.z - focus.z)*(position_atom1.z - focus.z)\n);\nfocus.w = Rsquare;\nmatrix_near = mat4( i_near, i_far, focus, e3 );\ngl_Position.z = 1.0;\n}");
ShaderRegistry.add("shader/HyperballStickImpostor.frag", "#define STANDARD\n#define IMPOSTOR\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float nearClip;\nuniform float shrink;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelViewProjectionMatrix;\nuniform mat4 modelViewMatrixInverseTranspose;\nuniform mat4 projectionMatrix;\nvarying mat4 matrix_near;\nvarying vec4 prime1;\nvarying vec4 prime2;\nvarying float vRadius;\nvarying float vRadius2;\n#ifdef PICKING\nuniform float objectId;\nvarying vec3 vPickingColor;\n#else\nvarying vec3 vColor1;\nvarying vec3 vColor2;\n#include common\n#include fog_pars_fragment\n#include bsdfs\n#include lights_pars\n#include lights_physical_pars_fragment\n#endif\nbool interior = false;\nfloat calcClip( vec4 cameraPos ){\nreturn dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\nfloat calcClip( vec3 cameraPos ){\nreturn calcClip( vec4( cameraPos, 1.0 ) );\n}\nfloat calcDepth( in vec3 cameraPos ){\nvec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\nreturn 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\nstruct Ray {\nvec3 origin ;\nvec3 direction ;\n};\nbool cutoff_plane (vec3 M, vec3 cutoff, vec3 x3){\nfloat a = x3.x;\nfloat b = x3.y;\nfloat c = x3.z;\nfloat d = -x3.x*cutoff.x-x3.y*cutoff.y-x3.z*cutoff.z;\nfloat l = a*M.x+b*M.y+c*M.z+d;\nif (l<0.0) {return true;}\nelse{return false;}\n}\nvec3 isect_surf(Ray r, mat4 matrix_coef){\nvec4 direction = vec4(r.direction, 0.0);\nvec4 origin = vec4(r.origin, 1.0);\nfloat a = dot(direction,(matrix_coef*direction));\nfloat b = dot(origin,(matrix_coef*direction));\nfloat c = dot(origin,(matrix_coef*origin));\nfloat delta =b*b-a*c;\ngl_FragColor.a = 1.0;\nif (delta<0.0){\ndiscard;\n}\nfloat t1 =(-b-sqrt(delta))/a;\nreturn r.origin+t1*r.direction;\n}\nvec3 isect_surf2(Ray r, mat4 matrix_coef){\nvec4 direction = vec4(r.direction, 0.0);\nvec4 origin = vec4(r.origin, 1.0);\nfloat a = dot(direction,(matrix_coef*direction));\nfloat b = dot(origin,(matrix_coef*direction));\nfloat c = dot(origin,(matrix_coef*origin));\nfloat delta =b*b-a*c;\ngl_FragColor.a = 1.0;\nif (delta<0.0){\ndiscard;\n}\nfloat t2 =(-b+sqrt(delta))/a;\nreturn r.origin+t2*r.direction;\n}\nRay primary_ray(vec4 near1, vec4 far1){\nvec3 near=near1.xyz/near1.w;\nvec3 far=far1.xyz/far1.w;\nreturn Ray(near,far-near);\n}\nfloat update_z_buffer(vec3 M, mat4 ModelViewP){\nfloat depth1;\nvec4 Ms=(ModelViewP*vec4(M,1.0));\nreturn depth1=(1.0+Ms.z/Ms.w)/2.0;\n}\nvoid main(){\nfloat radius = max( vRadius, vRadius2 );\nvec4 i_near, i_far, focus;\nvec3 e3, e1, e1_temp, e2;\ni_near = vec4(matrix_near[0][0],matrix_near[0][1],matrix_near[0][2],matrix_near[0][3]);\ni_far = vec4(matrix_near[1][0],matrix_near[1][1],matrix_near[1][2],matrix_near[1][3]);\nfocus = vec4(matrix_near[2][0],matrix_near[2][1],matrix_near[2][2],matrix_near[2][3]);\ne3 = vec3(matrix_near[3][0],matrix_near[3][1],matrix_near[3][2]);\ne1.x = 1.0;\ne1.y = 1.0;\ne1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;\ne1_temp = e1 - focus.xyz;\ne1 = normalize(e1_temp);\ne2 = normalize(cross(e1,e3));\nvec4 equation = focus;\nfloat shrinkfactor = shrink;\nfloat t1 = -1.0/(1.0-shrinkfactor);\nfloat t2 = 1.0/(shrinkfactor);\nvec4 colonne1, colonne2, colonne3, colonne4;\nmat4 mat;\nvec3 equation1 = vec3(t2,t2,t1);\nfloat A1 = - e1.x*equation.x - e1.y*equation.y - e1.z*equation.z;\nfloat A2 = - e2.x*equation.x - e2.y*equation.y - e2.z*equation.z;\nfloat A3 = - e3.x*equation.x - e3.y*equation.y - e3.z*equation.z;\nfloat A11 = equation1.x*e1.x*e1.x + equation1.y*e2.x*e2.x + equation1.z*e3.x*e3.x;\nfloat A21 = equation1.x*e1.x*e1.y + equation1.y*e2.x*e2.y + equation1.z*e3.x*e3.y;\nfloat A31 = equation1.x*e1.x*e1.z + equation1.y*e2.x*e2.z + equation1.z*e3.x*e3.z;\nfloat A41 = equation1.x*e1.x*A1 + equation1.y*e2.x*A2 + equation1.z*e3.x*A3;\nfloat A22 = equation1.x*e1.y*e1.y + equation1.y*e2.y*e2.y + equation1.z*e3.y*e3.y;\nfloat A32 = equation1.x*e1.y*e1.z + equation1.y*e2.y*e2.z + equation1.z*e3.y*e3.z;\nfloat A42 = equation1.x*e1.y*A1 + equation1.y*e2.y*A2 + equation1.z*e3.y*A3;\nfloat A33 = equation1.x*e1.z*e1.z + equation1.y*e2.z*e2.z + equation1.z*e3.z*e3.z;\nfloat A43 = equation1.x*e1.z*A1 + equation1.y*e2.z*A2 + equation1.z*e3.z*A3;\nfloat A44 = equation1.x*A1*A1 + equation1.y*A2*A2 + equation1.z*A3*A3 - equation.w;\ncolonne1 = vec4(A11,A21,A31,A41);\ncolonne2 = vec4(A21,A22,A32,A42);\ncolonne3 = vec4(A31,A32,A33,A43);\ncolonne4 = vec4(A41,A42,A43,A44);\nmat = mat4(colonne1,colonne2,colonne3,colonne4);\nRay ray = primary_ray(i_near,i_far) ;\nvec3 M;\nM = isect_surf(ray, mat);\nif (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }\nvec4 M1 = vec4(M,1.0);\nvec4 M2 = mat*M1;\nvec3 _normal = ( modelViewMatrixInverseTranspose * M2 ).xyz;\ngl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\n#ifdef NEAR_CLIP\nif( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 ){\nM = isect_surf2(ray, mat);\nif( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 )\ndiscard;\ninterior = true;\ngl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / radius ) );\n}\n}else if( gl_FragDepthEXT <= 0.0 ){\nM = isect_surf2(ray, mat);\ninterior = true;\ngl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix);\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );\n}\n}\n#else\nif( gl_FragDepthEXT <= 0.0 ){\nM = isect_surf2(ray, mat);\ninterior = true;\ngl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\nif( gl_FragDepthEXT >= 0.0 ){\ngl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );\n}\n}\n#endif\nif (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }\nif (gl_FragDepthEXT < 0.0)\ndiscard;\nif (gl_FragDepthEXT > 1.0)\ndiscard;\nfloat distance_ratio = ((M.x-prime2.x)*e3.x + (M.y-prime2.y)*e3.y +(M.z-prime2.z)*e3.z) /\ndistance(prime2.xyz,prime1.xyz);\n#ifdef PICKING\ngl_FragColor = vec4( vPickingColor, objectId );\n#else\nvec3 vViewPosition = -( modelViewMatrix * vec4( M, 1.0 ) ).xyz;\nvec3 vNormal = _normal;\nvec3 vColor;\nif( distance_ratio>0.5 ){\nvColor = vColor1;\n}else{\nvColor = vColor2;\n}\nvec4 diffuseColor = vec4( diffuse, opacity );\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveLight = emissive;\n#include color_fragment\n#include roughnessmap_fragment\n#include metalnessmap_fragment\nvec3 normal = normalize( vNormal );\nif( interior ){\nnormal = vec3( 0.0, 0.0, 0.4 );\n}\n#include lights_physical_fragment\n#include lights_template\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#include premultiplied_alpha_fragment\n#include tonemapping_fragment\n#include encodings_fragment\n#include fog_fragment\n#endif\n}");
var mapping$2 = new Float32Array([
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  1
]);
var mappingIndices$2 = new Uint16Array([
  0,
  1,
  2,
  0,
  2,
  3,
  1,
  5,
  6,
  1,
  6,
  2,
  4,
  6,
  5,
  4,
  7,
  6,
  0,
  7,
  4,
  0,
  3,
  7,
  0,
  5,
  1,
  0,
  4,
  5,
  3,
  2,
  6,
  3,
  6,
  7
]);
var BoxBuffer = function(MappedBuffer$$1) {
  function BoxBuffer2() {
    MappedBuffer$$1.apply(this, arguments);
  }
  if (MappedBuffer$$1)
    BoxBuffer2.__proto__ = MappedBuffer$$1;
  BoxBuffer2.prototype = Object.create(MappedBuffer$$1 && MappedBuffer$$1.prototype);
  BoxBuffer2.prototype.constructor = BoxBuffer2;
  var prototypeAccessors2 = {mapping: {}, mappingIndices: {}, mappingIndicesSize: {}, mappingType: {}, mappingSize: {}, mappingItemSize: {}};
  prototypeAccessors2.mapping.get = function() {
    return mapping$2;
  };
  prototypeAccessors2.mappingIndices.get = function() {
    return mappingIndices$2;
  };
  prototypeAccessors2.mappingIndicesSize.get = function() {
    return 36;
  };
  prototypeAccessors2.mappingType.get = function() {
    return "v3";
  };
  prototypeAccessors2.mappingSize.get = function() {
    return 8;
  };
  prototypeAccessors2.mappingItemSize.get = function() {
    return 3;
  };
  Object.defineProperties(BoxBuffer2.prototype, prototypeAccessors2);
  return BoxBuffer2;
}(MappedBuffer);
var HyperballStickImpostorBuffer = function(BoxBuffer$$1) {
  function HyperballStickImpostorBuffer2(data, params) {
    BoxBuffer$$1.call(this, data, params);
    var d = data || {};
    var p = params || {};
    var shrink = defaults(p.shrink, 0.14);
    this.addUniforms({
      modelViewProjectionMatrix: {value: new Matrix4()},
      modelViewProjectionMatrixInverse: {value: new Matrix4()},
      modelViewMatrixInverseTranspose: {value: new Matrix4()},
      shrink: {value: shrink}
    });
    this.addAttributes({
      position1: {type: "v3", value: null},
      position2: {type: "v3", value: null},
      color2: {type: "c", value: null},
      radius: {type: "f", value: null},
      radius2: {type: "f", value: null}
    });
    this.setAttributes(d);
    this.makeMapping();
  }
  if (BoxBuffer$$1)
    HyperballStickImpostorBuffer2.__proto__ = BoxBuffer$$1;
  HyperballStickImpostorBuffer2.prototype = Object.create(BoxBuffer$$1 && BoxBuffer$$1.prototype);
  HyperballStickImpostorBuffer2.prototype.constructor = HyperballStickImpostorBuffer2;
  var prototypeAccessors2 = {parameters: {}, isImpostor: {}, vertexShader: {}, fragmentShader: {}};
  prototypeAccessors2.parameters.get = function() {
    return Object.assign.call(this, {
      shrink: {uniform: true}
    }, BoxBuffer$$1.prototype.parameters);
  };
  prototypeAccessors2.isImpostor.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "HyperballStickImpostor.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "HyperballStickImpostor.frag";
  };
  Object.defineProperties(HyperballStickImpostorBuffer2.prototype, prototypeAccessors2);
  return HyperballStickImpostorBuffer2;
}(BoxBuffer);
var HyperballStickBuffer = function HyperballStickBuffer2(data, params) {
  if (!ExtensionFragDepth || params && params.disableImpostor) {
    data.radius = calculateMinArray(data.radius1, data.radius2);
    return new CylinderGeometryBuffer(data, params);
  } else {
    return new HyperballStickImpostorBuffer(data, params);
  }
};
var HyperballRepresentation = function(LicoriceRepresentation$$1) {
  function HyperballRepresentation2(structure, viewer, params) {
    LicoriceRepresentation$$1.call(this, structure, viewer, params);
    this.type = "hyperball";
    this.parameters = Object.assign({
      shrink: {
        type: "number",
        precision: 3,
        max: 1,
        min: 1e-3,
        buffer: true
      }
    }, this.parameters, {
      multipleBond: null,
      bondSpacing: null
    });
  }
  if (LicoriceRepresentation$$1)
    HyperballRepresentation2.__proto__ = LicoriceRepresentation$$1;
  HyperballRepresentation2.prototype = Object.create(LicoriceRepresentation$$1 && LicoriceRepresentation$$1.prototype);
  HyperballRepresentation2.prototype.constructor = HyperballRepresentation2;
  HyperballRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.scale = defaults(p.scale, 0.2);
    p.radius = defaults(p.radius, "vdw");
    this.shrink = defaults(p.shrink, 0.12);
    LicoriceRepresentation$$1.prototype.init.call(this, p);
  };
  HyperballRepresentation2.prototype.getBondParams = function getBondParams(what, params) {
    if (!what || what.radius) {
      params = Object.assign({radius2: true}, params);
    }
    return LicoriceRepresentation$$1.prototype.getBondParams.call(this, what, params);
  };
  HyperballRepresentation2.prototype.createData = function createData(sview) {
    var sphereBuffer = new SphereBuffer(sview.getAtomData(this.getAtomParams()), this.getBufferParams({
      sphereDetail: this.sphereDetail,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.__center = new Float32Array(sview.bondCount * 3);
    var stickBuffer = new HyperballStickBuffer(sview.getBondData(this.getBondParams()), this.getBufferParams({
      shrink: this.shrink,
      radialSegments: this.radialSegments,
      dullInterior: true
    }));
    return {
      bufferList: [sphereBuffer, stickBuffer]
    };
  };
  HyperballRepresentation2.prototype.updateData = function updateData(what, data) {
    var atomData = data.sview.getAtomData(this.getAtomParams());
    var bondData = data.sview.getBondData(this.getBondParams());
    var sphereData = {};
    var stickData = {};
    if (!what || what.position) {
      sphereData.position = atomData.position;
      var from = bondData.position1;
      var to = bondData.position2;
      stickData.position = calculateCenterArray(from, to, this.__center);
      stickData.position1 = from;
      stickData.position2 = to;
    }
    if (!what || what.color) {
      sphereData.color = atomData.color;
      stickData.color = bondData.color;
      stickData.color2 = bondData.color2;
    }
    if (!what || what.radius) {
      sphereData.radius = atomData.radius;
      stickData.radius = bondData.radius;
      stickData.radius2 = bondData.radius2;
    }
    data.bufferList[0].setAttributes(sphereData);
    data.bufferList[1].setAttributes(stickData);
  };
  return HyperballRepresentation2;
}(LicoriceRepresentation);
RepresentationRegistry.add("hyperball", HyperballRepresentation);
function LabelFactory(type2, text) {
  this.type = type2;
  this.text = text || {};
}
LabelFactory.prototype = {
  constructor: LabelFactory,
  atomLabel: function(a) {
    var type2 = this.type;
    var l;
    switch (type2) {
      case "atomname":
        l = a.atomname;
        break;
      case "atomindex":
        l = "" + a.index;
        break;
      case "occupancy":
        l = a.occupancy.toFixed(2);
        break;
      case "bfactor":
        l = a.bfactor.toFixed(2);
        break;
      case "serial":
        l = "" + a.serial;
        break;
      case "element":
        l = a.element;
        break;
      case "atom":
        l = a.atomname + "|" + a.index;
        break;
      case "resname":
        l = a.resname;
        break;
      case "resno":
        l = "" + a.resno;
        break;
      case "res":
        var resname = a.resname.toUpperCase();
        l = (AA1[resname] || resname) + a.resno;
        break;
      case "text":
        l = this.text[a.index];
        break;
      default:
        l = a.qualifiedName();
        break;
    }
    return l === void 0 ? "" : l;
  }
};
LabelFactory.types = {
  "": "",
  atomname: "atom name",
  atomindex: "atom index",
  occupancy: "occupancy",
  bfactor: "b-factor",
  serial: "serial",
  element: "element",
  atom: "atom name + index",
  resname: "residue name",
  resno: "residue no",
  res: "residue name + no",
  text: "text",
  qualified: "qualified name"
};
var LabelRepresentation = function(StructureRepresentation$$1) {
  function LabelRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "label";
    this.parameters = Object.assign({
      labelType: {
        type: "select",
        options: LabelFactory.types,
        rebuild: true
      },
      labelText: {
        type: "hidden",
        rebuild: true
      },
      fontFamily: {
        type: "select",
        options: {
          "sans-serif": "sans-serif",
          monospace: "monospace",
          serif: "serif"
        },
        buffer: true
      },
      fontStyle: {
        type: "select",
        options: {
          normal: "normal",
          italic: "italic"
        },
        buffer: true
      },
      fontWeight: {
        type: "select",
        options: {
          normal: "normal",
          bold: "bold"
        },
        buffer: true
      },
      sdf: {
        type: "boolean",
        buffer: true
      },
      xOffset: {
        type: "number",
        precision: 1,
        max: 20,
        min: -20,
        buffer: true
      },
      yOffset: {
        type: "number",
        precision: 1,
        max: 20,
        min: -20,
        buffer: true
      },
      zOffset: {
        type: "number",
        precision: 1,
        max: 20,
        min: -20,
        buffer: true
      },
      attachment: {
        type: "select",
        options: {
          "bottom-left": "bottom-left",
          "bottom-center": "bottom-center",
          "bottom-right": "bottom-right",
          "middle-left": "middle-left",
          "middle-center": "middle-center",
          "middle-right": "middle-right",
          "top-left": "top-left",
          "top-center": "top-center",
          "top-right": "top-right"
        },
        rebuild: true
      },
      showBorder: {
        type: "boolean",
        buffer: true
      },
      borderColor: {
        type: "color",
        buffer: true
      },
      borderWidth: {
        type: "number",
        precision: 2,
        max: 0.3,
        min: 0,
        buffer: true
      },
      showBackground: {
        type: "boolean",
        rebuild: true
      },
      backgroundColor: {
        type: "color",
        buffer: true
      },
      backgroundMargin: {
        type: "number",
        precision: 2,
        max: 2,
        min: 0,
        rebuild: true
      },
      backgroundOpacity: {
        type: "range",
        step: 0.01,
        max: 1,
        min: 0,
        buffer: true
      }
    }, this.parameters, {
      side: null,
      flatShaded: null,
      wireframe: null,
      linewidth: null,
      roughness: null,
      metalness: null,
      diffuse: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    LabelRepresentation2.__proto__ = StructureRepresentation$$1;
  LabelRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  LabelRepresentation2.prototype.constructor = LabelRepresentation2;
  LabelRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    this.labelType = defaults(p.labelType, "res");
    this.labelText = defaults(p.labelText, {});
    this.fontFamily = defaults(p.fontFamily, "sans-serif");
    this.fontStyle = defaults(p.fontStyle, "normal");
    this.fontWeight = defaults(p.fontWeight, "bold");
    this.sdf = defaults(p.sdf, Browser === "Chrome");
    this.xOffset = defaults(p.xOffset, 0);
    this.yOffset = defaults(p.yOffset, 0);
    this.zOffset = defaults(p.zOffset, 0.5);
    this.attachment = defaults(p.attachment, "bottom-left");
    this.showBorder = defaults(p.showBorder, false);
    this.borderColor = defaults(p.borderColor, "lightgrey");
    this.borderWidth = defaults(p.borderWidth, 0.15);
    this.showBackground = defaults(p.showBackground, false);
    this.backgroundColor = defaults(p.backgroundColor, "lightgrey");
    this.backgroundMargin = defaults(p.backgroundMargin, 0.5);
    this.backgroundOpacity = defaults(p.backgroundOpacity, 1);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  LabelRepresentation2.prototype.createData = function createData(sview) {
    var what = {position: true, color: true, radius: true};
    var atomData = sview.getAtomData(this.getAtomParams(what));
    var text = [];
    var labelFactory = new LabelFactory(this.labelType, this.labelText);
    sview.eachAtom(function(ap) {
      text.push(labelFactory.atomLabel(ap));
    });
    var textBuffer = new TextBuffer({
      position: atomData.position,
      size: atomData.radius,
      color: atomData.color,
      text
    }, this.getBufferParams({
      fontFamily: this.fontFamily,
      fontStyle: this.fontStyle,
      fontWeight: this.fontWeight,
      sdf: this.sdf,
      xOffset: this.xOffset,
      yOffset: this.yOffset,
      zOffset: this.zOffset,
      attachment: this.attachment,
      showBorder: this.showBorder,
      borderColor: this.borderColor,
      borderWidth: this.borderWidth,
      showBackground: this.showBackground,
      backgroundColor: this.backgroundColor,
      backgroundMargin: this.backgroundMargin,
      backgroundOpacity: this.backgroundOpacity
    }));
    return {
      bufferList: [textBuffer]
    };
  };
  LabelRepresentation2.prototype.updateData = function updateData(what, data) {
    var atomData = data.sview.getAtomData(this.getAtomParams(what));
    var textData = {};
    if (!what || what.position) {
      textData.position = atomData.position;
    }
    if (!what || what.radius) {
      textData.size = atomData.radius;
    }
    if (!what || what.color) {
      textData.color = atomData.color;
    }
    data.bufferList[0].setAttributes(textData);
  };
  return LabelRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("label", LabelRepresentation);
var LineRepresentation = function(StructureRepresentation$$1) {
  function LineRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "line";
    this.parameters = Object.assign({
      multipleBond: {
        type: "select",
        rebuild: true,
        options: {
          off: "off",
          symmetric: "symmetric",
          offset: "offset"
        }
      },
      bondSpacing: {
        type: "number",
        precision: 2,
        max: 2,
        min: 0.5
      }
    }, this.parameters, {
      flatShaded: null,
      side: null,
      wireframe: null,
      roughness: null,
      metalness: null,
      diffuse: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    LineRepresentation2.__proto__ = StructureRepresentation$$1;
  LineRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  LineRepresentation2.prototype.constructor = LineRepresentation2;
  LineRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    this.multipleBond = defaults(p.multipleBond, "off");
    this.bondSpacing = defaults(p.bondSpacing, 1);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  LineRepresentation2.prototype.getBondParams = function getBondParams(what, params) {
    params = Object.assign({
      multipleBond: this.multipleBond,
      bondSpacing: this.bondSpacing,
      radiusParams: {radius: 0.1, scale: 1}
    }, params);
    return StructureRepresentation$$1.prototype.getBondParams.call(this, what, params);
  };
  LineRepresentation2.prototype.createData = function createData(sview) {
    var what = {position: true, color: true};
    var bondData = sview.getBondData(this.getBondParams(what));
    var lineBuffer = new LineBuffer(bondData, this.getBufferParams());
    return {
      bufferList: [lineBuffer]
    };
  };
  LineRepresentation2.prototype.updateData = function updateData(what, data) {
    var bondData = data.sview.getBondData(this.getBondParams(what));
    var lineData = {};
    if (!what || what.position) {
      lineData.position1 = bondData.position1;
      lineData.position2 = bondData.position2;
    }
    if (!what || what.color) {
      lineData.color = bondData.color;
      lineData.color2 = bondData.color2;
    }
    data.bufferList[0].setAttributes(lineData);
  };
  LineRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && params.bondSpacing) {
      what.position = true;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return LineRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("line", LineRepresentation);
function Grid(length, width, height, DataCtor, elemSize) {
  DataCtor = DataCtor || Int32Array;
  elemSize = elemSize || 1;
  var j;
  var data = new DataCtor(length * width * height * elemSize);
  function index(x, y, z) {
    return ((x * width + y) * height + z) * elemSize;
  }
  this.data = data;
  this.index = index;
  this.set = function(x, y, z) {
    var arguments$1 = arguments;
    var i = index(x, y, z);
    for (j = 0; j < elemSize; ++j) {
      data[i + j] = arguments$1[3 + j];
    }
  };
  this.toArray = function(x, y, z, array, offset) {
    var i = index(x, y, z);
    if (array === void 0) {
      array = [];
    }
    if (offset === void 0) {
      offset = 0;
    }
    for (j = 0; j < elemSize; ++j) {
      array[offset + j] = data[i + j];
    }
  };
  this.fromArray = function(x, y, z, array, offset) {
    var i = index(x, y, z);
    if (offset === void 0) {
      offset = 0;
    }
    for (j = 0; j < elemSize; ++j) {
      data[i + j] = array[offset + j];
    }
  };
  this.copy = function(grid) {
    this.data.set(grid.data);
  };
  this.clone = function() {
    return new Grid(length, width, height, DataCtor, elemSize).copy(this);
  };
}
function EDTSurface(coordList, radiusList, indexList) {
  var radiusDict = getRadiusDict(radiusList);
  var bbox = computeBoundingBox(coordList);
  if (coordList.length === 0) {
    bbox[0].set([0, 0, 0]);
    bbox[1].set([0, 0, 0]);
  }
  var min = bbox[0];
  var max2 = bbox[1];
  var probeRadius, scaleFactor, cutoff;
  var pLength, pWidth, pHeight;
  var matrix2, ptran;
  var depty, widxz;
  var cutRadius;
  var setAtomID;
  var vpBits, vpDistance, vpAtomID;
  function init3(btype, _probeRadius, _scaleFactor, _cutoff, _setAtomID) {
    probeRadius = _probeRadius || 1.4;
    scaleFactor = _scaleFactor || 2;
    setAtomID = _setAtomID || true;
    var maxRadius2 = 0;
    for (var radius in radiusDict) {
      maxRadius2 = Math.max(maxRadius2, radius);
    }
    var grid = getSurfaceGrid(min, max2, maxRadius2, scaleFactor, btype ? probeRadius : 0);
    pLength = grid.dim[0];
    pWidth = grid.dim[1];
    pHeight = grid.dim[2];
    matrix2 = grid.matrix;
    ptran = grid.tran;
    scaleFactor = grid.scaleFactor;
    depty = {};
    widxz = {};
    boundingatom(btype);
    cutRadius = probeRadius * scaleFactor;
    if (_cutoff) {
      cutoff = _cutoff;
    } else {
      cutoff = probeRadius / scaleFactor;
    }
    vpBits = new Uint8Array(pLength * pWidth * pHeight);
    if (btype) {
      vpDistance = new Float64Array(pLength * pWidth * pHeight);
    }
    if (setAtomID) {
      vpAtomID = new Int32Array(pLength * pWidth * pHeight);
    }
  }
  var INOUT = 1;
  var ISDONE = 2;
  var ISBOUND = 4;
  var nb = [
    new Int32Array([1, 0, 0]),
    new Int32Array([-1, 0, 0]),
    new Int32Array([0, 1, 0]),
    new Int32Array([0, -1, 0]),
    new Int32Array([0, 0, 1]),
    new Int32Array([0, 0, -1]),
    new Int32Array([1, 1, 0]),
    new Int32Array([1, -1, 0]),
    new Int32Array([-1, 1, 0]),
    new Int32Array([-1, -1, 0]),
    new Int32Array([1, 0, 1]),
    new Int32Array([1, 0, -1]),
    new Int32Array([-1, 0, 1]),
    new Int32Array([-1, 0, -1]),
    new Int32Array([0, 1, 1]),
    new Int32Array([0, 1, -1]),
    new Int32Array([0, -1, 1]),
    new Int32Array([0, -1, -1]),
    new Int32Array([1, 1, 1]),
    new Int32Array([1, 1, -1]),
    new Int32Array([1, -1, 1]),
    new Int32Array([-1, 1, 1]),
    new Int32Array([1, -1, -1]),
    new Int32Array([-1, -1, 1]),
    new Int32Array([-1, 1, -1]),
    new Int32Array([-1, -1, -1])
  ];
  this.getVolume = function(type2, probeRadius2, scaleFactor2, cutoff2, setAtomID2) {
    console.time("EDTSurface.getVolume");
    var btype = type2 !== "vws";
    init3(btype, probeRadius2, scaleFactor2, cutoff2, setAtomID2);
    fillvoxels(btype);
    buildboundary();
    if (type2 === "ms" || type2 === "ses") {
      fastdistancemap();
    }
    if (type2 === "ses") {
      boundingatom(false);
      fillvoxelswaals();
    }
    marchingcubeinit(type2);
    for (var i = 0, il = vpAtomID.length; i < il; ++i) {
      vpAtomID[i] = indexList[vpAtomID[i]];
    }
    console.timeEnd("EDTSurface.getVolume");
    return {
      data: vpBits,
      nx: pHeight,
      ny: pWidth,
      nz: pLength,
      atomindex: vpAtomID
    };
  };
  this.getSurface = function(type2, probeRadius2, scaleFactor2, cutoff2, setAtomID2, smooth, contour) {
    var vd = this.getVolume(type2, probeRadius2, scaleFactor2, cutoff2, setAtomID2);
    var volsurf = new VolumeSurface(vd.data, vd.nx, vd.ny, vd.nz, vd.atomindex);
    return volsurf.getSurface(1, smooth, void 0, matrix2, contour);
  };
  function boundingatom(btype) {
    var r;
    var j;
    var k;
    var txz;
    var tdept;
    var sradius;
    var tradius;
    var widxzR;
    var deptyName;
    var indx;
    for (var name in radiusDict) {
      r = radiusDict[name];
      if (depty[name]) {
        continue;
      }
      if (!btype) {
        tradius = r * scaleFactor + 0.5;
      } else {
        tradius = (r + probeRadius) * scaleFactor + 0.5;
      }
      sradius = tradius * tradius;
      widxzR = Math.floor(tradius) + 1;
      deptyName = new Int32Array(widxzR * widxzR);
      indx = 0;
      for (j = 0; j < widxzR; ++j) {
        for (k = 0; k < widxzR; ++k) {
          txz = j * j + k * k;
          if (txz > sradius) {
            deptyName[indx] = -1;
          } else {
            tdept = Math.sqrt(sradius - txz);
            deptyName[indx] = Math.floor(tdept);
          }
          ++indx;
        }
      }
      widxz[name] = widxzR;
      depty[name] = deptyName;
    }
  }
  function fillatom(idx) {
    var ci = idx * 3;
    var ri = idx;
    var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
    var ii, jj, kk;
    cx = Math.floor(0.5 + scaleFactor * (coordList[ci] + ptran[0]));
    cy = Math.floor(0.5 + scaleFactor * (coordList[ci + 1] + ptran[1]));
    cz = Math.floor(0.5 + scaleFactor * (coordList[ci + 2] + ptran[2]));
    var at = radiusList[ri];
    var deptyAt = depty[at];
    var nind = 0;
    var pWH = pWidth * pHeight;
    var n = widxz[at];
    var deptyAtNind;
    for (i = 0; i < n; ++i) {
      for (j = 0; j < n; ++j) {
        deptyAtNind = deptyAt[nind];
        if (deptyAtNind !== -1) {
          for (ii = -1; ii < 2; ++ii) {
            for (jj = -1; jj < 2; ++jj) {
              for (kk = -1; kk < 2; ++kk) {
                if (ii !== 0 && jj !== 0 && kk !== 0) {
                  mi = ii * i;
                  mk = kk * j;
                  for (k = 0; k <= deptyAtNind; ++k) {
                    mj = k * jj;
                    si = cx + mi;
                    sj = cy + mj;
                    sk = cz + mk;
                    if (si < 0 || sj < 0 || sk < 0 || si >= pLength || sj >= pWidth || sk >= pHeight) {
                      continue;
                    }
                    var index = si * pWH + sj * pHeight + sk;
                    if (!setAtomID) {
                      vpBits[index] |= INOUT;
                    } else {
                      if (!(vpBits[index] & INOUT)) {
                        vpBits[index] |= INOUT;
                        vpAtomID[index] = idx;
                      } else if (vpBits[index] & INOUT) {
                        var ci2 = vpAtomID[index];
                        if (ci2 !== ci) {
                          ox = cx + mi - Math.floor(0.5 + scaleFactor * (coordList[ci2] + ptran[0]));
                          oy = cy + mj - Math.floor(0.5 + scaleFactor * (coordList[ci2 + 1] + ptran[1]));
                          oz = cz + mk - Math.floor(0.5 + scaleFactor * (coordList[ci2 + 2] + ptran[2]));
                          if (mi * mi + mj * mj + mk * mk < ox * ox + oy * oy + oz * oz) {
                            vpAtomID[index] = idx;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        nind++;
      }
    }
  }
  function fillvoxels(btype) {
    console.time("EDTSurface fillvoxels");
    var i, il;
    for (i = 0, il = vpBits.length; i < il; ++i) {
      vpBits[i] = 0;
      if (btype) {
        vpDistance[i] = -1;
      }
      if (setAtomID) {
        vpAtomID[i] = -1;
      }
    }
    for (i = 0, il = coordList.length / 3; i < il; ++i) {
      fillatom(i);
    }
    for (i = 0, il = vpBits.length; i < il; ++i) {
      if (vpBits[i] & INOUT) {
        vpBits[i] |= ISDONE;
      }
    }
    console.timeEnd("EDTSurface fillvoxels");
  }
  function fillAtomWaals(idx) {
    var ci = idx * 3;
    var ri = idx;
    var cx;
    var cy;
    var cz;
    var ox;
    var oy;
    var oz;
    var nind = 0;
    var mi;
    var mj;
    var mk;
    var si;
    var sj;
    var sk;
    var i;
    var j;
    var k;
    var ii;
    var jj;
    var kk;
    var n;
    cx = Math.floor(0.5 + scaleFactor * (coordList[ci] + ptran[0]));
    cy = Math.floor(0.5 + scaleFactor * (coordList[ci + 1] + ptran[1]));
    cz = Math.floor(0.5 + scaleFactor * (coordList[ci + 2] + ptran[2]));
    var at = radiusList[ri];
    var pWH = pWidth * pHeight;
    for (i = 0, n = widxz[at]; i < n; ++i) {
      for (j = 0; j < n; ++j) {
        if (depty[at][nind] !== -1) {
          for (ii = -1; ii < 2; ++ii) {
            for (jj = -1; jj < 2; ++jj) {
              for (kk = -1; kk < 2; ++kk) {
                if (ii !== 0 && jj !== 0 && kk !== 0) {
                  mi = ii * i;
                  mk = kk * j;
                  for (k = 0; k <= depty[at][nind]; ++k) {
                    mj = k * jj;
                    si = cx + mi;
                    sj = cy + mj;
                    sk = cz + mk;
                    if (si < 0 || sj < 0 || sk < 0 || si >= pLength || sj >= pWidth || sk >= pHeight) {
                      continue;
                    }
                    var index = si * pWH + sj * pHeight + sk;
                    if (!(vpBits[index] & ISDONE)) {
                      vpBits[index] |= ISDONE;
                      if (setAtomID) {
                        vpAtomID[index] = idx;
                      }
                    } else if (setAtomID) {
                      var ci2 = vpAtomID[index];
                      ox = Math.floor(0.5 + scaleFactor * (coordList[ci2] + ptran[0]));
                      oy = Math.floor(0.5 + scaleFactor * (coordList[ci2 + 1] + ptran[1]));
                      oz = Math.floor(0.5 + scaleFactor * (coordList[ci2 + 2] + ptran[2]));
                      if (mi * mi + mj * mj + mk * mk < ox * ox + oy * oy + oz * oz) {
                        vpAtomID[index] = idx;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        nind++;
      }
    }
  }
  function fillvoxelswaals() {
    var i, il;
    for (i = 0, il = vpBits.length; i < il; ++i) {
      vpBits[i] &= ~ISDONE;
    }
    for (i = 0, il = coordList.length / 3; i < il; ++i) {
      fillAtomWaals(i);
    }
  }
  function buildboundary() {
    var i, j, k;
    var pWH = pWidth * pHeight;
    for (i = 0; i < pLength; ++i) {
      for (j = 0; j < pHeight; ++j) {
        for (k = 0; k < pWidth; ++k) {
          var index = i * pWH + k * pHeight + j;
          if (vpBits[index] & INOUT) {
            var ii = 0;
            while (ii < 26) {
              var ti = i + nb[ii][0];
              var tj = j + nb[ii][2];
              var tk = k + nb[ii][1];
              if (ti > -1 && ti < pLength && tk > -1 && tk < pWidth && tj > -1 && tj < pHeight && !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
                vpBits[index] |= ISBOUND;
                break;
              } else {
                ii++;
              }
            }
          }
        }
      }
    }
  }
  function fastdistancemap() {
    console.time("EDTSurface fastdistancemap");
    var i, j, k, n;
    var boundPoint = new Grid(pLength, pWidth, pHeight, Uint16Array, 3);
    var pWH = pWidth * pHeight;
    var cutRSq = cutRadius * cutRadius;
    var totalsurfacevox = 0;
    var index;
    for (i = 0; i < pLength; ++i) {
      for (j = 0; j < pWidth; ++j) {
        for (k = 0; k < pHeight; ++k) {
          index = i * pWH + j * pHeight + k;
          vpBits[index] &= ~ISDONE;
          if (vpBits[index] & INOUT) {
            if (vpBits[index] & ISBOUND) {
              boundPoint.set(i, j, k, i, j, k);
              vpDistance[index] = 0;
              vpBits[index] |= ISDONE;
              totalsurfacevox += 1;
            }
          }
        }
      }
    }
    var inarray = new Int32Array(3 * totalsurfacevox);
    var positin = 0;
    var outarray = new Int32Array(3 * totalsurfacevox);
    var positout = 0;
    for (i = 0; i < pLength; ++i) {
      for (j = 0; j < pWidth; ++j) {
        for (k = 0; k < pHeight; ++k) {
          index = i * pWH + j * pHeight + k;
          if (vpBits[index] & ISBOUND) {
            inarray[positin] = i;
            inarray[positin + 1] = j;
            inarray[positin + 2] = k;
            positin += 3;
            vpBits[index] &= ~ISBOUND;
          }
        }
      }
    }
    do {
      positout = fastoneshell(inarray, boundPoint, positin, outarray);
      positin = 0;
      for (i = 0, n = positout; i < n; i += 3) {
        index = pWH * outarray[i] + pHeight * outarray[i + 1] + outarray[i + 2];
        vpBits[index] &= ~ISBOUND;
        if (vpDistance[index] <= 1.0404 * cutRSq) {
          inarray[positin] = outarray[i];
          inarray[positin + 1] = outarray[i + 1];
          inarray[positin + 2] = outarray[i + 2];
          positin += 3;
        }
      }
    } while (positin > 0);
    var cutoffSq = cutoff * cutoff;
    var index2;
    var bp = new Uint16Array(3);
    for (i = 0; i < pLength; ++i) {
      for (j = 0; j < pWidth; ++j) {
        for (k = 0; k < pHeight; ++k) {
          index = i * pWH + j * pHeight + k;
          vpBits[index] &= ~ISBOUND;
          if (vpBits[index] & INOUT) {
            if (!(vpBits[index] & ISDONE) || vpBits[index] & ISDONE && vpDistance[index] >= cutoffSq) {
              vpBits[index] |= ISBOUND;
              if (setAtomID && vpBits[index] & ISDONE) {
                boundPoint.toArray(i, j, k, bp);
                index2 = bp[0] * pWH + bp[1] * pHeight + bp[2];
                vpAtomID[index] = vpAtomID[index2];
              }
            }
          }
        }
      }
    }
    console.timeEnd("EDTSurface fastdistancemap");
  }
  function fastoneshell(inarray, boundPoint, positin, outarray) {
    var tx, ty, tz;
    var dx, dy, dz;
    var i, j, n;
    var square;
    var index;
    var nbj;
    var bp = new Uint16Array(3);
    var positout = 0;
    if (positin === 0) {
      return positout;
    }
    var tnvix = -1;
    var tnviy = -1;
    var tnviz = -1;
    var pWH = pWidth * pHeight;
    for (i = 0, n = positin; i < n; i += 3) {
      tx = inarray[i];
      ty = inarray[i + 1];
      tz = inarray[i + 2];
      boundPoint.toArray(tx, ty, tz, bp);
      for (j = 0; j < 6; ++j) {
        nbj = nb[j];
        tnvix = tx + nbj[0];
        tnviy = ty + nbj[1];
        tnviz = tz + nbj[2];
        if (tnvix < pLength && tnvix > -1 && tnviy < pWidth && tnviy > -1 && tnviz < pHeight && tnviz > -1) {
          index = tnvix * pWH + pHeight * tnviy + tnviz;
          if (vpBits[index] & INOUT && !(vpBits[index] & ISDONE)) {
            boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            vpDistance[index] = square;
            vpBits[index] |= ISDONE;
            vpBits[index] |= ISBOUND;
            outarray[positout] = tnvix;
            outarray[positout + 1] = tnviy;
            outarray[positout + 2] = tnviz;
            positout += 3;
          } else if (vpBits[index] & INOUT && vpBits[index] & ISDONE) {
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            if (square < vpDistance[index]) {
              boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
              vpDistance[index] = square;
              if (!(vpBits[index] & ISBOUND)) {
                vpBits[index] |= ISBOUND;
                outarray[positout] = tnvix;
                outarray[positout + 1] = tnviy;
                outarray[positout + 2] = tnviz;
                positout += 3;
              }
            }
          }
        }
      }
    }
    for (i = 0, n = positin; i < n; i += 3) {
      tx = inarray[i];
      ty = inarray[i + 1];
      tz = inarray[i + 2];
      boundPoint.toArray(tx, ty, tz, bp);
      for (j = 6; j < 18; j++) {
        nbj = nb[j];
        tnvix = tx + nbj[0];
        tnviy = ty + nbj[1];
        tnviz = tz + nbj[2];
        if (tnvix < pLength && tnvix > -1 && tnviy < pWidth && tnviy > -1 && tnviz < pHeight && tnviz > -1) {
          index = tnvix * pWH + pHeight * tnviy + tnviz;
          if (vpBits[index] & INOUT && !(vpBits[index] & ISDONE)) {
            boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            vpDistance[index] = square;
            vpBits[index] |= ISDONE;
            vpBits[index] |= ISBOUND;
            outarray[positout] = tnvix;
            outarray[positout + 1] = tnviy;
            outarray[positout + 2] = tnviz;
            positout += 3;
          } else if (vpBits[index] & INOUT && vpBits[index] & ISDONE) {
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            if (square < vpDistance[index]) {
              boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
              vpDistance[index] = square;
              if (!(vpBits[index] & ISBOUND)) {
                vpBits[index] |= ISBOUND;
                outarray[positout] = tnvix;
                outarray[positout + 1] = tnviy;
                outarray[positout + 2] = tnviz;
                positout += 3;
              }
            }
          }
        }
      }
    }
    for (i = 0, n = positin; i < n; i += 3) {
      tx = inarray[i];
      ty = inarray[i + 1];
      tz = inarray[i + 2];
      boundPoint.toArray(tx, ty, tz, bp);
      for (j = 18; j < 26; j++) {
        nbj = nb[j];
        tnvix = tx + nbj[0];
        tnviy = ty + nbj[1];
        tnviz = tz + nbj[2];
        if (tnvix < pLength && tnvix > -1 && tnviy < pWidth && tnviy > -1 && tnviz < pHeight && tnviz > -1) {
          index = tnvix * pWH + pHeight * tnviy + tnviz;
          if (vpBits[index] & INOUT && !(vpBits[index] & ISDONE)) {
            boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            vpDistance[index] = square;
            vpBits[index] |= ISDONE;
            vpBits[index] |= ISBOUND;
            outarray[positout] = tnvix;
            outarray[positout + 1] = tnviy;
            outarray[positout + 2] = tnviz;
            positout += 3;
          } else if (vpBits[index] & INOUT && vpBits[index] & ISDONE) {
            dx = tnvix - bp[0];
            dy = tnviy - bp[1];
            dz = tnviz - bp[2];
            square = dx * dx + dy * dy + dz * dz;
            if (square < vpDistance[index]) {
              boundPoint.fromArray(tnvix, tnviy, tnviz, bp);
              vpDistance[index] = square;
              if (!(vpBits[index] & ISBOUND)) {
                vpBits[index] |= ISBOUND;
                outarray[positout] = tnvix;
                outarray[positout + 1] = tnviy;
                outarray[positout + 2] = tnviz;
                positout += 3;
              }
            }
          }
        }
      }
    }
    return positout;
  }
  function marchingcubeinit(stype) {
    var i;
    var n = vpBits.length;
    if (stype === "vws") {
      for (i = 0; i < n; ++i) {
        vpBits[i] &= ~ISBOUND;
        vpBits[i] = vpBits[i] & ISDONE ? 1 : 0;
      }
    } else if (stype === "ms") {
      for (i = 0; i < n; ++i) {
        vpBits[i] &= ~ISDONE;
        if (vpBits[i] & ISBOUND) {
          vpBits[i] |= ISDONE;
        }
        vpBits[i] &= ~ISBOUND;
        vpBits[i] = vpBits[i] & ISDONE ? 1 : 0;
      }
    } else if (stype === "ses") {
      for (i = 0; i < n; ++i) {
        if (vpBits[i] & ISBOUND && vpBits[i] & ISDONE) {
          vpBits[i] &= ~ISBOUND;
        } else if (vpBits[i] & ISBOUND && !(vpBits[i] & ISDONE)) {
          vpBits[i] |= ISDONE;
        }
        vpBits[i] = vpBits[i] & ISDONE ? 1 : 0;
      }
    } else if (stype === "sas") {
      for (i = 0; i < n; ++i) {
        vpBits[i] &= ~ISBOUND;
        vpBits[i] = vpBits[i] & ISDONE ? 1 : 0;
      }
    }
  }
}
EDTSurface.__deps = [
  getSurfaceGrid,
  getRadiusDict,
  VolumeSurface,
  computeBoundingBox,
  Grid
];
function AVHash(atomsX, atomsY, atomsZ, atomsR, min, max2, maxDistance) {
  var nAtoms = atomsX.length;
  var minX = min[0];
  var minY = min[1];
  var minZ = min[2];
  var maxX = max2[0];
  var maxY = max2[1];
  var maxZ = max2[2];
  function hashFunc(w, minW) {
    return Math.floor((w - minW) / maxDistance);
  }
  var iDim = hashFunc(maxX, minX) + 1;
  var jDim = hashFunc(maxY, minY) + 1;
  var kDim = hashFunc(maxZ, minZ) + 1;
  var nCells = iDim * jDim * kDim;
  var jkDim = jDim * kDim;
  var cellID = function(x, y, z) {
    return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
  };
  var preHash = [];
  for (var i = 0; i < nAtoms; i++) {
    var cid = cellID(atomsX[i], atomsY[i], atomsZ[i]);
    if (preHash[cid] === void 0) {
      preHash[cid] = [i];
    } else {
      preHash[cid].push(i);
    }
  }
  var cellOffsets = new Uint32Array(nCells);
  var cellLengths = new Uint16Array(nCells);
  var data = new Uint32Array(nAtoms);
  var offset = 0;
  var maxCellLength = 0;
  for (i = 0; i < nCells; i++) {
    var start = cellOffsets[i] = offset;
    var subArray = preHash[i];
    if (subArray !== void 0) {
      for (var j = 0; j < subArray.length; j++) {
        data[offset] = subArray[j];
        offset++;
      }
    }
    var cellLength = offset - start;
    cellLengths[i] = cellLength;
    if (cellLength > maxCellLength) {
      maxCellLength = cellLength;
    }
  }
  this.neighbourListLength = 27 * maxCellLength + 1;
  this.withinRadii = function(x, y, z, rExtra, out) {
    var outIdx = 0;
    var nearI = hashFunc(x, minX);
    var nearJ = hashFunc(y, minY);
    var nearK = hashFunc(z, minZ);
    var loI = Math.max(0, nearI - 1);
    var loJ = Math.max(0, nearJ - 1);
    var loK = Math.max(0, nearK - 1);
    var hiI = Math.min(iDim, nearI + 1);
    var hiJ = Math.min(jDim, nearJ + 1);
    var hiK = Math.min(kDim, nearK + 1);
    for (var i2 = loI; i2 <= hiI; ++i2) {
      var iOffset = i2 * jkDim;
      for (var j2 = loJ; j2 <= hiJ; ++j2) {
        var jOffset = j2 * kDim;
        for (var k = loK; k <= hiK; ++k) {
          var cid2 = iOffset + jOffset + k;
          var cellStart = cellOffsets[cid2];
          var cellEnd = cellStart + cellLengths[cid2];
          for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
            var atomIndex = data[dataIndex];
            var dx = atomsX[atomIndex] - x;
            var dy = atomsY[atomIndex] - y;
            var dz = atomsZ[atomIndex] - z;
            var rSum = atomsR[atomIndex] + rExtra;
            if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
              out[outIdx++] = data[dataIndex];
            }
          }
        }
      }
    }
    out[outIdx] = -1;
  };
}
function AVSurface(coordList, radiusList, indexList) {
  var nAtoms = radiusList.length;
  var x = new Float32Array(nAtoms);
  var y = new Float32Array(nAtoms);
  var z = new Float32Array(nAtoms);
  for (var i = 0; i < nAtoms; i++) {
    var ci = 3 * i;
    x[i] = coordList[ci];
    y[i] = coordList[ci + 1];
    z[i] = coordList[ci + 2];
  }
  var bbox = computeBoundingBox(coordList);
  if (coordList.length === 0) {
    bbox[0].set([0, 0, 0]);
    bbox[1].set([0, 0, 0]);
  }
  var min = bbox[0];
  var max2 = bbox[1];
  var r, r2;
  var maxRadius2;
  var probeRadius, scaleFactor, setAtomID, probePositions;
  var lastClip = -1;
  var dim, matrix2, grid, atomIndex;
  var gridx, gridy, gridz;
  var sinTable, cosTable;
  var hash;
  var neighbours;
  var mid = new Float32Array([0, 0, 0]);
  var n1 = new Float32Array([0, 0, 0]);
  var n2 = new Float32Array([0, 0, 0]);
  var ngTorus;
  function init3(_probeRadius, _scaleFactor, _setAtomID, _probePositions) {
    probeRadius = defaults(_probeRadius, 1.4);
    scaleFactor = defaults(_scaleFactor, 2);
    setAtomID = defaults(_setAtomID, true);
    probePositions = defaults(_probePositions, 30);
    r = new Float32Array(nAtoms);
    r2 = new Float32Array(nAtoms);
    for (var i2 = 0; i2 < r.length; ++i2) {
      var rExt = radiusList[i2] + probeRadius;
      r[i2] = rExt;
      r2[i2] = rExt * rExt;
    }
    maxRadius2 = 0;
    for (var j = 0; j < r.length; ++j) {
      if (r[j] > maxRadius2) {
        maxRadius2 = r[j];
      }
    }
    initializeGrid();
    initializeAngleTables();
    initializeHash();
    lastClip = -1;
  }
  function fillGridDim(a, start, step) {
    for (var i2 = 0; i2 < a.length; i2++) {
      a[i2] = start + step * i2;
    }
  }
  function initializeGrid() {
    var surfGrid = getSurfaceGrid(min, max2, maxRadius2, scaleFactor, 0);
    scaleFactor = surfGrid.scaleFactor;
    dim = surfGrid.dim;
    matrix2 = surfGrid.matrix;
    ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
    grid = uniformArray(dim[0] * dim[1] * dim[2], -1001);
    atomIndex = new Int32Array(grid.length);
    gridx = new Float32Array(dim[0]);
    gridy = new Float32Array(dim[1]);
    gridz = new Float32Array(dim[2]);
    fillGridDim(gridx, min[0], 1 / scaleFactor);
    fillGridDim(gridy, min[1], 1 / scaleFactor);
    fillGridDim(gridz, min[2], 1 / scaleFactor);
  }
  function initializeAngleTables() {
    var theta = 0;
    var step = 2 * Math.PI / probePositions;
    cosTable = new Float32Array(probePositions);
    sinTable = new Float32Array(probePositions);
    for (var i2 = 0; i2 < probePositions; i2++) {
      cosTable[i2] = Math.cos(theta);
      sinTable[i2] = Math.sin(theta);
      theta += step;
    }
  }
  function initializeHash() {
    hash = new AVHash(x, y, z, r, min, max2, 2.01 * maxRadius2);
    neighbours = new Int32Array(hash.neighbourListLength);
  }
  function obscured(x2, y2, z2, a, b) {
    var ai;
    if (lastClip !== -1) {
      ai = lastClip;
      if (ai !== a && ai !== b && singleAtomObscures(ai, x2, y2, z2)) {
        return ai;
      } else {
        lastClip = -1;
      }
    }
    var ni = 0;
    ai = neighbours[ni];
    while (ai >= 0) {
      if (ai !== a && ai !== b && singleAtomObscures(ai, x2, y2, z2)) {
        lastClip = ai;
        return ai;
      }
      ai = neighbours[++ni];
    }
    lastClip = -1;
    return -1;
  }
  function singleAtomObscures(ai, x2, y2, z2) {
    var ci2 = 3 * ai;
    var ra2 = r2[ai];
    var dx = coordList[ci2] - x2;
    var dy = coordList[ci2 + 1] - y2;
    var dz = coordList[ci2 + 2] - z2;
    var d2 = dx * dx + dy * dy + dz * dz;
    return d2 < ra2;
  }
  function projectPoints() {
    for (var i2 = 0; i2 < nAtoms; i2++) {
      var ax = x[i2];
      var ay = y[i2];
      var az = z[i2];
      var ar = r[i2];
      var ar2 = r2[i2];
      hash.withinRadii(ax, ay, az, ar, neighbours);
      var ng = Math.ceil(ar * scaleFactor);
      var iax = Math.floor(scaleFactor * (ax - min[0]));
      var iay = Math.floor(scaleFactor * (ay - min[1]));
      var iaz = Math.floor(scaleFactor * (az - min[2]));
      var minx = Math.max(0, iax - ng);
      var miny = Math.max(0, iay - ng);
      var minz = Math.max(0, iaz - ng);
      var maxx = Math.min(dim[0], iax + ng + 2);
      var maxy = Math.min(dim[1], iay + ng + 2);
      var maxz = Math.min(dim[2], iaz + ng + 2);
      for (var ix = minx; ix < maxx; ix++) {
        var dx = gridx[ix] - ax;
        var xoffset = dim[1] * dim[2] * ix;
        for (var iy = miny; iy < maxy; iy++) {
          var dy = gridy[iy] - ay;
          var dxy2 = dx * dx + dy * dy;
          var xyoffset = xoffset + dim[2] * iy;
          for (var iz = minz; iz < maxz; iz++) {
            var dz = gridz[iz] - az;
            var d2 = dxy2 + dz * dz;
            if (d2 < ar2) {
              var idx = iz + xyoffset;
              if (grid[idx] < 0) {
                grid[idx] = -grid[idx];
              }
              var d = Math.sqrt(d2);
              var ap = ar / d;
              var spx = dx * ap;
              var spy = dy * ap;
              var spz = dz * ap;
              spx += ax;
              spy += ay;
              spz += az;
              if (obscured(spx, spy, spz, i2, -1) === -1) {
                var dd = ar - d;
                if (dd < grid[idx]) {
                  grid[idx] = dd;
                  if (setAtomID) {
                    atomIndex[idx] = i2;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  function projectTorii() {
    for (var i2 = 0; i2 < nAtoms; i2++) {
      hash.withinRadii(x[i2], y[i2], z[i2], r[i2], neighbours);
      var ia = 0;
      var ni = neighbours[ia];
      while (ni >= 0) {
        if (i2 < ni) {
          projectTorus(i2, ni);
        }
        ni = neighbours[++ia];
      }
    }
  }
  function projectTorus(a, b) {
    var r1 = r[a];
    var r22 = r[b];
    var dx = mid[0] = x[b] - x[a];
    var dy = mid[1] = y[b] - y[a];
    var dz = mid[2] = z[b] - z[a];
    var d2 = dx * dx + dy * dy + dz * dz;
    var d = Math.sqrt(d2);
    var cosA = (r1 * r1 + d * d - r22 * r22) / (2 * r1 * d);
    var dmp = r1 * cosA;
    v3normalize(mid, mid);
    normalToLine(n1, mid);
    v3normalize(n1, n1);
    v3cross(n2, mid, n1);
    v3normalize(n2, n2);
    var rInt = Math.sqrt(r1 * r1 - dmp * dmp);
    v3multiplyScalar(n1, n1, rInt);
    v3multiplyScalar(n2, n2, rInt);
    v3multiplyScalar(mid, mid, dmp);
    mid[0] += x[a];
    mid[1] += y[a];
    mid[2] += z[a];
    lastClip = -1;
    var ng = ngTorus;
    for (var i2 = 0; i2 < probePositions; i2++) {
      var cost = cosTable[i2];
      var sint = sinTable[i2];
      var px2 = mid[0] + cost * n1[0] + sint * n2[0];
      var py2 = mid[1] + cost * n1[1] + sint * n2[1];
      var pz2 = mid[2] + cost * n1[2] + sint * n2[2];
      if (obscured(px2, py2, pz2, a, b) === -1) {
        var iax = Math.floor(scaleFactor * (px2 - min[0]));
        var iay = Math.floor(scaleFactor * (py2 - min[1]));
        var iaz = Math.floor(scaleFactor * (pz2 - min[2]));
        var minx = Math.max(0, iax - ng);
        var miny = Math.max(0, iay - ng);
        var minz = Math.max(0, iaz - ng);
        var maxx = Math.min(dim[0], iax + ng + 2);
        var maxy = Math.min(dim[1], iay + ng + 2);
        var maxz = Math.min(dim[2], iaz + ng + 2);
        for (var ix = minx; ix < maxx; ix++) {
          dx = px2 - gridx[ix];
          var xoffset = dim[1] * dim[2] * ix;
          for (var iy = miny; iy < maxy; iy++) {
            dy = py2 - gridy[iy];
            var dxy2 = dx * dx + dy * dy;
            var xyoffset = xoffset + dim[2] * iy;
            for (var iz = minz; iz < maxz; iz++) {
              dz = pz2 - gridz[iz];
              d2 = dxy2 + dz * dz;
              var idx = iz + xyoffset;
              var current = grid[idx];
              if (current > 0 && d2 < current * current) {
                grid[idx] = Math.sqrt(d2);
                if (setAtomID) {
                  atomIndex[idx] = a;
                }
              }
            }
          }
        }
      }
    }
  }
  function normalToLine(out, p) {
    out[0] = out[1] = out[2] = 1;
    if (p[0] !== 0) {
      out[0] = (p[1] + p[2]) / -p[0];
    } else if (p[1] !== 0) {
      out[1] = (p[0] + p[2]) / -p[1];
    } else if (p[2] !== 0) {
      out[2] = (p[0] + p[1]) / -p[2];
    }
    return out;
  }
  function fixNegatives() {
    for (var i2 = 0; i2 < grid.length; i2++) {
      if (grid[i2] < 0) {
        grid[i2] = 0;
      }
    }
  }
  function fixAtomIDs() {
    for (var i2 = 0; i2 < atomIndex.length; i2++) {
      atomIndex[i2] = indexList[atomIndex[i2]];
    }
  }
  function getVolume(probeRadius2, scaleFactor2, setAtomID2) {
    console.time("AVSurface.getVolume");
    console.time("AVSurface.init");
    init3(probeRadius2, scaleFactor2, setAtomID2);
    console.timeEnd("AVSurface.init");
    console.time("AVSurface.projectPoints");
    projectPoints();
    console.timeEnd("AVSurface.projectPoints");
    console.time("AVSurface.projectTorii");
    projectTorii();
    console.timeEnd("AVSurface.projectTorii");
    fixNegatives();
    fixAtomIDs();
    console.timeEnd("AVSurface.getVolume");
  }
  this.getSurface = function(type2, probeRadius2, scaleFactor2, cutoff, setAtomID2, smooth, contour) {
    getVolume(probeRadius2, scaleFactor2, setAtomID2);
    var volsurf = new VolumeSurface(grid, dim[2], dim[1], dim[0], atomIndex);
    return volsurf.getSurface(probeRadius2, false, void 0, matrix2, contour);
  };
}
AVSurface.__deps = [
  getSurfaceGrid,
  VolumeSurface,
  uniformArray,
  computeBoundingBox,
  v3multiplyScalar,
  v3cross,
  v3normalize,
  AVHash,
  defaults
];
WorkerRegistry2.add("molsurf", function func2(e, callback) {
  var a = e.data.args;
  var p = e.data.params;
  if (a && p) {
    var SurfClass = p.type === "av" ? AVSurface : EDTSurface;
    var surf = new SurfClass(a.coordList, a.radiusList, a.indexList);
    var sd = surf.getSurface(p.type, p.probeRadius, p.scaleFactor, p.cutoff, true, p.smooth, p.contour);
    var transferList = [sd.position.buffer, sd.index.buffer];
    if (sd.normal) {
      transferList.push(sd.normal.buffer);
    }
    if (sd.atomindex) {
      transferList.push(sd.atomindex.buffer);
    }
    var data = {
      sd,
      p
    };
    callback(data, transferList);
  }
}, [EDTSurface, AVSurface]);
var MolecularSurface = function MolecularSurface2(structure) {
  this.structure = structure;
};
MolecularSurface.prototype._getAtomData = function _getAtomData() {
  return this.structure.getAtomData({
    what: {position: true, radius: true, index: true},
    radiusParams: {radius: "vdw", scale: 1}
  });
};
MolecularSurface.prototype._makeSurface = function _makeSurface2(sd, p) {
  var surface = new Surface(p.name, "", sd);
  surface.info.type = p.type;
  surface.info.probeRadius = p.probeRadius;
  surface.info.scaleFactor = p.scaleFactor;
  surface.info.smooth = p.smooth;
  surface.info.cutoff = p.cutoff;
  return surface;
};
MolecularSurface.prototype.getSurface = function getSurface2(params) {
  var p = params || {};
  var atomData = this._getAtomData();
  var coordList = atomData.position;
  var radiusList = atomData.radius;
  var indexList = atomData.index;
  var SurfClass = p.type === "av" ? AVSurface : EDTSurface;
  var surf = new SurfClass(coordList, radiusList, indexList);
  var sd = surf.getSurface(p.type, p.probeRadius, p.scaleFactor, p.cutoff, true, p.smooth, p.contour);
  return this._makeSurface(sd, p);
};
MolecularSurface.prototype.getSurfaceWorker = function getSurfaceWorker2(params, callback) {
  var this$1 = this;
  var p = Object.assign({}, params);
  if (window.Worker) {
    if (this.worker === void 0) {
      this.worker = new Worker("molsurf");
    }
    var atomData = this._getAtomData();
    var coordList = atomData.position;
    var radiusList = atomData.radius;
    var indexList = atomData.index;
    var msg = {
      args: {
        coordList,
        radiusList,
        indexList
      },
      params: p
    };
    var transferList = [
      coordList.buffer,
      radiusList.buffer,
      indexList.buffer
    ];
    this.worker.post(msg, transferList, function(e) {
      callback(this$1._makeSurface(e.data.sd, p));
    }, function(e) {
      console.warn("MolecularSurface.getSurfaceWorker error - trying without worker", e);
      this$1.worker.terminate();
      this$1.worker = void 0;
      var surface2 = this$1.getSurface(p);
      callback(surface2);
    });
  } else {
    var surface = this.getSurface(p);
    callback(surface);
  }
};
MolecularSurface.prototype.dispose = function dispose23() {
  if (this.worker) {
    this.worker.terminate();
  }
};
var MolecularSurfaceRepresentation = function(StructureRepresentation$$1) {
  function MolecularSurfaceRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "surface";
    this.parameters = Object.assign({
      surfaceType: {
        type: "select",
        rebuild: true,
        options: {
          vws: "vws",
          sas: "sas",
          ms: "ms",
          ses: "ses",
          av: "av"
        }
      },
      probeRadius: {
        type: "number",
        precision: 1,
        max: 20,
        min: 0,
        rebuild: true
      },
      smooth: {
        type: "integer",
        precision: 1,
        max: 10,
        min: 0,
        rebuild: true
      },
      scaleFactor: {
        type: "number",
        precision: 1,
        max: 5,
        min: 0,
        rebuild: true
      },
      cutoff: {
        type: "number",
        precision: 2,
        max: 50,
        min: 0,
        rebuild: true
      },
      contour: {
        type: "boolean",
        rebuild: true
      },
      background: {
        type: "boolean",
        rebuild: true
      },
      opaqueBack: {
        type: "boolean",
        buffer: true
      },
      filterSele: {
        type: "text",
        rebuild: true
      },
      colorVolume: {
        type: "hidden"
      },
      useWorker: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters, {
      radiusType: null,
      radius: null,
      scale: null
    });
    this.__infoList = [];
    this.structure.signals.refreshed.add(function() {
      this.__forceNewMolsurf = true;
    }, this);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    MolecularSurfaceRepresentation2.__proto__ = StructureRepresentation$$1;
  MolecularSurfaceRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  MolecularSurfaceRepresentation2.prototype.constructor = MolecularSurfaceRepresentation2;
  MolecularSurfaceRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "uniform");
    p.colorValue = defaults(p.colorValue, 14540253);
    p.disablePicking = defaults(p.disablePicking, true);
    this.surfaceType = defaults(p.surfaceType, "ms");
    this.probeRadius = defaults(p.probeRadius, 1.4);
    this.smooth = defaults(p.smooth, 2);
    this.scaleFactor = defaults(p.scaleFactor, 2);
    this.cutoff = defaults(p.cutoff, 0);
    this.contour = defaults(p.contour, false);
    this.background = defaults(p.background, false);
    this.opaqueBack = defaults(p.opaqueBack, true);
    this.filterSele = defaults(p.filterSele, "");
    this.colorVolume = defaults(p.colorVolume, void 0);
    this.useWorker = defaults(p.useWorker, true);
    StructureRepresentation$$1.prototype.init.call(this, params);
  };
  MolecularSurfaceRepresentation2.prototype.prepareData = function prepareData(sview, i, callback) {
    var info = this.__infoList[i];
    if (!info) {
      info = {};
      this.__infoList[i] = info;
    }
    if (!info.molsurf || info.sele !== sview.selection.string) {
      if (this.filterSele) {
        var sviewFilter = sview.structure.getView(new Selection(this.filterSele));
        var bbSize = sviewFilter.boundingBox.getSize();
        var maxDim = Math.max(bbSize.x, bbSize.y, bbSize.z);
        var asWithin = sview.getAtomSetWithinPoint(sviewFilter.center, maxDim / 2 + 6);
        sview = sview.getView(new Selection(sview.getAtomSetWithinSelection(asWithin, 3).toSeleString()));
      }
      info.sele = sview.selection.string;
      info.molsurf = new MolecularSurface(sview);
      var p = this.getSurfaceParams();
      var onSurfaceFinish = function(surface) {
        info.surface = surface;
        callback(i);
      };
      if (this.useWorker) {
        info.molsurf.getSurfaceWorker(p, onSurfaceFinish);
      } else {
        onSurfaceFinish(info.molsurf.getSurface(p));
      }
    } else {
      callback(i);
    }
  };
  MolecularSurfaceRepresentation2.prototype.prepare = function prepare(callback) {
    var this$1 = this;
    if (this.__forceNewMolsurf || this.__sele !== this.selection.string || this.__surfaceParams !== JSON.stringify(this.getSurfaceParams())) {
      this.__infoList.forEach(function(info) {
        info.molsurf.dispose();
      });
      this.__infoList.length = 0;
    }
    if (this.structureView.atomCount === 0) {
      callback();
      return;
    }
    var after = function() {
      this.__sele = this.selection.string;
      this.__surfaceParams = JSON.stringify(this.getSurfaceParams());
      this.__forceNewMolsurf = false;
      callback();
    }.bind(this);
    var name = this.assembly === "default" ? this.defaultAssembly : this.assembly;
    var assembly = this.structure.biomolDict[name];
    if (assembly) {
      assembly.partList.forEach(function(part, i) {
        var sview = part.getView(this$1.structureView);
        this$1.prepareData(sview, i, function(_i) {
          if (_i === assembly.partList.length - 1) {
            after();
          }
        });
      });
    } else {
      this.prepareData(this.structureView, 0, after);
    }
  };
  MolecularSurfaceRepresentation2.prototype.createData = function createData(sview, i) {
    var info = this.__infoList[i];
    var surface = info.surface;
    var surfaceData = {
      position: surface.getPosition(),
      color: surface.getColor(this.getColorParams()),
      index: surface.getFilteredIndex(this.filterSele, sview)
    };
    var bufferList = [];
    if (surface.contour) {
      var contourBuffer = new ContourBuffer(surfaceData, this.getBufferParams({
        wireframe: false
      }));
      bufferList.push(contourBuffer);
    } else {
      surfaceData.normal = surface.getNormal();
      surfaceData.picking = surface.getPicking(sview.getStructure());
      var surfaceBuffer = new SurfaceBuffer(surfaceData, this.getBufferParams({
        background: this.background,
        opaqueBack: this.opaqueBack,
        dullInterior: false
      }));
      var doubleSidedBuffer = new DoubleSidedBuffer(surfaceBuffer);
      bufferList.push(doubleSidedBuffer);
    }
    return {bufferList, info};
  };
  MolecularSurfaceRepresentation2.prototype.updateData = function updateData(what, data) {
    var surfaceData = {};
    if (what.position) {
      this.__forceNewMolsurf = true;
      this.build();
      return;
    }
    if (what.color) {
      surfaceData.color = data.info.surface.getColor(this.getColorParams());
    }
    if (what.index) {
      surfaceData.index = data.info.surface.getFilteredIndex(this.filterSele, data.sview);
    }
    data.bufferList[0].setAttributes(surfaceData);
  };
  MolecularSurfaceRepresentation2.prototype.setParameters = function setParameters8(params, what, rebuild) {
    what = what || {};
    if (params && params.filterSele) {
      what.index = true;
    }
    if (params && params.colorVolume !== void 0) {
      what.color = true;
    }
    if (params && params.wireframe && (params.contour || params.contour === void 0 && this.contour)) {
      params.wireframe = false;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  MolecularSurfaceRepresentation2.prototype.getSurfaceParams = function getSurfaceParams(params) {
    var p = Object.assign({
      type: this.surfaceType,
      probeRadius: this.probeRadius,
      scaleFactor: this.scaleFactor,
      smooth: this.smooth && !this.contour,
      cutoff: this.cutoff,
      contour: this.contour,
      useWorker: this.useWorker
    }, params);
    return p;
  };
  MolecularSurfaceRepresentation2.prototype.getColorParams = function getColorParams2() {
    var p = StructureRepresentation$$1.prototype.getColorParams.call(this);
    p.volume = this.colorVolume;
    return p;
  };
  MolecularSurfaceRepresentation2.prototype.clear = function clear7() {
    StructureRepresentation$$1.prototype.clear.call(this);
  };
  MolecularSurfaceRepresentation2.prototype.dispose = function dispose24() {
    this.__infoList.forEach(function(info) {
      info.molsurf.dispose();
    });
    this.__infoList.length = 0;
    StructureRepresentation$$1.prototype.dispose.call(this);
  };
  return MolecularSurfaceRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("surface", MolecularSurfaceRepresentation);
var PointRepresentation = function(StructureRepresentation$$1) {
  function PointRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "point";
    this.parameters = Object.assign({
      pointSize: {
        type: "number",
        precision: 1,
        max: 100,
        min: 0,
        buffer: true
      },
      sizeAttenuation: {
        type: "boolean",
        buffer: true
      },
      sortParticles: {
        type: "boolean",
        rebuild: true
      },
      useTexture: {
        type: "boolean",
        buffer: true
      },
      alphaTest: {
        type: "range",
        step: 1e-3,
        max: 1,
        min: 0,
        buffer: true
      },
      forceTransparent: {
        type: "boolean",
        buffer: true
      },
      edgeBleach: {
        type: "range",
        step: 1e-3,
        max: 1,
        min: 0,
        buffer: true
      }
    }, this.parameters, {
      flatShaded: null,
      wireframe: null,
      linewidth: null,
      roughness: null,
      metalness: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    PointRepresentation2.__proto__ = StructureRepresentation$$1;
  PointRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  PointRepresentation2.prototype.constructor = PointRepresentation2;
  PointRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    this.pointSize = defaults(p.pointSize, 1);
    this.sizeAttenuation = defaults(p.sizeAttenuation, true);
    this.sortParticles = defaults(p.sortParticles, false);
    this.useTexture = defaults(p.useTexture, false);
    this.alphaTest = defaults(p.alphaTest, 0.5);
    this.forceTransparent = defaults(p.forceTransparent, false);
    this.edgeBleach = defaults(p.edgeBleach, 0);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  PointRepresentation2.prototype.createData = function createData(sview) {
    var what = {position: true, color: true, picking: true};
    var atomData = sview.getAtomData(this.getAtomParams(what));
    var pointBuffer = new PointBuffer(atomData, this.getBufferParams({
      pointSize: this.pointSize,
      sizeAttenuation: this.sizeAttenuation,
      sortParticles: this.sortParticles,
      useTexture: this.useTexture,
      alphaTest: this.alphaTest,
      forceTransparent: this.forceTransparent,
      edgeBleach: this.edgeBleach
    }));
    return {
      bufferList: [pointBuffer]
    };
  };
  PointRepresentation2.prototype.updateData = function updateData(what, data) {
    var atomData = data.sview.getAtomData(this.getAtomParams(what));
    var pointData = {};
    if (!what || what.position) {
      pointData.position = atomData.position;
    }
    if (!what || what.color) {
      pointData.color = atomData.color;
    }
    data.bufferList[0].setAttributes(pointData);
  };
  return PointRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("point", PointRepresentation);
ShaderRegistry.add("shader/Ribbon.vert", "#define STANDARD\nuniform float nearClip;\nuniform vec3 clipCenter;\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || !defined( PICKING )\nvarying vec3 vViewPosition;\n#endif\n#if defined( RADIUS_CLIP )\nvarying vec3 vClipCenter;\n#endif\nattribute vec3 dir;\nattribute float size;\n#ifdef PICKING\n#include unpack_color\nattribute float primitiveId;\nvarying vec3 vPickingColor;\n#else\n#include color_pars_vertex\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#endif\n#include common\nvoid main(void){\n#ifdef PICKING\nvPickingColor = unpackColor( primitiveId );\n#else\n#include color_vertex\n#include beginnormal_vertex\n#include defaultnormal_vertex\n#ifndef FLAT_SHADED\nvNormal = normalize( transformedNormal );\n#endif\n#endif\n#include begin_vertex\ntransformed += normalize( dir ) * size;\n#include project_vertex\n#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || !defined( PICKING )\nvViewPosition = -mvPosition.xyz;\n#endif\n#if defined( RADIUS_CLIP )\nvClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;\n#endif\n#include nearclip_vertex\n}");
var quadIndices$1 = new Uint16Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var RibbonBuffer = function(MeshBuffer$$1) {
  function RibbonBuffer2(data, params) {
    var d = data || {};
    var n = d.position.length / 3 - 1;
    var n4 = n * 4;
    var x = n4 * 3;
    var meshPosition = new Float32Array(x);
    var meshColor = new Float32Array(x);
    var meshNormal = new Float32Array(x);
    var meshIndex = getUintArray(x, x / 3);
    MeshBuffer$$1.call(this, {
      position: meshPosition,
      color: meshColor,
      index: meshIndex,
      normal: meshNormal,
      picking: d.picking
    }, params);
    this.addAttributes({
      dir: {type: "v3", value: new Float32Array(x)}
    });
    this.addAttributes({
      size: {type: "f", value: new Float32Array(n4)}
    });
    d.primitiveId = serialArray(n);
    this.setAttributes(d);
    this.meshIndex = meshIndex;
    this.makeIndex();
  }
  if (MeshBuffer$$1)
    RibbonBuffer2.__proto__ = MeshBuffer$$1;
  RibbonBuffer2.prototype = Object.create(MeshBuffer$$1 && MeshBuffer$$1.prototype);
  RibbonBuffer2.prototype.constructor = RibbonBuffer2;
  var prototypeAccessors2 = {vertexShader: {}};
  RibbonBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var n4 = this.size;
    var n = n4 / 4;
    var attributes = this.geometry.attributes;
    var position, normal2, size, dir, color, primitiveId;
    var aPosition, aNormal, aSize, aDir, aColor, aPrimitiveId;
    if (data.position) {
      position = data.position;
      aPosition = attributes.position.array;
      attributes.position.needsUpdate = true;
    }
    if (data.normal) {
      normal2 = data.normal;
      aNormal = attributes.normal.array;
      attributes.normal.needsUpdate = true;
    }
    if (data.size) {
      size = data.size;
      aSize = attributes.size.array;
      attributes.size.needsUpdate = true;
    }
    if (data.dir) {
      dir = data.dir;
      aDir = attributes.dir.array;
      attributes.dir.needsUpdate = true;
    }
    if (data.color) {
      color = data.color;
      aColor = attributes.color.array;
      attributes.color.needsUpdate = true;
    }
    if (data.primitiveId) {
      primitiveId = data.primitiveId;
      aPrimitiveId = attributes.primitiveId.array;
      attributes.primitiveId.needsUpdate = true;
    }
    var v, i, k, p, l, v3;
    var currSize;
    var prevSize = size ? size[0] : null;
    for (v = 0; v < n; ++v) {
      v3 = v * 3;
      k = v * 3 * 4;
      l = v * 4;
      if (position) {
        aPosition[k] = aPosition[k + 3] = position[v3];
        aPosition[k + 1] = aPosition[k + 4] = position[v3 + 1];
        aPosition[k + 2] = aPosition[k + 5] = position[v3 + 2];
        aPosition[k + 6] = aPosition[k + 9] = position[v3 + 3];
        aPosition[k + 7] = aPosition[k + 10] = position[v3 + 4];
        aPosition[k + 8] = aPosition[k + 11] = position[v3 + 5];
      }
      if (normal2) {
        aNormal[k] = aNormal[k + 3] = -normal2[v3];
        aNormal[k + 1] = aNormal[k + 4] = -normal2[v3 + 1];
        aNormal[k + 2] = aNormal[k + 5] = -normal2[v3 + 2];
        aNormal[k + 6] = aNormal[k + 9] = -normal2[v3 + 3];
        aNormal[k + 7] = aNormal[k + 10] = -normal2[v3 + 4];
        aNormal[k + 8] = aNormal[k + 11] = -normal2[v3 + 5];
      }
      for (i = 0; i < 4; ++i) {
        p = k + 3 * i;
        if (color) {
          aColor[p] = color[v3];
          aColor[p + 1] = color[v3 + 1];
          aColor[p + 2] = color[v3 + 2];
        }
        if (primitiveId) {
          aPrimitiveId[l + i] = primitiveId[v];
        }
      }
      if (size) {
        currSize = size[v];
        if (prevSize !== size[v]) {
          aSize[l] = prevSize;
          aSize[l + 1] = prevSize;
          aSize[l + 2] = currSize;
          aSize[l + 3] = currSize;
        } else {
          aSize[l] = currSize;
          aSize[l + 1] = currSize;
          aSize[l + 2] = currSize;
          aSize[l + 3] = currSize;
        }
        prevSize = currSize;
      }
      if (dir) {
        aDir[k] = dir[v3];
        aDir[k + 1] = dir[v3 + 1];
        aDir[k + 2] = dir[v3 + 2];
        aDir[k + 3] = -dir[v3];
        aDir[k + 4] = -dir[v3 + 1];
        aDir[k + 5] = -dir[v3 + 2];
        aDir[k + 6] = dir[v3 + 3];
        aDir[k + 7] = dir[v3 + 4];
        aDir[k + 8] = dir[v3 + 5];
        aDir[k + 9] = -dir[v3 + 3];
        aDir[k + 10] = -dir[v3 + 4];
        aDir[k + 11] = -dir[v3 + 5];
      }
    }
  };
  RibbonBuffer2.prototype.makeIndex = function makeIndex() {
    var meshIndex = this.meshIndex;
    var n = meshIndex.length / 4 / 3;
    var s, v, ix, it;
    for (v = 0; v < n; ++v) {
      ix = v * 6;
      it = v * 4;
      meshIndex.set(quadIndices$1, ix);
      for (s = 0; s < 6; ++s) {
        meshIndex[ix + s] += it;
      }
    }
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Ribbon.vert";
  };
  Object.defineProperties(RibbonBuffer2.prototype, prototypeAccessors2);
  return RibbonBuffer2;
}(MeshBuffer);
var RibbonRepresentation = function(StructureRepresentation$$1) {
  function RibbonRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "ribbon";
    this.parameters = Object.assign({
      subdiv: {
        type: "integer",
        max: 50,
        min: 1,
        rebuild: true
      },
      tension: {
        type: "number",
        precision: 1,
        max: 1,
        min: 0.1
      },
      smoothSheet: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters, {
      side: null,
      wireframe: null,
      linewidth: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    RibbonRepresentation2.__proto__ = StructureRepresentation$$1;
  RibbonRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  RibbonRepresentation2.prototype.constructor = RibbonRepresentation2;
  RibbonRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "chainname");
    p.colorScale = defaults(p.colorScale, "RdYlBu");
    p.radius = defaults(p.radius, "sstruc");
    p.scale = defaults(p.scale, 4);
    if (p.quality === "low") {
      this.subdiv = 3;
    } else if (p.quality === "medium") {
      this.subdiv = 6;
    } else if (p.quality === "high") {
      this.subdiv = 12;
    } else {
      this.subdiv = defaults(p.subdiv, 6);
    }
    this.tension = defaults(p.tension, NaN);
    this.smoothSheet = defaults(p.smoothSheet, false);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  RibbonRepresentation2.prototype.getSplineParams = function getSplineParams(params) {
    return Object.assign({
      subdiv: this.subdiv,
      tension: this.tension,
      directional: true,
      smoothSheet: this.smoothSheet
    }, params);
  };
  RibbonRepresentation2.prototype.createData = function createData(sview) {
    var this$1 = this;
    var bufferList = [];
    var polymerList = [];
    this.structure.eachPolymer(function(polymer) {
      if (polymer.residueCount < 4) {
        return;
      }
      polymerList.push(polymer);
      var spline2 = new Spline$1(polymer, this$1.getSplineParams());
      var subPos = spline2.getSubdividedPosition();
      var subOri = spline2.getSubdividedOrientation();
      var subCol = spline2.getSubdividedColor(this$1.getColorParams());
      var subPick = spline2.getSubdividedPicking();
      var subSize = spline2.getSubdividedSize(this$1.radius, this$1.scale);
      bufferList.push(new RibbonBuffer({
        position: subPos.position,
        normal: subOri.binormal,
        dir: subOri.normal,
        color: subCol.color,
        size: subSize.size,
        picking: subPick.picking
      }, this$1.getBufferParams()));
    }, sview.getSelection());
    return {
      bufferList,
      polymerList
    };
  };
  RibbonRepresentation2.prototype.updateData = function updateData(what, data) {
    var this$1 = this;
    what = what || {};
    var i = 0;
    var n = data.polymerList.length;
    for (i = 0; i < n; ++i) {
      var bufferData = {};
      var spline2 = new Spline$1(data.polymerList[i], this$1.getSplineParams());
      if (what.position) {
        var subPos = spline2.getSubdividedPosition();
        var subOri = spline2.getSubdividedOrientation();
        bufferData.position = subPos.position;
        bufferData.normal = subOri.binormal;
        bufferData.dir = subOri.normal;
      }
      if (what.radius || what.scale) {
        var subSize = spline2.getSubdividedSize(this$1.radius, this$1.scale);
        bufferData.size = subSize.size;
      }
      if (what.color) {
        var subCol = spline2.getSubdividedColor(this$1.getColorParams());
        bufferData.color = subCol.color;
      }
      data.bufferList[i].setAttributes(bufferData);
    }
  };
  RibbonRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && params.tension) {
      what.position = true;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return RibbonRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("ribbon", RibbonRepresentation);
var RocketRepresentation = function(StructureRepresentation$$1) {
  function RocketRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "rocket";
    this.parameters = Object.assign({
      localAngle: {
        type: "integer",
        max: 180,
        min: 0,
        rebuild: true
      },
      centerDist: {
        type: "number",
        precision: 1,
        max: 10,
        min: 0,
        rebuild: true
      },
      ssBorder: {
        type: "boolean",
        rebuild: true
      },
      radialSegments: true,
      openEnded: true,
      disableImpostor: true
    }, this.parameters);
    this.helixbundleList = [];
    this.init(params);
  }
  if (StructureRepresentation$$1)
    RocketRepresentation2.__proto__ = StructureRepresentation$$1;
  RocketRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  RocketRepresentation2.prototype.constructor = RocketRepresentation2;
  RocketRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "sstruc");
    p.radius = defaults(p.radius, 1.5);
    p.scale = defaults(p.scale, 1);
    p.openEnded = defaults(p.openEnded, false);
    this.localAngle = defaults(p.localAngle, 30);
    this.centerDist = defaults(p.centerDist, 2.5);
    this.ssBorder = defaults(p.ssBorder, false);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  RocketRepresentation2.prototype.createData = function createData(sview) {
    var this$1 = this;
    var length = 0;
    var axisList = [];
    var helixbundleList = [];
    this.structure.eachPolymer(function(polymer) {
      if (polymer.residueCount < 4 || polymer.isNucleic()) {
        return;
      }
      var helixbundle = new Helixbundle(polymer);
      var axis = helixbundle.getAxis(this$1.localAngle, this$1.centerDist, this$1.ssBorder, this$1.getColorParams(), this$1.radius, this$1.scale);
      length += axis.size.length;
      axisList.push(axis);
      helixbundleList.push(helixbundle);
    }, sview.getSelection());
    var axisData = {
      begin: new Float32Array(length * 3),
      end: new Float32Array(length * 3),
      size: new Float32Array(length),
      color: new Float32Array(length * 3),
      picking: new Float32Array(length)
    };
    var offset = 0;
    axisList.forEach(function(axis) {
      axisData.begin.set(axis.begin, offset * 3);
      axisData.end.set(axis.end, offset * 3);
      axisData.size.set(axis.size, offset);
      axisData.color.set(axis.color, offset * 3);
      axisData.picking.set(axis.picking.array, offset);
      offset += axis.size.length;
    });
    if (length) {
      axisData.picking = new AtomPicker(axisData.picking, sview.getStructure());
    }
    var cylinderBuffer = new CylinderBuffer({
      position1: axisData.begin,
      position2: axisData.end,
      color: axisData.color,
      color2: axisData.color,
      radius: axisData.size,
      picking: axisData.picking
    }, this.getBufferParams({
      openEnded: this.openEnded,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    return {
      bufferList: [cylinderBuffer],
      axisList,
      helixbundleList,
      axisData
    };
  };
  RocketRepresentation2.prototype.updateData = function updateData(what, data) {
    var this$1 = this;
    what = what || {};
    if (what.position) {
      this.build();
      return;
    }
    var cylinderData = {};
    if (what.color || what.radius) {
      var offset = 0;
      data.helixbundleList.forEach(function(helixbundle) {
        var axis = helixbundle.getAxis(this$1.localAngle, this$1.centerDist, this$1.ssBorder, this$1.getColorParams(), this$1.radius, this$1.scale);
        if (what.color) {
          data.axisData.color.set(axis.color, offset * 3);
        }
        if (what.radius || what.scale) {
          data.axisData.size.set(axis.size, offset);
        }
        offset += axis.size.length;
      });
      if (what.color) {
        cylinderData.color = data.axisData.color;
        cylinderData.color2 = data.axisData.color;
      }
      if (what.radius || what.scale) {
        cylinderData.radius = data.axisData.size;
      }
    }
    data.bufferList[0].setAttributes(cylinderData);
  };
  return RocketRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("rocket", RocketRepresentation);
var RopeRepresentation = function(CartoonRepresentation$$1) {
  function RopeRepresentation2(structure, viewer, params) {
    CartoonRepresentation$$1.call(this, structure, viewer, params);
    this.type = "rope";
    this.parameters = Object.assign({
      smooth: {
        type: "integer",
        max: 15,
        min: 0,
        rebuild: true
      }
    }, this.parameters, {
      aspectRatio: null,
      smoothSheet: null
    });
  }
  if (CartoonRepresentation$$1)
    RopeRepresentation2.__proto__ = CartoonRepresentation$$1;
  RopeRepresentation2.prototype = Object.create(CartoonRepresentation$$1 && CartoonRepresentation$$1.prototype);
  RopeRepresentation2.prototype.constructor = RopeRepresentation2;
  RopeRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.aspectRatio = 1;
    p.tension = defaults(p.tension, 0.5);
    p.scale = defaults(p.scale, 5);
    p.smoothSheet = false;
    this.smooth = defaults(p.smooth, 2);
    CartoonRepresentation$$1.prototype.init.call(this, p);
  };
  RopeRepresentation2.prototype.getSpline = function getSpline(polymer) {
    var helixorient = new Helixorient(polymer);
    return new Spline$1(polymer, this.getSplineParams({
      directional: false,
      positionIterator: helixorient.getCenterIterator(this.smooth)
    }));
  };
  return RopeRepresentation2;
}(CartoonRepresentation);
RepresentationRegistry.add("rope", RopeRepresentation);
var SpacefillRepresentation = function(StructureRepresentation$$1) {
  function SpacefillRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "spacefill";
    this.parameters = Object.assign({
      sphereDetail: true,
      disableImpostor: true
    }, this.parameters);
    this.init(params);
  }
  if (StructureRepresentation$$1)
    SpacefillRepresentation2.__proto__ = StructureRepresentation$$1;
  SpacefillRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  SpacefillRepresentation2.prototype.constructor = SpacefillRepresentation2;
  SpacefillRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  SpacefillRepresentation2.prototype.createData = function createData(sview) {
    var sphereBuffer = new SphereBuffer(sview.getAtomData(this.getAtomParams()), this.getBufferParams({
      sphereDetail: this.sphereDetail,
      dullInterior: true,
      disableImpostor: this.disableImpostor
    }));
    return {
      bufferList: [sphereBuffer]
    };
  };
  SpacefillRepresentation2.prototype.updateData = function updateData(what, data) {
    var atomData = data.sview.getAtomData(this.getAtomParams(what));
    var sphereData = {};
    if (!what || what.position) {
      sphereData.position = atomData.position;
    }
    if (!what || what.color) {
      sphereData.color = atomData.color;
    }
    if (!what || what.radius) {
      sphereData.radius = atomData.radius;
    }
    data.bufferList[0].setAttributes(sphereData);
  };
  return SpacefillRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("spacefill", SpacefillRepresentation);
var TraceBuffer = function(Buffer$$1) {
  function TraceBuffer2(data, params) {
    var d = data || {};
    var p = params || {};
    var n = d.position.length / 3;
    var n1 = n - 1;
    var linePosition = new Float32Array(n1 * 3 * 2);
    var lineColor = new Float32Array(n1 * 3 * 2);
    Buffer$$1.call(this, {
      position: linePosition,
      color: lineColor
    }, p);
    this.setAttributes(data);
  }
  if (Buffer$$1)
    TraceBuffer2.__proto__ = Buffer$$1;
  TraceBuffer2.prototype = Object.create(Buffer$$1 && Buffer$$1.prototype);
  TraceBuffer2.prototype.constructor = TraceBuffer2;
  var prototypeAccessors2 = {isLine: {}, vertexShader: {}, fragmentShader: {}};
  TraceBuffer2.prototype.setAttributes = function setAttributes4(data) {
    var position, color;
    var linePosition, lineColor;
    var attributes = this.geometry.attributes;
    if (data.position) {
      position = data.position;
      linePosition = attributes.position.array;
      attributes.position.needsUpdate = true;
    }
    if (data.color) {
      color = data.color;
      lineColor = attributes.color.array;
      attributes.color.needsUpdate = true;
    }
    if (!position && !color) {
      Log.warn("TraceBuffer.prototype.setAttributes no data");
      return;
    }
    var v, v2;
    var n = this.size;
    var n1 = n - 1;
    for (var i = 0; i < n1; ++i) {
      v = 3 * i;
      v2 = 3 * i * 2;
      if (position) {
        linePosition[v2] = position[v];
        linePosition[v2 + 1] = position[v + 1];
        linePosition[v2 + 2] = position[v + 2];
        linePosition[v2 + 3] = position[v + 3];
        linePosition[v2 + 4] = position[v + 4];
        linePosition[v2 + 5] = position[v + 5];
      }
      if (color) {
        lineColor[v2] = color[v];
        lineColor[v2 + 1] = color[v + 1];
        lineColor[v2 + 2] = color[v + 2];
        lineColor[v2 + 3] = color[v + 3];
        lineColor[v2 + 4] = color[v + 4];
        lineColor[v2 + 5] = color[v + 5];
      }
    }
  };
  prototypeAccessors2.isLine.get = function() {
    return true;
  };
  prototypeAccessors2.vertexShader.get = function() {
    return "Line.vert";
  };
  prototypeAccessors2.fragmentShader.get = function() {
    return "Line.frag";
  };
  Object.defineProperties(TraceBuffer2.prototype, prototypeAccessors2);
  return TraceBuffer2;
}(Buffer);
var TraceRepresentation = function(StructureRepresentation$$1) {
  function TraceRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "trace";
    this.parameters = Object.assign({
      subdiv: {
        type: "integer",
        max: 50,
        min: 1,
        rebuild: true
      },
      tension: {
        type: "number",
        precision: 1,
        max: 1,
        min: 0.1
      },
      smoothSheet: {
        type: "boolean",
        rebuild: true
      }
    }, this.parameters, {
      flatShaded: null,
      side: null,
      wireframe: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    TraceRepresentation2.__proto__ = StructureRepresentation$$1;
  TraceRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  TraceRepresentation2.prototype.constructor = TraceRepresentation2;
  TraceRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorScheme = defaults(p.colorScheme, "chainname");
    p.colorScale = defaults(p.colorScale, "RdYlBu");
    if (p.quality === "low") {
      this.subdiv = 3;
    } else if (p.quality === "medium") {
      this.subdiv = 6;
    } else if (p.quality === "high") {
      this.subdiv = 12;
    } else {
      this.subdiv = defaults(p.subdiv, 6);
    }
    this.tension = defaults(p.tension, NaN);
    this.smoothSheet = defaults(p.smoothSheet, false);
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  TraceRepresentation2.prototype.getSplineParams = function getSplineParams(params) {
    return Object.assign({
      subdiv: this.subdiv,
      tension: this.tension,
      directional: false,
      smoothSheet: this.smoothSheet
    }, params);
  };
  TraceRepresentation2.prototype.createData = function createData(sview) {
    var this$1 = this;
    var bufferList = [];
    var polymerList = [];
    this.structure.eachPolymer(function(polymer) {
      if (polymer.residueCount < 4) {
        return;
      }
      polymerList.push(polymer);
      var spline2 = new Spline$1(polymer, this$1.getSplineParams());
      var subPos = spline2.getSubdividedPosition();
      var subCol = spline2.getSubdividedColor(this$1.getColorParams());
      bufferList.push(new TraceBuffer(Object.assign({}, subPos, subCol), this$1.getBufferParams()));
    }, sview.getSelection());
    return {
      bufferList,
      polymerList
    };
  };
  TraceRepresentation2.prototype.updateData = function updateData(what, data) {
    var this$1 = this;
    what = what || {};
    var i = 0;
    var n = data.polymerList.length;
    for (i = 0; i < n; ++i) {
      var bufferData = {};
      var spline2 = new Spline$1(data.polymerList[i], this$1.getSplineParams());
      if (what.position) {
        var subPos = spline2.getSubdividedPosition();
        bufferData.position = subPos.position;
      }
      if (what.color) {
        var subCol = spline2.getSubdividedColor(this$1.getColorParams());
        bufferData.color = subCol.color;
      }
      data.bufferList[i].setAttributes(bufferData);
    }
  };
  TraceRepresentation2.prototype.setParameters = function setParameters8(params) {
    var rebuild = false;
    var what = {};
    if (params && params.tension) {
      what.position = true;
    }
    StructureRepresentation$$1.prototype.setParameters.call(this, params, what, rebuild);
    return this;
  };
  return TraceRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("trace", TraceRepresentation);
var TubeRepresentation = function(CartoonRepresentation$$1) {
  function TubeRepresentation2(structure, viewer, params) {
    CartoonRepresentation$$1.call(this, structure, viewer, params);
    this.type = "tube";
    this.parameters = Object.assign({}, this.parameters, {aspectRatio: null});
  }
  if (CartoonRepresentation$$1)
    TubeRepresentation2.__proto__ = CartoonRepresentation$$1;
  TubeRepresentation2.prototype = Object.create(CartoonRepresentation$$1 && CartoonRepresentation$$1.prototype);
  TubeRepresentation2.prototype.constructor = TubeRepresentation2;
  TubeRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.aspectRatio = 1;
    p.scale = defaults(p.scale, 2);
    if (p.quality === "low") {
      this.radialSegments = 5;
    }
    CartoonRepresentation$$1.prototype.init.call(this, p);
  };
  TubeRepresentation2.prototype.getSplineParams = function getSplineParams() {
    return CartoonRepresentation$$1.prototype.getSplineParams.call(this, {
      directional: false
    });
  };
  return TubeRepresentation2;
}(CartoonRepresentation);
RepresentationRegistry.add("tube", TubeRepresentation);
var UnitcellRepresentation = function(StructureRepresentation$$1) {
  function UnitcellRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "unitcell";
    this.parameters = Object.assign({
      radius: {
        type: "number",
        precision: 3,
        max: 10,
        min: 1e-3
      },
      sphereDetail: true,
      radialSegments: true,
      disableImpostor: true
    }, this.parameters, {
      assembly: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    UnitcellRepresentation2.__proto__ = StructureRepresentation$$1;
  UnitcellRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  UnitcellRepresentation2.prototype.constructor = UnitcellRepresentation2;
  UnitcellRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    var defaultRadius = 0.5;
    if (this.structure.unitcell) {
      defaultRadius = Math.cbrt(this.structure.unitcell.volume) / 200;
    }
    p.radius = defaults(p.radius, defaultRadius);
    p.colorValue = defaults(p.colorValue, "orange");
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  UnitcellRepresentation2.prototype.getUnitcellData = function getUnitcellData(structure) {
    return structure.unitcell.getData(structure);
  };
  UnitcellRepresentation2.prototype.create = function create2() {
    var structure = this.structureView.getStructure();
    if (!structure.unitcell) {
      return;
    }
    var unitcellData = this.getUnitcellData(structure);
    this.sphereBuffer = new SphereBuffer(unitcellData.vertex, this.getBufferParams({
      sphereDetail: this.sphereDetail,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.cylinderBuffer = new CylinderBuffer(unitcellData.edge, this.getBufferParams({
      openEnded: true,
      radialSegments: this.radialSegments,
      disableImpostor: this.disableImpostor,
      dullInterior: true
    }));
    this.dataList.push({
      sview: this.structureView,
      bufferList: [this.sphereBuffer, this.cylinderBuffer]
    });
  };
  UnitcellRepresentation2.prototype.updateData = function updateData(what, data) {
    var structure = data.sview.getStructure();
    var unitcellData = this.getUnitcellData(structure);
    var sphereData = {};
    var cylinderData = {};
    if (!what || what.position) {
      sphereData.position = unitcellData.vertexPosition;
      cylinderData.position1 = unitcellData.edgePosition1;
      cylinderData.position2 = unitcellData.edgePosition2;
    }
    if (!what || what.color) {
      sphereData.color = unitcellData.vertexColor;
      cylinderData.color = unitcellData.edgeColor;
      cylinderData.color2 = unitcellData.edgeColor;
    }
    if (!what || what.radius) {
      sphereData.radius = unitcellData.vertexRadius;
      cylinderData.radius = unitcellData.edgeRadius;
    }
    this.sphereBuffer.setAttributes(sphereData);
    this.cylinderBuffer.setAttributes(cylinderData);
  };
  return UnitcellRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("unitcell", UnitcellRepresentation);
var ValidationRepresentation = function(StructureRepresentation$$1) {
  function ValidationRepresentation2(structure, viewer, params) {
    StructureRepresentation$$1.call(this, structure, viewer, params);
    this.type = "validation";
    this.parameters = Object.assign({}, this.parameters, {
      radiusType: null,
      radius: null,
      scale: null
    });
    this.init(params);
  }
  if (StructureRepresentation$$1)
    ValidationRepresentation2.__proto__ = StructureRepresentation$$1;
  ValidationRepresentation2.prototype = Object.create(StructureRepresentation$$1 && StructureRepresentation$$1.prototype);
  ValidationRepresentation2.prototype.constructor = ValidationRepresentation2;
  ValidationRepresentation2.prototype.init = function init3(params) {
    var p = params || {};
    p.colorValue = defaults(p.colorValue, "#f0027f");
    StructureRepresentation$$1.prototype.init.call(this, p);
  };
  ValidationRepresentation2.prototype.createData = function createData(sview) {
    if (!sview.validation) {
      return;
    }
    var clashData = sview.validation.getClashData({
      structure: sview,
      color: this.colorValue
    });
    var cylinderBuffer = new CylinderBuffer(clashData, this.getBufferParams({openEnded: false}));
    return {
      bufferList: [cylinderBuffer]
    };
  };
  return ValidationRepresentation2;
}(StructureRepresentation);
RepresentationRegistry.add("validation", ValidationRepresentation);
var Parser = function Parser2(streamer, params) {
  var p = params || {};
  this.streamer = streamer;
  this.name = defaults(p.name, "");
  this.path = defaults(p.path, "");
};
var prototypeAccessors$27 = {type: {}, __objName: {}};
prototypeAccessors$27.type.get = function() {
  return "";
};
prototypeAccessors$27.__objName.get = function() {
  return "";
};
Parser.prototype.parse = function parse2() {
  var this$1 = this;
  return this.streamer.read().then(function() {
    this$1._beforeParse();
    this$1._parse();
    this$1._afterParse();
    return this$1[this$1.__objName];
  });
};
Parser.prototype._parse = function _parse() {
};
Parser.prototype._beforeParse = function _beforeParse() {
};
Parser.prototype._afterParse = function _afterParse() {
  if (Debug) {
    Log.log(this[this.__objName]);
  }
};
Object.defineProperties(Parser.prototype, prototypeAccessors$27);
function StructureBuilder(structure) {
  var currentModelindex = null;
  var currentChainid = null;
  var currentResname = null;
  var currentResno = null;
  var currentInscode = null;
  var currentHetero = null;
  var previousResname;
  var previousHetero;
  var atomStore = structure.atomStore;
  var residueStore = structure.residueStore;
  var chainStore = structure.chainStore;
  var modelStore = structure.modelStore;
  var residueMap = structure.residueMap;
  var ai = -1;
  var ri = -1;
  var ci = -1;
  var mi = -1;
  function addResidueType(ri2) {
    var count2 = residueStore.atomCount[ri2];
    var offset = residueStore.atomOffset[ri2];
    var atomTypeIdList = new Array(count2);
    for (var i = 0; i < count2; ++i) {
      atomTypeIdList[i] = atomStore.atomTypeId[offset + i];
    }
    residueStore.residueTypeId[ri2] = residueMap.add(previousResname, atomTypeIdList, previousHetero);
  }
  this.addAtom = function(modelindex, chainname, chainid, resname, resno, hetero, sstruc, inscode) {
    var addModel = false;
    var addChain = false;
    var addResidue = false;
    if (currentModelindex !== modelindex) {
      addModel = true;
      addChain = true;
      addResidue = true;
      mi += 1;
      ci += 1;
      ri += 1;
    } else if (currentChainid !== chainid) {
      addChain = true;
      addResidue = true;
      ci += 1;
      ri += 1;
    } else if (currentResno !== resno || currentResname !== resname || currentInscode !== inscode) {
      addResidue = true;
      ri += 1;
    }
    ai += 1;
    if (addModel) {
      modelStore.growIfFull();
      modelStore.chainOffset[mi] = ci;
      modelStore.chainCount[mi] = 0;
      modelStore.count += 1;
      chainStore.modelIndex[ci] = mi;
    }
    if (addChain) {
      chainStore.growIfFull();
      chainStore.setChainname(ci, chainname);
      chainStore.setChainid(ci, chainid);
      chainStore.residueOffset[ci] = ri;
      chainStore.residueCount[ci] = 0;
      chainStore.count += 1;
      chainStore.modelIndex[ci] = mi;
      modelStore.chainCount[mi] += 1;
      residueStore.chainIndex[ri] = ci;
    }
    if (addResidue) {
      previousResname = currentResname;
      previousHetero = currentHetero;
      if (ri > 0) {
        addResidueType(ri - 1);
      }
      residueStore.growIfFull();
      residueStore.resno[ri] = resno;
      if (sstruc !== void 0) {
        residueStore.sstruc[ri] = sstruc.charCodeAt(0);
      }
      if (inscode !== void 0) {
        residueStore.inscode[ri] = inscode.charCodeAt(0);
      }
      residueStore.atomOffset[ri] = ai;
      residueStore.atomCount[ri] = 0;
      residueStore.count += 1;
      residueStore.chainIndex[ri] = ci;
      chainStore.residueCount[ci] += 1;
    }
    atomStore.count += 1;
    atomStore.residueIndex[ai] = ri;
    residueStore.atomCount[ri] += 1;
    currentModelindex = modelindex;
    currentChainid = chainid;
    currentResname = resname;
    currentResno = resno;
    currentInscode = inscode;
    currentHetero = hetero;
  };
  this.finalize = function() {
    previousResname = currentResname;
    previousHetero = currentHetero;
    if (ri > -1) {
      addResidueType(ri);
    }
  };
}
var StructureParser = function(Parser$$1) {
  function StructureParser2(streamer, params) {
    var p = params || {};
    Parser$$1.call(this, streamer, p);
    this.firstModelOnly = defaults(p.firstModelOnly, false);
    this.asTrajectory = defaults(p.asTrajectory, false);
    this.cAlphaOnly = defaults(p.cAlphaOnly, false);
    this.structure = new Structure(this.name, this.path);
    this.structureBuilder = new StructureBuilder(this.structure);
  }
  if (Parser$$1)
    StructureParser2.__proto__ = Parser$$1;
  StructureParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  StructureParser2.prototype.constructor = StructureParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "structure";
  };
  prototypeAccessors2.__objName.get = function() {
    return "structure";
  };
  Object.defineProperties(StructureParser2.prototype, prototypeAccessors2);
  return StructureParser2;
}(Parser);
function entityTypeFromString(string) {
  string = string.toLowerCase();
  switch (string) {
    case "polymer":
      return PolymerEntity;
    case "non-polymer":
      return NonPolymerEntity;
    case "macrolide":
      return MacrolideEntity;
    case "water":
      return WaterEntity;
    default:
      return UnknownEntity;
  }
}
var Entity = function Entity2(structure, index, description, type2, chainIndexList) {
  this.structure = structure;
  this.index = index;
  this.description = description || "";
  this.entityType = entityTypeFromString(type2 || "");
  this.chainIndexList = chainIndexList || [];
  chainIndexList.forEach(function(ci) {
    structure.chainStore.entityIndex[ci] = index;
  });
};
var prototypeAccessors$28 = {type: {}};
prototypeAccessors$28.type.get = function() {
  return "Entity";
};
Entity.prototype.getEntityType = function getEntityType() {
  return this.entityType;
};
Entity.prototype.isPolymer = function isPolymer3() {
  return this.entityType === PolymerEntity;
};
Entity.prototype.isNonPolymer = function isNonPolymer() {
  return this.entityType === NonPolymerEntity;
};
Entity.prototype.isMacrolide = function isMacrolide() {
  return this.entityType === MacrolideEntity;
};
Entity.prototype.isWater = function isWater4() {
  return this.entityType === WaterEntity;
};
Entity.prototype.eachChain = function eachChain3(callback) {
  var cp = this.structure.getChainProxy();
  this.chainIndexList.forEach(function(index) {
    cp.index = index;
    callback(cp);
  });
};
Object.defineProperties(Entity.prototype, prototypeAccessors$28);
var Unitcell = function Unitcell2(params) {
  var p = params || {};
  this.a = p.a || 1;
  this.b = p.b || 1;
  this.c = p.c || 1;
  this.alpha = p.alpha || 90;
  this.beta = p.beta || 90;
  this.gamma = p.gamma || 90;
  this.spacegroup = p.spacegroup || "P 1";
  this.cartToFrac = p.cartToFrac || p.scale;
  this.fracToCart = new Matrix4();
  var alphaRad = degToRad(this.alpha);
  var betaRad = degToRad(this.beta);
  var gammaRad = degToRad(this.gamma);
  var cosAlpha = Math.cos(alphaRad);
  var cosBeta = Math.cos(betaRad);
  var cosGamma = Math.cos(gammaRad);
  var sinBeta = Math.sin(betaRad);
  var sinGamma = Math.sin(gammaRad);
  this.volume = this.a * this.b * this.c * Math.sqrt(1 - cosAlpha * cosAlpha - cosBeta * cosBeta - cosGamma * cosGamma + 2 * cosAlpha * cosBeta * cosGamma);
  if (this.cartToFrac === void 0) {
    var cStar = this.a * this.b * sinGamma / this.volume;
    var cosAlphaStar = (cosBeta * cosGamma - cosAlpha) / (sinBeta * sinGamma);
    this.fracToCart.set(this.a, 0, 0, 0, this.b * cosGamma, this.b * sinGamma, 0, 0, this.c * cosBeta, -this.c * sinBeta * cosAlphaStar, 1 / cStar, 0, 0, 0, 0, 1).transpose();
    this.cartToFrac = new Matrix4().getInverse(this.fracToCart);
  } else {
    this.fracToCart.getInverse(this.cartToFrac);
  }
};
Unitcell.prototype.getPosition = function getPosition3(structure) {
  var vertexPosition = new Float32Array(3 * 8);
  var uc = structure.unitcell;
  var centerFrac = structure.center.clone().applyMatrix4(uc.cartToFrac).floor().multiplyScalar(2).addScalar(1);
  var v = new Vector3();
  var cornerOffset = 0;
  function addCorner(x, y, z) {
    v.set(x, y, z).multiply(centerFrac).applyMatrix4(uc.fracToCart).toArray(vertexPosition, cornerOffset);
    cornerOffset += 3;
  }
  addCorner(0, 0, 0);
  addCorner(1, 0, 0);
  addCorner(0, 1, 0);
  addCorner(0, 0, 1);
  addCorner(1, 1, 0);
  addCorner(1, 0, 1);
  addCorner(0, 1, 1);
  addCorner(1, 1, 1);
  return vertexPosition;
};
Unitcell.prototype.getCenter = function getCenter4(structure) {
  return centerArray3(this.getPosition(structure));
};
Unitcell.prototype.getData = function getData2(structure, params) {
  var p = params || {};
  var colorValue = defaults(p.colorValue, "orange");
  var radius = defaults(p.radius, Math.cbrt(this.volume) / 200);
  var c = new Color(colorValue);
  var v = new Vector3();
  var vertexPosition = this.getPosition(structure);
  var vertexColor = uniformArray3(8, c.r, c.g, c.b);
  var vertexRadius = uniformArray(8, radius);
  var edgePosition1 = new Float32Array(3 * 12);
  var edgePosition2 = new Float32Array(3 * 12);
  var edgeColor = uniformArray3(12, c.r, c.g, c.b);
  var edgeRadius = uniformArray(12, radius);
  var edgeOffset = 0;
  function addEdge(a, b) {
    v.fromArray(vertexPosition, a * 3).toArray(edgePosition1, edgeOffset);
    v.fromArray(vertexPosition, b * 3).toArray(edgePosition2, edgeOffset);
    edgeOffset += 3;
  }
  addEdge(0, 1);
  addEdge(0, 2);
  addEdge(0, 3);
  addEdge(1, 4);
  addEdge(1, 5);
  addEdge(2, 6);
  addEdge(3, 5);
  addEdge(4, 7);
  addEdge(5, 7);
  addEdge(2, 4);
  addEdge(7, 6);
  addEdge(3, 6);
  var picker = new UnitcellPicker(this, structure);
  return {
    vertex: {
      position: vertexPosition,
      color: vertexColor,
      radius: vertexRadius,
      picking: picker
    },
    edge: {
      position1: edgePosition1,
      position2: edgePosition2,
      color: edgeColor,
      color2: edgeColor,
      radius: edgeRadius,
      picking: picker
    }
  };
};
var HelixTypes = {
  1: "h",
  2: "h",
  3: "i",
  4: "h",
  5: "g",
  6: "h",
  7: "h",
  8: "h",
  9: "h",
  10: "h",
  "": "h"
};
var PdbParser = function(StructureParser$$1) {
  function PdbParser2(streamer, params) {
    var p = params || {};
    StructureParser$$1.call(this, streamer, p);
    this.hex = defaults(p.hex, false);
  }
  if (StructureParser$$1)
    PdbParser2.__proto__ = StructureParser$$1;
  PdbParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  PdbParser2.prototype.constructor = PdbParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "pdb";
  };
  PdbParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("PdbParser._parse " + this.name);
    }
    var isLegacy = false;
    var headerLine = this.streamer.peekLines(1)[0];
    var headerId = headerLine.substr(62, 4);
    var legacyId = headerLine.substr(72, 4);
    if (headerId === legacyId && legacyId.trim()) {
      isLegacy = true;
    }
    var isPqr = this.type === "pqr";
    var reWhitespace2 = /\s+/;
    var s = this.structure;
    var sb = this.structureBuilder;
    var hex = this.hex;
    var serialRadix = 10;
    var resnoRadix = 10;
    var firstModelOnly = this.firstModelOnly;
    var asTrajectory = this.asTrajectory;
    var cAlphaOnly = this.cAlphaOnly;
    var frames = s.frames;
    var boxes = s.boxes;
    var doFrames = false;
    var currentFrame, currentCoord;
    var biomolDict = s.biomolDict;
    var currentBiomol;
    var currentPart;
    var currentMatrix;
    var line, recordName;
    var serial, chainname, resno, resname, occupancy, inscode, atomname, hetero, bfactor, altloc;
    var startChain, startResi, startIcode;
    var endChain, endResi, endIcode;
    var serialDict = {};
    var unitcellDict = {};
    var bondDict = {};
    var entityDataList = [];
    var currentEntityData;
    var currentEntityKey;
    var entityKeyList = [
      "MOL_ID",
      "MOLECULE",
      "CHAIN",
      "FRAGMENT",
      "SYNONYM",
      "EC",
      "ENGINEERED",
      "MUTATION",
      "OTHER_DETAILS"
    ];
    var chainDict = {};
    var hetnameDict = {};
    var chainIdx, chainid, newChain;
    var currentChainname, currentResno, currentResname, currentInscode;
    var secStruct = {
      helices: [],
      sheets: []
    };
    var helices = secStruct.helices;
    var sheets = secStruct.sheets;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    atomStore.resize(Math.round(this.streamer.data.length / 80));
    var ap1 = s.getAtomProxy();
    var ap2 = s.getAtomProxy();
    var idx = 0;
    var modelIdx = 0;
    var pendingStart = true;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        line = lines[i];
        recordName = line.substr(0, 6);
        if (recordName === "ATOM  " || recordName === "HETATM") {
          if (pendingStart) {
            if (asTrajectory) {
              if (doFrames) {
                currentFrame = new Float32Array(atomStore.count * 3);
                frames.push(currentFrame);
              } else {
                currentFrame = [];
              }
              currentCoord = 0;
            } else {
              if (!firstModelOnly) {
                serialDict = {};
              }
            }
            chainIdx = 1;
            chainid = chainIdx.toString();
            newChain = true;
            pendingStart = false;
          }
          if (firstModelOnly && modelIdx > 0) {
            continue;
          }
          var x = void 0, y = void 0, z = void 0, ls = void 0, dd = void 0;
          if (isPqr) {
            ls = line.split(reWhitespace2);
            dd = ls.length === 10 ? 1 : 0;
            atomname = ls[2];
            if (cAlphaOnly && atomname !== "CA") {
              continue;
            }
            x = parseFloat(ls[6 - dd]);
            y = parseFloat(ls[7 - dd]);
            z = parseFloat(ls[8 - dd]);
          } else {
            atomname = line.substr(12, 4).trim();
            if (cAlphaOnly && atomname !== "CA") {
              continue;
            }
            x = parseFloat(line.substr(30, 8));
            y = parseFloat(line.substr(38, 8));
            z = parseFloat(line.substr(46, 8));
          }
          if (asTrajectory) {
            var j = currentCoord * 3;
            currentFrame[j + 0] = x;
            currentFrame[j + 1] = y;
            currentFrame[j + 2] = z;
            currentCoord += 1;
            if (doFrames) {
              continue;
            }
          }
          var element = void 0;
          if (isPqr) {
            serial = parseInt(ls[1]);
            element = "";
            hetero = line[0] === "H" ? 1 : 0;
            chainname = dd ? "" : ls[4];
            resno = parseInt(ls[5 - dd]);
            inscode = "";
            resname = ls[3];
            bfactor = parseFloat(ls[9 - dd]);
            altloc = "";
            occupancy = 0;
          } else {
            serial = parseInt(line.substr(6, 5), serialRadix);
            if (hex && serial === 99999) {
              serialRadix = 16;
            }
            hetero = line[0] === "H" ? 1 : 0;
            chainname = line[21].trim();
            resno = parseInt(line.substr(22, 4), resnoRadix) || 1;
            if (hex && resno === 9999) {
              resnoRadix = 16;
            }
            inscode = line[26].trim();
            resname = line.substr(17, 4).trim() || "MOL";
            bfactor = parseFloat(line.substr(60, 6));
            altloc = line[16].trim();
            occupancy = parseFloat(line.substr(54, 6));
            if (!isLegacy) {
              element = line.substr(76, 2).trim();
              if (!chainname) {
                chainname = line.substr(72, 4).trim();
              }
            }
          }
          atomStore.growIfFull();
          atomStore.atomTypeId[idx] = atomMap.add(atomname, element);
          atomStore.x[idx] = x;
          atomStore.y[idx] = y;
          atomStore.z[idx] = z;
          atomStore.serial[idx] = serial;
          atomStore.bfactor[idx] = isNaN(bfactor) ? 0 : bfactor;
          atomStore.altloc[idx] = altloc.charCodeAt(0);
          atomStore.occupancy[idx] = isNaN(occupancy) ? 0 : occupancy;
          if (hetero) {
            if (currentChainname !== chainname || currentResname !== resname || !WaterNames.includes(resname) && (currentResno !== resno || currentInscode !== inscode)) {
              chainIdx += 1;
              chainid = chainIdx.toString();
              currentResno = resno;
              currentResname = resname;
              currentInscode = inscode;
            }
          } else if (!newChain && currentChainname !== chainname) {
            chainIdx += 1;
            chainid = chainIdx.toString();
          }
          sb.addAtom(modelIdx, chainname, chainid, resname, resno, hetero, void 0, inscode);
          serialDict[serial] = idx;
          idx += 1;
          newChain = false;
          currentChainname = chainname;
        } else if (recordName === "CONECT") {
          var fromIdx = serialDict[parseInt(line.substr(6, 5))];
          var pos = [11, 16, 21, 26];
          var bondIndex = {};
          if (fromIdx === void 0) {
            continue;
          }
          for (var j$1 = 0; j$1 < 4; ++j$1) {
            var toIdx = parseInt(line.substr(pos[j$1], 5));
            if (Number.isNaN(toIdx)) {
              continue;
            }
            toIdx = serialDict[toIdx];
            if (toIdx === void 0) {
              continue;
            }
            if (fromIdx < toIdx) {
              ap1.index = fromIdx;
              ap2.index = toIdx;
            } else {
              ap1.index = toIdx;
              ap2.index = fromIdx;
            }
            if (bondIndex[toIdx] !== void 0) {
              s.bondStore.bondOrder[bondIndex[toIdx]] += 1;
            } else {
              var hash = ap1.index + "|" + ap2.index;
              if (bondDict[hash] === void 0) {
                bondDict[hash] = true;
                bondIndex[toIdx] = s.bondStore.count;
                s.bondStore.addBond(ap1, ap2, 1);
              }
            }
          }
        } else if (recordName === "HELIX ") {
          startChain = line[19].trim();
          startResi = parseInt(line.substr(21, 4));
          startIcode = line[25].trim();
          endChain = line[31].trim();
          endResi = parseInt(line.substr(33, 4));
          endIcode = line[37].trim();
          var helixType = parseInt(line.substr(39, 1));
          helixType = (HelixTypes[helixType] || HelixTypes[""]).charCodeAt(0);
          helices.push([
            startChain,
            startResi,
            startIcode,
            endChain,
            endResi,
            endIcode,
            helixType
          ]);
        } else if (recordName === "SHEET ") {
          startChain = line[21].trim();
          startResi = parseInt(line.substr(22, 4));
          startIcode = line[26].trim();
          endChain = line[32].trim();
          endResi = parseInt(line.substr(33, 4));
          endIcode = line[37].trim();
          sheets.push([
            startChain,
            startResi,
            startIcode,
            endChain,
            endResi,
            endIcode
          ]);
        } else if (recordName === "HETNAM") {
          hetnameDict[line.substr(11, 3)] = line.substr(15).trim();
        } else if (recordName === "COMPND") {
          var comp = line.substr(10, 70).trim();
          var keyEnd = comp.indexOf(":");
          var key = comp.substring(0, keyEnd);
          var value2 = void 0;
          if (entityKeyList.includes(key)) {
            currentEntityKey = key;
            value2 = comp.substring(keyEnd + 2);
          } else {
            value2 = comp;
          }
          value2 = value2.replace(/;$/, "");
          if (currentEntityKey === "MOL_ID") {
            currentEntityData = {
              chainList: [],
              name: ""
            };
            entityDataList.push(currentEntityData);
          } else if (currentEntityKey === "MOLECULE") {
            if (currentEntityData.name) {
              currentEntityData.name += " ";
            }
            currentEntityData.name += value2;
          } else if (currentEntityKey === "CHAIN") {
            Array.prototype.push.apply(currentEntityData.chainList, value2.split(/\s*,\s*/));
          }
        } else if (line.startsWith("TER")) {
          var cp = s.getChainProxy(s.chainStore.count - 1);
          chainDict[cp.chainname] = cp.index;
          chainIdx += 1;
          chainid = chainIdx.toString();
          newChain = true;
        } else if (recordName === "REMARK" && line.substr(7, 3) === "350") {
          if (line.substr(11, 12) === "BIOMOLECULE:") {
            var name = line.substr(23).trim();
            if (/^(0|[1-9][0-9]*)$/.test(name)) {
              name = "BU" + name;
            }
            currentBiomol = new Assembly(name);
            biomolDict[name] = currentBiomol;
          } else if (line.substr(13, 5) === "BIOMT") {
            var biomt = line.split(/\s+/);
            var row = parseInt(line[18]) - 1;
            if (row === 0) {
              currentMatrix = new Matrix4();
              currentPart.matrixList.push(currentMatrix);
            }
            var biomtElms = currentMatrix.elements;
            biomtElms[4 * 0 + row] = parseFloat(biomt[4]);
            biomtElms[4 * 1 + row] = parseFloat(biomt[5]);
            biomtElms[4 * 2 + row] = parseFloat(biomt[6]);
            biomtElms[4 * 3 + row] = parseFloat(biomt[7]);
          } else if (line.substr(11, 30) === "APPLY THE FOLLOWING TO CHAINS:" || line.substr(11, 30) === "                   AND CHAINS:") {
            if (line.substr(11, 5) === "APPLY") {
              currentPart = currentBiomol.addPart();
            }
            var chainList = line.substr(41, 30).split(",");
            for (var j$2 = 0, jl = chainList.length; j$2 < jl; ++j$2) {
              var c = chainList[j$2].trim();
              if (c) {
                currentPart.chainList.push(c);
              }
            }
          }
        } else if (recordName === "HEADER") {
          s.id = line.substr(62, 4);
        } else if (recordName === "TITLE ") {
          s.title += (s.title ? " " : "") + line.substr(10, 70).trim();
        } else if (recordName === "MODEL ") {
          pendingStart = true;
        } else if (recordName === "ENDMDL" || line.startsWith("END")) {
          if (pendingStart) {
            continue;
          }
          if (asTrajectory && !doFrames) {
            frames.push(new Float32Array(currentFrame));
            doFrames = true;
          }
          modelIdx += 1;
          pendingStart = true;
        } else if (line.substr(0, 5) === "MTRIX") {
          if (line[59] === "1") {
            continue;
          }
          var ncs = line.split(/\s+/);
          var ncsMat = ncs[1].trim();
          if (line[5] === "1" && ncsMat === "1") {
            var ncsName = "NCS";
            currentBiomol = new Assembly(ncsName);
            biomolDict[ncsName] = currentBiomol;
            currentPart = currentBiomol.addPart();
          }
          var ncsRow = parseInt(line[5]) - 1;
          if (ncsRow === 0) {
            currentMatrix = new Matrix4();
            currentPart.matrixList.push(currentMatrix);
          }
          var ncsElms = currentMatrix.elements;
          ncsElms[4 * 0 + ncsRow] = parseFloat(ncs[2]);
          ncsElms[4 * 1 + ncsRow] = parseFloat(ncs[3]);
          ncsElms[4 * 2 + ncsRow] = parseFloat(ncs[4]);
          ncsElms[4 * 3 + ncsRow] = parseFloat(ncs[5]);
        } else if (line.substr(0, 5) === "ORIGX") {
          if (!unitcellDict.origx) {
            unitcellDict.origx = new Matrix4();
          }
          var orgix = line.split(/\s+/);
          var origxRow = parseInt(line[5]) - 1;
          var origxElms = unitcellDict.origx.elements;
          origxElms[4 * 0 + origxRow] = parseFloat(orgix[1]);
          origxElms[4 * 1 + origxRow] = parseFloat(orgix[2]);
          origxElms[4 * 2 + origxRow] = parseFloat(orgix[3]);
          origxElms[4 * 3 + origxRow] = parseFloat(orgix[4]);
        } else if (line.substr(0, 5) === "SCALE") {
          if (!unitcellDict.scale) {
            unitcellDict.scale = new Matrix4();
          }
          var scale2 = line.split(/\s+/);
          var scaleRow = parseInt(line[5]) - 1;
          var scaleElms = unitcellDict.scale.elements;
          scaleElms[4 * 0 + scaleRow] = parseFloat(scale2[1]);
          scaleElms[4 * 1 + scaleRow] = parseFloat(scale2[2]);
          scaleElms[4 * 2 + scaleRow] = parseFloat(scale2[3]);
          scaleElms[4 * 3 + scaleRow] = parseFloat(scale2[4]);
        } else if (recordName === "CRYST1") {
          var aLength = parseFloat(line.substr(6, 9));
          var bLength = parseFloat(line.substr(15, 9));
          var cLength = parseFloat(line.substr(24, 9));
          var alpha = parseFloat(line.substr(33, 7));
          var beta = parseFloat(line.substr(40, 7));
          var gamma = parseFloat(line.substr(47, 7));
          var sGroup = line.substr(55, 11).trim();
          var box = new Float32Array(9);
          box[0] = aLength;
          box[4] = bLength;
          box[8] = cLength;
          boxes.push(box);
          if (modelIdx === 0) {
            unitcellDict.a = aLength;
            unitcellDict.b = bLength;
            unitcellDict.c = cLength;
            unitcellDict.alpha = alpha;
            unitcellDict.beta = beta;
            unitcellDict.gamma = gamma;
            unitcellDict.spacegroup = sGroup;
          }
        }
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    var en = entityDataList.length;
    if (entityDataList.length) {
      s.eachChain(function(cp) {
        cp.entityIndex = en;
      });
      entityDataList.forEach(function(e, i) {
        var chainIndexList = e.chainList.map(function(chainname2) {
          return chainDict[chainname2];
        });
        s.entityList.push(new Entity(s, i, e.name, "polymer", chainIndexList));
      });
      var ei = entityDataList.length;
      var rp = s.getResidueProxy();
      var residueDict = {};
      s.eachChain(function(cp) {
        if (cp.entityIndex === en) {
          rp.index = cp.residueOffset;
          if (!residueDict[rp.resname]) {
            residueDict[rp.resname] = [];
          }
          residueDict[rp.resname].push(cp.index);
        }
      });
      Object.keys(residueDict).forEach(function(resname2) {
        var chainList = residueDict[resname2];
        var type2 = "non-polymer";
        var name = hetnameDict[resname2] || resname2;
        if (WaterNames.includes(resname2)) {
          name = "water";
          type2 = "water";
        }
        s.entityList.push(new Entity(s, ei, name, type2, chainList));
        ei += 1;
      });
    }
    if (unitcellDict.a !== void 0) {
      s.unitcell = new Unitcell(unitcellDict);
    } else {
      s.unitcell = void 0;
    }
    if (helices.length || sheets.length) {
      assignSecondaryStructure(s, secStruct);
    }
    sb.finalize();
    s.finalizeAtoms();
    if (!isLegacy) {
      calculateChainnames(s);
    }
    calculateBonds(s);
    s.finalizeBonds();
    if (!helices.length && !sheets.length) {
      calculateSecondaryStructure(s);
    }
    buildUnitcellAssembly(s);
    if (Debug) {
      Log.timeEnd("PdbParser._parse " + this.name);
    }
  };
  Object.defineProperties(PdbParser2.prototype, prototypeAccessors2);
  return PdbParser2;
}(StructureParser);
ParserRegistry.add("pdb", PdbParser);
ParserRegistry.add("pdb1", PdbParser);
ParserRegistry.add("ent", PdbParser);
var reWhitespace = /\s+/;
var reQuotedWhitespace = /'((?:(?!'\s).)*)'|"((?:(?!"\s).)*)"|(\S+)/g;
var reDoubleQuote = /"/g;
var reTrimQuotes = /^['"]+|['"]+$/g;
function trimQuotes(str) {
  if (str && str[0] === str[str.length - 1] && (str[0] === "'" || str[0] === '"')) {
    return str.substring(1, str.length - 1);
  } else {
    return str;
  }
}
function ensureArray(dict, field) {
  if (!Array.isArray(dict[field])) {
    Object.keys(dict).forEach(function(key) {
      dict[key] = [dict[key]];
    });
  }
}
function hasValue(d) {
  return d !== "?";
}
function cifDefaults(value2, defaultValue) {
  return hasValue(value2) ? value2 : defaultValue;
}
function getBondOrder(valueOrder) {
  switch (valueOrder.toLowerCase()) {
    case "?":
    case "sing":
      return 1;
    case "doub":
      return 2;
    case "trip":
      return 3;
    case "quad":
      return 4;
  }
  return 0;
}
function parseChemComp(cif, structure, structureBuilder) {
  var atomStore = structure.atomStore;
  var atomMap = structure.atomMap;
  var i, n;
  var cc = cif.chem_comp;
  var cca = cif.chem_comp_atom;
  var ccb = cif.chem_comp_bond;
  if (cc) {
    if (cc.name) {
      structure.title = cc.name.trim().replace(reTrimQuotes, "");
    }
    if (cc.id) {
      structure.id = cc.id.trim().replace(reTrimQuotes, "");
    }
  }
  var atomnameDict = {};
  if (cca) {
    var atomname, element, resname, resno;
    n = cca.comp_id.length;
    for (i = 0; i < n; ++i) {
      atomStore.growIfFull();
      atomname = cca.atom_id[i].replace(reDoubleQuote, "");
      element = cca.type_symbol[i];
      atomnameDict[atomname] = i;
      atomStore.atomTypeId[i] = atomMap.add(atomname, element);
      atomStore.x[i] = cca.model_Cartn_x[i];
      atomStore.y[i] = cca.model_Cartn_y[i];
      atomStore.z[i] = cca.model_Cartn_z[i];
      atomStore.serial[i] = i;
      resname = cca.pdbx_component_comp_id[i];
      resno = cca.pdbx_residue_numbering ? cca.pdbx_residue_numbering[i] : 1;
      structureBuilder.addAtom(0, "", "", resname, resno, 1);
    }
    for (i = 0; i < n; ++i) {
      var j = i + n;
      atomStore.growIfFull();
      atomname = cca.atom_id[i].replace(reDoubleQuote, "");
      element = cca.type_symbol[i];
      atomStore.atomTypeId[j] = atomMap.add(atomname, element);
      atomStore.x[j] = cca.pdbx_model_Cartn_x_ideal[i];
      atomStore.y[j] = cca.pdbx_model_Cartn_y_ideal[i];
      atomStore.z[j] = cca.pdbx_model_Cartn_z_ideal[i];
      atomStore.serial[j] = j;
      resname = cca.pdbx_component_comp_id[i];
      resno = cca.pdbx_residue_numbering ? cca.pdbx_residue_numbering[i] : 1;
      structureBuilder.addAtom(1, "", "", resname, resno, 1);
    }
  }
  if (cca && ccb) {
    var atomname1, atomname2, bondOrder;
    n = ccb.comp_id.length;
    var na = cca.comp_id.length;
    var ap1 = structure.getAtomProxy();
    var ap2 = structure.getAtomProxy();
    for (i = 0; i < n; ++i) {
      atomname1 = ccb.atom_id_1[i].replace(reDoubleQuote, "");
      atomname2 = ccb.atom_id_2[i].replace(reDoubleQuote, "");
      bondOrder = getBondOrder(ccb.value_order[i]);
      ap1.index = atomnameDict[atomname1];
      ap2.index = atomnameDict[atomname2];
      structure.bondStore.growIfFull();
      structure.bondStore.addBond(ap1, ap2, bondOrder);
      ap1.index += na;
      ap2.index += na;
      structure.bondStore.growIfFull();
      structure.bondStore.addBond(ap1, ap2, bondOrder);
    }
  }
}
function parseCore(cif, structure, structureBuilder) {
  var atomStore = structure.atomStore;
  var atomMap = structure.atomMap;
  if (cif.data) {
    structure.id = cif.data;
    structure.name = cif.data;
  }
  structure.unitcell = new Unitcell({
    a: parseFloat(cif.cell_length_a),
    b: parseFloat(cif.cell_length_b),
    c: parseFloat(cif.cell_length_c),
    alpha: parseFloat(cif.cell_angle_alpha),
    beta: parseFloat(cif.cell_angle_beta),
    gamma: parseFloat(cif.cell_angle_gamma),
    spacegroup: trimQuotes(cif.symmetry_space_group_name_H)
  });
  var v = new Vector3();
  var c = new Vector3();
  var n = cif.atom_site_type_symbol.length;
  for (var i = 0; i < n; ++i) {
    atomStore.growIfFull();
    var atomname = cif.atom_site_label[i];
    var element = cif.atom_site_type_symbol[i];
    atomStore.atomTypeId[i] = atomMap.add(atomname, element);
    v.set(cif.atom_site_fract_x[i], cif.atom_site_fract_y[i], cif.atom_site_fract_z[i]);
    v.applyMatrix4(structure.unitcell.fracToCart);
    c.add(v);
    atomStore.x[i] = v.x;
    atomStore.y[i] = v.y;
    atomStore.z[i] = v.z;
    if (cif.atom_site_occupancy) {
      atomStore.occupancy[i] = parseFloat(cif.atom_site_occupancy[i]);
    }
    atomStore.serial[i] = i;
    structureBuilder.addAtom(0, "", "", "HET", 1, 1);
  }
  c.divideScalar(n);
  structure.center = c;
  buildUnitcellAssembly(structure);
  var v2 = new Vector3();
  var v3 = new Vector3();
  var ml = structure.biomolDict.SUPERCELL.partList[0].matrixList;
  var k = n;
  function covalent(idx) {
    return atomMap.get(atomStore.atomTypeId[idx]).covalent;
  }
  var identityMatrix = new Matrix4();
  var loop = function(i2) {
    var covalentI = covalent(i2);
    v.set(atomStore.x[i2], atomStore.y[i2], atomStore.z[i2]);
    ml.forEach(function(m2) {
      if (identityMatrix.equals(m2)) {
        return;
      }
      v2.copy(v);
      v2.applyMatrix4(m2);
      for (var j = 0; j < n; ++j) {
        v3.set(atomStore.x[j], atomStore.y[j], atomStore.z[j]);
        var distSquared = v2.distanceToSquared(v3);
        var d = covalent(j) + covalentI;
        var d1 = d + 0.3;
        var d2 = d - 0.5;
        if (distSquared < d1 * d1 && distSquared > d2 * d2) {
          atomStore.growIfFull();
          atomStore.atomTypeId[k] = atomStore.atomTypeId[i2];
          atomStore.x[k] = v2.x;
          atomStore.y[k] = v2.y;
          atomStore.z[k] = v2.z;
          atomStore.occupancy[k] = atomStore.occupancy[i2];
          atomStore.serial[k] = k;
          atomStore.altloc[k] = "A".charCodeAt(0);
          structureBuilder.addAtom(0, "", "", "HET", 1, 1);
          k += 1;
          return;
        }
      }
    });
  };
  for (var i$1 = 0; i$1 < n; ++i$1)
    loop(i$1);
}
function processSecondaryStructure(cif, structure, asymIdDict) {
  var helices = [];
  var sheets = [];
  var i, il, begIcode, endIcode;
  var sc = cif.struct_conf;
  if (sc) {
    ensureArray(sc, "id");
    for (i = 0, il = sc.beg_auth_seq_id.length; i < il; ++i) {
      var helixType = parseInt(sc.pdbx_PDB_helix_class[i]);
      if (!Number.isNaN(helixType)) {
        begIcode = sc.pdbx_beg_PDB_ins_code[i];
        endIcode = sc.pdbx_end_PDB_ins_code[i];
        helices.push([
          asymIdDict[sc.beg_label_asym_id[i]],
          parseInt(sc.beg_auth_seq_id[i]),
          cifDefaults(begIcode, ""),
          asymIdDict[sc.end_label_asym_id[i]],
          parseInt(sc.end_auth_seq_id[i]),
          cifDefaults(endIcode, ""),
          (HelixTypes[helixType] || HelixTypes[""]).charCodeAt(0)
        ]);
      }
    }
  }
  var ssr = cif.struct_sheet_range;
  if (ssr) {
    ensureArray(ssr, "id");
    for (i = 0, il = ssr.beg_auth_seq_id.length; i < il; ++i) {
      begIcode = ssr.pdbx_beg_PDB_ins_code[i];
      endIcode = ssr.pdbx_end_PDB_ins_code[i];
      sheets.push([
        asymIdDict[ssr.beg_label_asym_id[i]],
        parseInt(ssr.beg_auth_seq_id[i]),
        cifDefaults(begIcode, ""),
        asymIdDict[ssr.end_label_asym_id[i]],
        parseInt(ssr.end_auth_seq_id[i]),
        cifDefaults(endIcode, "")
      ]);
    }
  }
  if (sc || ssr) {
    return {
      helices,
      sheets
    };
  } else {
    return false;
  }
}
function processSymmetry(cif, structure, asymIdDict) {
  var operDict = {};
  var biomolDict = structure.biomolDict;
  if (cif.pdbx_struct_oper_list) {
    var biomolOp = cif.pdbx_struct_oper_list;
    ensureArray(biomolOp, "id");
    biomolOp.id.forEach(function(id, i) {
      var m2 = new Matrix4();
      var elms = m2.elements;
      elms[0] = parseFloat(biomolOp["matrix[1][1]"][i]);
      elms[1] = parseFloat(biomolOp["matrix[1][2]"][i]);
      elms[2] = parseFloat(biomolOp["matrix[1][3]"][i]);
      elms[4] = parseFloat(biomolOp["matrix[2][1]"][i]);
      elms[5] = parseFloat(biomolOp["matrix[2][2]"][i]);
      elms[6] = parseFloat(biomolOp["matrix[2][3]"][i]);
      elms[8] = parseFloat(biomolOp["matrix[3][1]"][i]);
      elms[9] = parseFloat(biomolOp["matrix[3][2]"][i]);
      elms[10] = parseFloat(biomolOp["matrix[3][3]"][i]);
      elms[3] = parseFloat(biomolOp["vector[1]"][i]);
      elms[7] = parseFloat(biomolOp["vector[2]"][i]);
      elms[11] = parseFloat(biomolOp["vector[3]"][i]);
      m2.transpose();
      operDict[id] = m2;
    });
  }
  if (cif.pdbx_struct_assembly_gen) {
    var gen = cif.pdbx_struct_assembly_gen;
    ensureArray(gen, "assembly_id");
    var getMatrixDict = function(expr) {
      var matDict = {};
      var l = expr.replace(/[()']/g, "").split(",");
      l.forEach(function(e) {
        if (e.includes("-")) {
          var es = e.split("-");
          var j = parseInt(es[0]);
          var m2 = parseInt(es[1]);
          for (; j <= m2; ++j) {
            matDict[j] = operDict[j];
          }
        } else {
          matDict[e] = operDict[e];
        }
      });
      return matDict;
    };
    gen.assembly_id.forEach(function(id, i) {
      var md = {};
      var oe = gen.oper_expression[i].replace(/['"]\(|['"]/g, "");
      if (oe.includes(")(") || oe.indexOf("(") > 0) {
        oe = oe.split("(");
        var md1 = getMatrixDict(oe[0]);
        var md2 = getMatrixDict(oe[1]);
        Object.keys(md1).forEach(function(k1) {
          Object.keys(md2).forEach(function(k2) {
            var mat = new Matrix4();
            mat.multiplyMatrices(md1[k1], md2[k2]);
            md[k1 + "x" + k2] = mat;
          });
        });
      } else {
        md = getMatrixDict(oe);
      }
      var matrixList = [];
      for (var k in md) {
        matrixList.push(md[k]);
      }
      var name = id;
      if (/^(0|[1-9][0-9]*)$/.test(name)) {
        name = "BU" + name;
      }
      var chainList = gen.asym_id_list[i].split(",");
      for (var j = 0, jl = chainList.length; j < jl; ++j) {
        chainList[j] = asymIdDict[chainList[j]];
      }
      if (biomolDict[name] === void 0) {
        biomolDict[name] = new Assembly(name);
      }
      biomolDict[name].addPart(matrixList, chainList);
    });
  }
  if (cif.struct_ncs_oper) {
    var ncsOp = cif.struct_ncs_oper;
    ensureArray(ncsOp, "id");
    var ncsName = "NCS";
    biomolDict[ncsName] = new Assembly(ncsName);
    var ncsPart = biomolDict[ncsName].addPart();
    ncsOp.id.forEach(function(id, i) {
      if (ncsOp.code[i] === "given") {
        return;
      }
      var m2 = new Matrix4();
      var elms = m2.elements;
      elms[0] = parseFloat(ncsOp["matrix[1][1]"][i]);
      elms[1] = parseFloat(ncsOp["matrix[1][2]"][i]);
      elms[2] = parseFloat(ncsOp["matrix[1][3]"][i]);
      elms[4] = parseFloat(ncsOp["matrix[2][1]"][i]);
      elms[5] = parseFloat(ncsOp["matrix[2][2]"][i]);
      elms[6] = parseFloat(ncsOp["matrix[2][3]"][i]);
      elms[8] = parseFloat(ncsOp["matrix[3][1]"][i]);
      elms[9] = parseFloat(ncsOp["matrix[3][2]"][i]);
      elms[10] = parseFloat(ncsOp["matrix[3][3]"][i]);
      elms[3] = parseFloat(ncsOp["vector[1]"][i]);
      elms[7] = parseFloat(ncsOp["vector[2]"][i]);
      elms[11] = parseFloat(ncsOp["vector[3]"][i]);
      m2.transpose();
      ncsPart.matrixList.push(m2);
    });
    if (ncsPart.matrixList.length === 0) {
      delete biomolDict[ncsName];
    }
  }
  var unitcellDict = {};
  if (cif.cell) {
    var cell = cif.cell;
    var a = parseFloat(cell.length_a);
    var b = parseFloat(cell.length_b);
    var c = parseFloat(cell.length_c);
    var box = new Float32Array(9);
    box[0] = a;
    box[4] = b;
    box[8] = c;
    structure.boxes.push(box);
    unitcellDict.a = a;
    unitcellDict.b = b;
    unitcellDict.c = c;
    unitcellDict.alpha = parseFloat(cell.angle_alpha);
    unitcellDict.beta = parseFloat(cell.angle_beta);
    unitcellDict.gamma = parseFloat(cell.angle_gamma);
  }
  if (cif.symmetry) {
    unitcellDict.spacegroup = trimQuotes(cif.symmetry["space_group_name_H-M"]);
  }
  var origx = new Matrix4();
  if (cif.database_PDB_matrix) {
    var origxMat = cif.database_PDB_matrix;
    var origxElms = origx.elements;
    origxElms[0] = parseFloat(origxMat["origx[1][1]"]);
    origxElms[1] = parseFloat(origxMat["origx[1][2]"]);
    origxElms[2] = parseFloat(origxMat["origx[1][3]"]);
    origxElms[4] = parseFloat(origxMat["origx[2][1]"]);
    origxElms[5] = parseFloat(origxMat["origx[2][2]"]);
    origxElms[6] = parseFloat(origxMat["origx[2][3]"]);
    origxElms[8] = parseFloat(origxMat["origx[3][1]"]);
    origxElms[9] = parseFloat(origxMat["origx[3][2]"]);
    origxElms[10] = parseFloat(origxMat["origx[3][3]"]);
    origxElms[3] = parseFloat(origxMat["origx_vector[1]"]);
    origxElms[7] = parseFloat(origxMat["origx_vector[2]"]);
    origxElms[11] = parseFloat(origxMat["origx_vector[3]"]);
    origx.transpose();
    unitcellDict.origx = origx;
  }
  var scale2 = new Matrix4();
  if (cif.atom_sites) {
    var scaleMat = cif.atom_sites;
    var scaleElms = scale2.elements;
    scaleElms[0] = parseFloat(scaleMat["fract_transf_matrix[1][1]"]);
    scaleElms[1] = parseFloat(scaleMat["fract_transf_matrix[1][2]"]);
    scaleElms[2] = parseFloat(scaleMat["fract_transf_matrix[1][3]"]);
    scaleElms[4] = parseFloat(scaleMat["fract_transf_matrix[2][1]"]);
    scaleElms[5] = parseFloat(scaleMat["fract_transf_matrix[2][2]"]);
    scaleElms[6] = parseFloat(scaleMat["fract_transf_matrix[2][3]"]);
    scaleElms[8] = parseFloat(scaleMat["fract_transf_matrix[3][1]"]);
    scaleElms[9] = parseFloat(scaleMat["fract_transf_matrix[3][2]"]);
    scaleElms[10] = parseFloat(scaleMat["fract_transf_matrix[3][3]"]);
    scaleElms[3] = parseFloat(scaleMat["fract_transf_vector[1]"]);
    scaleElms[7] = parseFloat(scaleMat["fract_transf_vector[2]"]);
    scaleElms[11] = parseFloat(scaleMat["fract_transf_vector[3]"]);
    scale2.transpose();
    unitcellDict.scale = scale2;
  }
  if (unitcellDict.a !== void 0) {
    structure.unitcell = new Unitcell(unitcellDict);
  } else {
    structure.unitcell = void 0;
  }
}
function processConnections(cif, structure, asymIdDict) {
  var sc = cif.struct_conn;
  if (sc) {
    ensureArray(sc, "id");
    var reDoubleQuote2 = /"/g;
    var ap1 = structure.getAtomProxy();
    var ap2 = structure.getAtomProxy();
    var atomIndicesCache = {};
    for (var i = 0, il = sc.id.length; i < il; ++i) {
      var connTypeId = sc.conn_type_id[i];
      if (connTypeId === "hydrog" || connTypeId === "mismat" || connTypeId === "saltbr") {
        continue;
      }
      if (sc.ptnr1_symmetry[i] !== "1_555" || sc.ptnr2_symmetry[i] !== "1_555") {
        continue;
      }
      var inscode1 = sc.pdbx_ptnr1_PDB_ins_code[i];
      var altloc1 = sc.pdbx_ptnr1_label_alt_id[i];
      var sele1 = sc.ptnr1_auth_seq_id[i] + (hasValue(inscode1) ? "^" + inscode1 : "") + ":" + asymIdDict[sc.ptnr1_label_asym_id[i]] + "." + sc.ptnr1_label_atom_id[i].replace(reDoubleQuote2, "") + (hasValue(altloc1) ? "%" + altloc1 : "");
      var atomIndices1 = atomIndicesCache[sele1];
      if (!atomIndices1) {
        var selection1 = new Selection(sele1);
        if (selection1.selection.error) {
          if (Debug) {
            Log.warn("invalid selection for connection", sele1);
          }
          continue;
        }
        atomIndices1 = structure.getAtomIndices(selection1);
        atomIndicesCache[sele1] = atomIndices1;
      }
      var inscode2 = sc.pdbx_ptnr2_PDB_ins_code[i];
      var altloc2 = sc.pdbx_ptnr2_label_alt_id[i];
      var sele2 = sc.ptnr2_auth_seq_id[i] + (hasValue(inscode2) ? "^" + inscode2 : "") + ":" + asymIdDict[sc.ptnr2_label_asym_id[i]] + "." + sc.ptnr2_label_atom_id[i].replace(reDoubleQuote2, "") + (hasValue(altloc2) ? "%" + altloc2 : "");
      var atomIndices2 = atomIndicesCache[sele2];
      if (!atomIndices2) {
        var selection2 = new Selection(sele2);
        if (selection2.selection.error) {
          if (Debug) {
            Log.warn("invalid selection for connection", sele2);
          }
          continue;
        }
        atomIndices2 = structure.getAtomIndices(selection2);
        atomIndicesCache[sele2] = atomIndices2;
      }
      var k = atomIndices1.length;
      var l = atomIndices2.length;
      if (k > l) {
        var tmpA = k;
        k = l;
        l = tmpA;
        var tmpB = atomIndices1;
        atomIndices1 = atomIndices2;
        atomIndices2 = tmpB;
      }
      if (k === 0 || l === 0) {
        if (Debug) {
          Log.warn("no atoms found for", sele1, sele2);
        }
        continue;
      }
      for (var j = 0; j < l; ++j) {
        ap1.index = atomIndices1[j % k];
        ap2.index = atomIndices2[j];
        if (ap1 && ap2) {
          structure.bondStore.addBond(ap1, ap2, getBondOrder(sc.pdbx_value_order[i]));
        } else {
          Log.log("atoms for connection not found");
        }
      }
    }
  }
}
function processEntities(cif, structure, chainIndexDict) {
  if (cif.entity) {
    ensureArray(cif.entity, "id");
    var e = cif.entity;
    var n = e.id.length;
    for (var i = 0; i < n; ++i) {
      var description = e.pdbx_description[i];
      var type2 = e.type[i];
      var chainIndexList = Array.from(chainIndexDict[e.id[i]]);
      structure.entityList[i] = new Entity(structure, i, description, type2, chainIndexList);
    }
  }
}
var CifParser = function(StructureParser$$1) {
  function CifParser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    CifParser2.__proto__ = StructureParser$$1;
  CifParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  CifParser2.prototype.constructor = CifParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "cif";
  };
  CifParser2.prototype._parse = function _parse2() {
    Log.time("CifParser._parse " + this.name);
    var s = this.structure;
    var sb = this.structureBuilder;
    var firstModelOnly = this.firstModelOnly;
    var asTrajectory = this.asTrajectory;
    var cAlphaOnly = this.cAlphaOnly;
    var frames = s.frames;
    var currentFrame, currentCoord;
    var rawline, line;
    var cif = {};
    var asymIdDict = {};
    var chainIndexDict = {};
    var pendingString = false;
    var currentString = null;
    var pendingValue = false;
    var pendingLoop = false;
    var pendingName = false;
    var loopPointers = [];
    var currentLoopIndex = null;
    var currentCategory = null;
    var currentName = null;
    var first = null;
    var pointerNames = [];
    var authAsymId, authSeqId, labelAtomId, labelCompId, labelAsymId, labelEntityId, labelAltId, groupPDB, id, typeSymbol, pdbxPDBmodelNum, pdbxPDBinsCode, CartnX, CartnY, CartnZ, bIsoOrEquiv, occupancy;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    atomStore.resize(this.streamer.data.length / 100);
    var idx = 0;
    var modelIdx = 0;
    var modelNum;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        rawline = lines[i];
        line = rawline.trim();
        if (!line && !pendingString && !pendingLoop || line[0] === "#") {
          pendingString = false;
          pendingLoop = false;
          pendingValue = false;
          loopPointers.length = 0;
          currentLoopIndex = null;
          currentCategory = null;
          currentName = null;
          first = null;
          pointerNames.length = 0;
        } else if (line.substring(0, 5) === "data_") {
          cif.data = line.substring(5).trim();
        } else if (line[0] === ";") {
          if (pendingString) {
            if (pendingLoop) {
              if (currentLoopIndex === loopPointers.length) {
                currentLoopIndex = 0;
              }
              loopPointers[currentLoopIndex].push(currentString);
              currentLoopIndex += 1;
            } else {
              if (currentName === false) {
                cif[currentCategory] = currentString;
              } else {
                cif[currentCategory][currentName] = currentString;
              }
            }
            pendingString = false;
            currentString = null;
          } else {
            pendingString = true;
            currentString = line.substring(1);
          }
        } else if (line === "loop_") {
          pendingLoop = true;
          pendingName = true;
          loopPointers.length = 0;
          pointerNames.length = 0;
          currentLoopIndex = 0;
        } else if (line[0] === "_") {
          var keyParts, category, name;
          if (pendingLoop && !pendingName) {
            pendingLoop = false;
          }
          if (pendingLoop) {
            keyParts = line.split(".");
            category = keyParts[0].substring(1);
            name = keyParts[1];
            if (keyParts.length === 1) {
              name = false;
              if (!cif[category]) {
                cif[category] = [];
              }
              loopPointers.push(cif[category]);
            } else {
              if (!cif[category]) {
                cif[category] = {};
              }
              if (cif[category][name]) {
                if (Debug) {
                  Log.warn(category, name, "already exists");
                }
              } else {
                cif[category][name] = [];
                loopPointers.push(cif[category][name]);
                pointerNames.push(name);
              }
            }
            currentCategory = category;
            currentName = name;
            first = true;
          } else {
            var keyValuePair = line.match(reQuotedWhitespace);
            var key = keyValuePair[0];
            var value2 = keyValuePair[1];
            keyParts = key.split(".");
            category = keyParts[0].substring(1);
            name = keyParts[1];
            if (keyParts.length === 1) {
              name = false;
              cif[category] = value2;
            } else {
              if (!cif[category]) {
                cif[category] = {};
              }
              if (cif[category][name]) {
                if (Debug) {
                  Log.warn(category, name, "already exists");
                }
              } else {
                cif[category][name] = value2;
              }
            }
            if (!value2) {
              pendingValue = true;
            }
            currentCategory = category;
            currentName = name;
          }
        } else {
          if (pendingString) {
            currentString += rawline;
          } else if (pendingLoop) {
            if (!line) {
              continue;
            } else if (currentCategory === "atom_site") {
              var ls = line.split(reWhitespace);
              if (first) {
                authAsymId = pointerNames.indexOf("auth_asym_id");
                authSeqId = pointerNames.indexOf("auth_seq_id");
                labelAtomId = pointerNames.indexOf("label_atom_id");
                labelCompId = pointerNames.indexOf("label_comp_id");
                labelAsymId = pointerNames.indexOf("label_asym_id");
                labelEntityId = pointerNames.indexOf("label_entity_id");
                labelAltId = pointerNames.indexOf("label_alt_id");
                CartnX = pointerNames.indexOf("Cartn_x");
                CartnY = pointerNames.indexOf("Cartn_y");
                CartnZ = pointerNames.indexOf("Cartn_z");
                id = pointerNames.indexOf("id");
                typeSymbol = pointerNames.indexOf("type_symbol");
                groupPDB = pointerNames.indexOf("group_PDB");
                bIsoOrEquiv = pointerNames.indexOf("B_iso_or_equiv");
                pdbxPDBmodelNum = pointerNames.indexOf("pdbx_PDB_model_num");
                pdbxPDBinsCode = pointerNames.indexOf("pdbx_PDB_ins_code");
                occupancy = pointerNames.indexOf("occupancy");
                first = false;
                modelNum = parseInt(ls[pdbxPDBmodelNum]);
                if (asTrajectory) {
                  currentFrame = [];
                  currentCoord = 0;
                }
              }
              var _modelNum = parseInt(ls[pdbxPDBmodelNum]);
              if (modelNum !== _modelNum) {
                if (asTrajectory) {
                  if (modelIdx === 0) {
                    frames.push(new Float32Array(currentFrame));
                  }
                  currentFrame = new Float32Array(atomStore.count * 3);
                  frames.push(currentFrame);
                  currentCoord = 0;
                }
                modelIdx += 1;
              }
              modelNum = _modelNum;
              if (firstModelOnly && modelIdx > 0) {
                continue;
              }
              var atomname = ls[labelAtomId].replace(reDoubleQuote, "");
              if (cAlphaOnly && atomname !== "CA") {
                continue;
              }
              var x = parseFloat(ls[CartnX]);
              var y = parseFloat(ls[CartnY]);
              var z = parseFloat(ls[CartnZ]);
              if (asTrajectory) {
                var frameOffset = currentCoord * 3;
                currentFrame[frameOffset + 0] = x;
                currentFrame[frameOffset + 1] = y;
                currentFrame[frameOffset + 2] = z;
                currentCoord += 1;
                if (modelIdx > 0) {
                  continue;
                }
              }
              var resname = ls[labelCompId];
              var resno = parseInt(ls[authSeqId]);
              var inscode = ls[pdbxPDBinsCode];
              inscode = inscode === "?" ? "" : inscode;
              var chainname = ls[authAsymId];
              var chainid = ls[labelAsymId];
              var hetero = ls[groupPDB][0] === "H" ? 1 : 0;
              var element = ls[typeSymbol];
              var bfactor = parseFloat(ls[bIsoOrEquiv]);
              var occ = parseFloat(ls[occupancy]);
              var altloc = ls[labelAltId];
              altloc = altloc === "." ? "" : altloc;
              atomStore.growIfFull();
              atomStore.atomTypeId[idx] = atomMap.add(atomname, element);
              atomStore.x[idx] = x;
              atomStore.y[idx] = y;
              atomStore.z[idx] = z;
              atomStore.serial[idx] = parseInt(ls[id]);
              atomStore.bfactor[idx] = isNaN(bfactor) ? 0 : bfactor;
              atomStore.occupancy[idx] = isNaN(occ) ? 0 : occ;
              atomStore.altloc[idx] = altloc.charCodeAt(0);
              sb.addAtom(modelIdx, chainname, chainid, resname, resno, hetero, void 0, inscode);
              if (Debug) {
                var assignedChainname = asymIdDict[chainid];
                if (assignedChainname !== void 0 && assignedChainname !== chainname) {
                  if (Debug) {
                    Log.warn(assignedChainname, chainname);
                  }
                }
              }
              asymIdDict[chainid] = chainname;
              var entityId = ls[labelEntityId];
              if (!chainIndexDict[entityId]) {
                chainIndexDict[entityId] = new Set();
              }
              chainIndexDict[entityId].add(s.chainStore.count - 1);
              idx += 1;
            } else {
              var ls$1 = line.match(reQuotedWhitespace);
              var nn = ls$1.length;
              if (currentLoopIndex === loopPointers.length) {
                currentLoopIndex = 0;
              }
              for (var j = 0; j < nn; ++j) {
                loopPointers[currentLoopIndex + j].push(ls$1[j]);
              }
              currentLoopIndex += nn;
            }
            pendingName = false;
          } else if (line[0] === "'" && line[line.length - 1] === "'") {
            var str = line.substring(1, line.length - 1);
            if (currentName === false) {
              cif[currentCategory] = str;
            } else {
              cif[currentCategory][currentName] = str;
            }
          } else if (pendingValue) {
            if (currentName === false) {
              cif[currentCategory] = line;
            } else {
              cif[currentCategory][currentName] = line;
            }
          } else {
            if (Debug) {
              Log.log("CifParser._parse: unknown state", line);
            }
          }
        }
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    if (cif.chem_comp && cif.chem_comp_atom) {
      parseChemComp(cif, s, sb);
      sb.finalize();
      s.finalizeAtoms();
      s.finalizeBonds();
      assignResidueTypeBonds(s);
    } else if (cif.atom_site_type_symbol && cif.atom_site_label && cif.atom_site_fract_x) {
      parseCore(cif, s, sb);
      sb.finalize();
      s.finalizeAtoms();
      calculateBonds(s);
      s.finalizeBonds();
    } else {
      var secStruct = processSecondaryStructure(cif, s, asymIdDict);
      processSymmetry(cif, s, asymIdDict);
      processConnections(cif, s, asymIdDict);
      processEntities(cif, s, chainIndexDict);
      if (cif.struct && cif.struct.title) {
        s.title = cif.struct.title.trim().replace(reTrimQuotes, "");
      }
      if (cif.entry && cif.entry.id) {
        s.id = cif.entry.id.trim().replace(reTrimQuotes, "");
      }
      if (cif.database_PDB_rev) {
        if (cif.database_PDB_rev.date) {
          ensureArray(cif.database_PDB_rev, "date");
          var dates = cif.database_PDB_rev.date.filter(hasValue);
          if (dates.length) {
            s.header.releaseDate = dates[dates.length - 1];
          }
        }
        if (cif.database_PDB_rev.date_original) {
          ensureArray(cif.database_PDB_rev, "date_original");
          var depDates = cif.database_PDB_rev.date_original.filter(hasValue);
          if (depDates.length) {
            s.header.depositionDate = depDates[depDates.length - 1];
          }
        }
      }
      if (cif.reflns && cif.reflns.d_resolution_high) {
        if (hasValue(cif.reflns.d_resolution_high)) {
          s.header.resolution = parseFloat(cif.reflns.d_resolution_high);
        }
      } else if (cif.refine && cif.refine.ls_d_res_high) {
        if (hasValue(cif.refine.ls_d_res_high)) {
          s.header.resolution = parseFloat(cif.refine.ls_d_res_high);
        }
      }
      if (cif.refine && cif.refine.ls_R_factor_R_free) {
        if (hasValue(cif.refine.ls_R_factor_R_free)) {
          s.header.rFree = parseFloat(cif.refine.ls_R_factor_R_free);
        }
      }
      if (cif.refine && cif.refine.ls_R_factor_R_work) {
        if (hasValue(cif.refine.ls_R_factor_R_work)) {
          s.header.rWork = parseFloat(cif.refine.ls_R_factor_R_work);
        }
      }
      if (cif.exptl && cif.exptl.method) {
        ensureArray(cif.exptl, "method");
        s.header.experimentalMethods = cif.exptl.method.map(function(m2) {
          return m2.replace(reTrimQuotes, "");
        });
      }
      sb.finalize();
      s.finalizeAtoms();
      calculateBonds(s);
      s.finalizeBonds();
      if (!secStruct) {
        calculateSecondaryStructure(s);
      } else {
        assignSecondaryStructure(s, secStruct);
      }
      buildUnitcellAssembly(s);
      s.extraData.cif = cif;
    }
    if (Debug) {
      Log.timeEnd("CifParser._parse " + this.name);
    }
  };
  Object.defineProperties(CifParser2.prototype, prototypeAccessors2);
  return CifParser2;
}(StructureParser);
ParserRegistry.add("cif", CifParser);
ParserRegistry.add("mcif", CifParser);
ParserRegistry.add("mmcif", CifParser);
var GroParser = function(StructureParser$$1) {
  function GroParser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    GroParser2.__proto__ = StructureParser$$1;
  GroParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  GroParser2.prototype.constructor = GroParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "gro";
  };
  GroParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("GroParser._parse " + this.name);
    }
    var s = this.structure;
    var sb = this.structureBuilder;
    var firstModelOnly = this.firstModelOnly;
    var asTrajectory = this.asTrajectory;
    var cAlphaOnly = this.cAlphaOnly;
    var frames = s.frames;
    var boxes = s.boxes;
    var currentFrame, currentCoord;
    var firstLines = this.streamer.peekLines(3);
    s.title = firstLines[0].trim();
    var ndec = firstLines[2].length - firstLines[2].lastIndexOf(".") - 1;
    var lpos = 5 + ndec;
    var xpos = 20;
    var ypos = 20 + lpos;
    var zpos = 20 + 2 * lpos;
    var atomname, resname, resno, serial;
    var atomCount = parseInt(firstLines[1]);
    var modelLineCount = atomCount + 3;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    atomStore.resize(atomCount);
    var idx = 0;
    var modelIdx = 0;
    var lineNo = 0;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        ++lineNo;
        var l = lineNo - 1;
        var line = lines[i];
        if (!line) {
          continue;
        }
        if (l % modelLineCount === 0) {
          if (asTrajectory) {
            currentFrame = new Float32Array(atomCount * 3);
            frames.push(currentFrame);
            currentCoord = 0;
          }
        } else if (l % modelLineCount === 1)
          ;
        else if (l % modelLineCount === modelLineCount - 1) {
          var str = line.trim().split(/\s+/);
          var box = new Float32Array(9);
          box[0] = parseFloat(str[0]) * 10;
          box[4] = parseFloat(str[1]) * 10;
          box[8] = parseFloat(str[2]) * 10;
          boxes.push(box);
          if (firstModelOnly) {
            return true;
          }
          modelIdx += 1;
        } else {
          atomname = line.substr(10, 5).trim();
          if (cAlphaOnly && atomname !== "CA") {
            continue;
          }
          var x = parseFloat(line.substr(xpos, lpos)) * 10;
          var y = parseFloat(line.substr(ypos, lpos)) * 10;
          var z = parseFloat(line.substr(zpos, lpos)) * 10;
          if (asTrajectory) {
            var j = currentCoord * 3;
            currentFrame[j + 0] = x;
            currentFrame[j + 1] = y;
            currentFrame[j + 2] = z;
            currentCoord += 1;
            if (l > modelLineCount) {
              continue;
            }
          }
          resname = line.substr(5, 5).trim();
          resno = parseInt(line.substr(0, 5));
          serial = parseInt(line.substr(15, 5));
          atomStore.growIfFull();
          atomStore.atomTypeId[idx] = atomMap.add(atomname);
          atomStore.x[idx] = x;
          atomStore.y[idx] = y;
          atomStore.z[idx] = z;
          atomStore.serial[idx] = serial;
          sb.addAtom(modelIdx, "", "", resname, resno, 0, "l");
          idx += 1;
        }
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    sb.finalize();
    s.finalizeAtoms();
    calculateChainnames(s);
    calculateBonds(s);
    s.finalizeBonds();
    calculateSecondaryStructure(s);
    if (Debug) {
      Log.timeEnd("GroParser._parse " + this.name);
    }
  };
  Object.defineProperties(GroParser2.prototype, prototypeAccessors2);
  return GroParser2;
}(StructureParser);
ParserRegistry.add("gro", GroParser);
var PassThroughFields = [
  "mmtfVersion",
  "mmtfProducer",
  "unitCell",
  "spaceGroup",
  "structureId",
  "title",
  "depositionDate",
  "releaseDate",
  "experimentalMethods",
  "resolution",
  "rFree",
  "rWork",
  "bioAssemblyList",
  "ncsOperatorList",
  "entityList",
  "groupList",
  "numBonds",
  "numAtoms",
  "numGroups",
  "numChains",
  "numModels",
  "groupsPerChain",
  "chainsPerModel"
];
var EncodedFields = [
  "xCoordList",
  "yCoordList",
  "zCoordList",
  "groupIdList",
  "groupTypeList",
  "chainIdList",
  "bFactorList",
  "atomIdList",
  "altLocList",
  "occupancyList",
  "secStructList",
  "insCodeList",
  "sequenceIndexList",
  "chainNameList",
  "bondAtomList",
  "bondOrderList"
];
var AllFields = PassThroughFields.concat(EncodedFields);
function getView2(ctor, typedArray, elemSize) {
  return typedArray ? new ctor(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / (elemSize || 1)) : void 0;
}
function getDataView(typedArray) {
  return getView2(DataView, typedArray);
}
function getUint8View(typedArray) {
  return getView2(Uint8Array, typedArray);
}
function getInt8View(typedArray) {
  return getView2(Int8Array, typedArray);
}
function getInt32View(typedArray) {
  return getView2(Int32Array, typedArray, 4);
}
function getFloat32View(typedArray) {
  return getView2(Float32Array, typedArray, 4);
}
function decodeInt16(bytes, output) {
  var n = bytes.length / 2;
  if (!output) {
    output = new Int16Array(n);
  }
  for (var i = 0, i2 = 0; i < n; ++i, i2 += 2) {
    output[i] = bytes[i2] << 8 ^ bytes[i2 + 1] << 0;
  }
  return output;
}
function decodeInt32(bytes, output) {
  var n = bytes.length / 4;
  if (!output) {
    output = new Int32Array(n);
  }
  for (var i = 0, i4 = 0; i < n; ++i, i4 += 4) {
    output[i] = bytes[i4] << 24 ^ bytes[i4 + 1] << 16 ^ bytes[i4 + 2] << 8 ^ bytes[i4 + 3] << 0;
  }
  return output;
}
function decodeFloat32(bytes, output) {
  var n = bytes.length;
  if (!output) {
    output = new Float32Array(n / 4);
  }
  var dvOut = getDataView(output);
  var dvIn = getDataView(bytes);
  for (var i = 0, i4 = 0, il = n / 4; i < il; ++i, i4 += 4) {
    dvOut.setFloat32(i4, dvIn.getFloat32(i4), true);
  }
  return output;
}
function decodeInteger(intArray, divisor, output) {
  var n = intArray.length;
  var invDiv = 1 / divisor;
  if (!output) {
    output = new Float32Array(n);
  }
  for (var i = 0; i < n; ++i) {
    output[i] = intArray[i] * invDiv;
  }
  return output;
}
function decodeRun(array, output) {
  var i, il;
  if (!output) {
    var fullLength = 0;
    for (i = 0, il = array.length; i < il; i += 2) {
      fullLength += array[i + 1];
    }
    output = new array.constructor(fullLength);
  }
  var dataOffset = 0;
  for (i = 0, il = array.length; i < il; i += 2) {
    var value2 = array[i];
    var length = array[i + 1];
    for (var j = 0; j < length; ++j) {
      output[dataOffset] = value2;
      ++dataOffset;
    }
  }
  return output;
}
function decodeDelta(array, output) {
  var n = array.length;
  if (!output) {
    output = new array.constructor(n);
  }
  if (n) {
    output[0] = array[0];
  }
  for (var i = 1; i < n; ++i) {
    output[i] = array[i] + output[i - 1];
  }
  return output;
}
function decodePacking(int16or8, output) {
  var upperLimit = int16or8 instanceof Int8Array ? 127 : 32767;
  var lowerLimit = -upperLimit - 1;
  var n = int16or8.length;
  var i, j;
  if (!output) {
    var fullLength = 0;
    for (i = 0; i < n; ++i) {
      if (int16or8[i] < upperLimit && int16or8[i] > lowerLimit) {
        ++fullLength;
      }
    }
    output = new Int32Array(fullLength);
  }
  i = 0;
  j = 0;
  while (i < n) {
    var value2 = 0;
    while (int16or8[i] === upperLimit || int16or8[i] === lowerLimit) {
      value2 += int16or8[i];
      ++i;
    }
    value2 += int16or8[i];
    ++i;
    output[j] = value2;
    ++j;
  }
  return output;
}
function decodeDeltaRun(array, output) {
  return decodeDelta(decodeRun(array), output);
}
function decodeIntegerRun(intArray, divisor, output) {
  return decodeInteger(decodeRun(intArray, getInt32View(output)), divisor, output);
}
function decodeIntegerDelta(intArray, divisor, output) {
  return decodeInteger(decodeDelta(intArray, getInt32View(output)), divisor, output);
}
function decodeIntegerPacking(int16or8, divisor, output) {
  return decodeInteger(decodePacking(int16or8, getInt32View(output)), divisor, output);
}
function decodeIntegerDeltaPacking(int16or8, divisor, output) {
  var unpacked = decodePacking(int16or8, getInt32View(output));
  return decodeIntegerDelta(unpacked, divisor, getFloat32View(unpacked));
}
function decodeBytes(bytes) {
  var dv = getDataView(bytes);
  var type2 = dv.getInt32(0);
  var size = dv.getInt32(4);
  var param = bytes.subarray(8, 12);
  var bytes = bytes.subarray(12);
  return [type2, bytes, size, param];
}
function decodeMsgpack(buffer) {
  var offset = 0;
  var dataView = new DataView(buffer.buffer);
  function map2(length) {
    var value2 = {};
    for (var i = 0; i < length; i++) {
      var key = parse3();
      value2[key] = parse3();
    }
    return value2;
  }
  function bin(length) {
    var value2 = buffer.subarray(offset, offset + length);
    offset += length;
    return value2;
  }
  function str(length) {
    var array2 = buffer.subarray(offset, offset + length);
    offset += length;
    var chunkSize = 65535;
    if (length > chunkSize) {
      var c = [];
      for (var i = 0; i < array2.length; i += chunkSize) {
        c.push(String.fromCharCode.apply(null, array2.subarray(i, i + chunkSize)));
      }
      return c.join("");
    } else {
      return String.fromCharCode.apply(null, array2);
    }
  }
  function array(length) {
    var value2 = new Array(length);
    for (var i = 0; i < length; i++) {
      value2[i] = parse3();
    }
    return value2;
  }
  function parse3() {
    var type2 = buffer[offset];
    var value2, length;
    if ((type2 & 128) === 0) {
      offset++;
      return type2;
    }
    if ((type2 & 240) === 128) {
      length = type2 & 15;
      offset++;
      return map2(length);
    }
    if ((type2 & 240) === 144) {
      length = type2 & 15;
      offset++;
      return array(length);
    }
    if ((type2 & 224) === 160) {
      length = type2 & 31;
      offset++;
      return str(length);
    }
    if ((type2 & 224) === 224) {
      value2 = dataView.getInt8(offset);
      offset++;
      return value2;
    }
    switch (type2) {
      case 192:
        offset++;
        return null;
      case 194:
        offset++;
        return false;
      case 195:
        offset++;
        return true;
      case 196:
        length = dataView.getUint8(offset + 1);
        offset += 2;
        return bin(length);
      case 197:
        length = dataView.getUint16(offset + 1);
        offset += 3;
        return bin(length);
      case 198:
        length = dataView.getUint32(offset + 1);
        offset += 5;
        return bin(length);
      case 202:
        value2 = dataView.getFloat32(offset + 1);
        offset += 5;
        return value2;
      case 203:
        value2 = dataView.getFloat64(offset + 1);
        offset += 9;
        return value2;
      case 204:
        value2 = buffer[offset + 1];
        offset += 2;
        return value2;
      case 205:
        value2 = dataView.getUint16(offset + 1);
        offset += 3;
        return value2;
      case 206:
        value2 = dataView.getUint32(offset + 1);
        offset += 5;
        return value2;
      case 208:
        value2 = dataView.getInt8(offset + 1);
        offset += 2;
        return value2;
      case 209:
        value2 = dataView.getInt16(offset + 1);
        offset += 3;
        return value2;
      case 210:
        value2 = dataView.getInt32(offset + 1);
        offset += 5;
        return value2;
      case 217:
        length = dataView.getUint8(offset + 1);
        offset += 2;
        return str(length);
      case 218:
        length = dataView.getUint16(offset + 1);
        offset += 3;
        return str(length);
      case 219:
        length = dataView.getUint32(offset + 1);
        offset += 5;
        return str(length);
      case 220:
        length = dataView.getUint16(offset + 1);
        offset += 3;
        return array(length);
      case 221:
        length = dataView.getUint32(offset + 1);
        offset += 5;
        return array(length);
      case 222:
        length = dataView.getUint16(offset + 1);
        offset += 3;
        return map2(length);
      case 223:
        length = dataView.getUint32(offset + 1);
        offset += 5;
        return map2(length);
    }
    throw new Error("Unknown type 0x" + type2.toString(16));
  }
  return parse3();
}
function performDecoding(type2, bytes, size, param) {
  switch (type2) {
    case 1:
      return decodeFloat32(bytes);
    case 2:
      return getInt8View(bytes);
    case 3:
      return decodeInt16(bytes);
    case 4:
      return decodeInt32(bytes);
    case 5:
      return getUint8View(bytes);
    case 6:
      return decodeRun(decodeInt32(bytes), new Uint8Array(size));
    case 7:
      return decodeRun(decodeInt32(bytes));
    case 8:
      return decodeDeltaRun(decodeInt32(bytes));
    case 9:
      return decodeIntegerRun(decodeInt32(bytes), decodeInt32(param)[0]);
    case 10:
      return decodeIntegerDeltaPacking(decodeInt16(bytes), decodeInt32(param)[0]);
    case 11:
      return decodeInteger(decodeInt16(bytes), decodeInt32(param)[0]);
    case 12:
      return decodeIntegerPacking(decodeInt16(bytes), decodeInt32(param)[0]);
    case 13:
      return decodeIntegerPacking(getInt8View(bytes), decodeInt32(param)[0]);
    case 14:
      return decodePacking(decodeInt16(bytes));
    case 15:
      return decodePacking(getInt8View(bytes));
  }
}
function decodeMmtf(inputDict, params) {
  params = params || {};
  var ignoreFields = params.ignoreFields;
  var outputDict = {};
  AllFields.forEach(function(name) {
    var ignore = ignoreFields ? ignoreFields.indexOf(name) !== -1 : false;
    var data = inputDict[name];
    if (!ignore && data !== void 0) {
      if (data instanceof Uint8Array) {
        outputDict[name] = performDecoding.apply(null, decodeBytes(data));
      } else {
        outputDict[name] = data;
      }
    }
  });
  return outputDict;
}
var SstrucMap = {
  "0": "i".charCodeAt(0),
  "1": "s".charCodeAt(0),
  "2": "h".charCodeAt(0),
  "3": "e".charCodeAt(0),
  "4": "g".charCodeAt(0),
  "5": "b".charCodeAt(0),
  "6": "t".charCodeAt(0),
  "7": "l".charCodeAt(0),
  "-1": "".charCodeAt(0)
};
var MmtfParser = function(StructureParser$$1) {
  function MmtfParser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    MmtfParser2.__proto__ = StructureParser$$1;
  MmtfParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  MmtfParser2.prototype.constructor = MmtfParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "mmtf";
  };
  MmtfParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("MmtfParser._parse " + this.name);
    }
    var i, il, j, jl, groupData;
    var s = this.structure;
    var sd = decodeMmtf(decodeMsgpack(this.streamer.data));
    var headerFields = [
      "depositionDate",
      "releaseDate",
      "resolution",
      "rFree",
      "rWork",
      "experimentalMethods"
    ];
    headerFields.forEach(function(name) {
      if (sd[name] !== void 0) {
        s.header[name] = sd[name];
      }
    });
    var numBonds, numAtoms, numGroups, numChains, numModels;
    var chainsPerModel;
    s.id = sd.structureId;
    s.title = sd.title;
    if (this.firstModelOnly || this.asTrajectory) {
      numModels = 1;
      numChains = sd.chainsPerModel[0];
      numGroups = 0;
      for (i = 0, il = numChains; i < il; ++i) {
        numGroups += sd.groupsPerChain[i];
      }
      numAtoms = 0;
      for (i = 0, il = numGroups; i < il; ++i) {
        groupData = sd.groupList[sd.groupTypeList[i]];
        numAtoms += groupData.atomNameList.length;
      }
      numBonds = sd.numBonds;
      chainsPerModel = [numChains];
    } else {
      numBonds = sd.numBonds;
      numAtoms = sd.numAtoms;
      numGroups = sd.numGroups;
      numChains = sd.numChains;
      numModels = sd.numModels;
      chainsPerModel = sd.chainsPerModel;
    }
    numBonds += numGroups;
    if (this.asTrajectory) {
      for (i = 0, il = sd.numModels; i < il; ++i) {
        var frame = new Float32Array(numAtoms * 3);
        var frameAtomOffset = numAtoms * i;
        for (j = 0; j < numAtoms; ++j) {
          var j3 = j * 3;
          var offset = j + frameAtomOffset;
          frame[j3] = sd.xCoordList[offset];
          frame[j3 + 1] = sd.yCoordList[offset];
          frame[j3 + 2] = sd.zCoordList[offset];
        }
        s.frames.push(frame);
      }
    }
    var bAtomIndex1 = new Uint32Array(numBonds);
    var bAtomIndex2 = new Uint32Array(numBonds);
    var bBondOrder = new Uint8Array(numBonds);
    var aGroupIndex = new Uint32Array(numAtoms);
    var gChainIndex = new Uint32Array(numGroups);
    var gAtomOffset = new Uint32Array(numGroups);
    var gAtomCount = new Uint16Array(numGroups);
    var cModelIndex = new Uint16Array(numChains);
    var cGroupOffset = new Uint32Array(numChains);
    var cGroupCount = new Uint32Array(numChains);
    var mChainOffset = new Uint32Array(numModels);
    var mChainCount = new Uint32Array(numModels);
    var chainOffset = 0;
    for (i = 0, il = numModels; i < il; ++i) {
      var modelChainCount = chainsPerModel[i];
      mChainOffset[i] = chainOffset;
      mChainCount[i] = modelChainCount;
      for (j = 0; j < modelChainCount; ++j) {
        cModelIndex[j + chainOffset] = i;
      }
      chainOffset += modelChainCount;
    }
    var groupsPerChain = sd.groupsPerChain;
    var groupOffset = 0;
    for (i = 0, il = numChains; i < il; ++i) {
      var chainGroupCount = groupsPerChain[i];
      cGroupOffset[i] = groupOffset;
      cGroupCount[i] = chainGroupCount;
      for (j = 0; j < chainGroupCount; ++j) {
        gChainIndex[j + groupOffset] = i;
      }
      groupOffset += chainGroupCount;
    }
    var atomOffset = 0;
    var bondOffset = 0;
    for (i = 0, il = numGroups; i < il; ++i) {
      groupData = sd.groupList[sd.groupTypeList[i]];
      var groupAtomCount = groupData.atomNameList.length;
      var groupBondAtomList = groupData.bondAtomList;
      var groupBondOrderList = groupData.bondOrderList;
      for (j = 0, jl = groupBondOrderList.length; j < jl; ++j) {
        bAtomIndex1[bondOffset] = atomOffset + groupBondAtomList[j * 2];
        bAtomIndex2[bondOffset] = atomOffset + groupBondAtomList[j * 2 + 1];
        bBondOrder[bondOffset] = groupBondOrderList[j];
        bondOffset += 1;
      }
      gAtomOffset[i] = atomOffset;
      gAtomCount[i] = groupAtomCount;
      for (j = 0; j < groupAtomCount; ++j) {
        aGroupIndex[atomOffset] = i;
        atomOffset += 1;
      }
    }
    var bondAtomList = sd.bondAtomList;
    if (bondAtomList) {
      if (sd.bondOrderList) {
        bBondOrder.set(sd.bondOrderList, bondOffset);
      }
      for (i = 0, il = bondAtomList.length; i < il; i += 2) {
        var atomIndex1 = bondAtomList[i];
        var atomIndex2 = bondAtomList[i + 1];
        if (atomIndex1 < numAtoms && atomIndex2 < numAtoms) {
          bAtomIndex1[bondOffset] = atomIndex1;
          bAtomIndex2[bondOffset] = atomIndex2;
          bondOffset += 1;
        }
      }
    }
    s.bondStore.length = bBondOrder.length;
    s.bondStore.count = bondOffset;
    s.bondStore.atomIndex1 = bAtomIndex1;
    s.bondStore.atomIndex2 = bAtomIndex2;
    s.bondStore.bondOrder = bBondOrder;
    s.atomStore.length = numAtoms;
    s.atomStore.count = numAtoms;
    s.atomStore.residueIndex = aGroupIndex;
    s.atomStore.atomTypeId = new Uint16Array(numAtoms);
    s.atomStore.x = sd.xCoordList.subarray(0, numAtoms);
    s.atomStore.y = sd.yCoordList.subarray(0, numAtoms);
    s.atomStore.z = sd.zCoordList.subarray(0, numAtoms);
    s.atomStore.serial = sd.atomIdList.subarray(0, numAtoms);
    s.atomStore.bfactor = sd.bFactorList.subarray(0, numAtoms);
    s.atomStore.altloc = sd.altLocList.subarray(0, numAtoms);
    s.atomStore.occupancy = sd.occupancyList.subarray(0, numAtoms);
    s.residueStore.length = numGroups;
    s.residueStore.count = numGroups;
    s.residueStore.chainIndex = gChainIndex;
    s.residueStore.residueTypeId = sd.groupTypeList;
    s.residueStore.atomOffset = gAtomOffset;
    s.residueStore.atomCount = gAtomCount;
    s.residueStore.resno = sd.groupIdList.subarray(0, numGroups);
    s.residueStore.sstruc = sd.secStructList.subarray(0, numGroups);
    s.residueStore.inscode = sd.insCodeList.subarray(0, numGroups);
    s.chainStore.length = numChains;
    s.chainStore.count = numChains;
    s.chainStore.entityIndex = new Uint16Array(numChains);
    s.chainStore.modelIndex = cModelIndex;
    s.chainStore.residueOffset = cGroupOffset;
    s.chainStore.residueCount = cGroupCount;
    s.chainStore.chainname = sd.chainNameList.subarray(0, numChains * 4);
    s.chainStore.chainid = sd.chainIdList.subarray(0, numChains * 4);
    s.modelStore.length = numModels;
    s.modelStore.count = numModels;
    s.modelStore.chainOffset = mChainOffset;
    s.modelStore.chainCount = mChainCount;
    var groupTypeDict = {};
    for (i = 0, il = sd.groupList.length; i < il; ++i) {
      var groupType = sd.groupList[i];
      var atomTypeIdList = [];
      for (j = 0, jl = groupType.atomNameList.length; j < jl; ++j) {
        var element = groupType.elementList[j].toUpperCase();
        var atomname = groupType.atomNameList[j];
        atomTypeIdList.push(s.atomMap.add(atomname, element));
      }
      var chemCompType = groupType.chemCompType.toUpperCase();
      var hetFlag = ChemCompHetero.includes(chemCompType);
      var numGroupBonds = groupType.bondOrderList.length;
      var atomIndices1 = new Array(numGroupBonds);
      var atomIndices2 = new Array(numGroupBonds);
      for (j = 0; j < numGroupBonds; ++j) {
        atomIndices1[j] = groupType.bondAtomList[j * 2];
        atomIndices2[j] = groupType.bondAtomList[j * 2 + 1];
      }
      var bonds = {
        atomIndices1,
        atomIndices2,
        bondOrders: groupType.bondOrderList
      };
      groupTypeDict[i] = s.residueMap.add(groupType.groupName, atomTypeIdList, hetFlag, chemCompType, bonds);
    }
    for (i = 0, il = numGroups; i < il; ++i) {
      s.residueStore.residueTypeId[i] = groupTypeDict[s.residueStore.residueTypeId[i]];
    }
    for (i = 0, il = s.atomStore.count; i < il; ++i) {
      var residueIndex = s.atomStore.residueIndex[i];
      var residueType = s.residueMap.list[s.residueStore.residueTypeId[residueIndex]];
      var resAtomOffset = s.residueStore.atomOffset[residueIndex];
      s.atomStore.atomTypeId[i] = residueType.atomTypeIdList[i - resAtomOffset];
    }
    if (sd.secStructList) {
      var secStructLength = sd.secStructList.length;
      for (i = 0, il = s.residueStore.count; i < il; ++i) {
        var sstruc = SstrucMap[s.residueStore.sstruc[i % secStructLength]];
        if (sstruc !== void 0) {
          s.residueStore.sstruc[i] = sstruc;
        }
      }
    }
    if (sd.entityList) {
      sd.entityList.forEach(function(e, i2) {
        s.entityList[i2] = new Entity(s, i2, e.description, e.type, e.chainIndexList);
      });
    }
    if (sd.bioAssemblyList) {
      sd.bioAssemblyList.forEach(function(_assembly, k) {
        var id = k + 1;
        var assembly = new Assembly(id);
        s.biomolDict["BU" + id] = assembly;
        var chainToPart = {};
        _assembly.transformList.forEach(function(_transform) {
          var matrix2 = new Matrix4().fromArray(_transform.matrix).transpose();
          var chainList = _transform.chainIndexList.map(function(chainIndex) {
            var chainname = "";
            for (var k2 = 0; k2 < 4; ++k2) {
              var code = sd.chainNameList[chainIndex * 4 + k2];
              if (code) {
                chainname += String.fromCharCode(code);
              } else {
                break;
              }
            }
            return chainname;
          });
          var part = chainToPart[chainList];
          if (part) {
            part.matrixList.push(matrix2);
          } else {
            chainToPart[chainList] = assembly.addPart([matrix2], chainList);
          }
        });
      });
    }
    if (sd.ncsOperatorList) {
      var ncsName = "NCS";
      var ncsAssembly = new Assembly(ncsName);
      var ncsPart = ncsAssembly.addPart();
      sd.ncsOperatorList.forEach(function(_operator) {
        var matrix2 = new Matrix4().fromArray(_operator).transpose();
        ncsPart.matrixList.push(matrix2);
      });
      if (ncsPart.matrixList.length > 0) {
        s.biomolDict[ncsName] = ncsAssembly;
      }
    }
    var uc = sd.unitCell;
    if (uc && Array.isArray(uc) && uc[0]) {
      s.unitcell = new Unitcell({
        a: uc[0],
        b: uc[1],
        c: uc[2],
        alpha: uc[3],
        beta: uc[4],
        gamma: uc[5],
        spacegroup: sd.spaceGroup
      });
    } else {
      s.unitcell = void 0;
    }
    calculateBondsBetween(s, true);
    calculateBondsWithin(s, true);
    s.finalizeAtoms();
    s.finalizeBonds();
    buildUnitcellAssembly(s);
    if (Debug) {
      Log.timeEnd("MmtfParser._parse " + this.name);
    }
  };
  Object.defineProperties(MmtfParser2.prototype, prototypeAccessors2);
  return MmtfParser2;
}(StructureParser);
ParserRegistry.add("mmtf", MmtfParser);
var reWhitespace$1 = /\s+/;
var Mol2Parser = function(StructureParser$$1) {
  function Mol2Parser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    Mol2Parser2.__proto__ = StructureParser$$1;
  Mol2Parser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  Mol2Parser2.prototype.constructor = Mol2Parser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "mol2";
  };
  Mol2Parser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("Mol2Parser._parse " + this.name);
    }
    var s = this.structure;
    var sb = this.structureBuilder;
    var firstModelOnly = this.firstModelOnly;
    var asTrajectory = this.asTrajectory;
    var frames = s.frames;
    var doFrames = false;
    var currentFrame, currentCoord;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    atomStore.resize(Math.round(this.streamer.data.length / 60));
    var idx = 0;
    var moleculeLineNo = 0;
    var modelAtomIdxStart = 0;
    var modelIdx = -1;
    var numAtoms = 0;
    var currentRecordType = 0;
    var moleculeRecordType = 1;
    var atomRecordType = 2;
    var bondRecordType = 3;
    var ap1 = s.getAtomProxy();
    var ap2 = s.getAtomProxy();
    var bondTypes = {
      "1": 1,
      "2": 2,
      "3": 3,
      am: 1,
      ar: 1,
      du: 1,
      un: 1,
      nc: 0
    };
    function _parseChunkOfLines(_i, _n, lines) {
      var ls;
      for (var i = _i; i < _n; ++i) {
        var line = lines[i].trim();
        if (line === "" || line[0] === "#") {
          continue;
        }
        if (line[0] === "@") {
          if (line === "@<TRIPOS>MOLECULE") {
            currentRecordType = moleculeRecordType;
            moleculeLineNo = 0;
            ++modelIdx;
          } else if (line === "@<TRIPOS>ATOM") {
            currentRecordType = atomRecordType;
            modelAtomIdxStart = atomStore.count;
            if (asTrajectory) {
              currentCoord = 0;
              currentFrame = new Float32Array(numAtoms * 3);
              frames.push(currentFrame);
              if (modelIdx > 0) {
                doFrames = true;
              }
            }
          } else if (line === "@<TRIPOS>BOND") {
            currentRecordType = bondRecordType;
          } else {
            currentRecordType = 0;
          }
        } else if (currentRecordType === moleculeRecordType) {
          if (moleculeLineNo === 0) {
            s.title = line;
            s.id = line;
          } else if (moleculeLineNo === 1) {
            ls = line.split(reWhitespace$1);
            numAtoms = parseInt(ls[0]);
          } else
            ;
          ++moleculeLineNo;
        } else if (currentRecordType === atomRecordType) {
          ls = line.split(reWhitespace$1);
          if (firstModelOnly && modelIdx > 0) {
            continue;
          }
          var x = parseFloat(ls[2]);
          var y = parseFloat(ls[3]);
          var z = parseFloat(ls[4]);
          if (asTrajectory) {
            var j = currentCoord * 3;
            currentFrame[j + 0] = x;
            currentFrame[j + 1] = y;
            currentFrame[j + 2] = z;
            currentCoord += 1;
            if (doFrames) {
              continue;
            }
          }
          var serial = ls[0];
          var atomname = ls[1];
          var element = ls[5].split(".")[0];
          var resno = ls[6] ? parseInt(ls[6]) : 1;
          var resname = ls[7] ? ls[7] : "";
          var bfactor = ls[8] ? parseFloat(ls[8]) : 0;
          atomStore.growIfFull();
          atomStore.atomTypeId[idx] = atomMap.add(atomname, element);
          atomStore.x[idx] = x;
          atomStore.y[idx] = y;
          atomStore.z[idx] = z;
          atomStore.serial[idx] = serial;
          atomStore.bfactor[idx] = bfactor;
          sb.addAtom(modelIdx, "", "", resname, resno, 1);
          idx += 1;
        } else if (currentRecordType === bondRecordType) {
          if (firstModelOnly && modelIdx > 0) {
            continue;
          }
          if (asTrajectory && modelIdx > 0) {
            continue;
          }
          ls = line.split(reWhitespace$1);
          ap1.index = parseInt(ls[1]) - 1 + modelAtomIdxStart;
          ap2.index = parseInt(ls[2]) - 1 + modelAtomIdxStart;
          var order = bondTypes[ls[3]];
          s.bondStore.addBond(ap1, ap2, order);
        }
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    sb.finalize();
    s.finalizeAtoms();
    calculateChainnames(s);
    calculateBondsWithin(s, true);
    calculateBondsBetween(s, true);
    s.finalizeBonds();
    assignResidueTypeBonds(s);
    calculateSecondaryStructure(s);
    if (Debug) {
      Log.timeEnd("Mol2Parser._parse " + this.name);
    }
  };
  Object.defineProperties(Mol2Parser2.prototype, prototypeAccessors2);
  return Mol2Parser2;
}(StructureParser);
ParserRegistry.add("mol2", Mol2Parser);
var PqrParser = function(PdbParser$$1) {
  function PqrParser2() {
    PdbParser$$1.apply(this, arguments);
  }
  if (PdbParser$$1)
    PqrParser2.__proto__ = PdbParser$$1;
  PqrParser2.prototype = Object.create(PdbParser$$1 && PdbParser$$1.prototype);
  PqrParser2.prototype.constructor = PqrParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "pqr";
  };
  Object.defineProperties(PqrParser2.prototype, prototypeAccessors2);
  return PqrParser2;
}(PdbParser);
ParserRegistry.add("pqr", PqrParser);
var TitleMode = 1;
var AtomMode = 2;
var BondMode = 3;
var AngleMode = 4;
var DihedralMode = 5;
var ImproperMode = 6;
var reWhitespace$2 = /\s+/;
var reTitle = /(^\*|REMARK)*/;
var PsfParser = function(StructureParser$$1) {
  function PsfParser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    PsfParser2.__proto__ = StructureParser$$1;
  PsfParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  PsfParser2.prototype.constructor = PsfParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "psf";
  };
  PsfParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("PsfParser._parse " + this.name);
    }
    var s = this.structure;
    var sb = this.structureBuilder;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    var title = [];
    var mode;
    var idx = 0;
    var bondIdx = 0;
    var bAtomIndex1, bAtomIndex2, bBondOrder;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        var line = lines[i].trim();
        if (!line) {
          mode = void 0;
          continue;
        }
        if (mode === AtomMode) {
          var ls = line.split(reWhitespace$2);
          var serial = parseInt(ls[0]);
          var resno = parseInt(ls[2]);
          var resname = ls[3];
          var atomname = ls[4];
          atomStore.growIfFull();
          atomStore.atomTypeId[idx] = atomMap.add(atomname);
          atomStore.serial[idx] = serial;
          sb.addAtom(0, "", "", resname, resno, 1);
          idx += 1;
        } else if (mode === BondMode) {
          var ls$1 = line.split(reWhitespace$2);
          for (var j = 0, m2 = ls$1.length; j < m2; j += 2) {
            bAtomIndex1[bondIdx] = parseInt(ls$1[j]) - 1;
            bAtomIndex2[bondIdx] = parseInt(ls$1[j + 1]) - 1;
            bBondOrder[bondIdx] = 1;
            bondIdx += 1;
          }
        } else if (mode === TitleMode) {
          title.push(line.replace(reTitle, "").trim());
        } else if (mode === AngleMode)
          ;
        else if (mode === DihedralMode)
          ;
        else if (mode === ImproperMode)
          ;
        else if (line.includes("!NATOM")) {
          mode = AtomMode;
          var numAtoms = parseInt(line.split(reWhitespace$2)[0]);
          atomStore.resize(numAtoms);
        } else if (line.includes("!NBOND")) {
          mode = BondMode;
          var numBonds = parseInt(line.split(reWhitespace$2)[0]);
          bAtomIndex1 = new Uint32Array(numBonds);
          bAtomIndex2 = new Uint32Array(numBonds);
          bBondOrder = new Uint8Array(numBonds);
        } else if (line.includes("!NTITLE")) {
          mode = TitleMode;
        } else if (line.includes("!NTHETA")) {
          mode = AngleMode;
        } else if (line.includes("!NPHI")) {
          mode = DihedralMode;
        } else if (line.includes("!NIMPHI")) {
          mode = ImproperMode;
        }
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    s.title = title.join(" ");
    s.bondStore.length = bBondOrder.length;
    s.bondStore.count = bondIdx;
    s.bondStore.atomIndex1 = bAtomIndex1;
    s.bondStore.atomIndex2 = bAtomIndex2;
    s.bondStore.bondOrder = bBondOrder;
    sb.finalize();
    s.finalizeAtoms();
    calculateChainnames(s);
    s.finalizeBonds();
    assignResidueTypeBonds(s);
    if (Debug) {
      Log.timeEnd("PsfParser._parse " + this.name);
    }
  };
  Object.defineProperties(PsfParser2.prototype, prototypeAccessors2);
  return PsfParser2;
}(StructureParser);
ParserRegistry.add("psf", PsfParser);
var reItem = /> <(.+)>/;
var SdfParser = function(StructureParser$$1) {
  function SdfParser2() {
    StructureParser$$1.apply(this, arguments);
  }
  if (StructureParser$$1)
    SdfParser2.__proto__ = StructureParser$$1;
  SdfParser2.prototype = Object.create(StructureParser$$1 && StructureParser$$1.prototype);
  SdfParser2.prototype.constructor = SdfParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "sdf";
  };
  SdfParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("SdfParser._parse " + this.name);
    }
    var s = this.structure;
    var sb = this.structureBuilder;
    var firstModelOnly = this.firstModelOnly;
    var asTrajectory = this.asTrajectory;
    var headerLines = this.streamer.peekLines(2);
    s.id = headerLines[0].trim();
    s.title = headerLines[1].trim();
    var frames = s.frames;
    var doFrames = false;
    var currentFrame, currentCoord;
    var atomMap = s.atomMap;
    var atomStore = s.atomStore;
    atomStore.resize(Math.round(this.streamer.data.length / 50));
    var ap1 = s.getAtomProxy();
    var ap2 = s.getAtomProxy();
    var idx = 0;
    var lineNo = 0;
    var modelIdx = 0;
    var modelAtomIdxStart = 0;
    var sdfData = [];
    var currentItem = false;
    var currentData = {};
    var mItem;
    s.extraData.sdf = sdfData;
    var atomCount, bondCount, atomStart, atomEnd, bondStart, bondEnd;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        var line = lines[i];
        if (line.substr(0, 4) === "$$$$") {
          lineNo = -1;
          ++modelIdx;
          modelAtomIdxStart = atomStore.count;
          sdfData.push(currentData);
          currentData = {};
          currentItem = false;
        } else if (lineNo === 3) {
          atomCount = parseInt(line.substr(0, 3));
          bondCount = parseInt(line.substr(3, 3));
          atomStart = 4;
          atomEnd = atomStart + atomCount;
          bondStart = atomEnd;
          bondEnd = bondStart + bondCount;
          if (asTrajectory) {
            currentCoord = 0;
            currentFrame = new Float32Array(atomCount * 3);
            frames.push(currentFrame);
            if (modelIdx > 0) {
              doFrames = true;
            }
          }
        } else if (lineNo >= atomStart && lineNo < atomEnd) {
          if (firstModelOnly && modelIdx > 0) {
            continue;
          }
          var x = parseFloat(line.substr(0, 10));
          var y = parseFloat(line.substr(10, 10));
          var z = parseFloat(line.substr(20, 10));
          if (asTrajectory) {
            var j = currentCoord * 3;
            currentFrame[j + 0] = x;
            currentFrame[j + 1] = y;
            currentFrame[j + 2] = z;
            currentCoord += 1;
            if (doFrames) {
              continue;
            }
          }
          var element = line.substr(31, 3).trim();
          var atomname = element + (idx + 1);
          atomStore.growIfFull();
          atomStore.atomTypeId[idx] = atomMap.add(atomname, element);
          atomStore.x[idx] = x;
          atomStore.y[idx] = y;
          atomStore.z[idx] = z;
          atomStore.serial[idx] = idx;
          sb.addAtom(modelIdx, "", "", "HET", 1, 1);
          idx += 1;
        } else if (lineNo >= bondStart && lineNo < bondEnd) {
          if (firstModelOnly && modelIdx > 0) {
            continue;
          }
          if (asTrajectory && modelIdx > 0) {
            continue;
          }
          ap1.index = parseInt(line.substr(0, 3)) - 1 + modelAtomIdxStart;
          ap2.index = parseInt(line.substr(3, 3)) - 1 + modelAtomIdxStart;
          var order = parseInt(line.substr(6, 3));
          s.bondStore.addBond(ap1, ap2, order);
        } else if (mItem = line.match(reItem)) {
          currentItem = mItem[1];
          currentData[currentItem] = [];
        } else if (currentItem !== false && line) {
          currentData[currentItem].push(line);
        }
        ++lineNo;
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    sb.finalize();
    s.finalizeAtoms();
    s.finalizeBonds();
    assignResidueTypeBonds(s);
    if (Debug) {
      Log.timeEnd("SdfParser._parse " + this.name);
    }
  };
  SdfParser2.prototype._postProcess = function _postProcess() {
    assignResidueTypeBonds(this.structure);
  };
  Object.defineProperties(SdfParser2.prototype, prototypeAccessors2);
  return SdfParser2;
}(StructureParser);
ParserRegistry.add("sdf", SdfParser);
ParserRegistry.add("sd", SdfParser);
var Frames = function Frames2(name, path) {
  this.name = name;
  this.path = path;
  this.coordinates = [];
  this.boxes = [];
};
var prototypeAccessors$29 = {type: {}};
prototypeAccessors$29.type.get = function() {
  return "Frames";
};
Object.defineProperties(Frames.prototype, prototypeAccessors$29);
var TrajectoryParser = function(Parser$$1) {
  function TrajectoryParser2(streamer, params) {
    Parser$$1.call(this, streamer, params);
    this.frames = new Frames(this.name, this.path);
  }
  if (Parser$$1)
    TrajectoryParser2.__proto__ = Parser$$1;
  TrajectoryParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  TrajectoryParser2.prototype.constructor = TrajectoryParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "trajectory";
  };
  prototypeAccessors2.__objName.get = function() {
    return "frames";
  };
  Object.defineProperties(TrajectoryParser2.prototype, prototypeAccessors2);
  return TrajectoryParser2;
}(Parser);
var DcdParser = function(TrajectoryParser$$1) {
  function DcdParser2() {
    TrajectoryParser$$1.apply(this, arguments);
  }
  if (TrajectoryParser$$1)
    DcdParser2.__proto__ = TrajectoryParser$$1;
  DcdParser2.prototype = Object.create(TrajectoryParser$$1 && TrajectoryParser$$1.prototype);
  DcdParser2.prototype.constructor = DcdParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "dcd";
  };
  DcdParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("DcdParser._parse " + this.name);
    }
    var bin = this.streamer.data;
    if (bin instanceof Uint8Array) {
      bin = bin.buffer;
    }
    var dv = new DataView(bin);
    var i, n;
    var f = this.frames;
    var coordinates = f.coordinates;
    var boxes = f.boxes;
    var header = {};
    var nextPos = 0;
    var intView = new Int32Array(bin, 0, 23);
    var ef = intView[0] !== dv.getInt32(0);
    if (intView[0] !== 84) {
      n = bin.byteLength;
      for (i = 0; i < n; i += 4) {
        dv.setFloat32(i, dv.getFloat32(i), true);
      }
    }
    if (intView[0] !== 84) {
      Log.error("dcd bad format, header block start");
    }
    var formatString = String.fromCharCode(dv.getUint8(4), dv.getUint8(5), dv.getUint8(6), dv.getUint8(7));
    if (formatString !== "CORD") {
      Log.error("dcd bad format, format string");
    }
    var isCharmm = false;
    var extraBlock = false;
    var fourDims = false;
    if (intView[22] !== 0) {
      isCharmm = true;
      if (intView[12] !== 0) {
        extraBlock = true;
      }
      if (intView[13] === 1) {
        fourDims = true;
      }
    }
    header.NSET = intView[2];
    header.ISTART = intView[3];
    header.NSAVC = intView[4];
    header.NAMNF = intView[10];
    if (isCharmm) {
      header.DELTA = dv.getFloat32(44, ef);
    } else {
      header.DELTA = dv.getFloat64(44, ef);
    }
    if (intView[22] !== 84) {
      Log.error("dcd bad format, header block end");
    }
    nextPos = nextPos + 21 * 4 + 8;
    var titleLength = dv.getInt32(nextPos, ef);
    var titlePos = nextPos + 1;
    if ((titleLength - 4) % 80 !== 0) {
      Log.error("dcd bad format, title block start");
    }
    header.TITLE = uint8ToString(new Uint8Array(bin, titlePos, titleLength));
    if (dv.getInt32(titlePos + titleLength + 4 - 1, ef) !== titleLength) {
      Log.error("dcd bad format, title block end");
    }
    nextPos = nextPos + titleLength + 8;
    if (dv.getInt32(nextPos, ef) !== 4) {
      Log.error("dcd bad format, natom block start");
    }
    header.NATOM = dv.getInt32(nextPos + 4, ef);
    if (dv.getInt32(nextPos + 8, ef) !== 4) {
      Log.error("dcd bad format, natom block end");
    }
    nextPos = nextPos + 4 + 8;
    if (header.NAMNF > 0) {
      Log.error("dcd format with fixed atoms unsupported, aborting");
      return;
    }
    var natom = header.NATOM;
    var natom4 = natom * 4;
    for (i = 0, n = header.NSET; i < n; ++i) {
      if (extraBlock) {
        nextPos += 4;
        var box = new Float32Array(9);
        box[0] = dv.getFloat64(nextPos, ef);
        box[4] = dv.getFloat64(nextPos + 2 * 8, ef);
        box[8] = dv.getFloat64(nextPos + 5 * 8, ef);
        boxes.push(box);
        nextPos += 48;
        nextPos += 4;
      }
      var coord = new Float32Array(natom * 3);
      for (var j = 0; j < 3; ++j) {
        if (dv.getInt32(nextPos, ef) !== natom4) {
          Log.error("dcd bad format, coord block start", i, j);
        }
        nextPos += 4;
        var c = new Float32Array(bin, nextPos, natom);
        for (var k = 0; k < natom; ++k) {
          coord[3 * k + j] = c[k];
        }
        nextPos += natom4;
        if (dv.getInt32(nextPos, ef) !== natom4) {
          Log.error("dcd bad format, coord block end", i, j);
        }
        nextPos += 4;
      }
      coordinates.push(coord);
      if (fourDims) {
        var bytes = dv.getInt32(nextPos, ef);
        nextPos += 4 + bytes + 4;
      }
    }
    if (Debug) {
      Log.timeEnd("DcdParser._parse " + this.name);
    }
  };
  Object.defineProperties(DcdParser2.prototype, prototypeAccessors2);
  return DcdParser2;
}(TrajectoryParser);
ParserRegistry.add("dcd", DcdParser);
var VolumeParser = function(Parser$$1) {
  function VolumeParser2(streamer, params) {
    var p = params || {};
    Parser$$1.call(this, streamer, p);
    this.volume = new Volume(this.name, this.path);
    this.voxelSize = defaults(p.voxelSize, 1);
  }
  if (Parser$$1)
    VolumeParser2.__proto__ = Parser$$1;
  VolumeParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  VolumeParser2.prototype.constructor = VolumeParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "volume";
  };
  prototypeAccessors2.__objName.get = function() {
    return "volume";
  };
  VolumeParser2.prototype._afterParse = function _afterParse2() {
    this.volume.setMatrix(this.getMatrix());
  };
  VolumeParser2.prototype.getMatrix = function getMatrix() {
    return new Matrix4();
  };
  Object.defineProperties(VolumeParser2.prototype, prototypeAccessors2);
  return VolumeParser2;
}(Parser);
var CubeParser = function(VolumeParser$$1) {
  function CubeParser2() {
    VolumeParser$$1.apply(this, arguments);
  }
  if (VolumeParser$$1)
    CubeParser2.__proto__ = VolumeParser$$1;
  CubeParser2.prototype = Object.create(VolumeParser$$1 && VolumeParser$$1.prototype);
  CubeParser2.prototype.constructor = CubeParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "cube";
  };
  CubeParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("CubeParser._parse " + this.name);
    }
    var v = this.volume;
    var headerLines = this.streamer.peekLines(6);
    var header = {};
    var reWhitespace2 = /\s+/;
    var bohrToAngstromFactor = 0.529177210859;
    var scaleFactor = bohrToAngstromFactor * this.voxelSize;
    function h(k, l) {
      var field = headerLines[k].trim().split(reWhitespace2)[l];
      return parseFloat(field);
    }
    header.atomCount = Math.abs(h(2, 0));
    header.originX = h(2, 1) * bohrToAngstromFactor;
    header.originY = h(2, 2) * bohrToAngstromFactor;
    header.originZ = h(2, 3) * bohrToAngstromFactor;
    header.NVX = h(3, 0);
    header.NVY = h(4, 0);
    header.NVZ = h(5, 0);
    header.basisX = new Vector3(h(3, 1), h(3, 2), h(3, 3)).multiplyScalar(scaleFactor);
    header.basisY = new Vector3(h(4, 1), h(4, 2), h(4, 3)).multiplyScalar(scaleFactor);
    header.basisZ = new Vector3(h(5, 1), h(5, 2), h(5, 3)).multiplyScalar(scaleFactor);
    var data = new Float32Array(header.NVX * header.NVY * header.NVZ);
    var count2 = 0;
    var lineNo = 0;
    var oribitalFlag = h(2, 0) > 0 ? 0 : 1;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        var line = lines[i].trim();
        if (line !== "" && lineNo >= header.atomCount + 6 + oribitalFlag) {
          line = line.split(reWhitespace2);
          for (var j = 0, lj = line.length; j < lj; ++j) {
            if (line.length !== 1) {
              data[count2] = parseFloat(line[j]);
              ++count2;
            }
          }
        }
        ++lineNo;
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    v.header = header;
    v.setData(data, header.NVZ, header.NVY, header.NVX);
    if (Debug) {
      Log.timeEnd("CubeParser._parse " + this.name);
    }
  };
  CubeParser2.prototype.getMatrix = function getMatrix() {
    var h = this.volume.header;
    var matrix2 = new Matrix4();
    matrix2.multiply(new Matrix4().makeTranslation(h.originX, h.originY, h.originZ));
    matrix2.multiply(new Matrix4().makeBasis(h.basisZ, h.basisY, h.basisX));
    return matrix2;
  };
  Object.defineProperties(CubeParser2.prototype, prototypeAccessors2);
  return CubeParser2;
}(VolumeParser);
ParserRegistry.add("cub", CubeParser);
ParserRegistry.add("cube", CubeParser);
var Dsn6Parser = function(VolumeParser$$1) {
  function Dsn6Parser2() {
    VolumeParser$$1.apply(this, arguments);
  }
  if (VolumeParser$$1)
    Dsn6Parser2.__proto__ = VolumeParser$$1;
  Dsn6Parser2.prototype = Object.create(VolumeParser$$1 && VolumeParser$$1.prototype);
  Dsn6Parser2.prototype.constructor = Dsn6Parser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "dsn6";
  };
  Dsn6Parser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("Dsn6Parser._parse " + this.name);
    }
    var bin = this.streamer.data;
    if (bin instanceof Uint8Array) {
      bin = bin.buffer;
    }
    var v = this.volume;
    var header = {};
    var divisor, summand;
    var intView = new Int16Array(bin);
    var byteView = new Uint8Array(bin);
    var brixStr = String.fromCharCode.apply(null, byteView.subarray(0, 512));
    if (brixStr.startsWith(":-)")) {
      header.xStart = parseInt(brixStr.substr(10, 5));
      header.yStart = parseInt(brixStr.substr(15, 5));
      header.zStart = parseInt(brixStr.substr(20, 5));
      header.xExtent = parseInt(brixStr.substr(32, 5));
      header.yExtent = parseInt(brixStr.substr(38, 5));
      header.zExtent = parseInt(brixStr.substr(42, 5));
      header.xRate = parseInt(brixStr.substr(52, 5));
      header.yRate = parseInt(brixStr.substr(58, 5));
      header.zRate = parseInt(brixStr.substr(62, 5));
      header.xlen = parseFloat(brixStr.substr(73, 10)) * this.voxelSize;
      header.ylen = parseFloat(brixStr.substr(83, 10)) * this.voxelSize;
      header.zlen = parseFloat(brixStr.substr(93, 10)) * this.voxelSize;
      header.alpha = parseFloat(brixStr.substr(103, 10));
      header.beta = parseFloat(brixStr.substr(113, 10));
      header.gamma = parseFloat(brixStr.substr(123, 10));
      divisor = parseFloat(brixStr.substr(138, 12)) / 100;
      summand = parseInt(brixStr.substr(155, 8));
    } else {
      if (intView[18] !== 100) {
        for (var i$1 = 0, n = intView.length; i$1 < n; ++i$1) {
          var val = intView[i$1];
          intView[i$1] = (val & 255) << 8 | val >> 8 & 255;
        }
      }
      header.xStart = intView[0];
      header.yStart = intView[1];
      header.zStart = intView[2];
      header.xExtent = intView[3];
      header.yExtent = intView[4];
      header.zExtent = intView[5];
      header.xRate = intView[6];
      header.yRate = intView[7];
      header.zRate = intView[8];
      var factor = 1 / intView[17];
      var scalingFactor = factor * this.voxelSize;
      header.xlen = intView[9] * scalingFactor;
      header.ylen = intView[10] * scalingFactor;
      header.zlen = intView[11] * scalingFactor;
      header.alpha = intView[12] * factor;
      header.beta = intView[13] * factor;
      header.gamma = intView[14] * factor;
      divisor = intView[15] / 100;
      summand = intView[16];
    }
    v.header = header;
    Log.log(header, divisor, summand);
    var data = new Float32Array(header.xExtent * header.yExtent * header.zExtent);
    var offset = 512;
    var xBlocks = Math.ceil(header.xExtent / 8);
    var yBlocks = Math.ceil(header.yExtent / 8);
    var zBlocks = Math.ceil(header.zExtent / 8);
    for (var zz = 0; zz < zBlocks; ++zz) {
      for (var yy = 0; yy < yBlocks; ++yy) {
        for (var xx = 0; xx < xBlocks; ++xx) {
          for (var k = 0; k < 8; ++k) {
            var z = 8 * zz + k;
            for (var j = 0; j < 8; ++j) {
              var y = 8 * yy + j;
              for (var i = 0; i < 8; ++i) {
                var x = 8 * xx + i;
                if (x < header.xExtent && y < header.yExtent && z < header.zExtent) {
                  var idx = (x * header.yExtent + y) * header.zExtent + z;
                  data[idx] = (byteView[offset] - summand) / divisor;
                  ++offset;
                } else {
                  offset += 8 - i;
                  break;
                }
              }
            }
          }
        }
      }
    }
    v.setData(data, header.zExtent, header.yExtent, header.xExtent);
    if (Debug) {
      Log.timeEnd("Dsn6Parser._parse " + this.name);
    }
  };
  Dsn6Parser2.prototype.getMatrix = function getMatrix() {
    var h = this.volume.header;
    var basisX = [
      h.xlen,
      0,
      0
    ];
    var basisY = [
      h.ylen * Math.cos(Math.PI / 180 * h.gamma),
      h.ylen * Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    var basisZ = [
      h.zlen * Math.cos(Math.PI / 180 * h.beta),
      h.zlen * (Math.cos(Math.PI / 180 * h.alpha) - Math.cos(Math.PI / 180 * h.gamma) * Math.cos(Math.PI / 180 * h.beta)) / Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    basisZ[2] = Math.sqrt(h.zlen * h.zlen * Math.sin(Math.PI / 180 * h.beta) * Math.sin(Math.PI / 180 * h.beta) - basisZ[1] * basisZ[1]);
    var basis = [0, basisX, basisY, basisZ];
    var nxyz = [0, h.xRate, h.yRate, h.zRate];
    var mapcrs = [0, 1, 2, 3];
    var matrix2 = new Matrix4();
    matrix2.set(basis[mapcrs[1]][0] / nxyz[mapcrs[1]], basis[mapcrs[2]][0] / nxyz[mapcrs[2]], basis[mapcrs[3]][0] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][1] / nxyz[mapcrs[1]], basis[mapcrs[2]][1] / nxyz[mapcrs[2]], basis[mapcrs[3]][1] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][2] / nxyz[mapcrs[1]], basis[mapcrs[2]][2] / nxyz[mapcrs[2]], basis[mapcrs[3]][2] / nxyz[mapcrs[3]], 0, 0, 0, 0, 1);
    matrix2.multiply(new Matrix4().makeRotationY(degToRad(90)));
    matrix2.multiply(new Matrix4().makeTranslation(-h.zStart, h.yStart, h.xStart));
    matrix2.multiply(new Matrix4().makeScale(-1, 1, 1));
    return matrix2;
  };
  Object.defineProperties(Dsn6Parser2.prototype, prototypeAccessors2);
  return Dsn6Parser2;
}(VolumeParser);
ParserRegistry.add("dsn6", Dsn6Parser);
ParserRegistry.add("brix", Dsn6Parser);
var DxParser = function(VolumeParser$$1) {
  function DxParser2() {
    VolumeParser$$1.apply(this, arguments);
  }
  if (VolumeParser$$1)
    DxParser2.__proto__ = VolumeParser$$1;
  DxParser2.prototype = Object.create(VolumeParser$$1 && VolumeParser$$1.prototype);
  DxParser2.prototype.constructor = DxParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "dx";
  };
  DxParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("DxParser._parse " + this.name);
    }
    var v = this.volume;
    var headerLines = this.streamer.peekLines(30);
    var headerInfo = this.parseHeaderLines(headerLines);
    var header = this.volume.header;
    var dataLineStart = headerInfo.dataLineStart;
    var reWhitespace2 = /\s+/;
    var size = header.nx * header.ny * header.nz;
    var data = new Float32Array(size);
    var count2 = 0;
    var lineNo = 0;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        if (count2 < size && lineNo > dataLineStart) {
          var line = lines[i].trim();
          if (line !== "") {
            var ls = line.split(reWhitespace2);
            for (var j = 0, lj = ls.length; j < lj; ++j) {
              data[count2] = parseFloat(ls[j]);
              ++count2;
            }
          }
        }
        ++lineNo;
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    v.setData(data, header.nz, header.ny, header.nx);
    if (Debug) {
      Log.timeEnd("DxParser._parse " + this.name);
    }
  };
  DxParser2.prototype.parseHeaderLines = function parseHeaderLines(headerLines) {
    var this$1 = this;
    var header = {};
    var reWhitespace2 = /\s+/;
    var n = headerLines.length;
    var dataLineStart = 0;
    var headerByteCount = 0;
    var deltaLineCount = 0;
    for (var i = 0; i < n; ++i) {
      var ls;
      var line = headerLines[i];
      if (line.startsWith("object 1")) {
        ls = line.split(reWhitespace2);
        header.nx = parseInt(ls[5]);
        header.ny = parseInt(ls[6]);
        header.nz = parseInt(ls[7]);
      } else if (line.startsWith("origin")) {
        ls = line.split(reWhitespace2);
        header.xmin = parseFloat(ls[1]);
        header.ymin = parseFloat(ls[2]);
        header.zmin = parseFloat(ls[3]);
      } else if (line.startsWith("delta")) {
        ls = line.split(reWhitespace2);
        if (deltaLineCount === 0) {
          header.hx = parseFloat(ls[1]) * this$1.voxelSize;
        } else if (deltaLineCount === 1) {
          header.hy = parseFloat(ls[2]) * this$1.voxelSize;
        } else if (deltaLineCount === 2) {
          header.hz = parseFloat(ls[3]) * this$1.voxelSize;
        }
        deltaLineCount += 1;
      } else if (line.startsWith("object 3")) {
        dataLineStart = i;
        headerByteCount += line.length + 1;
        break;
      }
      headerByteCount += line.length + 1;
    }
    this.volume.header = header;
    return {
      dataLineStart,
      headerByteCount
    };
  };
  DxParser2.prototype.getMatrix = function getMatrix() {
    var h = this.volume.header;
    var matrix2 = new Matrix4();
    matrix2.multiply(new Matrix4().makeRotationY(degToRad(90)));
    matrix2.multiply(new Matrix4().makeTranslation(-h.zmin, h.ymin, h.xmin));
    matrix2.multiply(new Matrix4().makeScale(-h.hz, h.hy, h.hx));
    return matrix2;
  };
  Object.defineProperties(DxParser2.prototype, prototypeAccessors2);
  return DxParser2;
}(VolumeParser);
ParserRegistry.add("dx", DxParser);
var DxbinParser = function(DxParser$$1) {
  function DxbinParser2() {
    DxParser$$1.apply(this, arguments);
  }
  if (DxParser$$1)
    DxbinParser2.__proto__ = DxParser$$1;
  DxbinParser2.prototype = Object.create(DxParser$$1 && DxParser$$1.prototype);
  DxbinParser2.prototype.constructor = DxbinParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "dxbin";
  };
  DxbinParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("DxbinParser._parse " + this.name);
    }
    var bin = this.streamer.data;
    if (bin instanceof Uint8Array) {
      bin = bin.buffer;
    }
    var headerLines = uint8ToLines(new Uint8Array(bin, 0, 1e3));
    var headerInfo = this.parseHeaderLines(headerLines);
    var header = this.volume.header;
    var headerByteCount = headerInfo.headerByteCount;
    var size = header.nx * header.ny * header.nz;
    var dv = new DataView(bin);
    var data = new Float32Array(size);
    for (var i = 0; i < size; ++i) {
      data[i] = dv.getFloat64(i * 8 + headerByteCount, true);
    }
    this.volume.setData(data, header.nz, header.ny, header.nx);
    if (Debug) {
      Log.timeEnd("DxbinParser._parse " + this.name);
    }
  };
  Object.defineProperties(DxbinParser2.prototype, prototypeAccessors2);
  return DxbinParser2;
}(DxParser);
ParserRegistry.add("dxbin", DxbinParser);
var MrcParser = function(VolumeParser$$1) {
  function MrcParser2() {
    VolumeParser$$1.apply(this, arguments);
  }
  if (VolumeParser$$1)
    MrcParser2.__proto__ = VolumeParser$$1;
  MrcParser2.prototype = Object.create(VolumeParser$$1 && VolumeParser$$1.prototype);
  MrcParser2.prototype.constructor = MrcParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "mrc";
  };
  MrcParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("MrcParser._parse " + this.name);
    }
    var bin = this.streamer.data;
    if (bin instanceof Uint8Array) {
      bin = bin.buffer;
    }
    var v = this.volume;
    var header = {};
    var intView = new Int32Array(bin, 0, 56);
    var floatView = new Float32Array(bin, 0, 56);
    var dv = new DataView(bin);
    header.MAP = String.fromCharCode(dv.getUint8(52 * 4), dv.getUint8(52 * 4 + 1), dv.getUint8(52 * 4 + 2), dv.getUint8(52 * 4 + 3));
    header.MACHST = [dv.getUint8(53 * 4), dv.getUint8(53 * 4 + 1)];
    if (header.MACHST[0] === 17 && header.MACHST[1] === 17) {
      var n = bin.byteLength;
      for (var i = 0; i < n; i += 4) {
        dv.setFloat32(i, dv.getFloat32(i), true);
      }
    }
    header.NX = intView[0];
    header.NY = intView[1];
    header.NZ = intView[2];
    header.MODE = intView[3];
    header.NXSTART = intView[4];
    header.NYSTART = intView[5];
    header.NZSTART = intView[6];
    header.MX = intView[7];
    header.MY = intView[8];
    header.MZ = intView[9];
    header.xlen = floatView[10] * this.voxelSize;
    header.ylen = floatView[11] * this.voxelSize;
    header.zlen = floatView[12] * this.voxelSize;
    header.alpha = floatView[13];
    header.beta = floatView[14];
    header.gamma = floatView[15];
    header.MAPC = intView[16];
    header.MAPR = intView[17];
    header.MAPS = intView[18];
    header.DMIN = floatView[19];
    header.DMAX = floatView[20];
    header.DMEAN = floatView[21];
    header.ISPG = intView[22];
    header.NSYMBT = intView[23];
    header.LSKFLG = intView[24];
    header.originX = floatView[49];
    header.originY = floatView[50];
    header.originZ = floatView[51];
    header.ARMS = floatView[54];
    v.header = header;
    var data;
    if (header.MODE === 2) {
      data = new Float32Array(bin, 256 * 4 + header.NSYMBT, header.NX * header.NY * header.NZ);
    } else if (header.MODE === 0) {
      data = new Float32Array(new Int8Array(bin, 256 * 4 + header.NSYMBT, header.NX * header.NY * header.NZ));
      if (intView[39] === -128 && intView[40] === 127) {
        var b1 = (header.DMAX - header.DMIN) / 255;
        var b0 = 0.5 * (header.DMIN + header.DMAX + b1);
        for (var j = 0, jl = data.length; j < jl; ++j) {
          data[j] = b1 * data[j] + b0;
        }
      }
    } else {
      Log.error("MrcParser unknown mode", header.MODE);
    }
    v.setData(data, header.NX, header.NY, header.NZ);
    if (Debug) {
      Log.timeEnd("MrcParser._parse " + this.name);
    }
  };
  MrcParser2.prototype.getMatrix = function getMatrix() {
    var h = this.volume.header;
    var basisX = [
      h.xlen,
      0,
      0
    ];
    var basisY = [
      h.ylen * Math.cos(Math.PI / 180 * h.gamma),
      h.ylen * Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    var basisZ = [
      h.zlen * Math.cos(Math.PI / 180 * h.beta),
      h.zlen * (Math.cos(Math.PI / 180 * h.alpha) - Math.cos(Math.PI / 180 * h.gamma) * Math.cos(Math.PI / 180 * h.beta)) / Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    basisZ[2] = Math.sqrt(h.zlen * h.zlen * Math.sin(Math.PI / 180 * h.beta) * Math.sin(Math.PI / 180 * h.beta) - basisZ[1] * basisZ[1]);
    var basis = [0, basisX, basisY, basisZ];
    var nxyz = [0, h.MX, h.MY, h.MZ];
    var mapcrs = [0, h.MAPC, h.MAPR, h.MAPS];
    var matrix2 = new Matrix4();
    matrix2.set(basis[mapcrs[1]][0] / nxyz[mapcrs[1]], basis[mapcrs[2]][0] / nxyz[mapcrs[2]], basis[mapcrs[3]][0] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][1] / nxyz[mapcrs[1]], basis[mapcrs[2]][1] / nxyz[mapcrs[2]], basis[mapcrs[3]][1] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][2] / nxyz[mapcrs[1]], basis[mapcrs[2]][2] / nxyz[mapcrs[2]], basis[mapcrs[3]][2] / nxyz[mapcrs[3]], 0, 0, 0, 0, 1);
    matrix2.setPosition(new Vector3(h.originX, h.originY, h.originZ));
    matrix2.multiply(new Matrix4().makeTranslation(h.NXSTART, h.NYSTART, h.NZSTART));
    return matrix2;
  };
  Object.defineProperties(MrcParser2.prototype, prototypeAccessors2);
  return MrcParser2;
}(VolumeParser);
ParserRegistry.add("mrc", MrcParser);
ParserRegistry.add("ccp4", MrcParser);
ParserRegistry.add("map", MrcParser);
var XplorParser = function(VolumeParser$$1) {
  function XplorParser2() {
    VolumeParser$$1.apply(this, arguments);
  }
  if (VolumeParser$$1)
    XplorParser2.__proto__ = VolumeParser$$1;
  XplorParser2.prototype = Object.create(VolumeParser$$1 && VolumeParser$$1.prototype);
  XplorParser2.prototype.constructor = XplorParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "xplor";
  };
  XplorParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("XplorParser._parse " + this.name);
    }
    var v = this.volume;
    var headerLines = this.streamer.peekLines(8);
    var header = {};
    var reWhitespace2 = /\s+/;
    function parseNumberLine(line) {
      return line.trim().split(reWhitespace2).map(parseFloat);
    }
    var infoStart;
    if (headerLines[2].startsWith("REMARKS")) {
      infoStart = parseInt(headerLines[1].substring(0, 8)) + 2;
    } else {
      infoStart = 5;
    }
    var dataStart = infoStart + 3;
    var gridInfo = parseNumberLine(headerLines[infoStart]);
    header.NA = gridInfo[0];
    header.AMIN = gridInfo[1];
    header.AMAX = gridInfo[2];
    header.NB = gridInfo[3];
    header.BMIN = gridInfo[4];
    header.BMAX = gridInfo[5];
    header.NC = gridInfo[6];
    header.CMIN = gridInfo[7];
    header.CMAX = gridInfo[8];
    var cellInfo = parseNumberLine(headerLines[infoStart + 1]);
    header.a = cellInfo[0] * this.voxelSize;
    header.b = cellInfo[1] * this.voxelSize;
    header.c = cellInfo[2] * this.voxelSize;
    header.alpha = cellInfo[3];
    header.beta = cellInfo[4];
    header.gamma = cellInfo[5];
    var na = header.AMAX - header.AMIN + 1;
    var nb = header.BMAX - header.BMIN + 1;
    var nc = header.CMAX - header.CMIN + 1;
    var n = na * nb * nc;
    var data = new Float32Array(n);
    var count2 = 0;
    var lineNo = 0;
    var lineSection = 1 + na * nb / 6;
    function _parseChunkOfLines(_i, _n, lines) {
      for (var i = _i; i < _n; ++i) {
        var line = lines[i];
        if (lineNo >= dataStart && (lineNo - dataStart) % lineSection !== 0 && count2 < n) {
          for (var j = 0, lj = 6; j < lj; ++j) {
            data[count2] = parseFloat(line.substr(12 * j, 12));
            ++count2;
          }
        }
        ++lineNo;
      }
    }
    this.streamer.eachChunkOfLines(function(lines) {
      _parseChunkOfLines(0, lines.length, lines);
    });
    v.header = header;
    v.setData(data, na, nb, nc);
    if (Debug) {
      Log.timeEnd("XplorParser._parse " + this.name);
    }
  };
  XplorParser2.prototype.getMatrix = function getMatrix() {
    var h = this.volume.header;
    var basisX = [
      h.a,
      0,
      0
    ];
    var basisY = [
      h.b * Math.cos(Math.PI / 180 * h.gamma),
      h.b * Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    var basisZ = [
      h.c * Math.cos(Math.PI / 180 * h.beta),
      h.c * (Math.cos(Math.PI / 180 * h.alpha) - Math.cos(Math.PI / 180 * h.gamma) * Math.cos(Math.PI / 180 * h.beta)) / Math.sin(Math.PI / 180 * h.gamma),
      0
    ];
    basisZ[2] = Math.sqrt(h.c * h.c * Math.sin(Math.PI / 180 * h.beta) * Math.sin(Math.PI / 180 * h.beta) - basisZ[1] * basisZ[1]);
    var basis = [0, basisX, basisY, basisZ];
    var nxyz = [0, h.NA, h.NB, h.NC];
    var mapcrs = [0, 1, 2, 3];
    var matrix2 = new Matrix4();
    matrix2.set(basis[mapcrs[1]][0] / nxyz[mapcrs[1]], basis[mapcrs[2]][0] / nxyz[mapcrs[2]], basis[mapcrs[3]][0] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][1] / nxyz[mapcrs[1]], basis[mapcrs[2]][1] / nxyz[mapcrs[2]], basis[mapcrs[3]][1] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][2] / nxyz[mapcrs[1]], basis[mapcrs[2]][2] / nxyz[mapcrs[2]], basis[mapcrs[3]][2] / nxyz[mapcrs[3]], 0, 0, 0, 0, 1);
    matrix2.multiply(new Matrix4().makeTranslation(h.AMIN, h.BMIN, h.CMIN));
    return matrix2;
  };
  Object.defineProperties(XplorParser2.prototype, prototypeAccessors2);
  return XplorParser2;
}(VolumeParser);
ParserRegistry.add("xplor", XplorParser);
ParserRegistry.add("cns", XplorParser);
var SurfaceParser = function(Parser$$1) {
  function SurfaceParser2(streamer, params) {
    Parser$$1.call(this, streamer, params);
    this.loader = this.getLoader();
    this.surface = new Surface(this.name, this.path);
  }
  if (Parser$$1)
    SurfaceParser2.__proto__ = Parser$$1;
  SurfaceParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  SurfaceParser2.prototype.constructor = SurfaceParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "surface";
  };
  prototypeAccessors2.__objName.get = function() {
    return "surface";
  };
  SurfaceParser2.prototype._parse = function _parse2() {
    var geometry = this.loader.parse(this.streamer.asText());
    this.surface.fromGeometry(geometry);
  };
  Object.defineProperties(SurfaceParser2.prototype, prototypeAccessors2);
  return SurfaceParser2;
}(Parser);
function OBJLoader() {
  this.regexp = {
    vertex_pattern: /^v\s+([\d|.|+|\-|e|E]+)\s+([\d|.|+|\-|e|E]+)\s+([\d|.|+|\-|e|E]+)/,
    normal_pattern: /^vn\s+([\d|.|+|\-|e|E]+)\s+([\d|.|+|\-|e|E]+)\s+([\d|.|+|\-|e|E]+)/,
    uv_pattern: /^vt\s+([\d|.|+|\-|e|E]+)\s+([\d|.|+|\-|e|E]+)/,
    face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
    face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
    face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
    face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
    object_pattern: /^[og]\s*(.+)?/,
    smoothing_pattern: /^s\s+(\d+|on|off)/,
    material_library_pattern: /^mtllib /,
    material_use_pattern: /^usemtl /
  };
}
OBJLoader.prototype = {
  constructor: OBJLoader,
  setPath: function(value2) {
    this.path = value2;
  },
  _createParserState: function() {
    var state = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      startObject: function(name, fromDeclaration) {
        if (this.object && this.object.fromDeclaration === false) {
          this.object.name = name;
          this.object.fromDeclaration = fromDeclaration !== false;
          return;
        }
        this.object = {
          name: name || "",
          geometry: {
            vertices: [],
            normals: []
          },
          fromDeclaration: fromDeclaration !== false
        };
        this.objects.push(this.object);
      },
      parseVertexIndex: function(value2, len) {
        var index = parseInt(value2, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      parseNormalIndex: function(value2, len) {
        var index = parseInt(value2, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      addVertex: function(a, b, c) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
        dst.push(src[b + 0]);
        dst.push(src[b + 1]);
        dst.push(src[b + 2]);
        dst.push(src[c + 0]);
        dst.push(src[c + 1]);
        dst.push(src[c + 2]);
      },
      addVertexLine: function(a) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
      },
      addNormal: function(a, b, c) {
        var src = this.normals;
        var dst = this.object.geometry.normals;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
        dst.push(src[b + 0]);
        dst.push(src[b + 1]);
        dst.push(src[b + 2]);
        dst.push(src[c + 0]);
        dst.push(src[c + 1]);
        dst.push(src[c + 2]);
      },
      addFace: function(a, b, c, d, na, nb, nc, nd) {
        var vLen = this.vertices.length;
        var ia = this.parseVertexIndex(a, vLen);
        var ib = this.parseVertexIndex(b, vLen);
        var ic = this.parseVertexIndex(c, vLen);
        var id;
        if (d === void 0) {
          this.addVertex(ia, ib, ic);
        } else {
          id = this.parseVertexIndex(d, vLen);
          this.addVertex(ia, ib, id);
          this.addVertex(ib, ic, id);
        }
        if (na !== void 0) {
          var nLen = this.normals.length;
          ia = this.parseNormalIndex(na, nLen);
          ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
          ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
          if (d === void 0) {
            this.addNormal(ia, ib, ic);
          } else {
            id = this.parseNormalIndex(nd, nLen);
            this.addNormal(ia, ib, id);
            this.addNormal(ib, ic, id);
          }
        }
      },
      addLineGeometry: function(vertices) {
        var this$1 = this;
        this.object.geometry.type = "Line";
        var vLen = this.vertices.length;
        for (var vi = 0, l = vertices.length; vi < l; vi++) {
          this$1.addVertexLine(this$1.parseVertexIndex(vertices[vi], vLen));
        }
      }
    };
    state.startObject("", false);
    return state;
  },
  parse: function(text) {
    var this$1 = this;
    var state = this._createParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    var i, l;
    var lines = text.split("\n");
    var line = "";
    var lineFirstChar = "";
    var lineSecondChar = "";
    var lineLength = 0;
    var result = [];
    var trimLeft = typeof "".trimLeft === "function";
    for (i = 0, l = lines.length; i < l; i++) {
      line = lines[i];
      line = trimLeft ? line.trimLeft() : line.trim();
      lineLength = line.length;
      if (lineLength === 0) {
        continue;
      }
      lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#") {
        continue;
      }
      if (lineFirstChar === "v") {
        lineSecondChar = line.charAt(1);
        if (lineSecondChar === " " && (result = this$1.regexp.vertex_pattern.exec(line)) !== null) {
          state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
        } else if (lineSecondChar === "n" && (result = this$1.regexp.normal_pattern.exec(line)) !== null) {
          state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
        } else if (lineSecondChar === "t" && (result = this$1.regexp.uv_pattern.exec(line)) !== null)
          ;
        else {
          throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
        }
      } else if (lineFirstChar === "f") {
        if ((result = this$1.regexp.face_vertex_uv_normal.exec(line)) !== null) {
          state.addFace(result[1], result[4], result[7], result[10], result[3], result[6], result[9], result[12]);
        } else if ((result = this$1.regexp.face_vertex_uv.exec(line)) !== null)
          ;
        else if ((result = this$1.regexp.face_vertex_normal.exec(line)) !== null) {
          state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
        } else if ((result = this$1.regexp.face_vertex.exec(line)) !== null) {
          state.addFace(result[1], result[2], result[3], result[4]);
        } else {
          throw new Error("Unexpected face line: '" + line + "'");
        }
      } else if (lineFirstChar === "l") {
        var lineParts = line.substring(1).trim().split(" ");
        var lineVertices = [];
        var lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (var li = 0, llen = lineParts.length; li < llen; li++) {
            var parts = lineParts[li].split("/");
            if (parts[0] !== "") {
              lineVertices.push(parts[0]);
            }
            if (parts[1] !== "") {
              lineUVs.push(parts[1]);
            }
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if ((result = this$1.regexp.object_pattern.exec(line)) !== null) {
        var name = result[0].substr(1).trim();
        state.startObject(name);
      } else if (this$1.regexp.material_use_pattern.test(line))
        ;
      else if (this$1.regexp.material_library_pattern.test(line))
        ;
      else if ((result = this$1.regexp.smoothing_pattern.exec(line)) !== null)
        ;
      else {
        if (line === "\0") {
          continue;
        }
        throw new Error("Unexpected line: '" + line + "'");
      }
    }
    var container = [];
    for (i = 0, l = state.objects.length; i < l; i++) {
      var object = state.objects[i];
      var geometry = object.geometry;
      if (geometry.vertices.length === 0) {
        continue;
      }
      var buffergeometry = new BufferGeometry();
      buffergeometry.addAttribute("position", new BufferAttribute(new Float32Array(geometry.vertices), 3));
      if (geometry.normals.length > 0) {
        buffergeometry.addAttribute("normal", new BufferAttribute(new Float32Array(geometry.normals), 3));
      } else {
        buffergeometry.computeVertexNormals();
      }
      container.push(buffergeometry);
    }
    return container;
  }
};
var ObjParser = function(SurfaceParser$$1) {
  function ObjParser2() {
    SurfaceParser$$1.apply(this, arguments);
  }
  if (SurfaceParser$$1)
    ObjParser2.__proto__ = SurfaceParser$$1;
  ObjParser2.prototype = Object.create(SurfaceParser$$1 && SurfaceParser$$1.prototype);
  ObjParser2.prototype.constructor = ObjParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "obj";
  };
  ObjParser2.prototype.getLoader = function getLoader() {
    return new OBJLoader();
  };
  Object.defineProperties(ObjParser2.prototype, prototypeAccessors2);
  return ObjParser2;
}(SurfaceParser);
ParserRegistry.add("obj", ObjParser);
function PLYLoader() {
  this.propertyNameMapping = {};
}
PLYLoader.prototype = {
  constructor: PLYLoader,
  setPropertyNameMapping: function(mapping2) {
    this.propertyNameMapping = mapping2;
  },
  bin2str: function(buf) {
    var arrayBuffer = new Uint8Array(buf);
    var str = "";
    for (var i = 0; i < buf.byteLength; i++) {
      str += String.fromCharCode(arrayBuffer[i]);
    }
    return str;
  },
  isASCII: function(data) {
    var header = this.parseHeader(this.bin2str(data));
    return header.format === "ascii";
  },
  parse: function(data) {
    if (data instanceof ArrayBuffer) {
      return this.isASCII(data) ? this.parseASCII(this.bin2str(data)) : this.parseBinary(data);
    } else {
      return this.parseASCII(data);
    }
  },
  parseHeader: function(data) {
    var this$1 = this;
    var patternHeader = /ply([\s\S]*)end_header\s/;
    var headerText = "";
    var headerLength = 0;
    var result = patternHeader.exec(data);
    if (result !== null) {
      headerText = result[1];
      headerLength = result[0].length;
    }
    var header = {
      comments: [],
      elements: [],
      headerLength
    };
    var lines = headerText.split("\n");
    var currentElement, lineType, lineValues;
    function makePlyElementProperty(propertValues, propertyNameMapping) {
      var property = {
        type: propertValues[0]
      };
      if (property.type === "list") {
        property.name = propertValues[3];
        property.countType = propertValues[1];
        property.itemType = propertValues[2];
      } else {
        property.name = propertValues[1];
      }
      if (property.name in propertyNameMapping) {
        property.name = propertyNameMapping[property.name];
      }
      return property;
    }
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      line = line.trim();
      if (line === "") {
        continue;
      }
      lineValues = line.split(/\s+/);
      lineType = lineValues.shift();
      line = lineValues.join(" ");
      switch (lineType) {
        case "format":
          header.format = lineValues[0];
          header.version = lineValues[1];
          break;
        case "comment":
          header.comments.push(line);
          break;
        case "element":
          if (currentElement !== void 0) {
            header.elements.push(currentElement);
          }
          currentElement = {};
          currentElement.name = lineValues[0];
          currentElement.count = parseInt(lineValues[1]);
          currentElement.properties = [];
          break;
        case "property":
          currentElement.properties.push(makePlyElementProperty(lineValues, this$1.propertyNameMapping));
          break;
        default:
          console.log("unhandled", lineType, lineValues);
      }
    }
    if (currentElement !== void 0) {
      header.elements.push(currentElement);
    }
    return header;
  },
  parseASCIINumber: function(n, type2) {
    switch (type2) {
      case "char":
      case "uchar":
      case "short":
      case "ushort":
      case "int":
      case "uint":
      case "int8":
      case "uint8":
      case "int16":
      case "uint16":
      case "int32":
      case "uint32":
        return parseInt(n);
      case "float":
      case "double":
      case "float32":
      case "float64":
        return parseFloat(n);
    }
  },
  parseASCIIElement: function(properties, line) {
    var this$1 = this;
    var values = line.split(/\s+/);
    var element = {};
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].type === "list") {
        var list = [];
        var n = this$1.parseASCIINumber(values.shift(), properties[i].countType);
        for (var j = 0; j < n; j++) {
          list.push(this$1.parseASCIINumber(values.shift(), properties[i].itemType));
        }
        element[properties[i].name] = list;
      } else {
        element[properties[i].name] = this$1.parseASCIINumber(values.shift(), properties[i].type);
      }
    }
    return element;
  },
  parseASCII: function(data) {
    var this$1 = this;
    var geometry = new Geometry();
    var result;
    var header = this.parseHeader(data);
    var patternBody = /end_header\s([\s\S]*)$/;
    var body = "";
    if ((result = patternBody.exec(data)) !== null) {
      body = result[1];
    }
    var lines = body.split("\n");
    var currentElement = 0;
    var currentElementCount = 0;
    geometry.useColor = false;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      line = line.trim();
      if (line === "") {
        continue;
      }
      if (currentElementCount >= header.elements[currentElement].count) {
        currentElement++;
        currentElementCount = 0;
      }
      var element = this$1.parseASCIIElement(header.elements[currentElement].properties, line);
      this$1.handleElement(geometry, header.elements[currentElement].name, element);
      currentElementCount++;
    }
    return this.postProcess(geometry);
  },
  postProcess: function(geometry) {
    if (geometry.useColor) {
      for (var i = 0; i < geometry.faces.length; i++) {
        geometry.faces[i].vertexColors = [
          geometry.colors[geometry.faces[i].a],
          geometry.colors[geometry.faces[i].b],
          geometry.colors[geometry.faces[i].c]
        ];
      }
      geometry.elementsNeedUpdate = true;
    }
    geometry.computeBoundingSphere();
    return geometry;
  },
  handleElement: function(geometry, elementName, element) {
    if (elementName === "vertex") {
      geometry.vertices.push(new Vector3(element.x, element.y, element.z));
      if ("red" in element && "green" in element && "blue" in element) {
        geometry.useColor = true;
        var color = new Color();
        color.setRGB(element.red / 255, element.green / 255, element.blue / 255);
        geometry.colors.push(color);
      }
    } else if (elementName === "face") {
      var vertexIndices = element.vertex_indices;
      if (vertexIndices.length === 3) {
        geometry.faces.push(new Face3(vertexIndices[0], vertexIndices[1], vertexIndices[2]));
      } else if (vertexIndices.length === 4) {
        geometry.faces.push(new Face3(vertexIndices[0], vertexIndices[1], vertexIndices[3]), new Face3(vertexIndices[1], vertexIndices[2], vertexIndices[3]));
      }
    }
  },
  binaryRead: function(dataview, at, type2, littleEndian) {
    switch (type2) {
      case "int8":
      case "char":
        return [dataview.getInt8(at), 1];
      case "uint8":
      case "uchar":
        return [dataview.getUint8(at), 1];
      case "int16":
      case "short":
        return [dataview.getInt16(at, littleEndian), 2];
      case "uint16":
      case "ushort":
        return [dataview.getUint16(at, littleEndian), 2];
      case "int32":
      case "int":
        return [dataview.getInt32(at, littleEndian), 4];
      case "uint32":
      case "uint":
        return [dataview.getUint32(at, littleEndian), 4];
      case "float32":
      case "float":
        return [dataview.getFloat32(at, littleEndian), 4];
      case "float64":
      case "double":
        return [dataview.getFloat64(at, littleEndian), 8];
    }
  },
  binaryReadElement: function(dataview, at, properties, littleEndian) {
    var this$1 = this;
    var element = {};
    var result;
    var read2 = 0;
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].type === "list") {
        var list = [];
        result = this$1.binaryRead(dataview, at + read2, properties[i].countType, littleEndian);
        var n = result[0];
        read2 += result[1];
        for (var j = 0; j < n; j++) {
          result = this$1.binaryRead(dataview, at + read2, properties[i].itemType, littleEndian);
          list.push(result[0]);
          read2 += result[1];
        }
        element[properties[i].name] = list;
      } else {
        result = this$1.binaryRead(dataview, at + read2, properties[i].type, littleEndian);
        element[properties[i].name] = result[0];
        read2 += result[1];
      }
    }
    return [element, read2];
  },
  parseBinary: function(data) {
    var this$1 = this;
    var geometry = new Geometry();
    var header = this.parseHeader(this.bin2str(data));
    var littleEndian = header.format === "binary_little_endian";
    var body = new DataView(data, header.headerLength);
    var result;
    var loc = 0;
    for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {
      for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {
        result = this$1.binaryReadElement(body, loc, header.elements[currentElement].properties, littleEndian);
        loc += result[1];
        var element = result[0];
        this$1.handleElement(geometry, header.elements[currentElement].name, element);
      }
    }
    return this.postProcess(geometry);
  }
};
var PlyParser = function(SurfaceParser$$1) {
  function PlyParser2() {
    SurfaceParser$$1.apply(this, arguments);
  }
  if (SurfaceParser$$1)
    PlyParser2.__proto__ = SurfaceParser$$1;
  PlyParser2.prototype = Object.create(SurfaceParser$$1 && SurfaceParser$$1.prototype);
  PlyParser2.prototype.constructor = PlyParser2;
  var prototypeAccessors2 = {type: {}};
  prototypeAccessors2.type.get = function() {
    return "ply";
  };
  PlyParser2.prototype.getLoader = function getLoader() {
    return new PLYLoader();
  };
  Object.defineProperties(PlyParser2.prototype, prototypeAccessors2);
  return PlyParser2;
}(SurfaceParser);
ParserRegistry.add("ply", PlyParser);
var CsvParser = function(Parser$$1) {
  function CsvParser2(streamer, params) {
    var p = params || {};
    Parser$$1.call(this, streamer, p);
    this.delimiter = defaults(p.delimiter, ",");
    this.comment = defaults(p.comment, "#");
    this.columnNames = defaults(p.columnNames, false);
    this.table = {
      name: this.name,
      path: this.path,
      columnNames: [],
      data: []
    };
  }
  if (Parser$$1)
    CsvParser2.__proto__ = Parser$$1;
  CsvParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  CsvParser2.prototype.constructor = CsvParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "csv";
  };
  prototypeAccessors2.__objName.get = function() {
    return "table";
  };
  CsvParser2.prototype._parse = function _parse2() {
    var this$1 = this;
    var data = this.table.data;
    var reDelimiter = new RegExp("\\s*" + this.delimiter + "\\s*");
    var j = 0;
    this.streamer.eachChunkOfLines(function(chunk2) {
      var n = chunk2.length;
      for (var i = 0; i < n; ++i) {
        var line = chunk2[i].trim();
        if (line.startsWith(this$1.comment)) {
          continue;
        }
        var values = line.split(reDelimiter);
        if (j === 0) {
          this$1.table.columnNames = values;
        } else if (line) {
          data.push(values);
        }
        ++j;
      }
    });
  };
  Object.defineProperties(CsvParser2.prototype, prototypeAccessors2);
  return CsvParser2;
}(Parser);
ParserRegistry.add("csv", CsvParser);
var JsonParser = function(Parser$$1) {
  function JsonParser2(streamer, params) {
    var p = params || {};
    Parser$$1.call(this, streamer, p);
    this.string = defaults(p.string, false);
    this.json = {
      name: this.name,
      path: this.path,
      data: {}
    };
  }
  if (Parser$$1)
    JsonParser2.__proto__ = Parser$$1;
  JsonParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  JsonParser2.prototype.constructor = JsonParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "json";
  };
  prototypeAccessors2.__objName.get = function() {
    return "json";
  };
  JsonParser2.prototype._parse = function _parse2() {
    if (this.streamer.isBinary() || this.string) {
      this.json.data = JSON.parse(this.streamer.asText());
    } else {
      this.json.data = this.streamer.data;
    }
  };
  Object.defineProperties(JsonParser2.prototype, prototypeAccessors2);
  return JsonParser2;
}(Parser);
ParserRegistry.add("json", JsonParser);
var TextParser = function(Parser$$1) {
  function TextParser2(streamer, params) {
    Parser$$1.call(this, streamer, params);
    this.text = {
      name: this.name,
      path: this.path,
      data: ""
    };
  }
  if (Parser$$1)
    TextParser2.__proto__ = Parser$$1;
  TextParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  TextParser2.prototype.constructor = TextParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "text";
  };
  prototypeAccessors2.__objName.get = function() {
    return "text";
  };
  TextParser2.prototype._parse = function _parse2() {
    this.text.data = this.streamer.asText();
  };
  Object.defineProperties(TextParser2.prototype, prototypeAccessors2);
  return TextParser2;
}(Parser);
ParserRegistry.add("txt", TextParser);
ParserRegistry.add("text", TextParser);
var reStrip = /^['"]|['"]$/g;
var reTag = /^<([\w-:.]+)\s*/;
var reContent = /^([^<]*)/;
var reAttr = /([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/;
function strip(val) {
  return val.replace(reStrip, "");
}
function parseXml(xml) {
  xml = xml.trim().replace(/<!--[\s\S]*?-->/g, "");
  return document2();
  function document2() {
    return {
      declaration: declaration(),
      root: tag()
    };
  }
  function declaration() {
    var m2 = match(/^<\?xml\s*/);
    if (!m2) {
      return;
    }
    var node = {
      attributes: {}
    };
    while (!(eos() || is("?>"))) {
      var attr = attribute();
      if (!attr) {
        return node;
      }
      node.attributes[attr.name] = attr.value;
    }
    match(/\?>\s*/);
    return node;
  }
  function tag() {
    var m2 = match(reTag);
    if (!m2) {
      return;
    }
    var node = {
      name: m2[1],
      attributes: {},
      children: []
    };
    while (!(eos() || is(">") || is("?>") || is("/>"))) {
      var attr = attribute();
      if (!attr) {
        return node;
      }
      node.attributes[attr.name] = attr.value;
    }
    if (match(/^\s*\/>\s*/)) {
      return node;
    }
    match(/\??>\s*/);
    node.content = content();
    var child;
    while (child = tag()) {
      node.children.push(child);
    }
    match(/^<\/[\w-:.]+>\s*/);
    return node;
  }
  function content() {
    var m2 = match(reContent);
    if (m2) {
      return m2[1];
    }
    return "";
  }
  function attribute() {
    var m2 = match(reAttr);
    if (!m2) {
      return;
    }
    return {name: m2[1], value: strip(m2[2])};
  }
  function match(re2) {
    var m2 = xml.match(re2);
    if (!m2) {
      return;
    }
    xml = xml.slice(m2[0].length);
    return m2;
  }
  function eos() {
    return xml.length === 0;
  }
  function is(prefix) {
    return xml.indexOf(prefix) === 0;
  }
}
var XmlParser = function(Parser$$1) {
  function XmlParser2(streamer, params) {
    var p = params || {};
    Parser$$1.call(this, streamer, p);
    this.useDomParser = defaults(p.useDomParser, false);
    this.xml = {
      name: this.name,
      path: this.path,
      data: {}
    };
  }
  if (Parser$$1)
    XmlParser2.__proto__ = Parser$$1;
  XmlParser2.prototype = Object.create(Parser$$1 && Parser$$1.prototype);
  XmlParser2.prototype.constructor = XmlParser2;
  var prototypeAccessors2 = {type: {}, __objName: {}};
  prototypeAccessors2.type.get = function() {
    return "xml";
  };
  prototypeAccessors2.__objName.get = function() {
    return "xml";
  };
  XmlParser2.prototype.__xmlParser = function __xmlParser(xml) {
    return parseXml(xml);
  };
  XmlParser2.prototype.__domParser = function __domParser(xml) {
    var domParser = new window.DOMParser();
    return domParser.parseFromString(xml, "text/xml");
  };
  XmlParser2.prototype._parse = function _parse2() {
    if (Debug) {
      Log.time("XmlParser._parse " + this.name);
    }
    if (this.useDomParser) {
      if (this.streamer.data instanceof window.Document) {
        this.xml.data = this.streamer.data;
      } else {
        this.xml.data = this.__domParser(this.streamer.asText());
      }
    } else {
      this.xml.data = this.__xmlParser(this.streamer.asText());
    }
    if (Debug) {
      Log.timeEnd("XmlParser._parse " + this.name);
    }
  };
  Object.defineProperties(XmlParser2.prototype, prototypeAccessors2);
  return XmlParser2;
}(Parser);
ParserRegistry.add("xml", XmlParser);
function getSele(a, atomname, useAltcode) {
  var icode = a.icode.value;
  var chain = a.chain.value;
  var altcode = a.altcode.value;
  var sele = a.resnum.value;
  if (icode.trim()) {
    sele += "^" + icode;
  }
  if (chain.trim()) {
    sele += ":" + chain;
  }
  if (atomname) {
    sele += "." + atomname;
  }
  if (useAltcode && altcode.trim()) {
    sele += "%" + altcode;
  }
  sele += "/" + (parseInt(a.model.value) - 1);
  return sele;
}
function setBitDict(dict, key, bit) {
  if (dict[key] === void 0) {
    dict[key] = bit;
  } else {
    dict[key] |= bit;
  }
}
function hasAttrValue(attr, value2) {
  return attr !== void 0 && attr.value === value2;
}
function getAtomSele(ap) {
  var icode = ap.inscode;
  var chain = ap.chainname;
  var atomname = ap.atomname;
  var altcode = ap.altloc;
  var sele = ap.resno;
  if (icode) {
    sele += "^" + icode;
  }
  if (chain) {
    sele += ":" + chain;
  }
  if (atomname) {
    sele += "." + atomname;
  }
  if (altcode) {
    sele += "%" + altcode;
  }
  sele += "/" + ap.modelIndex;
  return sele;
}
function getProblemCount(clashDict, g, ga) {
  var geoProblemCount = 0;
  var clashes = g.getElementsByTagName("clash");
  for (var j = 0, jl = clashes.length; j < jl; ++j) {
    if (clashDict[clashes[j].attributes.cid.value]) {
      geoProblemCount += 1;
      break;
    }
  }
  var angleOutliers = g.getElementsByTagName("angle-outlier");
  if (angleOutliers.length > 0) {
    geoProblemCount += 1;
  }
  var bondOutliers = g.getElementsByTagName("bond-outlier");
  if (bondOutliers.length > 0) {
    geoProblemCount += 1;
  }
  var planeOutliers = g.getElementsByTagName("plane-outlier");
  if (planeOutliers.length > 0) {
    geoProblemCount += 1;
  }
  if (hasAttrValue(ga.rota, "OUTLIER")) {
    geoProblemCount += 1;
  }
  if (hasAttrValue(ga.rama, "OUTLIER")) {
    geoProblemCount += 1;
  }
  if (hasAttrValue(ga.RNApucker, "outlier")) {
    geoProblemCount += 1;
  }
  return geoProblemCount;
}
var Validation = function Validation2(name, path) {
  this.name = name;
  this.path = path;
  this.rsrzDict = {};
  this.rsccDict = {};
  this.clashDict = {};
  this.clashArray = [];
  this.geoDict = {};
  this.geoAtomDict = {};
  this.atomDict = {};
  this.clashSele = "NONE";
};
var prototypeAccessors$30 = {type: {}};
prototypeAccessors$30.type.get = function() {
  return "validation";
};
Validation.prototype.fromXml = function fromXml(xml) {
  if (Debug) {
    Log.time("Validation.fromXml");
  }
  var rsrzDict = this.rsrzDict;
  var rsccDict = this.rsccDict;
  var clashDict = this.clashDict;
  var clashArray = this.clashArray;
  var geoDict = this.geoDict;
  var geoAtomDict = this.geoAtomDict;
  var atomDict = this.atomDict;
  var groups = xml.getElementsByTagName("ModelledSubgroup");
  var _clashDict = {};
  var clashList = [];
  if (Debug) {
    Log.time("Validation.fromXml#clashDict");
  }
  for (var i = 0, il = groups.length; i < il; ++i) {
    var g = groups[i];
    var ga = g.attributes;
    var sele = getSele(ga);
    if (ga.rsrz !== void 0) {
      rsrzDict[sele] = parseFloat(ga.rsrz.value);
    }
    if (ga.rscc !== void 0) {
      rsccDict[sele] = parseFloat(ga.rscc.value);
    }
    ga.sele = sele;
    var clashes = g.getElementsByTagName("clash");
    for (var j = 0, jl = clashes.length; j < jl; ++j) {
      var ca = clashes[j].attributes;
      var atom = ca.atom.value;
      if (guessElement(atom) !== "H") {
        var cid = ca.cid.value;
        var atomSele = getSele(ga, atom, true);
        atomDict[atomSele] = true;
        if (_clashDict[cid] === void 0) {
          _clashDict[cid] = {
            sele1: atomSele,
            res1: sele
          };
        } else {
          var c = _clashDict[cid];
          if (c.res1 !== sele) {
            c.sele2 = atomSele;
            c.res2 = sele;
            clashList.push(c.res1, sele);
            clashDict[cid] = c;
            clashArray.push(c);
          }
        }
      }
    }
  }
  if (Debug) {
    Log.timeEnd("Validation.fromXml#clashDict");
  }
  for (var i$1 = 0, il$1 = groups.length; i$1 < il$1; ++i$1) {
    var g$1 = groups[i$1];
    var ga$1 = g$1.attributes;
    var sele$1 = ga$1.sele;
    var isPolymer4 = ga$1.seq.value !== ".";
    if (isPolymer4) {
      var geoProblemCount = getProblemCount(clashDict, g$1, ga$1);
      if (geoProblemCount > 0) {
        geoDict[sele$1] = geoProblemCount;
      }
    } else {
      var clashes$1 = g$1.getElementsByTagName("clash");
      var mogBondOutliers = g$1.getElementsByTagName("mog-bond-outlier");
      var mogAngleOutliers = g$1.getElementsByTagName("mog-angle-outlier");
      if (mogBondOutliers.length > 0 || mogAngleOutliers.length > 0 || clashes$1.length > 0) {
        var atomDict$1 = {};
        geoAtomDict[sele$1] = atomDict$1;
        for (var j$1 = 0, jl$1 = clashes$1.length; j$1 < jl$1; ++j$1) {
          var ca$1 = clashes$1[j$1].attributes;
          if (clashDict[ca$1.cid.value]) {
            setBitDict(atomDict$1, ca$1.atom.value, 1);
          }
        }
        for (var j$2 = 0, jl$2 = mogBondOutliers.length; j$2 < jl$2; ++j$2) {
          var mbo = mogBondOutliers[j$2].attributes;
          mbo.atoms.value.split(",").forEach(function(atomname) {
            setBitDict(atomDict$1, atomname, 2);
          });
        }
        for (var j$3 = 0, jl$3 = mogAngleOutliers.length; j$3 < jl$3; ++j$3) {
          var mao = mogAngleOutliers[j$3].attributes;
          mao.atoms.value.split(",").forEach(function(atomname) {
            setBitDict(atomDict$1, atomname, 4);
          });
        }
      }
    }
  }
  this.clashSele = clashList.length ? clashList.join(" OR ") : "NONE";
  if (Debug) {
    Log.timeEnd("Validation.fromXml");
  }
};
Validation.prototype.getClashData = function getClashData(params) {
  if (Debug) {
    Log.time("Validation.getClashData");
  }
  var p = params || {};
  var s = p.structure;
  var atomSet = s.atomSet;
  var c = new Color(defaults(p.color, "#f0027f"));
  var ap1 = s.getAtomProxy();
  var ap2 = s.getAtomProxy();
  var vDir = new Vector3();
  var vPos1 = new Vector3();
  var vPos2 = new Vector3();
  var clashArray = this.clashArray;
  var n = clashArray.length;
  var position1 = new Float32Array(n * 3);
  var position2 = new Float32Array(n * 3);
  var color = uniformArray3(n, c.r, c.g, c.b);
  var radius = new Float32Array(n);
  var picking = new Float32Array(n);
  if (Debug) {
    Log.time("Validation.getClashData#atomDict");
  }
  var atomDict = this.atomDict;
  s.eachAtom(function(ap) {
    var sele = getAtomSele(ap);
    if (atomDict[sele] === true) {
      atomDict[sele] = ap.index;
    }
  });
  if (Debug) {
    Log.timeEnd("Validation.getClashData#atomDict");
  }
  var i = 0;
  clashArray.forEach(function(c2, idx) {
    ap1.index = atomDict[c2.sele1];
    ap2.index = atomDict[c2.sele2];
    if (ap1.index === void 0 || ap2.index === void 0 || !atomSet.isSet(ap1.index, ap2.index)) {
      return;
    }
    vDir.subVectors(ap2, ap1).setLength(ap1.vdw);
    vPos1.copy(ap1).add(vDir);
    vDir.subVectors(ap1, ap2).setLength(ap2.vdw);
    vPos2.copy(ap2).add(vDir);
    var dHalf = ap1.distanceTo(ap2) / 2;
    var r1 = Math.sqrt(ap1.vdw * ap1.vdw - dHalf * dHalf);
    var r2 = Math.sqrt(ap2.vdw * ap2.vdw - dHalf * dHalf);
    vPos1.toArray(position1, i * 3);
    vPos2.toArray(position2, i * 3);
    radius[i] = (r1 + r2) / 2;
    picking[i] = idx;
    ++i;
  });
  if (Debug) {
    Log.timeEnd("Validation.getClashData");
  }
  return {
    position1: position1.subarray(0, i * 3),
    position2: position2.subarray(0, i * 3),
    color: color.subarray(0, i * 3),
    color2: color.subarray(0, i * 3),
    radius: radius.subarray(0, i),
    picking: new ClashPicker(picking.subarray(0, i), this, s)
  };
};
Object.defineProperties(Validation.prototype, prototypeAccessors$30);
var ValidationParser = function(XmlParser$$1) {
  function ValidationParser2(streamer, params) {
    var p = params || {};
    XmlParser$$1.call(this, streamer, p);
    this.useDomParser = true;
    this.validation = new Validation(this.name, this.path);
  }
  if (XmlParser$$1)
    ValidationParser2.__proto__ = XmlParser$$1;
  ValidationParser2.prototype = Object.create(XmlParser$$1 && XmlParser$$1.prototype);
  ValidationParser2.prototype.constructor = ValidationParser2;
  var prototypeAccessors2 = {__objName: {}};
  prototypeAccessors2.__objName.get = function() {
    return "validation";
  };
  ValidationParser2.prototype._parse = function _parse2() {
    XmlParser$$1.prototype._parse.call(this);
    if (Debug) {
      Log.time("ValidationParser._parse " + this.name);
    }
    this.validation.fromXml(this.xml.data);
    if (Debug) {
      Log.timeEnd("ValidationParser._parse " + this.name);
    }
  };
  Object.defineProperties(ValidationParser2.prototype, prototypeAccessors2);
  return ValidationParser2;
}(XmlParser);
ParserRegistry.add("validation", ValidationParser);
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
}
function shrinkBuf(buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
}
function arraySet(dest, src, src_offs, len, dest_offs) {
  if (src.subarray && dest.subarray) {
    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
    return;
  }
  for (var i = 0; i < len; i++) {
    dest[dest_offs + i] = src[src_offs + i];
  }
}
function flattenChunks(chunks) {
  var i, l, len, pos, chunk2, result;
  len = 0;
  for (i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  result = new Uint8Array(len);
  pos = 0;
  for (i = 0, l = chunks.length; i < l; i++) {
    chunk2 = chunks[i];
    result.set(chunk2, pos);
    pos += chunk2.length;
  }
  return result;
}
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
function makeTable() {
  var c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
}
var crcTable = makeTable();
function crc32(crc, buf, len, pos) {
  var t = crcTable, end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var BAD$1 = 30;
var TYPE$1 = 12;
function inflate_fast(strm, start) {
  var state;
  var _in;
  var last;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
}
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
function inflate_table(type2, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count2 = new Uint16Array(MAXBITS + 1);
  var offs = new Uint16Array(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count2[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count2[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count2[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count2[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count2[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count2[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type2 === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count2[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count2[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new Uint8Array(4);
  var opts;
  var n;
  var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                arraySet(state.head.extra, input, next, copy, len);
              }
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = {bits: state.lenbits};
          ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = {bits: state.lenbits};
          ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = {bits: state.distbits};
          ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK;
}
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
function string2buf(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
}
function _buf2binstring(buf, len) {
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
function binstring2buf(str) {
  var buf = new Uint8Array(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
}
function buf2string(buf, max2) {
  var i, out, c, c_len;
  var len = max2 || buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return _buf2binstring(utf16buf, out);
}
function utf8border(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
}
var Z_NO_FLUSH = 0;
var Z_SYNC_FLUSH = 2;
var Z_FINISH$1 = 4;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_NEED_DICT$1 = 2;
var Z_BUF_ERROR$1 = -5;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var toString2 = Object.prototype.toString;
function Inflate(options) {
  if (!(this instanceof Inflate)) {
    return new Inflate(options);
  }
  this.options = assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }
  this.header = new GZheader();
  inflateGetHeader(this.strm, this.header);
}
Inflate.prototype.push = function(data, mode) {
  var this$1 = this;
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$1 : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = binstring2buf(data);
  } else if (toString2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate(strm, Z_NO_FLUSH);
    if (status === Z_NEED_DICT$1 && dictionary) {
      if (typeof dictionary === "string") {
        dict = string2buf(dictionary);
      } else if (toString2.call(dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }
      status = inflateSetDictionary(this$1.strm, dict);
    }
    if (status === Z_BUF_ERROR$1 && allowBufError === true) {
      status = Z_OK$1;
      allowBufError = false;
    }
    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
      this$1.onEnd(status);
      this$1.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$1 || strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH)) {
        if (this$1.options.to === "string") {
          next_out_utf8 = utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this$1.onData(utf8str);
        } else {
          this$1.onData(shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);
  if (status === Z_STREAM_END$1) {
    _mode = Z_FINISH$1;
  }
  if (_mode === Z_FINISH$1) {
    status = inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$1;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function(chunk2) {
  this.chunks.push(chunk2);
};
Inflate.prototype.onEnd = function(status) {
  if (status === Z_OK$1) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function doInflate(input, options) {
  var inflator = new Inflate(options);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg;
  }
  return inflator.result;
}
function gzipDecompress(data) {
  var decompressedData;
  if (data instanceof ArrayBuffer) {
    data = new Uint8Array(data);
  }
  try {
    decompressedData = doInflate(data);
  } catch (e) {
    decompressedData = data;
  }
  return decompressedData;
}
DecompressorRegistry.add("gz", gzipDecompress);
var baseUrl$1 = "//files.rcsb.org/download/";
var mmtfBaseUrl = "//mmtf.rcsb.org/v1.0/";
var mmtfFullUrl = mmtfBaseUrl + "full/";
var mmtfReducedUrl = mmtfBaseUrl + "reduced/";
function RcsbDatasource() {
  this.getUrl = function(src) {
    var info = getFileInfo(src);
    var pdbid = info.name.substr(0, 4);
    var url;
    if (["pdb", "cif"].includes(info.ext) && (info.compressed === false || info.compressed === "gz")) {
      url = baseUrl$1 + info.path;
    } else if (info.ext === "mmtf") {
      if (info.base.endsWith(".bb")) {
        url = mmtfReducedUrl + pdbid;
      } else {
        url = mmtfFullUrl + pdbid;
      }
    } else if (!info.ext) {
      url = mmtfFullUrl + pdbid;
    } else {
      Log.warn("unsupported ext", info.ext);
      url = mmtfFullUrl + pdbid;
    }
    return getProtocol() + url;
  };
  this.getExt = function(src) {
    var info = getFileInfo(src);
    if (info.ext === "mmtf" || !info.ext) {
      return "mmtf";
    }
  };
}
DatasourceRegistry.add("rcsb", new RcsbDatasource());
var baseUrl$2 = "//pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/";
var suffixUrl = "/SDF?record_type=3d";
function PubchemDatasource() {
  this.getUrl = function(src) {
    var info = getFileInfo(src);
    var cid = info.name;
    var url;
    if (!info.ext || info.ext === "sdf") {
      url = baseUrl$2 + cid + suffixUrl;
    } else {
      Log.warn("unsupported ext", info.ext);
      url = baseUrl$2 + cid + suffixUrl;
    }
    return getProtocol() + url;
  };
  this.getExt = function(src) {
    var info = getFileInfo(src);
    if (!info.ext || info.ext === "sdf") {
      return "sdf";
    }
  };
}
DatasourceRegistry.add("pubchem", new PubchemDatasource());
function PassThroughDatasource() {
  this.getUrl = function(path) {
    return path;
  };
}
DatasourceRegistry.add("ftp", new PassThroughDatasource());
DatasourceRegistry.add("http", new PassThroughDatasource());
DatasourceRegistry.add("https", new PassThroughDatasource());
var reProtocol = /^((http|https|ftp):)*\/\//;
function StaticDatasource(baseUrl) {
  baseUrl = baseUrl || "";
  this.getUrl = function(src) {
    var info = getFileInfo(src);
    var url = baseUrl + info.path;
    if (!reProtocol.test(baseUrl)) {
      url = getAbsolutePath(url);
    }
    return url;
  };
}
var version$1 = "0.10.4";
var Version = version$1;
if (typeof window !== "undefined" && !window.Promise) {
  window.Promise = Promise$1;
}
export {ArrowBuffer, Assembly, Box3, BufferRepresentation, Collection, Color, Colormaker, ColormakerRegistry2 as ColormakerRegistry, ComponentCollection, ConeBuffer, Counter, CylinderBuffer, DatasourceRegistry, Debug, EllipsoidBuffer, Euler, Kdtree, LeftMouseButton, Matrix3, Matrix4, MiddleMouseButton, MolecularSurface, MouseActions, ParserRegistry, PdbWriter, Plane, Quaternion, Queue, RepresentationCollection, RepresentationRegistry, RightMouseButton, Selection, Shape$1 as Shape, Signal, SpatialHash, SphereBuffer, Stage, StaticDatasource, TextBuffer, TrajectoryPlayer, Vector2, Vector3, Version, autoLoad, download, getDataInfo, getFileInfo, getQuery, guessElement, setDebug, superpose, throttle, uniqueArray};
export default null;
